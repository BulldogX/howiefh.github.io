<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>Spring笔记二 | 净土</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="Spring">
<meta property="og:type" content="article">
<meta property="og:title" content="Spring笔记二">
<meta property="og:url" content="http://howiefh.github.io/2015/03/06/spring-note-2/index.html">
<meta property="og:site_name" content="净土">
<meta property="og:description" content="Spring">
<meta property="og:image" content="http://fh-1.qiniudn.com/Bean后处理器两个方法的毁掉时机.png">
<meta property="og:image" content="http://fh-1.qiniudn.com/AOP代理的方法和目标对象代理的方法.jpg">
<meta property="og:updated_time" content="2015-03-13T02:19:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spring笔记二">
<meta name="twitter:description" content="Spring">
  
    <link rel="alternative" href="/atom.xml" title="净土" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.ico">
  
  <link href="http://fonts.useso.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  <link rel="stylesheet" href="/css/style.css" type="text/css">
  
<script type="text/javascript">
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-40492061-1', 'auto');
ga('send', 'pageview');

</script>


  
<script>
var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?56d2899c5e919fbf4a7b00de5d1c31dd";
  var s = document.getElementsByTagName("script")[0]; 
  s.parentNode.insertBefore(hm, s);
})();
</script>


</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">净土</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">乐不在外而在心，心以为乐，则是境皆乐；心以为苦，则无境不苦。</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-github-link" class="nav-icon" href="https://github.com/howiefh" title="Github" target="_blank"></a>
        
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed" target="_blank"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://howiefh.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-spring-note-2" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    
<a href="/2015/03/06/spring-note-2/" class="article-date">
  <time datetime="2015-03-06T08:09:20.000Z" itemprop="datePublished">2015-03-06</time>
</a>


    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaEE/">JavaEE</a>►<a class="article-category-link" href="/categories/JavaEE/Spring/">Spring</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Spring笔记二
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
		
		<div id="toc" class="toc-article">
			<h2 class="toc-title"><span>Contents</span></h2>
		
			<ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#两种后处理器"><span class="toc-number">1.</span> <span class="toc-text">两种后处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean后处理器"><span class="toc-number">1.1.</span> <span class="toc-text">Bean后处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器后处理器"><span class="toc-number">1.2.</span> <span class="toc-text">容器后处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性占位符配置器"><span class="toc-number">1.3.</span> <span class="toc-text">属性占位符配置器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写占位符配置器"><span class="toc-number">1.4.</span> <span class="toc-text">重写占位符配置器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring的“零配置”支持"><span class="toc-number">2.</span> <span class="toc-text">Spring的“零配置”支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指定Bean的作用域"><span class="toc-number">2.1.</span> <span class="toc-text">指定Bean的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用@Resource配置依赖"><span class="toc-number">2.2.</span> <span class="toc-text">使用@Resource配置依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用@PostConstruct和@PreDestroy定制生命周期行为"><span class="toc-number">2.3.</span> <span class="toc-text">使用@PostConstruct和@PreDestroy定制生命周期行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring3-0新增的@DependsOn和@Lazy"><span class="toc-number">2.4.</span> <span class="toc-text">Spring3.0新增的@DependsOn和@Lazy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动装配和精确装配"><span class="toc-number">2.5.</span> <span class="toc-text">自动装配和精确装配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#资源访问"><span class="toc-number">3.</span> <span class="toc-text">资源访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Resource实现类"><span class="toc-number">3.1.</span> <span class="toc-text">Resource实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceLoader接口和ResourceLoaderAware接口"><span class="toc-number">3.2.</span> <span class="toc-text">ResourceLoader接口和ResourceLoaderAware接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Resource作为属性"><span class="toc-number">3.3.</span> <span class="toc-text">使用Resource作为属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在ApplicationContext中使用资源"><span class="toc-number">3.4.</span> <span class="toc-text">在ApplicationContext中使用资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplicationContext实现类指定访问策略"><span class="toc-number">3.4.1.</span> <span class="toc-text">ApplicationContext实现类指定访问策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#前缀指定访问策略"><span class="toc-number">3.4.2.</span> <span class="toc-text">前缀指定访问策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#classpath*:前缀的用法"><span class="toc-number">3.4.3.</span> <span class="toc-text">classpath*:前缀的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#file:前缀的用法"><span class="toc-number">3.4.4.</span> <span class="toc-text">file:前缀的用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring的AOP"><span class="toc-number">4.</span> <span class="toc-text">Spring的AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用AspectJ实现AOP"><span class="toc-number">4.1.</span> <span class="toc-text">使用AspectJ实现AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AspectJ使用入门"><span class="toc-number">4.1.1.</span> <span class="toc-text">AspectJ使用入门</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP_的基本概念"><span class="toc-number">4.2.</span> <span class="toc-text">AOP 的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring_的AOP支持"><span class="toc-number">4.3.</span> <span class="toc-text">Spring 的AOP支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于Annotation的“零配置”方式"><span class="toc-number">4.4.</span> <span class="toc-text">基于Annotation的“零配置”方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义切面Bean"><span class="toc-number">4.4.1.</span> <span class="toc-text">定义切面Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义Before增强处理"><span class="toc-number">4.4.2.</span> <span class="toc-text">定义Before增强处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义AfterReturning增强处理"><span class="toc-number">4.4.3.</span> <span class="toc-text">定义AfterReturning增强处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义AfterThrowing增强处理"><span class="toc-number">4.4.4.</span> <span class="toc-text">定义AfterThrowing增强处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#After增强处理"><span class="toc-number">4.4.5.</span> <span class="toc-text">After增强处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Around增强处理"><span class="toc-number">4.4.6.</span> <span class="toc-text">Around增强处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#访问目标方法"><span class="toc-number">4.4.7.</span> <span class="toc-text">访问目标方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#织入增强处理的顺序"><span class="toc-number">4.4.8.</span> <span class="toc-text">织入增强处理的顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义切入点"><span class="toc-number">4.4.9.</span> <span class="toc-text">定义切入点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#切入点指示符"><span class="toc-number">4.4.10.</span> <span class="toc-text">切入点指示符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用组合切点表达式"><span class="toc-number">4.4.11.</span> <span class="toc-text">使用组合切点表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于XML配置文件的管理方式"><span class="toc-number">4.5.</span> <span class="toc-text">基于XML配置文件的管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#配置切面"><span class="toc-number">4.5.1.</span> <span class="toc-text">配置切面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置增强处理"><span class="toc-number">4.5.2.</span> <span class="toc-text">配置增强处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置切点"><span class="toc-number">4.5.3.</span> <span class="toc-text">配置切点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring_的事务"><span class="toc-number">5.</span> <span class="toc-text">Spring 的事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring支持的事务策略"><span class="toc-number">5.1.</span> <span class="toc-text">Spring支持的事务策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用声明式事务"><span class="toc-number">5.2.</span> <span class="toc-text">使用声明式事务</span></a></li></ol></li></ol>
		
		</div>
		
        <h2 id="两种后处理器">两种后处理器</h2><p>Spring框架提供了很好的扩展性，除了可以与各种第三方框架良好整合外，其IoC容器也允许开发者进行扩展，这种扩展甚至无须实现BeanFactory或ApplicationContext接口，而是允许通过两个后处理器对IOC容器进行扩展。Spring提供了两种常用的后处理器：</p>
<ol>
<li>Bean后处理器：这种后处理器会对容器中的Bean进行后处理，对Bean功能进行额外加强。</li>
<li>容器后处理器：这种后处理器对IoC容器进行后处理，用于增强容器功能。</li>
</ol>
<a id="more"></a>
<h3 id="Bean后处理器">Bean后处理器</h3><p>Bean后处理器是一种特殊的Bean，这种特殊Bean并不对外提供服务，它甚至可以无须id属性，它主要负责对容器中的其他Bean执行后处理，例如为容器中的目标Bean生成代理等。</p>
<p>Bean后处理器会在Bean实例创建成功之后，对Bean实例进行进一步的增强处理。</p>
<p>Bean后处理器必须实现 BeanPostProcessor 接口，它包含两个方法：</p>
<ol>
<li>Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException：第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean实例的名字。</li>
<li>Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException：第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean实例的名字。</li>
</ol>
<p>实现该接口的Bean后处理器必须实现这两个方法，这两个方法会对容器中的Bean进行后处理，会在目标Bean初始化之前、初始化之后分别被回调，这两个方法用于对容器中的Bean实例进行增强处理。</p>
<p>Axe.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖Bean:SteelAxe实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;  </span><br><span class="line">    public void useAxe();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span>,<span class="title">InitializingBean</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring执行依赖关系注入,setAxe..."</span>);  </span><br><span class="line">        <span class="keyword">this</span>.axe = axe;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring执行依赖关系注入,setName..."</span>);  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring实例化主调Bean:Chinese实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(name+axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"正在执行初始化方法afterPropertiesSet..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"正在执行初始化方法init..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FirstBeanPostProcessor.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span>  </span><br><span class="line">            <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Bean后处理器在初始化之前对"</span>+beanName+<span class="string">"进行增强处理..."</span>);  </span><br><span class="line">        <span class="keyword">return</span> bean;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span>  </span><br><span class="line">            <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Bean后处理器在初始化之后对"</span>+beanName+<span class="string">"进行增强处理..."</span>);  </span><br><span class="line">        <span class="keyword">if</span>(bean <span class="keyword">instanceof</span> Chinese)&#123;  </span><br><span class="line">            Chinese c=(Chinese)bean;  </span><br><span class="line">            c.setName(<span class="string">"中国人"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> bean;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span> init-<span class="keyword">method</span>=<span class="string">"init"</span>&gt;  </span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;  </span><br><span class="line">   &lt;property name=<span class="string">"name"</span> value=<span class="string">"依赖注入的值"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">   </span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"beanPostProcessor"</span> class=<span class="string">"com.bean.FirstBeanPostProcessor"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        p.useAxe();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器中一旦注册了Bean后处理器，Bean后处理器就会自动启动，在容器中每个Bean创建时自动工作。从上面程序的运行结果可以看出，Bean后处理器两个方法的回调时机如下所示：</p>
<p><img src="http://fh-1.qiniudn.com/Bean后处理器两个方法的毁掉时机.png" alt="Bean后处理器两个方法的毁掉时机"></p>
<p>采用ApplicationContext作为Spring容器时，无须手动注册BeanPostProcessor。但是如果采用BeanFactory作为Spring容器时，就必须手动注册BeanPostProcess，如下：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ClassPathResource resource=new ClassPathResource(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        XmlBeanFactory factory=new XmlBeanFactory(resource);  </span><br><span class="line">        BeanPostProcessor bpp=(FirstBeanPostProcessor) factory.getBean(<span class="string">"beanPostProcessor"</span>);  </span><br><span class="line">        factory.addBeanPostProcessor(bpp);  //注册BeanPostProcessor实例  </span><br><span class="line">        System.out.println(<span class="string">"程序已经实例化BeanFactory..."</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) factory.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(<span class="string">"程序中已经完成了chinese bean的实例化..."</span>);  </span><br><span class="line">        p.useAxe();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是Spring提供的两个常用的后处理器：</p>
<ol>
<li>BeanNameAutoProxyCreator：根据Bean实例的name属性，创建Bean实例的代理。</li>
<li>DefaultAdvisorAutoProxyCreator：根据提供的advisor，对容器中所有的Bean实例创建代理。<br>上面提供的两个Bean后处理器，都用于根据容器中配置的拦截器，创建代理Bean，代理Bean就是对目标Bean进行增强、在目标Bean的基础上进行修改得到新的Bean。</li>
</ol>
<h3 id="容器后处理器">容器后处理器</h3><p>Spring还提供了一种容器后处理器。Bean后处理器负责处理容器中的所有Bean实例，而容器后处理器则负责处理容器本身。</p>
<p>容器后处理器必须实现 BeanFactoryPostProcessor 接口，该接口中有一个方法：</p>
<p>void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException</p>
<p>实现该方法的方法体就是对Spring容器进行的处理，这种处理可以对Spring容器进行自定义扩展，当然也可以对Spring容器不进行任何处理。</p>
<p>FirstBeanFactoryPostProcessor.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span>  </span><br><span class="line">            <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"程序对Spring所做的BeanFactory的初始化没有改变..."</span>);  </span><br><span class="line">        System.out.println(<span class="string">"Spring容器是:"</span>+beanFactory);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span>&gt;  </span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">   </span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"beanFactoryPostProcessor"</span> class=<span class="string">"com.bean.FirstBeanFactoryPostProcessor"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        p.useAxe();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序会自动搜索容器中实现了BeanFactoryPostProcessor接口的类，并将它注册成容器后处理器。</p>
<p>Spring已经提供了如下几个常用的容器后处理器：</p>
<ol>
<li>PropertyPlaceholderConfigurer：属性占位符配置器。</li>
<li>PropertyOverrideConfigurer：重写占位符配置器。</li>
<li>CustomAutowireConfigurer：自定义自动装配的配置器。</li>
<li>CustomScopeConfigurer：自定义作用域的配置器。</li>
</ol>
<p>从上面的介绍可以看出，容器后处理器通常用于对Spring容器进行处理，并且总是在容器实例化任何其他的Bean之前，读取配置文件的元数据，并有可能修改这些元数据。</p>
<p>如果有需要，程序可以配置多个容器后处理器，多个容器后处理器可设置order属性来控制容器后处理器的执行次序。</p>
<h3 id="属性占位符配置器">属性占位符配置器</h3><p>Spring提供了PropertyPlaceholderConfigurer，它是一个容器后处理器，负责读取Properties属性文件里的属性值，并将这些属性值设置成Spring配置文件的元数据。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans  </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--如果采用基于XML Schema的配置文件则可以简化下面配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"locations"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">value</span>&gt;</span>dbconn.properties<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 如果有多个属性文件，依次在下面列出来 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attribute">destroy-method</span>=<span class="value">"close"</span> &gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClass"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.driverClassName&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jdbcUrl"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>dbconn.properties:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClassName=com<span class="class">.mysql</span><span class="class">.jdbc</span><span class="class">.Driver</span></span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/javaee</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure></p>
<p>通过这种方法，可从主XML配置文件中分离出部分配置信息。如果仅需要修改数据库连接属性，则无须修改主XML配置文件。</p>
<p>简化的配置属性占位符<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">context</span>:<span class="keyword">property</span>-placeholder location=<span class="string">"classpath:dbconn.properties"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="重写占位符配置器">重写占位符配置器</h3><p>Spring提供了PropertyOverrideConfigurer，负责读取Properties属性文件里的属性值，并将这些属性值直接覆盖Spring配置文件的元数据。即允许XML配置文件中有默认的配置信息。可以认为Spring配置文件是XML配置文件和属性文件的总和。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans  </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--如果采用基于XML Schema的配置文件则可以简化下面配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.springframework.beans.factory.config.PropertyOverrideConfigurer"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"locations"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">value</span>&gt;</span>dbconn.properties<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 如果有多个属性文件，依次在下面列出来 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attribute">destroy-method</span>=<span class="value">"close"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>dbconn.properties:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClassName=com<span class="class">.mysql</span><span class="class">.jdbc</span><span class="class">.Driver</span></span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/javaee</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure></p>
<p>通过这种方法，可从主XML配置文件中分离出部分配置信息。如果仅需要修改数据库连接属性，则无须修改主XML配置文件。</p>
<p>简化的配置属性占位符<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">context</span>:<span class="keyword">property</span>-override location=<span class="string">"classpath:dbconn.properties"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Spring的“零配置”支持">Spring的“零配置”支持</h2><p>Spring提供了如下几个Annotation来标注Spring Bean。</p>
<table>
<thead>
<tr>
<th>Annotation名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Component</td>
<td>标注一个普通的Spring Bean类。</td>
</tr>
<tr>
<td>@Controller</td>
<td>标注一个控制器组件类。</td>
</tr>
<tr>
<td>@Service</td>
<td>标注一个业务逻辑组件类。</td>
</tr>
<tr>
<td>@Repository</td>
<td>标注一个DAO组件类。</td>
</tr>
</tbody>
</table>
<p>如果我们需要定义一个普通的Spring Bean，则直接使用@Component标注即可。但如果用@Repository、@Service或@Controller来标注这些Bean类，这些Bean类将被作为特殊的JavaEE组件对待，也许能更好地被工具处理，或与切面进行关联。</p>
<p>在Spring的未来版本中，@Controller、@Service和@Repository也许还能携带更多语义，因此如果需要在JavaEE应用中使用这些标注时，尽量考虑使用@Controller、@Service和@Repository来代替通用的@Component标注。</p>
<p>指定了某些类可作为Spring Bean类使用后，最后还需要让Spring搜索指定路径，此时需要在Spring配置文件中导入context Scheme，并指定一个简单的搜索路径。</p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>StoneAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoneAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"石斧砍柴真慢"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.axe = axe;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">        <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line">        <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">        <span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span>  </span><br><span class="line">        <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans   </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span><br><span class="line">                http://www.springframework.org/schema/context   </span><br><span class="line">                http://www.springframework.org/schema/context/spring-context-2.5.xsd  </span><br><span class="line">                http://www.springframework.org/schema/tx   </span><br><span class="line">                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"com.bean"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </span><br><span class="line">        ApplicationContext ctx=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        System.<span class="keyword">out</span>.println(Arrays.toString(ctx.getBeanDefinitionNames()));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行Test.java，控制台输出：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ steelAxe, stoneAxe, chinese, </span><br><span class="line">org<span class="class">.springframework</span><span class="class">.context</span><span class="class">.annotation</span><span class="class">.internalCommonAnnotationProcessor</span>, </span><br><span class="line">org<span class="class">.springframework</span><span class="class">.context</span><span class="class">.annotation</span><span class="class">.internalAutowiredAnnotationProcessor</span>,</span><br><span class="line">org<span class="class">.springframework</span><span class="class">.context</span><span class="class">.annotation</span><span class="class">.internalRequiredAnnotationProcessor</span> ]</span><br></pre></td></tr></table></figure></p>
<p>从上面程序的运行结果来看，Spring容器中三个Bean实例的名称分别为chinese、steelAxe和stoneAxe，之所以叫这些名称，是因为在这种基于Annotation的方式下，Spring采用约定的方式来为这些Bean实例指定名称，这些Bean实例的名称默认是Bean类的首字母小写，其他部分不变。</p>
<p>当然，Spring也允许在使用@Component标注时指定Bean实例的名称：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>(<span class="string">"axe"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span>&#123;</span>  </span><br><span class="line">   <span class="comment">//codes here  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在默认情况下，Spring会自动搜索所有以@Component、@Controller、@Service和@Repository标注的Java类，并将它们当成Spring Bean来处理。</p>
<p>除此之外，我们还可通过为<code>&lt;component-scan.../&gt;</code>元素添加<code>&lt;include-filter.../&gt;</code>或<code>&lt;exclude-filter.../&gt;</code>子元素来指定Spring Bean类，只要位于指定路径下的Java类满足这种规则，即使这些java类没有使用任何Annotation标注，Spring一样会将它们当成Bean类来处理。</p>
<p><code>&lt;include-filter.../&gt;</code>元素用于指定满足该规则的Java类会被当成Bean类处理。<code>&lt;exclude-filter.../&gt;</code>元素用于指定满足该规则的Java类不会被当成Bean类处理。使用这两个元素时都要求指定如下两个属性：</p>
<ol>
<li>type：指定过滤器类型。</li>
<li>expression：指定过滤器所需要的表达式。<br>Spring内建支持如下4种过滤器：</li>
<li>annotation：Annotation过滤器，该过滤器需要指定一个Annotation名，如lee.AnnotationTest</li>
<li>assignable：类名过滤器，该过滤器直接指定一个Java类。</li>
<li>regex：正则表达式过滤器，该过滤器指定一个正则表达式，匹配该正则表达式的Java类将满足该过滤规则，如<code>org\.example\.Default.*</code>。</li>
<li>aspectj：AspectJ过滤器，如<code>org.example..*Service+</code>。</li>
</ol>
<p>例如下面的配置文件指定所有以Chinese结尾的类，以Axe结尾的类都将被当成Spring Bean处理。<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="literal">context</span>:component-scan base-<span class="keyword">package</span>=<span class="string">"org.crazyit.app.service"</span>&gt;  </span><br><span class="line">  &lt;<span class="literal">context</span>:<span class="literal">include</span>-filter <span class="built_in">type</span>=<span class="string">"regex"</span> expression=<span class="string">".*Chinese"</span>/&gt;  </span><br><span class="line">  &lt;<span class="literal">context</span>:<span class="literal">include</span>-filter <span class="built_in">type</span>=<span class="string">"regex"</span> expression=<span class="string">".*Axe"</span>/&gt;  </span><br><span class="line">&lt;/<span class="literal">context</span>:component-scan&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="指定Bean的作用域">指定Bean的作用域</h3><p>当使用XML配置方式来配置Bean实例时，可以通过scope来指定Bean实例的作用域，没有指定scope属性的Bean实例的作用域默认是singleton。</p>
<p>当我们采用零配置方式来管理Bean实例时，可以使用@Scope Annotation，只要在该Annotation中提供作用域的名称即可。例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Scope</span>(<span class="string">"prototype"</span>)  </span><br><span class="line"><span class="variable">@Component</span>(<span class="string">"axe"</span>)  </span><br><span class="line">public class SteelAxe implements Axe&#123;  </span><br><span class="line">   <span class="comment">//codes here  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用@Resource配置依赖">使用@Resource配置依赖</h3><p>@Resource位于java.annotation包下，是来自JavaEE规范的一个Annotation，Spring直接借鉴了该Annotation，通过使用该Annotation为目标Bean指定协作者Bean。</p>
<p>@Resource有一个name属性，默认情况下，Spring将这个值解释为需要被注入的Bean实例的名字。换句话说，使用@Resource与<code>&lt;property.../&gt;</code>元素的ref属性有相同的效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="annotation">@Resource</span>(name=<span class="string">"stoneAxe"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.axe = axe;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的@Resource Annotation指定将stoneAxe注入该setAxe( )方法，也就是将容器中的stoneAxe Bean作为setAxe方法的参数传入。</p>
<p>@Resource不仅可以修饰setter方法，也可以直接修饰Field，使用@Resource时还可以省略name属性。使用@Resource修饰Field时连setter方法都可以不要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Resource</span>(name=<span class="string">"stoneAxe"</span>)  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>当使用@Resource修饰setter方法时，如果省略name属性，例如@Resource标注setName( )方法，则Spring默认注入容器中名为name的组件。</li>
<li>当使用@Resource修饰Field时，如果省略name属性，例如@Resource标注name Field，则Spring默认会注入容器中名为name的组件。</li>
</ol>
<h3 id="使用@PostConstruct和@PreDestroy定制生命周期行为">使用@PostConstruct和@PreDestroy定制生命周期行为</h3><p>@PostConstruct和@PreDestroy同样位于java.annotation包下，也是来自JavaEE规范的两个Annotation，Spring直接借鉴了它们，用于定制Spring容器中Bean的生命周期行为。</p>
<p>@PostConstruct和@PreDestroy大致相当于<code>&lt;bean.../&gt;</code>元素的 init-method 属性和 destroy-method 属性指定的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Resource</span>(name=<span class="string">"steelAxe"</span>)  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@PostConstruct</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"正在执行初始化的init方法..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@PreDestroy</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"正在执行销毁之前的close方法..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spring3-0新增的@DependsOn和@Lazy">Spring3.0新增的@DependsOn和@Lazy</h3><p>@DependsOn用于强制初始化其他Bean。可以修饰Bean类或方法，使用该Annotation时可以指定一个字符串数组作为参数，每个数组元素对应于一个强制初始化的Bean。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@DependsOn</span>(&#123;<span class="string">"steelAxe"</span>,<span class="string">"abc"</span>&#125;)  </span><br><span class="line"><span class="variable">@Component</span>  </span><br><span class="line">public class Chinese implements Person&#123;  </span><br><span class="line">   <span class="comment">//codes here  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Lazy用于指定该Bean是否取消预初始化。主要用于修饰Spring Bean类，用于指定该Bean的预初始化行为，使用该Annotation时可以指定一个boolean型的value属性，该属性决定是否要预初始化该Bean。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Lazy</span>(true)  </span><br><span class="line"><span class="variable">@Component</span>  </span><br><span class="line">public class Chinese implements Person&#123;  </span><br><span class="line">   <span class="comment">//codes here  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="自动装配和精确装配">自动装配和精确装配</h3><p>spring提供了@Autowired Annotation来指定自动装配，使用@Autowired可以标注setter方法、普通方法、Field、函数形参和构造器等。</p>
<p>例如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="annotation">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Axe <span class="title">getAxe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码使用@Autowired 指定setAxe()方法进行自动装配，spring将会自动搜索容器中类型为Axe的Bean实例，并将该Bean实例作为setAxe()方法的参数传入，此时spring默认的装配策略为byType。同样的@Autowired可以修饰普通的方法，Field和构造器等，且其默认的装配策略均为byType类型的装配。</p>
<p>为了实现精确的自动装配，spring提供了@Qualifier Annotation，通过使用@Qualifier，允许根据Bean的标识来指定自动装配，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Autowired</span></span><br><span class="line">    <span class="annotation">@Qualifier</span>(<span class="string">"steelAxe"</span>)</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Axe <span class="title">getAxe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="资源访问">资源访问</h2><p>Resource接口的主要方法有:</p>
<ul>
<li>InputStream getInputStream() throws IOException:返回资源对应的输入流.</li>
<li>boolean exists():资源是否存在.</li>
<li>boolean isOpen():资源是否打开.</li>
<li>URL getURL() throws IOException:如果底层资源可以表示成URL,该方法返回对应的URL对象.</li>
<li>File getFile() throws IOException:如果底层资源对应一个文件,该方法返回对应的File对象.</li>
<li>String getDescription():返回资源的描述信息，用于资源处理出错时输出该信息，通常是全限定文件名或实际URL.</li>
<li>String getFilename():返回资源文件名，通常是路径中的最后一部分，比如”file.txt”.</li>
</ul>
<h3 id="Resource实现类">Resource实现类</h3><p>Spring在设计上使用了策略模式，针对不同的资源访问，提供了不同的实现类，常用的实现类有：</p>
<ul>
<li>UrlResource：封装了java.net.URL,用户能够访问任何可以通过URL表示的资源,如文件的系统资源,HTTP资源和FTP资源等.</li>
<li>ClassPathResource：访问类加载路径里的资源的实现类.</li>
<li>FileSystemResource：访问文件系统资源的实现类</li>
<li>ServletContextResource：访问相对于ServletContext路径里的资源的实现类</li>
<li>InputStreamResource：访问输入流资源的实现类</li>
<li><p>ByteArrayResource：访问字节数组资源的实现类</p>
</li>
<li><p>访问网络资源</p>
</li>
</ul>
<p>URL资源通常应该提供标准的协议前缀。file:用于访问文件系统；http:用于通过HTTP协议访问资源；ftp:用于通过FTP协议访问资源等。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class UrlResourceTest &#123;</span><br><span class="line">    public static void main<span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Resource对象，指定从文件系统里读取资源</span></span><br><span class="line">        <span class="comment">//1.只需要将此出替换即可使用其他策略</span></span><br><span class="line">        Resource res = new UrlResource<span class="params">(<span class="string">"file:book.xml"</span>)</span>;</span><br><span class="line">        <span class="comment">//获取该资源的简单信息</span></span><br><span class="line">        System.out.println<span class="params">(res.getFilename<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(res.getDescription<span class="params">()</span>)</span>;</span><br><span class="line">        <span class="comment">//创建Dom4j的解析器</span></span><br><span class="line">        SAXReader reader = new SAXReader<span class="params">()</span>;</span><br><span class="line">        Document doc = reader.read<span class="params">(res.getFile<span class="params">()</span>)</span>;</span><br><span class="line">        <span class="comment">//获取根元素</span></span><br><span class="line">        Element el = doc.getRootElement<span class="params">()</span>;</span><br><span class="line">        List list = el.elements<span class="params">()</span>;</span><br><span class="line">        <span class="comment">//遍历根元素的全部子元素</span></span><br><span class="line">        <span class="keyword">for</span> <span class="params">(Iterator it = list.iterator<span class="params">()</span>;it.hasNext<span class="params">()</span>;)</span> &#123;</span><br><span class="line">            Element book = <span class="params">(Element)</span>it.next<span class="params">()</span>;</span><br><span class="line">            List ll = book.elements<span class="params">()</span>;</span><br><span class="line">            <span class="keyword">for</span><span class="params">(Iterator it2 = ll.iterator<span class="params">()</span>;it2.hasNext<span class="params">()</span>;)</span> &#123;</span><br><span class="line">                Element eee = <span class="params">(Element)</span>it2.next<span class="params">()</span>;</span><br><span class="line">                System.out.println<span class="params">(eee.getText<span class="params">()</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>加载类加载路径下的资源</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource <span class="keyword">res</span> = <span class="keyword">new</span> ClassPathResource(<span class="string">"book.xml"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>访问文件系统资源</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource <span class="keyword">res</span> = <span class="keyword">new</span> FileSystemResource(<span class="string">"book.xml"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>访问应用相关资源</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource <span class="keyword">res</span> = <span class="keyword">new</span> ServletContextResource(<span class="string">"book.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>用于访问Web Context下相对路径下的资源。默认情况下，JSP不能直接访问WEB-INF路径下的任何资源，所以应用中的JSP页面需要使用ServletContextResource来访问资源。</p>
<ul>
<li>访问字节数组资源</li>
</ul>
<p>Spring 提供了InputStreamResource来访问二进制输入流资源，InputStreamResource是针对输入流的Resource实现，只有当没有合适的Resource实现时，才考虑使用该InputStreamResource。通常情况下，优先考虑使用ByteArrayResource或者基于文件的Resource实现。</p>
<p>InputStreamResource是一个总是被打开的Resource，所以isOpen方法总是返回true。因此需要多次读取某个流，就不要使用InputStreamResource，创建InputStreamResource实例时应提供一个InputStreamResource参数。</p>
<p>在某些情况下，如读取数据库得到的Blob对象，可以通过Blob的getBinaryStream方法获取二进制输入流。</p>
<p>ByteArrayResource在Socket，线程之间的信息交换方面是很有用的。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">file</span> = <span class="string">"&lt;?xml version='1.0' encoding='UTF-8'"</span></span><br><span class="line">            + <span class="string">"&lt;计算机书籍列表&gt;&lt;书&gt;&lt;书名&gt;疯狂JAVA讲义"</span></span><br><span class="line">            + <span class="string">"&lt;/书名&gt;&lt;作者&gt;李刚&lt;/作者&gt;&lt;/书&gt;&lt;书&gt;&lt;书名&gt;"</span></span><br><span class="line">            + <span class="string">"轻量级java ee企业应用实战&lt;/书名&gt;&lt;作者&gt;李刚"</span></span><br><span class="line">            + <span class="string">"&lt;/作者&gt;&lt;/书&gt;&lt;/计算机书籍列表&gt;"</span></span><br><span class="line"><span class="keyword">byte</span>[] fileBytes = <span class="keyword">file</span>.getBytes();</span><br><span class="line">Resource res = <span class="keyword">new</span> ByteArrayResource(fileBytes);</span><br></pre></td></tr></table></figure>
<h3 id="ResourceLoader接口和ResourceLoaderAware接口">ResourceLoader接口和ResourceLoaderAware接口</h3><p>ResourceLoader 接口由能返回(或者载入)Resource 实例的对象来实现。</p>
<p>所有的ApplicationContext都实现了 ResourceLoader 接口， 因此它们可以用来获取Resource 实例。</p>
<p>当你调用特定ApplicationContext的 getResource() 方法， 而且资源路径并没有特定的前缀时，你将获得与该ApplicationContext相应的 Resource 类型。例如：假定下面的代码片断是基于ClassPathXmlApplicationContext 实例上执行的：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="keyword">template</span> = ctx.getResource(<span class="string">"some/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure>
<p>这将返回ClassPathResource；如果是基于FileSystemXmlApplicationContext 实例上执行的，那你将获得FileSystemResource。而对于 WebApplicationContext 你将获得ServletContextResource，依此类推。</p>
<p>另一方面，无论什么类型的ApplicationContext，你可以通过使用特定的前缀 classpath: 强制使用ClassPathResource。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="keyword">template</span> = ctx.getResource(<span class="string">"classpath:some/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure>
<p>同样的，你可以用任何标准的 java.net.URL 前缀，强制使用 UrlResource ：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="keyword">template</span> = ctx.getResource(<span class="string">"file:/some/resource/path/myTemplate.txt"</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="keyword">template</span> = ctx.getResource(<span class="string">"http://myhost.com/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure></p>
<p>下面的表格概述了 String 到 Resource 的转换规则：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>classpath:</td>
<td>classpath:com/myapp/config.xml</td>
<td>从classpath中加载。</td>
</tr>
<tr>
<td>file:</td>
<td>file:/data/config.xml</td>
<td>作为 URL 从文件系统中加载。</td>
</tr>
<tr>
<td>http:</td>
<td><a href="http://myserver/logo.png" target="_blank" rel="external">http://myserver/logo.png</a></td>
<td>作为 URL 加载。</td>
</tr>
<tr>
<td>(none)</td>
<td>/data/config.xml</td>
<td>根据 ApplicationContext 进行判断。</td>
</tr>
</tbody>
</table>
<p>ResourceLoaderAware是特殊的标记接口，它希望拥有一个ResourceLoader 引用的对象。<br>当实现了 ResourceLoaderAware接口的类部署到ApplicationContext(比如受Spring管理的bean)中时，它会被ApplicationContext识别为 ResourceLoaderAware。 接着ApplicationContext会调用setResourceLoader(ResourceLoader)方法，并把自身作为参数传入该方法(记住，所有Spring里的ApplicationContext都实现了ResourceLoader接口)。</p>
<p>既然 ApplicationContext 就是ResourceLoader，那么该bean就可以实现 ApplicationContextAware接口并直接使用所提供的ApplicationContext来载入资源，但是通常更适合使用特定的满足所有需要的 ResourceLoader实现。 这样一来，代码只需要依赖于可以看作辅助接口的资源载入接口，而不用依赖于整个Spring ApplicationContext 接口。</p>
<p>TestBean.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    ResourceLoader rd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceloader)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rd = resourceloader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SpringTest.java:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpringTest</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        TestBean tb = (TestBean)ctx.getBean(<span class="string">"test"</span>);</span><br><span class="line">        ResourceLoader rl = tb.getResourceLoader();</span><br><span class="line">        System.<span class="keyword">out</span>.println(rl == ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用Resource作为属性">使用Resource作为属性</h3><p>前面都是通过编码的方式获取资源的，资源所在的物理位置就耦合到代码中了，如果资源位置变化，则必须改写程序。因此，可以通过依赖注入资源</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestBean</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResource</span>(<span class="params">Resource res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.res = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bean.xml:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="property">id</span>=<span class="string">"testBean"</span> <span class="type">class</span>=<span class="string">"com.bean.TestBean"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"res"</span> value=<span class="string">"classpath:book.xml"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果不采用任何前缀，则Spring将采用与该ApplicationContext相同的资源访问策略来访问资源。</p>
<h3 id="在ApplicationContext中使用资源">在ApplicationContext中使用资源</h3><p>ApplicationContext确定资源访问策略通常有两个方法：</p>
<ul>
<li>ApplicationContext实现类指定访问策略</li>
<li>前缀指定访问策略</li>
</ul>
<h4 id="ApplicationContext实现类指定访问策略">ApplicationContext实现类指定访问策略</h4><p>ClassPathXmlApplicationContext：返回ClassPathResource<br>FileSystemXmlApplicationContext： 获得FileSystemResource<br>XmlWebApplicationContext： 获得ServletContextResource</p>
<h4 id="前缀指定访问策略">前缀指定访问策略</h4><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new FileSystemXmlApplicationContext<span class="params">(<span class="string">"classpath:bean.xml"</span>)</span>;</span><br><span class="line">Resource r = ctx.getResource<span class="params">(<span class="string">"book.xml"</span>)</span>;</span><br><span class="line">System.out.println<span class="params">(r.getDescription<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>通过classpath:前缀指定资源访问策略仅仅对当次访问有效，程序后面进行资源访问时，还是会根据ApplicationContext的实现类来选择对应的资源访问策略。建议尽量显示指定资源，而不是通过前缀。</p>
<h4 id="classpath*:前缀的用法">classpath*:前缀的用法</h4><p>classpath<em>:前缀提供了装载多个XML配置文件的能力，当使用classpath</em>:前缀来指定XML配置文件时，系统搜索类加载路径，找出所有与文件名匹配的文件，分辨装载文件中的配置定义，最后合并成一个ApplicationContext。classpath<em>:前缀仅对ApplicationContext有效，用于加载配置文件。其他情况，使用classpath</em>:前缀加载多个资源是不行的。</p>
<p>还有一种可以一次加载多个配置文件的方式：指定配置文件时使用通配符。</p>
<p>这两种方式也可以混合使用</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"classpath*:bean*.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>这将会加载类加载路径下所有以bean开头的配置文件。</p>
<h4 id="file:前缀的用法">file:前缀的用法</h4><p>FileSystemApplicationContext 会简单地让所有绑定的 FileSystemResource 实例把绝对路径都当成相对路径，而不管它们是否以反斜杠开头。也就是说，下面的含义是相同的：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"conf/context.xml"</span>);</span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"/conf/context.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的两行代码是没有区别的。</p>
<p>实际上如果的确需要使用绝对路径，那你最好就不要使用 FileSystemResource 或 FileSystemXmlApplicationContext来确定绝对路径。我们可以通过使用 file: URL前缀来强制使用UrlResource。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"file:/conf/context.xml"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Spring的AOP">Spring的AOP</h2><h3 id="使用AspectJ实现AOP">使用AspectJ实现AOP</h3><p>AOP 专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。</p>
<p>AspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳了它的一些思想。由于Spring3.0的AOP与AspectJ进行了很好的集成，因此掌握AspectJ是学习Spring AOP的基础。</p>
<p>AspectJ是Java语言的一个AOP实现，其主要包括两个部分：第一个部分定义了如何表达、定义AOP编程中的语法规范，通过这套语法规范，我们可以方便地用AOP来解决Java语言中存在的交叉关注点问题；第二个部分是工具部分，包括编译器、调试工具等。</p>
<p>AspectJ是最早、功能比较强大的AOP实现之一，对整套AOP机制都有较好的实现，很多其他语言的AOP实现，也借鉴或采纳了AspectJ中的很多设计。而在Java领域，AspectJ中的很多语法结构基本上已经成为AOP领域的标准。</p>
<p>从Spring2.0开始，Spring AOP已经引入了对AspectJ的支持，并且允许直接使用AspectJ进行AOP编程，而Spring自身的AOP API也努力与AspectJ保持一致。因此学习Spring AOP就必然需要从AspectJ开始，因为它是Java领域最流行的AOP解决方案。即使不用Spring框架，我们甚至也可以直接使用AspectJ进行AOP编程。</p>
<p>下载、安装AspectJ和配置环境变量：<br>登陆点击打开链接站点<a href="http://www.eclipse.org/aspectj/downloads.php#stable_release" target="_blank" rel="external">AspectJ</a>，下载AspectJ的一个稳定版本。下载完成后得到一个aspectj-[version].jar文件。我这里将它放在D盘的lib文件夹下的aspectj文件夹下。启动命令行窗口：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">java</span> <span class="tag">-jar</span> <span class="tag">aspectj-</span><span class="attr_selector">[version]</span><span class="class">.jar</span></span><br></pre></td></tr></table></figure>
<p>安装好了以后记得配置环境变量：将 E:\Java\AOP\aspectj\bin添加到path环境变量中，将 E:\Java\AOP\aspectj\lib\aspectjrt.jar添加到CLASSPATH，注意这还不够，前面得有点号和分号。</p>
<h4 id="AspectJ使用入门">AspectJ使用入门</h4><p>我们在D盘下写一个Hello.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hello</span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;  </span><br><span class="line">        Hello h=<span class="keyword">new</span> Hello();  </span><br><span class="line">        h.sayHello();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Hello AspectJ !"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac -d . Hello<span class="class">.java</span></span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure></p>
<p>假设现在客户需要在执行sayHello()方法之前启动事务，方法结束之后关闭事务，在传统的编程模式下，我们必须手动修改sayHello()方法。但是如果采用面向切面编程的思想，则可以无须修改sayHello( )方法，也可以达到同样的效果。这里我们使用AspectJ框架帮我们做到这一点。我们在D盘下写一个TransactionAspect.java：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="aspect"><span class="keyword">aspect</span> <span class="title">TransactionAspect</span></span>&#123;  </span><br><span class="line">    <span class="comment">//指定执行Hello.sayHello()方法时执行下面的代码块  </span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">around</span>():<span class="keyword">call</span>(<span class="keyword">void</span> Hello.sayHello())&#123;  </span><br><span class="line">        System.out.println(<span class="string">"开启事务"</span>);  </span><br><span class="line">        <span class="keyword">proceed</span>();<span class="comment">//回调原来的sayHello()方法  </span></span><br><span class="line">        System.out.println(<span class="string">"结束事务"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的java文件不是使用class、interface或enum，而是使用 aspect，aspect是AspectJ才能识别的关键字。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ajc -d . Hello<span class="class">.java</span> TransactionAspect<span class="class">.java</span></span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure></p>
<p>我们可以把 ajc 命令理解成javac命令，它们都用于编译Java程序，区别是ajc命令可以识别AspectJ的语法，从这个意义上看，我们可以将ajc当成一个增强版的javac命令。</p>
<p>运行Hello类没有任何改变，但是程序的输出已经让我们足够惊喜了，对，就是我们想要的结果！</p>
<p>有了AOP，我们完全可以不对Hello.java类进行任何修改，同时又可以满足客户的需求。上面的程序只是在控制台打印输出语句模拟事务的开启和关闭，在实际工作中可以用实际的操作代码来代替打印语句，这就可以满足客户的要求了。<br>如果客户再次提出新需求，需要在sayHello( )方法后增加记录日志的功能，那也很简单，我们再写一个 LogAspect.java :</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="aspect"><span class="keyword">aspect</span> <span class="title">LogAspect</span></span>&#123;  </span><br><span class="line">    <span class="keyword">pointcut</span> <span class="title">logPointcut</span>()  </span><br><span class="line">        :<span class="keyword">execution</span>(<span class="keyword">void</span> Hello.sayHello());  </span><br><span class="line">    <span class="keyword">after</span>():logPointcut()&#123;  </span><br><span class="line">        System.out.println(<span class="string">"记录日志功能..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ajc</span> -d . <span class="regexp">*.java</span></span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure>
<p>实际上，AspectJ允许同时为多个方法添加新功能，只要我们定义Pointcut时指定匹配更多的方法即可。如如下片段：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointcut xxxPointcut()  </span><br><span class="line">   :execution(void H*.<span class="keyword">say</span>*());</span><br></pre></td></tr></table></figure>
<p>上面程序中的xxxPointcut将可以匹配所有以H开头的类中、所有以say开头的方法，但该方法返回的必须是void。如果想匹配任意的返回值类型：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointcut xxxPointcut  </span><br><span class="line">   :execution(* H*.<span class="keyword">say</span>*());</span><br></pre></td></tr></table></figure>
<p>修改：</p>
<p>Hello.java :</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hello</span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;  </span><br><span class="line">        Hello h=<span class="keyword">new</span> Hello();  </span><br><span class="line">        h.sayHello();  </span><br><span class="line">        h.sayGoodbye();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Hello AspectJ !"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayGoodbye</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Goodbye Java !"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LogAspect.java :</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="aspect"><span class="keyword">aspect</span> <span class="title">LogAspect</span></span>&#123;  </span><br><span class="line">    <span class="keyword">pointcut</span> <span class="title">logPointcut</span>()  </span><br><span class="line">        :<span class="keyword">execution</span>(<span class="keyword">void</span> Hello.say*());  </span><br><span class="line">    <span class="keyword">after</span>():logPointcut()&#123;  </span><br><span class="line">        System.out.println(<span class="string">"记录日志功能..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransactionAspect.java :</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="aspect"><span class="keyword">aspect</span> <span class="title">TransactionAspect</span></span>&#123;  </span><br><span class="line">    <span class="comment">//指定执行Hello.sayHello()方法时执行下面的代码块  </span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">around</span>():<span class="keyword">call</span>(<span class="keyword">void</span> Hello.say*())&#123;  </span><br><span class="line">        System.out.println(<span class="string">"开启事务"</span>);  </span><br><span class="line">        <span class="keyword">proceed</span>();<span class="comment">//回调原来的sayHello()方法  </span></span><br><span class="line">        System.out.println(<span class="string">"结束事务"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AOP_的基本概念">AOP 的基本概念</h3><p>如果安装了Java的反编译工具，可以反编译上篇文章中的Hello.class文件，我们将会发现该Hello.class文件不是由Hello.java文件编译得到的，该Hello.class里新增了很多内容。这表明AspectJ在编译时已增强了Hello.class类的功能，因此 AspectJ 通常被称为编译时增强的AOP框架。</p>
<p>与AspectJ相对的还有另外一种AOP框架，它们不需要在编译时对目标类进行增强，而是运行时生成目标类的代理类，该代理类要么与目标类实现相同的接口，要么是目标类的子类。总之，代理类都对目标类进行了增强处理，前者是JDK动态代理的处理策略，后者是CGLIB代理的处理策略。</p>
<p>Spring AOP以创建动态代理的方式来生成代理类，底层既可使用JDK动态代理，也可采用CGLIB代理。</p>
<p>一般来说，编译时增强的AOP框架在性能上更有优势—因为运行时动态增强的AOP框架需要每次运行时都进行动态增强。</p>
<p>AOP从程序运行角度考虑程序的流程，提取业务处理过程的切面。AOP面向的是程序运行中各个步骤，希望以更好的方式来组合业务处理的各个步骤。</p>
<p>AOP框架并不与特定的代码耦合，AOP框架能处理程序执行中特定切入点（Pointcut），而不与某个具体类耦合。AOP框架具有如下两个特征：</p>
<ol>
<li>各步骤之间的良好隔离性。</li>
<li>源代码无关性。</li>
</ol>
<p>下面是关于面向切面编程的一些术语：</p>
<ol>
<li>切面（Aspect）：业务流程运行的某个特定步骤，也就是应用运行过程的关注点，关注点可能横切多个对象，所以常常也称为横切关注点。</li>
<li>连接点（Joinpoint）：程序执行过程中明确的点，如方法的调用或者异常的抛出。Spring AOP中，连接点总是方法的调用。</li>
<li>增强处理（Advice）：AOP框架在特定的切入点执行的增强处理。处理有around，before，after等类型。</li>
<li>切入点（Pointcut）：可以插入增强处理的连接点。简而言之，当某个连接点满足指定要求时，该连接点将被添加增强处理，该连接点也就变成了切入点。例如如下代码：<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointcut xxxPointcut()  </span><br><span class="line">   :execution(void H*.<span class="keyword">say</span>*())</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>每个方法被调用都只是连接点，但如果该方法属于H开头的类，且方法名义say开头，那么该方法的调用执行将变成切入点。如何使用表达式来定义切入点是AOP的核心，Spring默认使用AspectJ切入点语法：</p>
<ol>
<li>引入：将方法或字段添加到被处理的类中。Spring允许引入新的接口到任何被处理的对象。例如你可以使用一个引入，使任何对象实现isModified接口，以此来简化缓存。</li>
<li>目标对象：被AOP框架进行增强处理的对象，也被称为被增强的对象。如果AOP框架是通过运行时代理来实现的，那么这个对象将是一个被代理的对象。</li>
<li>AOP代理：AOP框架创建的对象，简单地说，代理就是对目标对象的加强。Spring中的AOP代理可以是JDK动态代理，也可以是CGLIB代理。前者为实现接口的目标对象的代理，后者为不实现接口的目标对象的代理。</li>
<li>织入（Weaving）：将增强处理添加到目标对象中，并创建一个被增强的对象（AOP代理）的过程就是织入。织入有两种实现方式：编译时增强（例如AspectJ）和运行时增强（例如CGLIB）。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li>
</ol>
<p>由前面的介绍知道：AOP代理其实是由AOP框架动态生成的一个对象，该对象可作为目标对象使用。AOP代理包含了目标对象的全部方法，但AOP代理中的方法与目标对象的方法存在差异：AOP方法在特定切入点添加了增强处理，并且回调了目标对象的方法。<br>AOP代理所包含的方法与目标对象的方法示意图如下：</p>
<p><img src="http://fh-1.qiniudn.com/AOP代理的方法和目标对象代理的方法.jpg" alt="AOP代理的方法和目标对象代理的方法"></p>
<h3 id="Spring_的AOP支持">Spring 的AOP支持</h3><p>Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其他Bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了。</p>
<p>Spring也可以使用CGLIB代理，在需要代理类而不是代理接口的时候，Spring会自动切换为使用CGLIB代理。但Spring推荐使用面向接口编程，因此业务对象通常都会实现一个或多个接口，此时默认将使用JDK动态代理，但也可强制使用CGLIB。</p>
<p>Spring AOP使用纯Java实现，它不需要专门的编译过程。Spring AOP不需要控制类装载器层次，因此它可以在所有JavaWeb容器或应用服务器中运行良好。</p>
<p>Spring目前仅支持将方法调用作为连接点，如果需要把对field的访问和更新也作为增强处理的连接点，则可以考虑使用AspectJ。</p>
<p>Spring实现AOP的方法跟其他的框架不同，Spring并不是要提供最完整的AOP实现，Spring侧重于AOP实现和Spring IOC容器之间的整合，用于帮助解决在企业级开发中的常见问题。</p>
<p>因此Spring的AOP通常和Spring IOC容器一起使用，Spring AOP从来没有打算通过提供一种全面的AOP解决方案来与AspectJ竞争。Spring AOP采用基于代理的AOP实现方案，而AspectJ则采用编译时增强的解决方案。</p>
<p>一旦我们掌握了上面AOP的相关概念，就不难发现进行AOP编程其实是很简单的事情。纵观AOP编程，其中需要程序员参与的只有三个部分：</p>
<ol>
<li>定义普通业务组件。</li>
<li>定义切入点，一个切入点可能横切多个业务组件。</li>
<li>定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作。</li>
</ol>
<p>上面三个部分的第一个部分是最平常不过的事情，那么进行AOP编程的关键就是定义切入点和定义增强处理。一旦定义了合适的切入点和增强处理，AOP框架将会自动生成AOP代理，而AOP代理的方法大致有如下公式：</p>
<p>代理对象的方法 = 增强处理 + 被代理对象的方法</p>
<p>我们使用AspectJ方式来定义切入点和增强处理，在这种方式下，Spring有两种选择来定义切入点和增强处理。</p>
<ol>
<li>基于 Annotation 的零配置方式：使用@Aspect、@Pointcut等Annotation来标注切入点和增强处理。</li>
<li>基于XML配置文件的管理方式：使用Spring配置文件来定义切入点和增强处理。</li>
</ol>
<h3 id="基于Annotation的“零配置”方式">基于Annotation的“零配置”方式</h3><p>AspectJ 允许使用Annotation定义切面、切入点和增强处理，而 Spring框架则可识别并根据这些Annotation来生成AOP代理。Spring只是使用了和AspectJ一样的注解，并没有使用AspectJ的编译器和织入器，底层依然使用的是 Spring AOP，依然是在运行时动态生成AOP代理，并不依赖于AspectJ的编译器或者织入器。</p>
<p>为了启用Spring对@AspectJ切面配置的支持，并保证Spring容器中的目标Bean被一个或多个切面自动增强，必须在配置文件中加如下代码：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;aop:aspectj-autoproxy/&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不打算使用Spring的XML Schema配置方式，则应该在Spring配置文件中增加如下片段来启用@AspectJ支持</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="keyword">class</span>=<span class="string">"org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>为了在Spring应用中启动@AspectJ支持，还需要添加 aspectjrt.jar 和aspectjweaver.jar到工程lib目录下。</p>
<h4 id="定义切面Bean">定义切面Bean</h4><p>使用@Aspect标注一个Java类，该Java类将会作为切面Bean</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> &#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发时无须担心使用@Aspect 定义的切面类被增强处理，当Spring容器检测到某个Bean类使用了@Aspect标注之后，Spring容器不会对该Bean类进行增强。</p>
<h4 id="定义Before增强处理">定义Before增强处理</h4><p>Person.java:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;  </span><br><span class="line">    public String sayHello(String name);  </span><br><span class="line">    public void eat(String food);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"我正在吃:"</span>+food);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">"Hello,Spring AOP"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BeforeAdviceTest.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeAdviceTest</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Before</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authority</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"模拟执行权限检查"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">        <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line">        <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">        <span class="attribute">xmlns:aop</span>=<span class="value">"http://www.springframework.org/schema/aop"</span>  </span><br><span class="line">        <span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span>  </span><br><span class="line">        <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans   </span><br><span class="line">                http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span><br><span class="line">                http://www.springframework.org/schema/context   </span><br><span class="line">                http://www.springframework.org/schema/context/spring-context-3.0.xsd  </span><br><span class="line">                http://www.springframework.org/schema/aop  </span><br><span class="line">                http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"com.bean"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">context:include-filter</span> <span class="attribute">type</span>=<span class="value">"annotation"</span>   </span><br><span class="line">                 <span class="attribute">expression</span>=<span class="value">"org.aspectj.lang.annotation.Aspect"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">context:component-scan</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:aspectj-autoproxy</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));  </span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="定义AfterReturning增强处理">定义AfterReturning增强处理</h4><p>AfterReturning 增强处理将在目标方法正常完成后被织入。<br>使用@AfterReturning可指定如下两个属性：</p>
<ol>
<li>pointcut / value : 两者都用于指定该切入点对应的切入表达式</li>
<li>returning : 指定一个返回值形参名，增强处理定义的方法可通过该行参名来访问目标方法的返回值。</li>
</ol>
<p>AfterReturningAdviceTest.java :</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Aspect  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AfterReturningAdviceTest</span> &#123;  </span><br><span class="line">    @AfterReturning(returning=<span class="string">"rvt"</span>,pointcut=<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span>(<span class="params">Object rvt</span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"获取目标方法返回值："</span>+rvt);  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"模拟记录日志的功能..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));  </span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="定义AfterThrowing增强处理">定义AfterThrowing增强处理</h4><p>@AfterThrowing 主要用于处理程序中未处理的异常。<br>使用@AfterThrowing 时可指定如下两个属性：</p>
<ol>
<li>pointcut / value : 用于指定该切入点对应的切入表达式。</li>
<li>throwing : 指定一个返回值形参名，增强处理定义的方法可通过该形参名来访问目标方法中所抛出的异常对象。</li>
</ol>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">5</span>/<span class="number">0</span>;  </span><br><span class="line">        System.out.println(<span class="string">"divide执行完成！"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">"sayHello方法开始被执行..."</span>);  </span><br><span class="line">            <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"目标类的异常处理"</span>+e.getMessage());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">" Hello,Spring AOP"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AfterThrowingAdviceTest.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Aspect  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AfterThrowingAdviceTest</span> &#123;  </span><br><span class="line">    @AfterThrowing(throwing=<span class="string">"ex"</span>,pointcut=<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span>(<span class="params">Throwable ex</span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"目标方法中抛出的异常:"</span>+ex);  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"模拟抛出异常后的增强处理..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));  </span><br><span class="line">        p.divide();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面程序中的sayHello方法和divide两个方法都会抛出异常，但sayHello方法中的异常将由该方法显式捕捉，所以Spring AOP不会处理该异常；而divide方法将抛出ArithmeticException异常，且该异常没有被任何程序所处理，故Spring AOP会对该异常进行处理。</p>
<p>catch捕捉 意味着完全处理该异常，如果catch块中没有重新抛出新异常，则该方法可以正常结束；而 AfterThrowing 虽然处理了该异常，但他不能完全处理该异常，该异常依然会传播到上一级调用者，本例中传播到JVM，导致程序终止。</p>
<p>如果上面的doRecoveryActions方法定义了ex形参的类型是NullPointerException，则该切入点只匹配抛出NullPointerException异常的情况。</p>
<h4 id="After增强处理">After增强处理</h4><p>@After与@AfterReturning有点相似，但是也有区别：</p>
<ol>
<li>AfterReturning 增强处理只在目标方法成功完成后才会被织入。</li>
<li>After 增强处理不管目标方法如何结束，包括成功完成和遇到异常终止两种情况，它都会被织入。<br>因为不论一个方法是如何结束的，After增强处理都会被织入，因此After增强处理必须准备处理正常返回和异常返回两种情况，这种增强处理通常用于释放资源。</li>
</ol>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">5</span>/<span class="number">0</span>;  </span><br><span class="line">        System.out.println(<span class="string">"divide执行完成！"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">"sayHello方法开始被执行..."</span>);  </span><br><span class="line">            <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"目标类的异常处理"</span>+e.getMessage());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">" Hello,Spring AOP"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AfterAdviceTest.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterAdviceTest</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@After</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">realease</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"模拟方法结束后的释放资源..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));  </span><br><span class="line">        p.divide();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然divide方法因为ArithemeticException异常结束，但After增强处理依然被正常织入。由此After的作用有点类似finally块。</p>
<h4 id="Around增强处理">Around增强处理</h4><p>@Around 增强处理是功能比较强大的增强处理，它近似等于Before 和 AfterReturning的总和。@Around既可在执行目标方法之前织入增强动作，也可在执行目标方法之后织入增强动作。@Around甚至可以决定目标方法在什么时候执行，如何执行，更甚者可以完全阻止目标方法的执行。</p>
<p>@Around可以改变执行目标方法的参数值，也可以改变执行目标方法之后的返回值。</p>
<p>@Around功能虽然强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturning就能解决的问题，就没有必要使用Around了。如果需要目标方法执行之前和之后共享某种状态数据，则应该考虑使用Around。尤其是需要使用增强处理阻止目标的执行，或需要改变目标方法的返回值时，则只能使用Around增强处理了。</p>
<p>当定义一个Around增强处理方法时，该方法的第一个形参必须是 ProceedingJoinPoint 类型，在增强处理方法体内，调用ProceedingJoinPoint的proceed方法才会执行目标方法—这就是@Around增强处理可以完全控制目标方法执行时机、如何执行的关键；如果程序没有调用ProceedingJoinPoint的proceed方法，则目标方法不会执行。</p>
<p>调用ProceedingJoinPoint的proceed方法时，还可以传入一个Object[]对象，该数组中的值将被传入目标方法作为实参。如果传入的Object[]数组长度与目标方法所需要的参数个数不相等，或者Object[]数组元素与目标方法所需参数的类型不匹配，程序就会出现异常。</p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">5</span>/<span class="number">0</span>;  </span><br><span class="line">        System.out.println(<span class="string">"divide执行完成！"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"sayHello方法被调用..."</span>);  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">" Hello,Spring AOP"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"我正在吃:"</span>+food);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AroundAdviceTest.java :<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundAdviceTest</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Around</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">processTx</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"执行目标方法之前，模拟开始事务..."</span>);  </span><br><span class="line">        Object rvt=jp.<span class="keyword">proceed</span>(<span class="keyword">new</span> String[]&#123;<span class="string">"被改变的参数"</span>&#125;);  </span><br><span class="line">        System.out.println(<span class="string">"执行目标方法之后，模拟结束事务..."</span>);  </span><br><span class="line">        <span class="keyword">return</span> rvt+<span class="string">"新增的内容"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));  </span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);  </span><br><span class="line">        p.divide();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果proceed方法参数数组的维度大于需要增强处理的方法，程序会抛出异常。</p>
<h4 id="访问目标方法">访问目标方法</h4><p>最简单的做法就是定义增强处理方法时将第一个参数定义为JoinPoint 类型，当该增强处理方法被调用时，该JoinPoint参数就代表了织入增强处理的连接点。JoinPoint里包含了如下几个常用的方法：</p>
<ul>
<li>Object[ ] getArgs( )    返回执行目标方法时的参数</li>
<li>Signature getSignature( )    返回被增强的方法的相关信息</li>
<li>Object getTarget( )    返回被织入增强处理的目标对象</li>
<li>Object getThis( )    返回AOP框架为目标对象生成的代理对象</li>
</ul>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"sayHello方法被调用..."</span>);  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">" Hello,Spring AOP"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"我正在吃:"</span>+food);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FourAdviceTest.java :<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Aspect  </span><br><span class="line">public class FourAdviceTest &#123;  </span><br><span class="line">    @Around<span class="params">(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span>  </span><br><span class="line">    public Object processTx<span class="params">(ProceedingJoinPoint jp)</span> throws Throwable&#123;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Around增强:执行目标方法之前，模拟开始事务..."</span>)</span>;</span><br><span class="line">        Object[] args=jp.getArgs<span class="params">()</span>;  </span><br><span class="line">        <span class="keyword">if</span><span class="params">(args!=null &amp;&amp; args.length&gt;<span class="number">0</span> &amp;&amp; args[<span class="number">0</span>].getClass<span class="params">()</span>==String.class)</span>&#123;</span><br><span class="line">            args[<span class="number">0</span>]=<span class="string">"被改变的参数"</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        Object rvt=jp.proceed<span class="params">(args)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Around增强:执行目标方法之后，模拟结束事务..."</span>)</span>;</span><br><span class="line">        return rvt+<span class="string">" 新增的内容"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Before<span class="params">(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span>  </span><br><span class="line">    public void authority<span class="params">(JoinPoint jp)</span>&#123;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Before增强:模拟执行权限检查..."</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Before增强:被织入增强处理的目标方法为："</span>+ jp.getSignature<span class="params">()</span>.getName<span class="params">()</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Before增强：目标方法的参数为："</span>+Arrays.toString<span class="params">(jp.getArgs<span class="params">()</span>)</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Before增强:被织入增强处理的目标对象为："</span>+jp.getTarget<span class="params">()</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    @AfterReturning<span class="params">(returning=<span class="string">"rvt"</span>,pointcut=<span class="string">"execution(* com.bean.*.*(..))"</span>)</span>  </span><br><span class="line">    public void <span class="built_in">log</span><span class="params">(JoinPoint jp,Object rvt)</span>&#123;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强：获取目标方法返回值："</span>+rvt)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强：模拟记录日志功能..."</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强：被织入增强处理的目标方法为:"</span>+ jp.getSignature<span class="params">()</span>.getName<span class="params">()</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强：目标方法的参数为："</span>+ Arrays.toString<span class="params">(jp.getArgs<span class="params">()</span>)</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强:被织入增强处理的目标对象为："</span>+ jp.getTarget<span class="params">()</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    @After<span class="params">(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span>  </span><br><span class="line">    public void release<span class="params">(JoinPoint jp)</span>&#123;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"After增强：模拟方法结束后的释放资源..."</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"After增强：被织入增强处理的目标方法为："</span>+ jp.getSignature<span class="params">()</span>.getName<span class="params">()</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"After增强：目标方法的参数为："</span>+ Arrays.toString<span class="params">(jp.getArgs<span class="params">()</span>)</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"After增强: 被织入增强处理的目标对象为："</span>+ jp.getTarget<span class="params">()</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));  </span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Before、Around、AfterReturning、After增强处理的优先级从低到高的顺序：Before、Around、AfterReturning、After</p>
<h4 id="织入增强处理的顺序">织入增强处理的顺序</h4><p>Spring AOP 采用和 AspectJ 一样的优先顺序来织入增强处理：在进入连接点时，高优先级的增强处理将先被织入；在退出连接点时，高优先级的增强处理会后被织入。</p>
<p>当不同的切面里的两个增强处理需要在同一个连接点被织入时，Spring AOP将以随机的顺序来织入这两个增强处理。如果应用需要指定不同切面类里增强处理的优先级，Spring提供了如下两种解决方案：</p>
<ol>
<li>让切面类实现org.springframework.core.Ordered接口，实现该接口只需实现一个int getOrder()方法，该方法返回值越小，则优先级越高。</li>
<li>直接使用@Order注解来修饰一个切面类，使用 @Order 时可指定一个int型的value属性，该属性值越小，则优先级越高。</li>
</ol>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"我正在吃:"</span>+food);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AspectFirst.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span>  </span><br><span class="line"><span class="annotation">@Order</span>(<span class="number">5</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectFirst</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Before</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspectFirstStart</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"@Before增强处理：我是AspectFirst切面，我的优先级为5"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@After</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspectFirstEnd</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"@After增强处理：我是AspectFirst切面，我的优先级为5"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AspectSecond.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span>  </span><br><span class="line"><span class="annotation">@Order</span>(<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectSecond</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Before</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspectSecondStart</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"@Before增强处理：我是AspectSecond切面，我的优先级为1"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@After</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspectSecondEnd</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"@After增强处理：我是AspectSecond切面，我的优先级为1"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同一个切面类里的两个相同类型的增强处理在同一个连接点被织入时，Spring AOP将以随机顺序来织入这两个增强处理，没有办法指定它们的织入顺序。如果确实需要保证它们以固有的顺序被织入，则可考虑将多个增强处理压缩成一个，或者将不同增强处理重构到不同切面类中，通过在切面类级别上进行排序。</p>
<h4 id="定义切入点">定义切入点</h4><p>我们在前面的文章中，在一个切面类中定义了4个增强处理，定义4个增强处理时分别指定了相同的切入点表达式，这种做法显然不太符合软件设计的原则：我们居然将那个切入点表达式重复了4次，如果有一天需要修改这个切入点表达式，那就要修改4个地方。如果重复了更多次呢？岁，我们就得修改更多次。</p>
<p>为了解决这个问题，AspectJ和Spring都允许定义切入点。所谓 定义切入点，其实质就是为一个切入点表达式起一个名称，从而允许在多个增强处理中重用该名称。</p>
<p>Spring AOP 只支持以Spring Bean的方法执行组作为连接点，所以可以把 切入点 看成所有能和切入表达式匹配的Bean方法。</p>
<p>切入点定义包括两个部分：</p>
<ol>
<li>一个切入点表达式：用于指定该切入点和哪些方法进行匹配。</li>
<li>一个包含名字和任意参数的方法签名：作为该切入点的名称。</li>
</ol>
<p>在@AspectJ风格的AOP中，切入点签名 采用一个普通的方法定义(方法体通常为空)，且方法的返回值必须为void；切入点表达式需要使用@Pointcut注解来标注。</p>
<p>下面的代码片段定义了一个切入点，anyOldTransfer，这个切入点将匹配任何名为transfer的方法的执行：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用@Pointcut注解时指定切入点表达式  </span></span><br><span class="line"><span class="annotation">@Pointcut</span>(<span class="string">"execution(* transfer(..))"</span>)  </span><br><span class="line"><span class="comment">//使用一个返回值为void，方法体为空的方法来命名切入点  </span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">anyOldTransfer</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>切入点表达式，也就是组成@Pointcut注解的值，是正规的AspectJ5切入点表达式。如果想要更多了解AspectJ的切入点语法，参见AspectJ编程指南。</p>
<p>一旦采用上面的代码片段定义了名为anyOldTransfer的切入点之后，程序就可以多次重复使用该切入点了，甚至可以在其他切面类、其他包的切面类里使用该切入点，至于是否可以在其他切面类、其他包的切面类里访问该切入点，则取决于该方法签名前的访问控制符—例如，本示例中anyOldTransfer方法使用的是private修饰符，则意味着仅能在当前切面类中使用该切入点。</p>
<p>如果需要使用本切面类中的切入点，则可在使用@Pointcut时，指定value属性值为已有的切入点，如下所示：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@AfterReturning</span>(pointcut=<span class="string">"myPointcut()"</span>,returning=<span class="string">"retVal"</span>)  </span><br><span class="line">public <span class="keyword">void</span> writeLog(<span class="built_in">String</span> msg,<span class="built_in">Object</span> retVal)&#123;  </span><br><span class="line">   ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，指定切入点时非常像调用Java方法的语法———只是该方法代表一个切入点，其实质是为该增强处理定义一个切入点表达式。</p>
<p>如果需要使用其他切面类中的切入点，则其他切面类中的切入点不能使用private修饰。如下程序的切面类中仅定义了一个切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemArchitecture</span></span>&#123;  </span><br><span class="line">   <span class="annotation">@Pointcut</span>(<span class="string">"execution(* org.crazyit.app.service.impl.Chin*.say*(..))"</span>)  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPointcut</span><span class="params">()</span></span>&#123;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的切面类中将直接使用上面定义的myPointcut切入点：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Aspect  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAspect</span> &#123;  </span><br><span class="line">    @AfterReturning(pointcut=<span class="string">"SystemArchitecture.myPointcut()&amp;&amp; args(msg)"</span>,returning=<span class="string">"retVal"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span>(<span class="params">String msg,Object retVal</span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(msg);  </span><br><span class="line">        System.<span class="keyword">out</span>.println(retVal);  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"模拟记录日志..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="切入点指示符">切入点指示符</h4><p>前面定义切点表达式时使用了大量的execution表达式，其中execution就是一个切入点指示符。Spring AOP仅支持部分AspectJ的切入点指示符，但Spring AOP还额外支持一个bean切入点指示符。不仅如此，因为Spring AOP只支持使用方法调用作为连接点，所以Spring AOP的切入点指示符仅匹配方法执行的连接点。</p>
<p>完整的AspectJ切入点语言支持大量切入点指示符，但是Spring并不支持它们。它们是：call，get，preinitialization，staticinitialization，initialization，handler，adviceexecution，withincode，cflow，cflowbelow，if，@this和@withincode。一旦在Spring AOP中使用这些切点指示符，就会抛出IllegalArgumentException。</p>
<p>Spring AOP支持的切入点指示符有如下几个：</p>
<ul>
<li><p>execution：用于匹配执行方法的连接点，这是Spring AOP中国最主要的切入点指示符。该切入点的用法也相对复杂，execution表达式的格式如下：</p>
<p>  execution(modifier-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)</p>
<p>  上面的格式中，execution是不变的，用于作为execution表达式的开头，整个表达式中几个参数的详细解释如下：</p>
<ul>
<li>modifier-pattern：指定方法的修饰符，支持通配符，该部分可以省略</li>
<li>ret-type-pattern：指定返回值类型，支持通配符，可以使用“*”来通配所有的返回值类型</li>
<li>declaring-type-pattern：指定方法所属的类，支持通配符，该部分可以省略</li>
<li>name-pattern：指定匹配的方法名，支持通配符，可以使用“*”来通配所有的方法名</li>
<li>param-pattern：指定方法的形参列表，支持两个通配符，“<em>”和“..”，其中“</em>”代表一个任意类型的参数，而“..”代表0个或多个任意类型的参数。</li>
<li>throw-pattern：指定方法声明抛出的异常，支持通配符，该部分可以省略</li>
</ul>
</li>
</ul>
<p>如下是几个execution表达式：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">execution</span><span class="params">(public * * (..)</span></span>)<span class="comment">//匹配所有public方法</span></span><br><span class="line"><span class="function"><span class="title">execution</span><span class="params">(* set*(..)</span></span>)<span class="comment">//匹配以set开始的方法</span></span><br><span class="line"><span class="function"><span class="title">execution</span><span class="params">(* com.abc.service.AdviceManager.* (..)</span></span>)<span class="comment">//匹配AdviceManager中任意方法</span></span><br><span class="line"><span class="function"><span class="title">execution</span><span class="params">(* com.abc.service.*.* (..)</span></span>)<span class="comment">//匹配com.abc.servcie包中任意类的任意方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>within：限定匹配特定类型的连接点，当使用Spring AOP的时候，只能匹配方法执行的连接点。下面是几个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">within</span><span class="params">(com.abc.service.*)</span></span><span class="comment">//匹配com.abc.service包中的任意连接点</span></span><br><span class="line"><span class="function"><span class="title">within</span><span class="params">(com.abc.service..*)</span></span><span class="comment">//匹配com.abc.service包或子包中任意的连接点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>this：用于指定AOP代理必须是指定类型的实例，用于匹配该对象的所有连接点。当使用Spring AOP的时候，只能匹配方法执行的连接点。下面是个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">this</span><span class="params">(com.abc.service.AdviceManager)</span></span><span class="comment">//匹配实现了AdviceManager接口的代理对象的所有连接点，在Spring中只是方法执行的连接点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>target：用于限定目标对象必须是指定类型的实例，用于匹配该对象的所有连接点。当使用Spring AOP的时候，只能匹配方法执行的连接点。下面是个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">target</span><span class="params">(com.abc.servcie.AdviceManager)</span></span><span class="comment">//匹配实现了AdviceManager接口的目标对象的所有连接点，在Spring中只是方法执行的连接点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>args：用于对连接点的参数类型进行限制，要求参数的类型时指定类型的实例。同样，当使用Spring AOP的时候，只能匹配方法执行的连接点。下面是个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">args</span><span class="params">(java.io.Serializable)</span></span><span class="comment">//匹配只接受一个参数，且参数类型是Serializable的所有连接点，在Spring中只是方法执行的连接点</span></span><br></pre></td></tr></table></figure>
<p>  注意，这个例子与使用execution(<em> </em>(java.io.Serializable))定义的切点不同，args版本只匹配运行时动态传入参数值是Serializable类型的情形，而execution版本则匹配方法签名只包含一个Serializable类型的形参的方法。</p>
<p>  另外，Spring AOP还提供了一个名为bean的切入点提示符，它是Spring AOP额外支持的，并不是AspectJ所支持的切入点指示符。这个指示符对Spring框架来说非常有用：它将指定为Spring中的哪个Bean织入增强处理。当然，Spring AOP中只能使用方法执行作为连接点。</p>
</li>
<li><p>bean：用于指定只匹配该Bean实例内的连接点，实际上只能使用方法执行作为连接点。定义bean表达式时需要传入Bean的id或name，支持使用”*”通配符。下面是几个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">bean</span><span class="params">(adviceManager)</span></span><span class="comment">//匹配adviceManager实例内方法执行的连接点</span></span><br><span class="line"><span class="function"><span class="title">bean</span><span class="params">(*Manager)</span></span><span class="comment">//匹配以Manager结尾的实例内方法执行的连接点</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="使用组合切点表达式">使用组合切点表达式</h4><p>Spring支持使用如下三个逻辑运算符来组合切入点表达式：</p>
<ul>
<li>&amp;&amp;：要求连接点同时匹配两个切点表达式</li>
<li>||：要求连接点匹配至少一个切入点表达式</li>
<li>!：要求连接点不匹配指定的切入点表达式</li>
</ul>
<p>其实在之前介绍args的时候，已经用到了“&amp;&amp;”运算符：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">pointcut</span><span class="params">(<span class="string">"execution(* com.abc.service.*.*(..) &amp;&amp; args(name))"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>上面的pointcut由两个表达式组成，而且使用&amp;&amp;来组合这两个表达式，因此连接点需要同时满足这两个表达式才能被织入增强处理。</p>
<h3 id="基于XML配置文件的管理方式">基于XML配置文件的管理方式</h3><p>在Spring的配置文件中，所有的切面、切点和增强处理都必须定义在<code>&lt;aop:config../&gt;</code>元素内部。<code>&lt;beans../&gt;</code>元素可以包含多个<code>&lt;aop:config../&gt;</code>元素，一个<code>&lt;aop:config../&gt;</code>可以包含pointcut、advisor和aspect元素，且这三个元素需要按照此顺序来定义。</p>
<p>注意：当我们使用<code>&lt;aop:config../&gt;</code>方式进行配置时，可能与Spring的自动代理方式相互冲突，因此，建议要么全部使用<code>&lt;aop:config../&gt;</code>配置方式，要么全部使用自动代理方式，不要把两者混合使用。</p>
<h4 id="配置切面">配置切面</h4><p>配置<code>&lt;aop:config../&gt;</code>元素时，实质是将已有的Spring Bean转换成切面Bean，所以需要先定义一个普通的Spring Bean。因为切面Bean可以当成一个普通的Spring Bean来配置，所以我们完全可以为该切面Bean配置依赖注入。当切面Bean的定义完成后，通过<code>&lt;aop:congig../&gt;</code>元素中使用ref属性来引用该Bean，就可以将该Bean转换成切面Bean了。配置<code>&lt;aop:config../&gt;</code>元素时可以指定如下三个属性：</p>
<ul>
<li>id：该切面Bean的标识名</li>
<li>ref：指定将要被转换成切面Bean的的普通Bean的id</li>
<li>order：指定该切面Bean的优先级，值越小，优先级越高</li>
</ul>
<p>如下配置片段定义了一个切面：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义普通的Bean实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"afterAdviceBean"</span> <span class="attribute">class</span>=<span class="value">"com.bean.AfterAdviceBean"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将容器中的afterAdviceBean转换成切面Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:aspect</span> <span class="attribute">id</span>=<span class="value">"afterAdviceAspect"</span> <span class="attribute">ref</span>=<span class="value">"afterAdviceBean"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="title">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的配置中，将一个AfterAdviceBean类型普通的Bean对象afterAdviceBean转换成了切面Bean对象afterAdviceAspect。</p>
<h4 id="配置增强处理">配置增强处理</h4><p>与使用@AspectJ完全一样，使用XML一样可以配置Before、After、AfterReturning、AfterThrowing和Around 5种增强处理，而且完全支持和@Aspect完全一样的语义。使用XML配置增强处理分别依赖于如下几个元素：</p>
<ul>
<li><code>&lt;aop:before../&gt;</code>：配置Before增强处理</li>
<li><code>&lt;aop:after../&gt;</code>：配置After增强处理</li>
<li><code>&lt;aop:after-returning../&gt;</code>：配置AfterReturning增强处理</li>
<li><code>&lt;aop:after-throwing../&gt;</code>：配置AfterThrowing增强处理</li>
<li><code>&lt;aop:around../&gt;</code>：配置Around增强处理</li>
</ul>
<p>这些元素都不支持使用子元素，但通常可以指定如下属性：</p>
<ul>
<li>pointcut：指定一个切入点表达式，Spring将在匹配该表达式的连接点织入增强处理</li>
<li>pointcut-ref：指定一个已经存在的切入点名称，通常pointcut和pointcut-ref只需使用其中之一</li>
<li>method：指定一个方法名，指定切面Bean的该方法作为增强处理</li>
<li>throwing：只对<code>&lt;aop:after-throwing../&gt;</code>元素有效，用于指定一个形参名，AfterThrowing增强处理方法，可通过该形参访问目标方法所抛出的异常</li>
<li>returning：只对<code>&lt;aop:after-returning../&gt;</code>元素有效，用于指定一个形参名，AfterThrowing增强处理方法，可通过该形参访问目标方法的返回值</li>
</ul>
<p>定义切点时，XML配置方式和@AspectJ注解方式支持完全相同的切点指示符，一样可以支持execution、within、args、this、target和bean等切点提示符。另外，XML配置文件方式也和@AspectJ方式一样支持组合切入点表达式，但XML配置方式不再使用简单的&amp;&amp;、|| 和 ! 作为组合运算符（因为直接在XML文件中需要使用实体引用来表示他们），而是使用如下三个组合运算符：and（相当于&amp;&amp;）、or（相当于||）和not（相当于！）。 下面是一个使用<code>&lt;aop:congig../&gt;</code>的例子，这是把前面的例子中关于切面切点和增强处理的注解去掉后，使用XML配置文件来重新实现这些切面切点的功能：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"adviceTest"</span> <span class="attribute">class</span>=<span class="value">"com.bean.AdviceTest"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意这里可以使用order属性为Aspect指定优先级 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:aspect</span> <span class="attribute">id</span>=<span class="value">"firstAspect"</span> <span class="attribute">ref</span>=<span class="value">"adviceTest"</span> <span class="attribute">order</span>=<span class="value">"2"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @Before切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:before</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span> </span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"permissionCheck"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @After切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:after</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span> </span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"releaseResource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @AfterReturning切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:after-returning</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span> </span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"log"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @AfterThrowing切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:after-throwing</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span> </span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"handleException"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @Around切点（多个切点提示符使用and、or或者not连接） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:around</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..)) and args(name,time,..)"</span> </span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"process"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的定义中，特意为firstAspec指定了order=2，表明firstAspect的优先级为2，如果这个XML文件中还有order=1的Aspect，那么这个Aspect将被Spring AOP优先织入。其执行结果，和前面几篇文章中介绍的相同，这里不再给出。</p>
<h4 id="配置切点">配置切点</h4><p>在Spring中通过<code>&lt;aop:pointcut../&gt;</code>元素来定义切点。当把<code>&lt;aop:pointcut../&gt;</code>元素作为<code>&lt;aop:config../&gt;</code>的子元素时，表明该切点可以被多个切面共享；当把<code>&lt;aop:pointcut../&gt;</code>元素作为<code>&lt;aop:aspect../&gt;</code>的子元素时，表明该切点只能在这个切面内使用。配置<code>&lt;aop:pointcut../&gt;</code>时，通常需要配置如下两个属性：</p>
<ul>
<li>id：指定该切点的标识名</li>
<li>expression：指定该切点关联的切点表达式</li>
</ul>
<p>如下的配置定义了一个简单的切点：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:pointcut <span class="variable">id=</span><span class="string">"point1"</span> <span class="variable">expression=</span><span class="string">"execution(* com.bean.service.*.*(..))"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>另外，如果程序中已经使用注解的方式定义了切点，在<code>&lt;aop:pointcut../&gt;</code>元素中指定切入点表达式时还有另一种用法，看例子：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:pointcut <span class="variable">id=</span><span class="string">"point2"</span> <span class="variable">expression=</span><span class="string">"com.bean.AdviceTest.myPointcut()"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>下面的程序中定义了一个AfterThrowing增强处理，包含该增强处理的切面类如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AfterThrowingAdviceTest</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个普通方法作为增强处理方法，这个方法名将在XML配置文件中指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryAction</span>(<span class="params">Throwable th</span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"目标方法抛出异常："</span> + th);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"模拟数据库事务恢复"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与前面的切面类完全类似，该Java类就是一个普通的Java类。下面的配置文件将负责配置该Bean实例，并将该Bean转换成切面Bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"afterThrowingAdviceTest"</span> </span><br><span class="line">    <span class="attribute">class</span>=<span class="value">"com.abc.advice.AfterThrowingAdviceTest"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个切点将可以被多个&lt;aop:aspect../&gt;使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:pointcut</span> <span class="attribute">id</span>=<span class="value">"myPointcut"</span> </span><br><span class="line">        <span class="attribute">expression</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个aspect由上面的Bean afterThrowingAdviceTest转化而来 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:aspect</span> <span class="attribute">id</span>=<span class="value">"aspect1"</span> <span class="attribute">ref</span>=<span class="value">"afterThrowingAdviceTest"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义一个AfterThrowing增强处理，指定切入点以切面Bean中</span><br><span class="line">            的doRecoverryAction作为增强处理方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:after-throwing</span> <span class="attribute">pointcut-ref</span>=<span class="value">"myPointcut"</span> </span><br><span class="line">            <span class="attribute">method</span>=<span class="value">"doRecoveryAction"</span> <span class="attribute">throwing</span>=<span class="value">"th"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的<code>&lt;aop:pointcut../&gt;</code>元素定义了一个全局的切点myPointcut，这样其他切面Bean就可以多次复用这个切点了。<code>&lt;aop:after-throwing../&gt;</code>元素中，使用pointcut-ref属性指定了一个已经存在的切点。</p>
<h2 id="Spring_的事务">Spring 的事务</h2><h3 id="Spring支持的事务策略">Spring支持的事务策略</h3><p>JavaEE应用的传统事务有两种策略：全局事务和局部事务。</p>
<ul>
<li>全局事务由应用服务器管理，需要底层服务器的JTA支持。</li>
<li>局部事务和底层所采用的持久化技术有关，当采用JDBC持久化技术时，需要使用Connection对象来操作事务；而采用Hibernate持久化技术时，需要使用Session对象来操作事务。</li>
</ul>
<p>当采用传统的事务编程策略时，程序代码必然和具体的事务操作代码耦合，这样造成的后果是：当应用需要在不同的事务策略之间切换时，开发者必须手动修改程序代码。当使用Spring事务策略后，就可以改变这种状况。</p>
<p>Spring事务策略是通过PlatformTransactionManager接口实现的，该接口是Spring事务策略的核心。该接口的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;  </span><br><span class="line">   <span class="comment">//平台无关的获得事务的方法  </span></span><br><span class="line">   <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">   <span class="comment">//平台无关的事务提交方法  </span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">   <span class="comment">//平台无关的事务回滚方法  </span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PlatformTransactionManager是一个与任何事务策略分离的接口，随着底层不同事务策略的切换，应用必须采用不同的实现类。PlatformTransactionManager接口没有与任何事务资源捆绑在一起，它可以适应于任何的事务策略，结合Spring的IoC容器，可以向PlatformTransactionManager注入相关的平台特性。</p>
<p>PlatformTransactionManager接口有许多不同的实现类，应用程序面向于平台无关的接口编程，当底层采用不同的持久层技术时，系统只需使用不同的 PlatformTransactionManager 实现类即可。而这种切换通常由Spring容器负责管理，应用程序既无须与具体的事务API耦合，也无须与特定实现类耦合，从而将应用和持久化技术、事务API彻底分离开来。</p>
<p>TransactionStatus对象表示一个事务。getTransaction(TransactionDefinition definition)返回的TransactionStatus对象，可能是一个新的事务，也可能是一个已经存在的事务对象；否则，系统将新建一个事务对象后返回。</p>
<p>TransactionDefinition接口定义了一个事务规则，该接口必须指定如下几个属性：</p>
<ul>
<li>事务隔离    当前事务和其他事务的隔离程度。例如这个事务能否看到其他事务未提交的数据等。</li>
<li>事务传播    通常，在事务中执行的代码都会在当前事务中运行。但是如果一个事务上下文已经存在，有几个选项可指定该事务性方法的执行行为。例如，大多数情况下，简单地在现有的事务上下文中运行；或者挂起现有事务，创建一个新的事务。Spring提供EJB CMT中所有的事务传播选项。</li>
<li>事务超时    事务在超时前能运行多久，也就是事务的最长持续时间。如果事务一直没有被提交或回滚，将在超出该时间后，系统自动回滚事务。</li>
<li>只读状态    只读事务不修改任何数据。在某些情况下，例如使用Hibernate时，只读事务是非常有用的优化。TransactionStatus代表事务本身，它提供了简单的控制事务执行和查询事务状态的方法，这些方法在所有的事务API中都是相同的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SavepointManager</span> </span>&#123;  </span><br><span class="line">    <span class="function">Object <span class="title">createSavepoint</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollbackToSavepoint</span><span class="params">(Object savepoint)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseSavepoint</span><span class="params">(Object savepoint)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring具体的事务管理由PlatformTransactionManager的不同实现类来完成。在Spring容器中配置PlatformTransactionManager Bean时，必须针对不同环境提供不同的实现类。<br>譬如针对 JDBC数据源 的局部事务策略的配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">        <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line">        <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">        <span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span>  </span><br><span class="line">        <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans   </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span><br><span class="line">                http://www.springframework.org/schema/context   </span><br><span class="line">                http://www.springframework.org/schema/context/spring-context-2.5.xsd  </span><br><span class="line">                http://www.springframework.org/schema/tx   </span><br><span class="line">                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义数据源Bean，使用C3P0数据源实现 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClass"</span> <span class="attribute">value</span>=<span class="value">"oracle.jdbc.driver.OracleDriver"</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jdbcUrl"</span> <span class="attribute">value</span>=<span class="value">"jdbc:oracle:thin:@localhost:1521:orcl"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"scott"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"tiger"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxPoolSize"</span> <span class="attribute">value</span>=<span class="value">"40"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"minPoolSize"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"initialPoolSize"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxIdleTime"</span> <span class="attribute">value</span>=<span class="value">"20"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 配置JDBC数据源的局部事务管理器，使用DataSourceTransactionManager类 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 该类实现PlatformTransactionManager接口，是针对采用数据源连接的特定实现 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span>   </span><br><span class="line">          <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>针对 Hibernate 的局部事务策略的配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义Hibernate的SessionFactory --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionFactory"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"mappingResources"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">list</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>xxx/Xxx.hbm.xml<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="title">list</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernateProperties"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">props</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLInnoDBDialect<span class="tag">&lt;/<span class="title">prop</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="title">prop</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="title">props</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 配置Hibernate的局部事务管理器，使用HibernateTransactionManager类 --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 该类实现PlatformTransactionManager接口，是针对采用Hibernate的特定实现 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span>   </span><br><span class="line">        <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionFactory"</span> <span class="attribute">ref</span>=<span class="value">"sessionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">```      </span><br><span class="line"></span><br><span class="line">从上面的配置文件可以看出，当采用Spring事务管理策略时，应用程序无须与具体的事务策略耦合。Spring提供了两种事务管理方式：</span><br><span class="line">1. 编程式事务管理：即使利用Spring编程式事务时，程序也可直接获取容器中的transactionManager Bean，该Bean总是PlatformTransactionManager的实例，所以可以通过该接口提供的3个方法来开始、提交事务和回滚事务。</span><br><span class="line">2. 声明式事务管理：无须在Java程序中书写任何的事务操作代码，而是通过在XML文件中为业务组件配置事务代理，AOP为事务代理所织入的增强处理也由Spring提供：在目标方法执行之前，织入开始事务；在目标方法执行之后，织入结束事务。</span><br><span class="line"></span><br><span class="line">不论采用何种持久化策略，Spring都提供了一致的事务抽象，因此，应用开发者能在任何环境下，使用一致的编程模型。无须更改代码，应用就可在不同的事务管理策略中切换。</span><br><span class="line"></span><br><span class="line">### 使用TransactionProxyFactoryBean创建事务代理</span><br><span class="line"></span><br><span class="line">Spring同时支持编程式事务策略和声明式事务策略，在实际开发中，几乎都采用声明式事务策略。使用声明式事务策略的优势 十分明显：</span><br><span class="line"></span><br><span class="line">1. 声明式事务能大大降低开发者的代码书写量，而且声明式事务几乎不影响应用的代码。因此，无论底层事务策略如何变化，应用程序都无须任何改变。</span><br><span class="line">2. 应用程序代码无须任何事务处理代码，可以更关注于业务逻辑的实现。</span><br><span class="line">3. Spring可对任何POJO的方法提供事务管理，而且Spring的声明式事务管理无须容器的支持，可在任何环境下使用。</span><br><span class="line">4. EJB的CMT无法提供声明式回滚规则；而通过配置文件，Spring可指定事务在遇到特定异常时自动回滚。Spring不仅可在代码中使用setRollbackOnly回滚事务，也可在配置文件中配置回滚规则。</span><br><span class="line">5. 由于Spring采用AOP方式管理事务，因此可以在事务回滚动作中插入用户自己的动作，而不仅仅是执行系统默认的回滚。</span><br><span class="line"></span><br><span class="line">在Spring1.x中，声明式事务使用 TransactionProxyFactoryBean 来配置事务代理Bean。每个TransactionProxyFactoryBean为一个目标Bean生成一个事务代理Bean，事务代理的方法改写了目标Bean的方法，就是在目标Bean的方法执行之前加入开始事务，在目标Bean的方法正常结束之后提交事务，如果遇到特定异常则回滚事务。</span><br><span class="line"></span><br><span class="line">TransactionProxyFactoryBean创建事务代理时，需要了解当前事务所处的环境，该环境属性通过PlatformTransactionManager实例传入，而相关事务规则则在该Bean定义中给出。</span><br><span class="line"></span><br><span class="line">NewsDao.java :</span><br></pre></td></tr></table></figure></p>
<p>public interface NewsDao {<br>    public void insert(Integer id,String title,String content);<br>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NewsDaoImpl<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class NewsDaoImpl implements NewsDao{<br>    private DataSource ds;<br>    public void setDs(DataSource ds) {<br>        this.ds = ds;<br>    }<br>    @Override<br>    public void insert(Integer id, String title, String content) {<br>        JdbcTemplate jt=new JdbcTemplate(ds);<br>        jt.update(“insert into news values(?,?,?)”,new Object[]{id,title,content});<br>        jt.update(“insert into news values(?,?,?)”,new Object[]{id,title,content});<br>    }<br>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean<span class="class">.xml</span> :</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;  </p>
<p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemalocation="http://www.springframework.org/schema/beans   
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  
                http://www.springframework.org/schema/context   
                http://www.springframework.org/schema/context/spring-context-2.5.xsd  
                http://www.springframework.org/schema/tx   
                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"><br>    <!-- 定义数据源Bean --><br>    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"><br>        <property name="driverClass" value="oracle.jdbc.driver.OracleDriver"><br>        <property name="jdbcUrl" value="jdbc:oracle:thin:@localhost:1521:orcl"><br>        <property name="user" value="scott"><br>        <property name="password" value="tiger"><br>        <property name="maxPoolSize" value="40"><br>        <property name="minPoolSize" value="1"><br>        <property name="initialPoolSize" value="1"><br>        <property name="maxIdleTime" value="20"><br>    </property></property></property></property></property></property></property></property></bean><br>    <!-- 配置一个业务逻辑Bean --><br>    <bean id="newsDao" class="com.bean.NewsDaoImpl"><br>        <property name="ds" ref="dataSource"><br>    </property></bean><br>    <!-- 配置JDBC数据源的局部事务管理器 --><br>    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"><br>        <property name="dataSource" ref="dataSource"><br>    </property></bean><br>    <!-- 为业务逻辑Bean配置事务代理 --><br>    <bean id="newsDaoTrans" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"><br>          <property name="transactionManager" ref="transactionManager"><br>          <property name="target" ref="newsDao"><br>          <property name="transactionAttributes"><br>            <props><br>                <prop key="*">PROPAGATION_REQUIRED</prop><br>            </props><br>          </property><br>    </property></property></bean><br></beans><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class Test {<br>    public static void main(String[] args) {<br>        ApplicationContext ctx=new ClassPathXmlApplicationContext(“bean.xml”);<br>        NewsDao dao=(NewsDao) ctx.getBean(“newsDaoTrans”);<br>        dao.insert(1,”夺冠”,”绿衫军夺冠”);<br>    }<br>}<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以知道，插入数据失败。上面程序中违反主键约束，该行代码将引发异常。</span><br><span class="line"></span><br><span class="line">如果在没有事务控制的环境下，前一条代码将会向数据表中插入一条记录，第二条插入失败。但是现在一条记录都没有插入，这说明事务起作用了，这两条语句是一个整体，因为第二条插入失败，导致第一条插入的数据也被回滚。</span><br><span class="line"></span><br><span class="line">配置事务代理 时需要传入一个事务管理器，一个目标Bean，并指定该事物代理的事务属性，事务属性由transactionAttributes属性指定。上面事务属性只有一条事务传播规则，该规则指定对于所有方法都使用PROPAGATION_REQUIRED的传播规则。Spring支持的事务传播规则如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>PROPAGATION_MANDATORY	要求调用该方法的线程必须处于事务环境中，否则抛出异常。</span><br><span class="line"><span class="bullet">* </span>PROPAGATION<span class="emphasis">_NESTED	如果执行该方法的线程已经处于事务环境下，依然启动新的事务，方法在嵌套的事务里执行。如果执行该方法的线程并未处于事务中，也启动新的事务，然后执行该方法，次时与PROPAGATION_</span>REQUIRED相同。</span><br><span class="line"><span class="bullet">* </span>PROPAGATION_NEVER	不允许调用该方法的线程处于事务环境下，如果调用该方法的线程处于事务环境下，则抛出异常。</span><br><span class="line"><span class="bullet">* </span>PROPAGATION<span class="emphasis">_NOT_</span>SUPPORTED	如果调用该方法的线程处在事务中，则先暂停当前事务，然后执行该方法。</span><br><span class="line"><span class="bullet">* </span>PROPAGATION_REQUIRED	要求在事务环境中执行该方法，如果当前执行线程已经处于事务中，则直接调用；如果当前执行线程不处于事务中，则启动新的事务后执行该方法。</span><br><span class="line"><span class="bullet">* </span>PROPAGATION<span class="emphasis">_REQUIRES_</span>NEW	该方法要求在新的事务环境中执行，如果当前执行线程已经处于事务中，则先暂停当前事务，启动新事务后执行该方法；如果当前调用线程不处于事务中，则启动新的事务后执行方法。</span><br><span class="line"><span class="bullet">* </span>PROPAGATION_SUPPORTS	如果当前执行线程处于事务中，则使用当前事务，否则不使用事务。</span><br><span class="line"></span><br><span class="line"><span class="header">### Spring2.x的事务配置策略</span></span><br><span class="line"></span><br><span class="line">Spring1.x 的声明式事务使用TransactionProxyFactoryBean配置策略简单易懂，但是配置起来极为繁琐：每个目标Bean都需要额外配置一个TransactionProxyFactoryBean代理，这种方式将导致配置文件急剧增加。</span><br><span class="line"></span><br><span class="line">Spring 2.x 的XML Schema方式提供了更简洁的事务配置策略，Spring2.x提供了tx命名空间来配置事务管理，tx命名空间下提供了<span class="code">`&lt;tx:advice.../&gt;`</span> 元素来配置事务增强处理，一旦使用该元素配置了事务增强处理，就可直接使用<span class="code">`&lt;aop:advisor.../&gt;`</span> 元素启用自动代理了。</span><br><span class="line"></span><br><span class="line">bean.xml :</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;  </p>
<p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemalocation="http://www.springframework.org/schema/beans   
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  
                http://www.springframework.org/schema/context   
                http://www.springframework.org/schema/context/spring-context-2.5.xsd  
                http://www.springframework.org/schema/tx   
                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd  
                http://www.springframework.org/schema/aop   
                http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"><br>    <!-- 定义数据源Bean --><br>    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"><br>        <property name="driverClass" value="oracle.jdbc.driver.OracleDriver"><br>        <property name="jdbcUrl" value="jdbc:oracle:thin:@localhost:1521:orcl"><br>        <property name="user" value="scott"><br>        <property name="password" value="tiger"><br>        <property name="maxPoolSize" value="40"><br>        <property name="minPoolSize" value="1"><br>        <property name="initialPoolSize" value="1"><br>        <property name="maxIdleTime" value="20"><br>    </property></property></property></property></property></property></property></property></bean><br>    <!-- 配置一个业务逻辑Bean --><br>    <bean id="newsDao" class="com.bean.NewsDaoImpl"><br>        <property name="ds" ref="dataSource"><br>    </property></bean><br>    <!-- 配置JDBC数据源的局部事务管理器 --><br>    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"><br>        <property name="dataSource" ref="dataSource"><br>    </property></bean><br>    <!-- 配置事务增强处理Bean，指定事务管理器 --><br>    <tx:advice id="txAdvice" transaction-manager="transactionManager"><br>        <tx:attributes><br>            <!-- 所有以'get'开头的方法是只读的 --><br>            <tx:method name="get*" read-only="true"><br>            <!-- 其他方法使用默认的事务处理 --><br>            <tx:method name="*"><br>        </tx:method></tx:method></tx:attributes><br>    </tx:advice><br>    <!-- AOP配置的元素 --><br>    <aop:config><br>        <aop:pointcut id="myPointcut" expression="execution(* com.bean.*.*(..))"><br>        <aop:advisor advice-ref="txAdvice" pointcut-ref="myPointcut"><br>    </aop:advisor></aop:pointcut></aop:config><br></beans><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class Test {<br>    public static void main(String[] args) {<br>        ApplicationContext ctx=new ClassPathXmlApplicationContext(“bean.xml”);<br>        NewsDao dao=(NewsDao) ctx.getBean(“newsDao”);<br>        dao.insert(1,”夺冠”,”绿衫军夺冠”);<br>    }<br>}<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可见，事务已经自动启动了。两条记录是一个事务，第二条记录插入失败，导致第一条记录也被回滚。</span><br><span class="line"></span><br><span class="line">配置 `&lt;tx:advice.../&gt;` 元素时只需指定一个transaction-manager属性，该属性的默认值是“transactionManager”。除了transaction-manager属性之外，还需要配置一个attributes子元素，该子元素里又可包含多个<span class="keyword">method</span>子元素，每个`&lt;<span class="keyword">method</span>.../&gt;`子元素为一批方法指定所需的事务语义，包括事务传播属性、事务隔离属性、事务超时属性、只读事务、对指定异常回滚，对指定异常不回滚等。</span><br><span class="line"></span><br><span class="line">配置<span class="keyword">method</span>子元素时可以指定如下几个属性：</span><br><span class="line"></span><br><span class="line">* name	必选属性，与该事务语义关联的方法名。该属性支持使用通配符，例如get*，handle*等。</span><br><span class="line">* propagation	指定事务传播行为，该属性值可为<span class="type">Propagation</span>枚举类的任一枚举值，默认为<span class="type">Propagation_REQUIRED</span>。</span><br><span class="line">* isolation	指定事务隔离级别。该属性值可为<span class="type">Isolation</span>枚举类的任一枚举值，默认为<span class="type">Isolation_DEFAULT</span>。</span><br><span class="line">* timeout	指定事务超时的时间(以秒为单位)。指定-<span class="number">1</span>意味着不超时，默认值为-<span class="number">1</span>。</span><br><span class="line">* read-only	指定事务是否只读。默认为<span class="literal">false</span>。</span><br><span class="line">* rollback-<span class="keyword">for</span>	指定触发事务回滚的异常类，可指定多个异常类，以英文逗号隔开。</span><br><span class="line">* no-rollback-<span class="keyword">for</span>	指定不触发事务回滚的异常类，可指定多个异常类，以英文逗号隔开。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 使用@Transactional</span></span><br><span class="line"></span><br><span class="line"><span class="type">Spring</span> 还允许将事务配置放在<span class="type">Java</span>类中定义，这需要借助于@<span class="type">Transactional</span>注解，该注解既可用于修饰<span class="type">Spring</span> <span class="type">Bean</span>类，也可用于修饰<span class="type">Bean</span>类中的某个方法。</span><br><span class="line"></span><br><span class="line">使用@<span class="type">Transactional</span>修饰<span class="type">Bean</span>类，表明这些事务设置对整个<span class="type">Bean</span>类起作用；</span><br><span class="line">使用@<span class="type">Transactional</span>修饰<span class="type">Bean</span>类中的某个方法，表明这些事务设置只对该方法有效。</span><br><span class="line">使用@<span class="type">Transactional</span> 时可指定如下属性：</span><br><span class="line">* isolation	用于指定事务的隔离级别，默认为底层事务的隔离级别。</span><br><span class="line">* noRollbackFor	指定遇到指定异常时强制不回滚事务。</span><br><span class="line">* noRollbackForClassName	指定遇到指定多个异常时强制不回滚事务，该属性值可以指定多个异常类名。</span><br><span class="line">* propagation	指定事务传播属性。</span><br><span class="line">* readOnly	指定事务是否只读。</span><br><span class="line">* rollbackFor	指定遇到特定异常时强制回滚事务。</span><br><span class="line">* rollbackForClassName	指定遇到指定多个异常时强制回滚事务，该属性值可以指定多个异常类名。</span><br><span class="line">* timeout	指定事务的超时时长。 例如：</span><br></pre></td></tr></table></figure></p>
<p>public class NewsDaoImpl implements NewsDao{<br>    private DataSource ds;<br>    public void setDs(DataSource ds) {<br>        this.ds = ds;<br>    }<br>    @Transactional(propagation=Propagation.REQUIRED)//这里<br>public void insert(Integer id, String title, String content) {<br>        JdbcTemplate jt=new JdbcTemplate(ds);<br>        jt.update(“insert into news values(?,?,?)”,new Object[]{id,title,content});<br>        jt.update(“insert into news values(?,?,?)”,new Object[]{id,title,content});<br>    }<br>}<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">仅仅使用这个<span class="keyword">Annotation</span>修饰还不够，还需要让Spring根据<span class="keyword">Annotation</span>来配置事务代理，所以还需要在Spring配置文件中增加如下配置片段：</span><br></pre></td></tr></table></figure></p>
<p><bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"><br>        <property name="dataSource" ref="dataSource"><br>    </property></bean>  </p>
<p><tx:annotation-driven transaction-manager="transactionManager"><br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Spring整合Struts2</span><br><span class="line"></span><br><span class="line">### 启动Spring容器</span><br><span class="line"></span><br><span class="line">实际开发中，项目多数会选择使用Spring整合Struts2框架。对于使用Spring框架的Web应用，我们不能手动创建Spring容器，而是通过配置文件，声明式地创建Spring容器。为了让Spring容器随着Web应用的启动而自动地创建起来，可以借助于ServletContextListener监听器完成，该监听器可以在Web应用启动时回调自定义方法从而创建Spring容器。</span><br><span class="line"></span><br><span class="line">Spring提供了一个ContextLoaderListener，该监听器类实现了ServletContextListener接口，可以作为监听器使用。那么该监听器类的回调方法根据什么东西创建Spring容器呢？答案当然是Spring的配置文件。如果有多个配置文件需要载入，考虑使用<span class="escape">`&lt;</span>context-param.../&gt;<span class="escape">`元</span>素来确定配置文件。ContextLoaderListener加载时，会查找名为contextConfigLocation的初始化参数，因此配置<span class="escape">`&lt;</span>context-param.../&gt;<span class="escape">`时</span>应指定参数名为contextConfigLocation。参数值为Spring的多个配置文件，文件之间以逗号隔开。</span><br><span class="line"></span><br><span class="line">Spring根据指定配置文件创建WebApplicationContext对象，并将其保存在Web应用的ServletContext中。如果要获得Spring容器对象，可以通过如下代码：</span><br></pre></td></tr></table></figure></tx:annotation-driven></p>
<p>WebApplicationContext ctx=  WebApplicationContextUtils.getWebApplicationContext(servletContext);<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">web<span class="class">.xml</span> :</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;  </p>
<p><web-app version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://java.sun.com/xml/ns/j2ee   
    http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"><br>  <context-param><br>    <param-name>contextConfigLocation</param-name><br>    <param-value>classpath:beans.xml</param-value><br>  </context-param><br>  <listener><br>    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class><br>  </listener><br>  <filter><br>    <filter-name>struts2</filter-name><br>    <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class><br>  </filter><br>  <filter-mapping><br>    <filter-name>struts2</filter-name><br>    <url-pattern>/*</url-pattern><br>  </filter-mapping><br></web-app><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index<span class="class">.jsp</span> :</span><br></pre></td></tr></table></figure></p>
<p><body><br><a href="test">点击我</a><br></body><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok<span class="class">.jsp</span> :</span><br></pre></td></tr></table></figure></p>
<p><body><br>操作成功，已获得Spring容器实例,控制台已经输出了容器对象…<br></body><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struts<span class="class">.xml</span> :</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;<br>&lt;!DOCTYPE struts PUBLIC<br>    “-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN”<br>    “<a href="http://struts.apache.org/dtds/struts-2.1.7.dtd&quot;&gt;" target="_blank" rel="external">http://struts.apache.org/dtds/struts-2.1.7.dtd&quot;&gt;</a>  </p>
<p><struts><br>    <package name="demo" extends="struts-default"><br>        <action name="test" class="com.action.TestAction"><br>            <result>/ok.jsp</result><br>        </action><br>    </package><br></struts><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestAction<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class TestAction extends ActionSupport {<br>    @Override<br>    public String execute() throws Exception {<br>        ServletContext servletContext=ServletActionContext.getServletContext();<br>        WebApplicationContext ctx=<br>            WebApplicationContextUtils.getWebApplicationContext(servletContext);<br>        System.out.println(ctx);<br>        return “success”;<br>    }<br>}<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果将Spring的配置文件放在WEB-INF目录下：</span><br><span class="line"></span><br><span class="line">则修改web.xml的&lt;<span class="built_in">param</span>-<span class="built_in">value</span>&gt;的值为：</span><br></pre></td></tr></table></figure></p>
<p><context-param><br>  <param-name>contextConfigLocation</param-name><br>  <param-value>/WEB-INF/beans.xml</param-value><br></context-param><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="header">### MVC框架与Spring整合的思考</span></span><br><span class="line"></span><br><span class="line">对于一个基于B/S架构的JavaEE应用而言，用户请求总是向MVC框架的控制器请求，而当控制器拦截到用户请求后，必须调用业务逻辑组件来处理用户请求。此时有一个问题：控制器应该如何获得业务逻辑组件？</span><br><span class="line"></span><br><span class="line">最容易想到的策略是，直接通过 new 关键字创建业务逻辑组件，然后调用业务逻辑组件的方法，根据业务逻辑方法的返回值确定结果。</span><br><span class="line"></span><br><span class="line">在实际开发中，很少采用上面的策略，因为这是一种非常差的策略。原因有三：</span><br><span class="line"><span class="bullet">1. </span>控制器直接创建业务逻辑组件，导致控制器和业务逻辑组件的耦合降低到代码层次，不利于高层次解耦。</span><br><span class="line"><span class="bullet">2. </span>控制器不应该负责业务逻辑组件的创建，控制器只是业务逻辑组件的使用者，无须关心业务逻辑组件的实现。</span><br><span class="line"><span class="bullet">3. </span>每次创建新的业务逻辑组件导致性能下降。</span><br><span class="line"></span><br><span class="line">对于轻量级的JavaEE应用，工厂模式 则是更实际的策略。因为在轻量级JavaEE应用中，业务逻辑组件不是EJB，通常就是一个POJO，业务逻辑组件的生成通常应由工厂负责，而且工厂可以保证该组件的实例只有一个，这样就可以避免重复实例化造成的系统开销。</span><br><span class="line"></span><br><span class="line">采用工厂模式，将控制器和业务逻辑组件的实现分离，从而提供更好的解耦。在采用工厂模式的访问策略中，所有的业务逻辑组件的创建由工厂负责，业务逻辑组件的运行也由工厂负责。控制器只需定位工厂实例即可。</span><br><span class="line"></span><br><span class="line">如果系统采用 Spring框架，则Spring成为最大的工厂。Spring负责业务逻辑组件的创建和生成，并可管理业务逻辑组件的生命周期。可以如此理解：Spring是个性能非常优秀的工厂，可以生产出所有的实例，从业务逻辑组件，到持久层组件，甚至控制器组件。</span><br><span class="line"></span><br><span class="line">现在的问题是：控制器如何访问到Spring容器中的业务逻辑组件呢？有两种策略：</span><br><span class="line"><span class="bullet">1. </span>Spring容器负责管理控制器Action，并利用依赖注入为控制器注入业务逻辑组件。</span><br><span class="line"><span class="bullet">2. </span>利用Spring的自动装配，Action将会自动从Spring容器中获取所需的业务逻辑组件。</span><br><span class="line"></span><br><span class="line"><span class="header">### 让Spring容器管理控制器</span></span><br><span class="line"></span><br><span class="line">web.xml如前所示。 </span><br><span class="line">index.jsp :</span><br></pre></td></tr></table></figure></p>
<p><body>  </body></p>
<p><form action="add" method="post"><br>部门名称:<input type="text" name="dname"><br><br>部门地址:<input type="text" name="loc"><br>  </form></p>
<p><input type="submit" value="提交"><br><br><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok<span class="class">.jsp</span> :</span><br></pre></td></tr></table></figure></p>
<p><body><br>部门信息添加成功…<br></body><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dept<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class Dept {<br>    private String dname;<br>    private String loc;<br>    //setter .. getter<br>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeptDAO<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public interface DeptDAO {<br>    public void save(Dept dept);<br>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeptDAOImpl<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class DeptDAOImpl implements DeptDAO {<br>    @Override<br>    public void save(Dept dept) {<br>        System.out.println(“将Dept对象保存进数据库”);<br>    }<br>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddDeptAction<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class AddDeptAction extends ActionSupport {<br>    private String dname;<br>    private String loc;<br>    private DeptDAO deptDao;<br>    public String execute(){<br>        Dept dept=new Dept();<br>        dept.setDname(dname);<br>        dept.setLoc(loc);<br>        deptDao.save(dept);<br>        return “success”;<br>    }<br>    //setter … getter<br>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struts<span class="class">.xml</span> :</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;<br>&lt;!DOCTYPE struts PUBLIC<br>    “-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN”<br>    “<a href="http://struts.apache.org/dtds/struts-2.1.7.dtd&quot;&gt;" target="_blank" rel="external">http://struts.apache.org/dtds/struts-2.1.7.dtd&quot;&gt;</a>  </p>
<p><struts><br>    <package name="demo" extends="struts-default"><br>        <action name="add" class="addDeptAction"><br>            <result>/ok.jsp</result><br>        </action><br>    </package><br></struts><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beans<span class="class">.xml</span> :</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;  </p>
<p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemalocation="http://www.springframework.org/schema/beans   
                http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  
                http://www.springframework.org/schema/context   
                http://www.springframework.org/schema/context/spring-context-2.5.xsd  
                http://www.springframework.org/schema/tx  
                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd  
                http://www.springframework.org/schema/aop  
                http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"><br>    <bean id="addDeptAction" class="com.action.AddDeptAction" scope="prototype"><br>        <property name="deptDao" ref="dao"><br>    </property></bean><br>    <bean id="dao" class="com.dao.DeptDAOImpl"><br></bean></beans><br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">## Spring整合Hibernate</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### Spring提供的DAO支持</span></span><br><span class="line"></span><br><span class="line">DAO模式 是一种标准的Java EE设计模式，DAO模式的核心思想是：所有的数据库访问，都通过DAO组件完成，DAO组件封装了数据库的增删改等原子操作。业务逻辑组件依赖于DAO组件提供的数据库原子操作，完成系统业务逻辑的实现。</span><br><span class="line"></span><br><span class="line">DAO组件是整个Java EE应用的持久层访问的重要组件，每个JavaEE应用的底层实现都难以离开DAO组件的支持。Spring对实现DAO组件提供了许多工具类，系统的DAO组件可通过继承这些工具类完成，从而可以更加简便地实现DAO组件。</span><br><span class="line"></span><br><span class="line">Spring提供了一系列的抽象类，这些抽象类将被作为应用中DAO实现类的父类。通过继承这些抽象类，Spring简化了DAO的开发步骤，能以一致的方式使用数据库访问技术。不管底层采用JDBC还是Hibernate，应用中都可采用一致的编程模型。</span><br><span class="line"></span><br><span class="line">除外之外，Spring通过了一致的异常抽象，将原有的checked异常转换包装成Runtime异常，因而，编码时无须捕获各种技术中特定的异常。Spring DAO体系中的异常，都继承DataAccessException，而DataAccessException异常是Runtime的，无须显式捕捉。通过DataAccessException的子类包装原始异常信息，从而保证应用程序依然可以捕捉到原始异常信息。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 管理Hibernate的SessionFactory</span></span><br><span class="line"></span><br><span class="line">在实际开发中，我们直接以配置文件来管理SessionFactory实例。</span><br></pre></td></tr></table></figure></p>
<!-- 定义Hibernate的SessionFactory -->  
<p><bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"><br>    <property name="dataSource" ref="dataSource"><br>    <property name="mappingResources"><br>        <list><br>            <value>xxx/Xxx.hbm.xml</value><br>        </list><br>    </property><br>    <property name="hibernateProperties"><br>        <props><br>            <prop key="hibernate.dialect">org.hibernate.dialect.MySQLInnoDBDialect</prop><br>            <prop key="hibernate.hbm2ddl.auto">update</prop><br>        </props><br>    </property><br></property></bean><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### 使用HibernateTemplate</span></span><br><span class="line"></span><br><span class="line"><span class="type">HibernateTemplate</span>文档中的一句话：</span><br><span class="line"></span><br><span class="line"><span class="type">NOTE</span>: <span class="type">As</span> <span class="keyword">of</span> <span class="type">Hibernate</span> <span class="number">3</span>.<span class="number">0</span>.<span class="number">1</span>, transactional <span class="type">Hibernate</span> access code can also be coded <span class="keyword">in</span> plain <span class="type">Hibernate</span> style. <span class="type">Hence</span>, <span class="keyword">for</span> newly started projects,consider adopting the standard <span class="type">Hibernate3</span> style <span class="keyword">of</span> coding data access objects instead, based on <span class="type">SessionFactory</span>.getCurrentSession().(<span class="type">Spring</span>'s <span class="type">LocalSessionFactoryBean</span> automatically supports <span class="type">Spring</span> transaction management <span class="keyword">for</span> the <span class="type">Hibernate3</span> getCurrentSession() <span class="keyword">method</span>.)作者说：在新开始的工程，可以考虑用标准的<span class="type">Hibernate3</span>的编码方式作为<span class="type">HibernateTemplate</span>的替代。因为<span class="type">Hibernate3</span>提供的<span class="type">SessionFactory</span>.getCurrentSession()已经取代了以往那种每次操作都open一个新<span class="type">Session</span>的方式，同时<span class="type">Spring</span>的<span class="type">LocalSessionFactoryBean</span>自动支持<span class="type">Hibernate3</span>的getCurrentSession()的事务管理。也就是说，如果不用<span class="type">HibernateTemplate</span>这咱<span class="type">Spring</span>的专有<span class="type">API</span>，而只用<span class="type">Hibernate3</span>,我们一样可以受用<span class="type">Spring</span>的事务管理。</span><br></pre></td></tr></table></figure></p>
<p>puclic class PersonDaoImpl implements PersonDao {<br>    private HibernateTemplate ht = null;<br>    @Resource(name=”sessionFactory”)<br>    private SessionFactory sessionFactory;</p>
<pre><code>private HibernateTemplate getHibernateTemplate(){
    if(ht==null){
        ht = new HibernateTemplate(sessionFactory);
    }
    return ht;
}
public <span class="keyword">Person</span> get(Integer id){
    return getHibernateTemplate().get(<span class="keyword">Person</span>.class,id);
}
//....
</code></pre><p>}<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">常用方法</span><br><span class="line">delete(Object entity)：删除指定持久化实例</span><br><span class="line">deleteAll(Collection entities)：删除集合内全部持久化类实例</span><br><span class="line">find(String queryString)：根据HQL查询字符串来返回实例集合  //from <span class="keyword">Person</span>,返回<span class="keyword">Person</span>的全部实例 ；select p.name,p.password from <span class="keyword">Person</span> 则返回Object对象， select后要new select new <span class="keyword">Person</span>（p.name,p.password）from Pserson p</span><br><span class="line">findByNamedQuery(String queryName)：根据命名查询返回实例集合</span><br><span class="line">get(Class entityClass, Serializable id)：根据主键加载特定持久化类的实例</span><br><span class="line">save(Object entity)：保存新的实例</span><br><span class="line">saveOrUpdate(Object entity)：根据实例状态，选择保存或者更新</span><br><span class="line">update(Object entity)：更新实例的状态，要求entity是持久状态</span><br><span class="line">setMaxResults(int maxResults)：设置分页的大小</span><br><span class="line"></span><br><span class="line">### 使用HibernateCallback</span><br><span class="line"></span><br><span class="line">弥补HibernateTemplate灵活性不足。HibernateTemplate还提供一种更加灵活的方式来操作数据库，通过这种方式可以完全使用Hibernate的操作方式。这种灵活方式主要是通过如下两个方法完成的：</span><br></pre></td></tr></table></figure></p>
<p>Object execute(HibernateCallback action)<br>List executeFind(HibernateCallback action)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HibernateCallback是个接口，该接口包含一个方法<span class="function"><span class="title">doInHibernate</span><span class="params">(org.hibernate.Session session)</span></span>，该方法只有一个参数Session。 </span><br><span class="line"></span><br><span class="line">在doInHibernate方法内可访问Session，该Session对象是绑定到该线程的Session实例。在该方法内的持久层操作，与不使用Spring时的持久化操作完全相同。这保证了对于复杂的持久化层访问，依然可以使用Hibernate的访问方式。</span><br></pre></td></tr></table></figure></p>
<p>/<em>*<br>使用hql进行分页查询<br>@param hql 需要查询的hql语句<br>@param offset 第一条记录索引<br>@param pageSize 当前需要显示的记录数<br>@return 当前页的所有记录   </em>/<br>public List findByPage(final String hql, final int offset, final int pageSize){<br>        //通过一个HibernateCallback对象来执行查询<br>        List list = getHibernateTemplate().executeFind(<br>                new HibernateCallback(){//实现HibernateCallback接口必须实现的方法<br>                    public Object doInHibernate(Session session)throws HibernateException, SQLException{//执行Hibernate分页查询<br>                        List result = session.createQuery(hql)<br>                        .setFirstResult(offset)<br>                        .setMaxResults(pageSize)<br>                        .list();<br>                        return result;<br>                        }<br>                    });<br>        return list;<br>}<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">注意：Spring提供的XxxTemplate和XxxCallBack互为补充，XxxTemplate对通用操作进行封装，而XxxCallBack解决了封装后灵活性不足的缺陷。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 实现DAO组件</span></span><br><span class="line"></span><br><span class="line">为了实现DAO组件，Spring提供了大量的XxxDaoSupport类，这些DAO支持类对于实现DAO组件有很大的帮助，因为这些DAO支持类完成了大量基础性工作。 </span><br><span class="line"></span><br><span class="line">Spring为Hibernate的DAO提供工具类：HibernateDaoSupport。该类主要提供如下两个方法来简化DAO的实现： </span><br><span class="line"></span><br><span class="line">* <span class="keyword">public</span> <span class="keyword">final</span> HibernateTemplate getHibernateTemplate() </span><br><span class="line">* <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> setSessionFactory(SessionFactory sessionFactory) </span><br><span class="line"></span><br><span class="line">在继承HibernateDaoSupport的DAO实现里，程序无须理会Hibernate的Session管理，Spring会根据实际的操作，采用“每次事务打开一次session”的策略，自动提高数据库访问的性能。</span><br></pre></td></tr></table></figure></p>
<p>public class MyHibernateDaoSupport extends HibernateDaoSupport implements IMyHibernateDaoSupport {  </p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDao</span><span class="params">()</span></span>{  
    List <span class="built_in">list</span> = getHibernateTemplate().find(<span class="string">"from NewsInf"</span>);  
    System.out.println(<span class="string">"list.size()="</span>+<span class="built_in">list</span>.size());  
}  
</code></pre><p>}<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><bean id="myHibernateDaoSupport" class="com.dao.impl.MyHibernateDaoSupport"><br>        <property name="hibernateTemplate" ref="hibernateTemplate"></property><br></bean><br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">### 使用IoC容器组装各种组件</span><br><span class="line"></span><br><span class="line">至此为止，J2</span>EE应用所需要的各种组件都已经出现了，从M<span class="title">VC层的控制器组件，到业务逻辑组件，以及持久层的DAO组件，已经全部成功实现。应用程序代码并未将这些组件耦合在一起，代码中都是面向接口编程，因此必须利用Spring的IoC容器将他们组合在一起。</span><br><span class="line"></span><br><span class="line">从用户角度来看，用户发出HTTP请求，当MVC框架的控制器组件拦截到用户请求时，将调用系统的业务逻辑组件，而业务逻辑组件则调用系统的DAO组件，而DAO组件则依赖于SessionFactory和DataSource等底层组件实现数据库访问。</span><br><span class="line"></span><br><span class="line">从系统实现角度来看，IoC容器先创建SessionFactory和DataSource等底层组件，然后将这些底层组件注入给DAO组件，提供一个完整的DAO组件，并将此DAO组件注入给业务逻辑组件，从而提供一个完整的业务逻辑组件，而业务逻辑组件又被注入给控制器组件，控制器组件负责拦截用户请求，并将处理结果呈现给用户——这一系列的衔接都由Spring的IoC容器提供实现。</span><br><span class="line"></span><br><span class="line">下面给出关于如何在容器中配置J2</span>EE组件的大致模板，其模板代码如下：</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”GBK”?&gt;<br><!-- beans是Spring配置文件的根元素，并且指定了Schema信息 --></p>
<p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br>    <!-- 定义数据源Bean，使用C3P0数据源实现 --><br>    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"><br>        <!-- 指定连接数据库的驱动 --><br>        <property name="driverClass" value="com.mysql.jdbc.Driver"><br>        <!-- 指定连接数据库的URL --><br>        <property name="jdbcUrl" value="jdbc:mysql://localhost/j2ee"><br>        <!-- 指定连接数据库的用户名 --><br>        <property name="user" value="root"><br>        <!-- 指定连接数据库的密码 --><br>        <property name="password" value="32147"><br>        <!-- 指定连接数据库连接池的最大连接数 --><br>        <property name="maxPoolSize" value="40"><br>        <!-- 指定连接数据库连接池的最小连接数 --><br>        <property name="minPoolSize" value="1"><br>        <!-- 指定连接数据库连接池的初始化连接数 --><br>        <property name="initialPoolSize" value="1"><br>        <!-- 指定连接数据库连接池的连接最大空闲时间 --><br> <property name="maxIdleTime" value="20"><br>    </property></property></property></property></property></property></property></property></bean><br>    <!-- 定义Hibernate的SessionFactory Bean --><br>    <bean id="sessionFactory" class="org.springframework.orm.hibernate3. 
    LocalSessionFactoryBean"><br>        <!-- 依赖注入数据源，注入的正是上文中定义的dataSource --><br>        <property name="dataSource" ref="dataSource"><br>        <!-- mappingResources属性用来列出全部映射文件 --><br>        <property name="mappingResources"><br>            <list><br>                <!-- 以下用来列出所有的PO映射文件 --><br>                <value>lee/Person.hbm.xml</value><br>                <!-- 此处还可列出更多的PO映射文件 --><br>            </list><br>        </property><br>          <!-- 定义Hibernate的SessionFactory属性 --><br>        <property name="hibernateProperties"><br>             <props><br>                <!-- 指定Hibernate的连接方言 --><br>                <prop key="hibernate.dialect">org.hibernate.dialect.<br>                MySQLDialect</prop><br>                <!-- 指定启动应用时，是否根据Hibernate映射文件创建数据表 --><br>                  <prop key="hibernate.hbm2ddl.auto">update</prop><br>             </props><br>        </property><br>    </property></bean><br>    <!-- 配置Person持久化类的DAO Bean --><br>    <bean id="personDao" class="lee.PersonDaoImpl"><br>        <!-- 采用依赖注入来传入SessionFactory的引用 --><br>        <property name="sessionFactory" ref="sessionFactory"><br>    </property></bean><br>    <!-- 下面能以相同的方式配置更多的持久化Bean --><br>    …<br>    <bean id="myService" class="lee.MyServiceImp"><br>        <!-- 注入业务逻辑组件所必需的DAO组件 --><br>        <property name="peronDdao" ref=" personDao "><br>        <!-- 此处可采用依赖注入更多的DAO组件 --><br>        …<br>    </property></bean><br>    <!-- 配置控制器Bean，设置起作用域为Request --><br>    <bean name="/login" class="lee.LoginAction" scope="request"><br>        <!-- 依赖注入控制器所必需的业务逻辑组件 --><br>        <property name="myService" ref=" myService "><br>    </property></bean><br></beans><br>```<br>在上面的配置文件中，同时配置了控制器Bean、业务逻辑组件Bean、DAO组件Bean以及一些基础资源Bean。各组件的组织被解耦到配置文件中，而不是在代码层次的低级耦合。<br>当客户端的HTTP请求向/login.do发送请求时，将被容器中的lee.LoginAction拦截，LoginAction调用myService Bean，myService Bean则调用personDao等系列DAO组件，整个流程将系统中的各组件有机地组织在一起。</p>
<p>注意：在实际应用中，很少会将DAO组件、业务逻辑组件以及控制组件都配置在同一个文件中。而是在不同配置文件中，配置相同一组J2EE应用组件。</p>
<h3 id="使用声明式事务">使用声明式事务</h3><ul>
<li>针对不同的事务策略配置对应的事务管理器   <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"txManager"</span> class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"dataSource"</span> <span class="keyword">ref</span>=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li>使用<code>&lt;tx:advice&gt;</code>元素配置事务增强处理Bean，配置事务增强处理Bean时使用多个<code>&lt;method../&gt;</code>子元素为不同方法指定相应的事务语义</li>
<li>在<code>&lt;aop:config../&gt;</code>子元素中使用<code>&lt;aop:advisor../&gt;</code>元素配置自动事务代理  <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=<span class="string">"txAdvice"</span> transaction-manager=<span class="string">"txManager"</span>&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"get*"</span> read-only=<span class="string">"true"</span> propagation=<span class="string">"NOT_SUPPORTED"</span>/&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"save*"</span>/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut</span><br><span class="line">            expression=<span class="string">"execution(* org.flyne.service.impl.*.*(..))"</span></span><br><span class="line">            id=<span class="string">"perform"</span>/&gt;</span><br><span class="line">    &lt;aop:advisor advice-<span class="keyword">ref</span>=<span class="string">"txAdvice"</span> pointcut-<span class="keyword">ref</span>=<span class="string">"perform"</span>/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
	  
	  <!-- 百度分享 Start -->
	  <div class="bdsharebuttonbox"><a href="#" class="bds_more" data-cmd="more"></a><a href="#" class="bds_qzone" data-cmd="qzone" title="分享到QQ空间"></a><a href="#" class="bds_tsina" data-cmd="tsina" title="分享到新浪微博"></a><a href="#" class="bds_tqq" data-cmd="tqq" title="分享到腾讯微博"></a><a href="#" class="bds_renren" data-cmd="renren" title="分享到人人网"></a><a href="#" class="bds_weixin" data-cmd="weixin" title="分享到微信"></a></div>
	  <!-- 百度分享 End -->
	  
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Spring/">Spring</a></li></ul>

	  
<span>
Updated:<time datetime="2015-03-13T02:19:56.000Z" itemprop="dateModified">2015-03-13</time>
</span>


    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/03/13/jsp-servlet-note/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          JSP/Servlet及相关技术笔记
        
      </div>
    </a>
  
  
    <a href="/2015/03/06/spring-note-1/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Spring笔记一</div>
    </a>
  
</nav>

  
</article>



<!-- 多说评论框 start -->

<section id="comments">
  <div class="ds-thread"  data-thread-key="/2015/03/06/spring-note-2/" data-title="Spring笔记二" data-url="http://howiefh.github.io/2015/03/06/spring-note-2/" id="ds_thread">
    <noscript>Please enable JavaScript to view the <a href="//duoshuo.com/?ref_noscript">comments powered by duoshuo.</a></noscript>
  </div>
</section>

<!-- 多说评论框 end -->
</section>
        
          
  <div id="toc" class="toc-aside">
  <h2 class="toc-title">Contents</h2>
    
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#两种后处理器"><span class="toc-number">1.</span> <span class="toc-text">两种后处理器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Bean后处理器"><span class="toc-number">1.1.</span> <span class="toc-text">Bean后处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#容器后处理器"><span class="toc-number">1.2.</span> <span class="toc-text">容器后处理器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性占位符配置器"><span class="toc-number">1.3.</span> <span class="toc-text">属性占位符配置器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#重写占位符配置器"><span class="toc-number">1.4.</span> <span class="toc-text">重写占位符配置器</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring的“零配置”支持"><span class="toc-number">2.</span> <span class="toc-text">Spring的“零配置”支持</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#指定Bean的作用域"><span class="toc-number">2.1.</span> <span class="toc-text">指定Bean的作用域</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用@Resource配置依赖"><span class="toc-number">2.2.</span> <span class="toc-text">使用@Resource配置依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用@PostConstruct和@PreDestroy定制生命周期行为"><span class="toc-number">2.3.</span> <span class="toc-text">使用@PostConstruct和@PreDestroy定制生命周期行为</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring3-0新增的@DependsOn和@Lazy"><span class="toc-number">2.4.</span> <span class="toc-text">Spring3.0新增的@DependsOn和@Lazy</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动装配和精确装配"><span class="toc-number">2.5.</span> <span class="toc-text">自动装配和精确装配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#资源访问"><span class="toc-number">3.</span> <span class="toc-text">资源访问</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Resource实现类"><span class="toc-number">3.1.</span> <span class="toc-text">Resource实现类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ResourceLoader接口和ResourceLoaderAware接口"><span class="toc-number">3.2.</span> <span class="toc-text">ResourceLoader接口和ResourceLoaderAware接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用Resource作为属性"><span class="toc-number">3.3.</span> <span class="toc-text">使用Resource作为属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#在ApplicationContext中使用资源"><span class="toc-number">3.4.</span> <span class="toc-text">在ApplicationContext中使用资源</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#ApplicationContext实现类指定访问策略"><span class="toc-number">3.4.1.</span> <span class="toc-text">ApplicationContext实现类指定访问策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#前缀指定访问策略"><span class="toc-number">3.4.2.</span> <span class="toc-text">前缀指定访问策略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#classpath*:前缀的用法"><span class="toc-number">3.4.3.</span> <span class="toc-text">classpath*:前缀的用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#file:前缀的用法"><span class="toc-number">3.4.4.</span> <span class="toc-text">file:前缀的用法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring的AOP"><span class="toc-number">4.</span> <span class="toc-text">Spring的AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#使用AspectJ实现AOP"><span class="toc-number">4.1.</span> <span class="toc-text">使用AspectJ实现AOP</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#AspectJ使用入门"><span class="toc-number">4.1.1.</span> <span class="toc-text">AspectJ使用入门</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AOP_的基本概念"><span class="toc-number">4.2.</span> <span class="toc-text">AOP 的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring_的AOP支持"><span class="toc-number">4.3.</span> <span class="toc-text">Spring 的AOP支持</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于Annotation的“零配置”方式"><span class="toc-number">4.4.</span> <span class="toc-text">基于Annotation的“零配置”方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义切面Bean"><span class="toc-number">4.4.1.</span> <span class="toc-text">定义切面Bean</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义Before增强处理"><span class="toc-number">4.4.2.</span> <span class="toc-text">定义Before增强处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义AfterReturning增强处理"><span class="toc-number">4.4.3.</span> <span class="toc-text">定义AfterReturning增强处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义AfterThrowing增强处理"><span class="toc-number">4.4.4.</span> <span class="toc-text">定义AfterThrowing增强处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#After增强处理"><span class="toc-number">4.4.5.</span> <span class="toc-text">After增强处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Around增强处理"><span class="toc-number">4.4.6.</span> <span class="toc-text">Around增强处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#访问目标方法"><span class="toc-number">4.4.7.</span> <span class="toc-text">访问目标方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#织入增强处理的顺序"><span class="toc-number">4.4.8.</span> <span class="toc-text">织入增强处理的顺序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#定义切入点"><span class="toc-number">4.4.9.</span> <span class="toc-text">定义切入点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#切入点指示符"><span class="toc-number">4.4.10.</span> <span class="toc-text">切入点指示符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用组合切点表达式"><span class="toc-number">4.4.11.</span> <span class="toc-text">使用组合切点表达式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于XML配置文件的管理方式"><span class="toc-number">4.5.</span> <span class="toc-text">基于XML配置文件的管理方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#配置切面"><span class="toc-number">4.5.1.</span> <span class="toc-text">配置切面</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置增强处理"><span class="toc-number">4.5.2.</span> <span class="toc-text">配置增强处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置切点"><span class="toc-number">4.5.3.</span> <span class="toc-text">配置切点</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Spring_的事务"><span class="toc-number">5.</span> <span class="toc-text">Spring 的事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Spring支持的事务策略"><span class="toc-number">5.1.</span> <span class="toc-text">Spring支持的事务策略</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用声明式事务"><span class="toc-number">5.2.</span> <span class="toc-text">使用声明式事务</span></a></li></ol></li></ol>
    
  </div>

<aside id="sidebar">

  
    
<div class="widget-wrap">
  <h3 class="widget-title">ABOUT ME</h3>
  <ul class="widget about-me">
    
    <li><img class="author" title="About me" src="http://fh-1.qiniudn.com/okal-eltocat.jpg" /></li>
    
    
    <li>Hi,I'm FengHao.</li>
    
    <li>I'll share something interesting and my learning experience with you at this blog.</li>
    
    <li>前博客:<a href="http://hi.baidu.com/idea_star" target="_BLANK">百度空间</a></li>
    
  </ul>
</div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Android/">Android</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/C/">C</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/">Database</a><span class="category-list-count">12</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MongoDB/">MongoDB</a><span class="category-list-count">10</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Database/MySQL/">MySQL</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Eclipse/">Eclipse</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/FTP/">FTP</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Git/">Git</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Hexo/">Hexo</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/">Java</a><span class="category-list-count">19</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Java/FreeMarker/">FreeMarker</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java/Shiro/">Shiro</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaEE/">JavaEE</a><span class="category-list-count">4</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaEE/Hibernate/">Hibernate</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaEE/JSP/">JSP</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaEE/Spring/">Spring</a><span class="category-list-count">2</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/">JavaScript</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaScript/jQuery/">jQuery</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/PHP/">PHP</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Suse/">Suse</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Ubuntu/">Ubuntu</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Vim/">Vim</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/编程/">编程</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/软件/">软件</a><span class="category-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/Android/" style="font-size: 14.75px; color: #65bfa7">Android</a> <a href="/tags/C/" style="font-size: 13.88px; color: #71c1c2">C</a> <a href="/tags/CAS/" style="font-size: 13px; color: #7dc3de">CAS</a> <a href="/tags/Chrome/" style="font-size: 13px; color: #7dc3de">Chrome</a> <a href="/tags/Clean-Code/" style="font-size: 13.88px; color: #71c1c2">Clean Code</a> <a href="/tags/Eclipse/" style="font-size: 13px; color: #7dc3de">Eclipse</a> <a href="/tags/FTP/" style="font-size: 13.88px; color: #71c1c2">FTP</a> <a href="/tags/FreeMarker/" style="font-size: 14.75px; color: #65bfa7">FreeMarker</a> <a href="/tags/Gcc/" style="font-size: 13px; color: #7dc3de">Gcc</a> <a href="/tags/Git/" style="font-size: 14.75px; color: #65bfa7">Git</a> <a href="/tags/Github-Pages/" style="font-size: 13px; color: #7dc3de">Github Pages</a> <a href="/tags/Hexo/" style="font-size: 14.75px; color: #65bfa7">Hexo</a> <a href="/tags/Hibernate/" style="font-size: 13px; color: #7dc3de">Hibernate</a> <a href="/tags/JSP/" style="font-size: 13px; color: #7dc3de">JSP</a> <a href="/tags/JVM/" style="font-size: 14.75px; color: #65bfa7">JVM</a> <a href="/tags/Java/" style="font-size: 13.88px; color: #71c1c2">Java</a> <a href="/tags/JavaMail/" style="font-size: 13px; color: #7dc3de">JavaMail</a> <a href="/tags/JavaScript/" style="font-size: 13px; color: #7dc3de">JavaScript</a> <a href="/tags/Linux/" style="font-size: 13.88px; color: #71c1c2">Linux</a> <a href="/tags/Log/" style="font-size: 13px; color: #7dc3de">Log</a> <a href="/tags/Markdown/" style="font-size: 13.88px; color: #71c1c2">Markdown</a> <a href="/tags/MongoDB/" style="font-size: 20px; color: #1db400">MongoDB</a> <a href="/tags/MySQL/" style="font-size: 13.88px; color: #71c1c2">MySQL</a> <a href="/tags/PHP/" style="font-size: 16.5px; color: #4dbc6f">PHP</a> <a href="/tags/Rhythmbox/" style="font-size: 13px; color: #7dc3de">Rhythmbox</a> <a href="/tags/SSO/" style="font-size: 13px; color: #7dc3de">SSO</a> <a href="/tags/Servlet/" style="font-size: 13px; color: #7dc3de">Servlet</a> <a href="/tags/Shiro/" style="font-size: 13.88px; color: #71c1c2">Shiro</a> <a href="/tags/Spring/" style="font-size: 13.88px; color: #71c1c2">Spring</a> <a href="/tags/Suse/" style="font-size: 13px; color: #7dc3de">Suse</a> <a href="/tags/Thinking-in-Java/" style="font-size: 19.13px; color: #29b61c">Thinking in Java</a> <a href="/tags/Ubuntu/" style="font-size: 17.38px; color: #41ba53">Ubuntu</a> <a href="/tags/Vim/" style="font-size: 18.25px; color: #35b838">Vim</a> <a href="/tags/VirtualBox/" style="font-size: 13px; color: #7dc3de">VirtualBox</a> <a href="/tags/Vsftpd/" style="font-size: 13px; color: #7dc3de">Vsftpd</a> <a href="/tags/jQuery/" style="font-size: 13px; color: #7dc3de">jQuery</a> <a href="/tags/pam-mysql/" style="font-size: 13px; color: #7dc3de">pam_mysql</a> <a href="/tags/小米/" style="font-size: 13px; color: #7dc3de">小米</a> <a href="/tags/软件/" style="font-size: 15.63px; color: #59bd8b">软件</a>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/05/">May 2015</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/04/">April 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/03/">March 2015</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2015/02/">February 2015</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/12/">December 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/11/">November 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/10/">October 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/09/">September 2014</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/08/">August 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/07/">July 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/06/">June 2014</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/05/">May 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/04/">April 2014</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/03/">March 2014</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/02/">February 2014</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2014/01/">January 2014</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/12/">December 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/11/">November 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/08/">August 2013</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/07/">July 2013</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/06/">June 2013</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/05/">May 2013</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2013/04/">April 2013</a><span class="archive-list-count">3</span></li></ul>
    </div>
  </div>


  
    <div class="widget-wrap">
  <h3 class="widget-title">Calendar</h3>
  <div class="widget">
    <div id="g-calendar" class="g-calendar">
        <span class="g-calendar-prev"></span>
		 
        <span class="g-calendar-back"></span>
        <span class="g-calendar-now"></span>
		 
        <span class="g-calendar-next"></span>
        <div class="g-calendar-hd"></div>
        <div class="g-calendar-tit"></div>
        <div class="g-calendar-bd"></div>
    </div>
  </div>
</div>
<script type="text/javascript">
function LGY_calendar(wrapId, options){
    this.oWrap = this.getId(wrapId);
    this.oHead = this.getByClassName('g-calendar-hd',this.oWrap)[0];
    this.oBody = this.getByClassName('g-calendar-bd',this.oWrap)[0];
    this.oTit = this.getByClassName('g-calendar-tit',this.oWrap)[0];
    this.oPrev = this.getByClassName('g-calendar-prev',this.oWrap)[0];
    this.oNext = this.getByClassName('g-calendar-next',this.oWrap)[0];
    this.oNow = this.getByClassName('g-calendar-now',this.oWrap)[0];
    this.oBack = this.getByClassName('g-calendar-back',this.oWrap)[0];
    this.init();
}
LGY_calendar.prototype = {
    ///////////获取ID元素
    getId:function(id){
        return document.getElementById(id);
    },
    ////////获取css类名元素
    getByClassName:function(className,parent){
        var elem = [],
            node = parent != undefined&&parent.nodeType==1?parent.getElementsByTagName('*'):document.getElementsByTagName('*'),
            p = new RegExp("(^|\\s)"+className+"(\\s|$)");
        for(var n=0,i=node.length;n<i;n++){
            if(p.test(node[n].className)){
                elem.push(node[n]);
            }
        }
        return elem;
    },
    //填充日历
    fillDate:function(year,month){
        //本月份第一天是星期几-为显示上个月的天数做铺垫
        var first_day = new Date(year,month,1).getDay(),
        //如果刚好是星期天，则空出一行（显示上个月的天数）
            first_day = first_day == 0?first_day=7:first_day;
        //本月份最后一天是几号
        var final_date = new Date(year,month+1,0).getDate(),
        //上个月的最后一天是几号
            last_date = new Date(year,month,0).getDate(),
        //剩余的格子数--即排在末尾的格子数
            surplus = 42 - first_day - final_date;
        //设置年的链接
        var yearHead = "<a href='/" + "archives/" + year + "/'>" + year + " "+ "</a>"; 
        //设置年的链接
        var monthHead = "";
        var month1 = month + 1;
        if (month1 < 10) {
            monthHead = "<a href='/" + "archives/" + year + "/" + "0" + month1 + "/'>" + " " + month1 + " " + "</a>";
        } else {
            monthHead = "<a href='/" + "archives/" + year + "/" + month1 + "/'>" + " " + month1 + " " + "</a>";
        }
        //设置表头的日历
        this.oHead.innerHTML = yearHead+'年'+monthHead+'月';
        //填充日历执行
        var html = '';
        //上个月的显示天数
        for(var i=0;i<first_day;i++){
            html+='<span class="g-calendar-grey">'+(last_date-(first_day-1)+i)+'</span>';
        }
        //本月的显示天数
        var postdate = new Date("Fri Mar 06 2015 16:09:20 GMT+0800"); 
        if (true && postdate.getFullYear() == year && postdate.getMonth() == month) { 
            html += '<span>1</span><span>2</span><span>3</span><span>4</span><span><a href="/2015/03/05/hibernate-note/" title="Hibernate笔记">5</a></span><span><a href="/2015/03/06/spring-note-2/" title="当天有2篇博客,第一篇:Spring笔记二">6</a></span><span>7</span><span>8</span><span>9</span><span>10</span><span>11</span><span>12</span><span><a href="/2015/03/13/jsp-servlet-note/" title="JSP/Servlet及相关技术笔记">13</a></span><span>14</span><span>15</span><span>16</span><span>17</span><span>18</span><span>19</span><span>20</span><span>21</span><span>22</span><span>23</span><span>24</span><span>25</span><span>26</span><span>27</span><span>28</span>';
        } else {
            for(var j=0;j<final_date;j++){        
                html+='<span id="d'+(j+1)+'">'+(j+1)+'</span>';
            }
        }
        //下个月的显示天数
        for(var k=0;k<surplus;k++){
            html+='<span class="g-calendar-grey">'+(k+1)+'</span>';
        }
        //fill
        this.oBody.innerHTML = html;
        // 当前状态
        if(year==this.c_year&&this.c_month==month){
            this.oBody.getElementsByTagName('span')[first_day+this.date-1].className='g-calendar-on';
        }

        // 对所有文章遍历,然后将有文章的日期加上链接,如果文章太多的话,生成页面会很大,去掉了
        
    },
    // next切换
    next:function(){
        var _that = this;
        this.oNext.onclick = function(){
            _that.month++;
            if(_that.month>11){
                _that.month = 0;
                _that.year++;
            }
            // 填充日历
            _that.fillDate(_that.year,_that.month);
        };
    },
    // back 切换
    back:function(){
        var _that = this;
        if(this.oBack != undefined) {
            this.oBack.onclick = function(){
                var postdate = new Date("Fri Mar 06 2015 16:09:20 GMT+0800"); 
                _that.year = postdate.getFullYear();
                _that.month = postdate.getMonth();
                // 填充日历
                _that.fillDate(_that.year,_that.month);
            };
        }
    },
    // now切换
    now:function(){
        var _that = this;
        if(this.oNow != undefined ) {
            this.oNow.onclick = function(){
                var nowDate = new Date(); 
                _that.year = nowDate.getFullYear();
                _that.month = nowDate.getMonth();
                // 填充日历
                _that.fillDate(_that.year,_that.month);
            };
        }
    },
    // prev切换
    prev:function(){
        var _that = this;
        this.oPrev.onclick = function(){
            _that.month--;
            if(_that.month<0){
                _that.month = 11;
                _that.year--;
            }
            // 填充日历
            _that.fillDate(_that.year,_that.month);
        };
    },
    init:function(){
        this.oTit.innerHTML = '<span>日</span><span>一</span><span>二</span><span>三</span><span>四</span><span>五</span><span>六</span>';
        // 获取今天的日历时间
        var now = new Date();
        this.c_year = this.year = now.getFullYear();
        this.c_month = this.month = now.getMonth();
        this.date = now.getDate();
        // 初始化--填充日历
        this.fillDate(this.year,this.month);
        //next切换
        this.next();
        //prev切换
        this.prev();
        //back 切换
        this.back();
        //now 切换
        this.now();
    }
}
new LGY_calendar('g-calendar');
</script>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2015/05/22/vim-install-youcompleteme-plugin/">Vim 自动补全插件 YouCompleteMe 安装与配置</a>
          </li>
        
          <li>
            <a href="/2015/05/19/shiro-cas-single-sign-on/">Shiro &amp; CAS 实现单点登录</a>
          </li>
        
          <li>
            <a href="/2015/05/12/shiro-note/">Shiro笔记</a>
          </li>
        
          <li>
            <a href="/2015/05/03/freemarker-XML-processing-note/">FreeMarker-XML处理笔记</a>
          </li>
        
          <li>
            <a href="/2015/05/02/freemarker-program-development-note/">FreeMarker-程序开发指南笔记</a>
          </li>
        
      </ul>
    </div>
  </div>


  
    
<div class="widget-wrap">
  <h3 class="widget-title">Recent Comments</h3>
  <ul class="widget ds-recent-comments" data-num-items="5" data-show-avatars="0" data-show-title="1" data-show-time="1"></ul>
</div>
<!-- 需要多说的公用代码 -->


  

</aside>

        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2015 howiefh<br>
      Powered by <a href="http://zespia.tw/hexo/" target="_blank">Hexo</a> and Theme by <a href="https://github.com/howiefh/hexo-theme-landscape-f" target="_blank" title="Landscape-F">Landscape-F</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<!-- 多说公共JS代码 start (一个网页只需插入一次) -->

<script type="text/javascript">
  var duoshuoQuery = {short_name:"howiefh"};
  (function() {
	var ds = document.createElement('script');
	ds.type = 'text/javascript';ds.async = true;
	ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
	ds.charset = 'UTF-8';
	(document.getElementsByTagName('head')[0] 
		|| document.getElementsByTagName('body')[0]).appendChild(ds);
  })();
</script> 

<!-- 多说公共JS代码 end -->

<!-- 百度分享 start -->

<script>window._bd_share_config={"common":{"bdSnsKey":{},"bdText":"","bdMini":"2","bdMiniList":["mshare","douban","bdysc","sqq","qq","hi","baidu","huaban","youdao","sdo","mail","xg","diandian","fx","copy","print"],"bdPic":"","bdStyle":"1","bdSize":"16"},"share":{},"image":{"viewList":["qzone","tsina","tqq","renren","weixin"],"viewText":"分享到：","viewSize":"16"}};with(document)0[(getElementsByTagName('head')[0]||body).appendChild(createElement('script')).src='http://bdimg.share.baidu.com/static/api/js/share.js?v=89860593.js?cdnversion='+~(-new Date()/36e5)];</script>

<!-- 百度分享 end -->

<!--
<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>
<script src="/js/jquery.min.js"></script>
-->
<script src="/js/jquery.min.js" type="text/javascript"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css" type="text/css">
  <script src="/fancybox/jquery.fancybox.pack.js" type="text/javascript"></script>


<div class="bottom-btn">

	<a class="icon-gotop" href="javascript:void(0)" title="返回顶部"></a>
	<script src="/js/gotop.js" type="text/javascript"></script>
	<!--
	<script src="/js/gotop.js"></script>
	-->


	<a class="icon-toc-toggle" href="javascript:void(0)" title="文章目录"></a>
	<!--
	<script src="/js/toc_aside_toggle.js"></script>
	-->

</div>
<script src="/js/toc_aside_toggle.js" type="text/javascript"></script>


<script src="/js/script.js" type="text/javascript"></script>

  </div>
</body>
</html>
