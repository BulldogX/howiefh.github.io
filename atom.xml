<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[净土]]></title>
  <subtitle><![CDATA[乐不在外而在心，心以为乐，则是境皆乐；心以为苦，则无境不苦。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://howiefh.github.io//"/>
  <updated>2015-05-21T16:36:01.000Z</updated>
  <id>http://howiefh.github.io//</id>
  
  <author>
    <name><![CDATA[howiefh]]></name>
    <email><![CDATA[howiefh@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Vim 自动补全插件 YouCompleteMe 安装与配置]]></title>
    <link href="http://howiefh.github.io/2015/05/22/vim-install-youcompleteme-plugin/"/>
    <id>http://howiefh.github.io/2015/05/22/vim-install-youcompleteme-plugin/</id>
    <published>2015-05-22T12:31:12.000Z</published>
    <updated>2015-05-21T16:36:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>对于代码自动补全，之前一直使用的是Shougo/neocomplcache和Shougo/neosnippet。早就听说过YouCompleteMe的大名，一直想尝试一下YCM，但是还是拖到了现在。YCM和其它Vim插件的安装有些不同，可能需要折腾一下。之所以安装稍微会麻烦些，是因为YCM 后端调用 libclang(以获取AST,当然还有其他语言的语义分析库)、前端由 C++ 开发(以提升补全效率)、外层由 python 封装(以成为 vim 插件),它可能是安装最复杂的 vim 插件了。YCM是Client-sever架构的，Vim这部分的YCM只是很小的一个客户端，与具有大量逻辑和功能的ycmd HTTP+JSON交互。server在你开启或关闭Vim是自动开启或关闭。</p>
<p>其它自动补全的插件基本上是基于文本的，也就是说它们基本上是使用正则去猜。区别于其它Vim的自动补全插件，YCM基于语义引擎（比如C家族的libclang）提供了语义补全，是通过分析源文件，经过语法分析之后进行补全。对于C家族的语言这种基于语义的自动补全依赖于clang/llvm，其他语言 ,会调用vim设置的omnifunc来匹配，可以查看<a href="https://github.com/Valloric/YouCompleteMe#semantic-completion-for-other-languages" target="_blank" rel="external">github</a></p>
<ul>
<li>Java/Ruby <a href="http://eclim.org/" target="_blank" rel="external">eclim</a></li>
<li>Python <a href="https://github.com/davidhalter/jedi" target="_blank" rel="external">Jedi</a></li>
<li>Go <a href="https://github.com/nsf/gocode" target="_blank" rel="external">Gocode</a></li>
<li>C# <a href="https://github.com/nosami/OmniSharpServer" target="_blank" rel="external">OmniSharp</a></li>
<li>JavaScript <a href="https://github.com/marijnh/tern_for_vim" target="_blank" rel="external">Tern for Vim</a></li>
</ul>
<p>YCM不是基于前缀补全的，而是子序列，所以输入 abc 可以补全 xaybgc，它对于大小写的补全也非常智能。对于C家族的语言和Python支持跳转到定义处。此外还可以对文件路径进行补全，和ultisnips也很好结合。</p>
<a id="more"></a>
<h2 id="安装">安装</h2><h3 id="完全安装">完全安装</h3><p><strong>如果用Vundle更新YCM，yum_support_lib库API改变了，YCM会提醒你重新编译它。</strong></p>
<ol>
<li><p>确保Vim版本至少是7.3.584，并且支持python2脚本。</p>
<p> 在Vim中输入<code>:version</code>可以查看版本。如果版本已经高于7.4了，那么OK。版本是7.3。那么继续往下看，看到<code>包含版本:1-Z</code>，如果Z小于584就需要重装了。Ubuntu的话可以通过<a href="http://linuxg.net/how-to-install-vim-7-4-on-ubuntu-13-10-13-04-12-04-linux-mint-16-15-13-and-debian-sid/" target="_blank" rel="external">PPA</a>安装高版本的。否则就要从源码编译安装了。<br> 查看是否支持python2：进入vim,命令:echo has(‘python’)，输出为1,则表示支持。如果为0,则需要重新编译安装vim，在编译时添加python支持。</p>
</li>
<li><p>通过Vundle安装YCM，在你的vimrc中添加<code>Plugin &#39;Valloric/YouCompleteMe&#39;</code>，然后执行<code>:PluginInstall</code></p>
</li>
<li><p>如果不需要对C家族的语言进行语义补全支持，则跳过这一步。</p>
<p> 下载最新版的libclang。Clang是一个开源编译器，能够编译C/C++/Objective-C/Objective-C++。Clang提供的libclang库是用于驱动YCM对这些语言的语义补全支持。YCM需要版本至少为3.6的libclang，但是理论上3.2+版本也行。也可以使用系统libclang，如果确定是3.3版本或者更高。推荐下载<llvm.org>官网的<a href="http://llvm.org/releases/download.html" target="_blank" rel="external">二进制文件</a>。确保选对适合自己系统的包。</llvm.org></p>
</li>
<li><p>编译YCM需要的ycm_support_libs库。YCM的C++引擎通过这些库来获取更快的补全速度。<br> 需要cmake，如果未安装，安装之：<code>sudo apt-get install build-essential cmake</code>（也可以下载安装<a href="http://www.cmake.org/cmake/resources/software.html" target="_blank" rel="external">http://www.cmake.org/cmake/resources/software.html</a>）。确保python头文件已安装：<code>sudo apt-get install python-dev</code>。假设你已经通过Vundle装好YCM了，那么它应该位于<code>~/.vim/bundle/YouCompleteMe</code>。我们新建一个目录用来放置编译文件，并切换到此目录下<code>cd ~;mkdir ycm_build;cd ycm_build;</code><br> 下一步生成makefile，这一步很重要，有点复杂。</p>
<ul>
<li>如果不需要C族语言的语义支持，在ycm_build目录下执行：<code>cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</code></li>
<li>如果需要C族语言的语义支持，还得分几种情况：<ul>
<li>假如你从llvm的官网下载了LLVM+Clang，然后解压到：~/ycm_temp/llvm_root_dir （该目录下有 bin, lib, include 等文件夹），然后执行：<code>cmake -G &quot;Unix Makefiles&quot; -DPATH_TO_LLVM_ROOT=~/ycm_temp/llvm_root_dir . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</code></li>
<li>如果想用系统的libclang：<code>cmake -G &quot;Unix Makefiles&quot; -DUSE_SYSTEM_LIBCLANG=ON . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</code></li>
<li>如果想用自定义的libclang：<code>cmake -G &quot;Unix Makefiles&quot; -DEXTERNAL_LIBCLANG_PATH=/path/to/libclang.so . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</code>。/path/to/libclang.so这部分填入你自己的路径。<br>makefiles生成后执行：<code>make ycm_support_libs</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>我是从llvm网站下载的二进制文件，安装的，安装过程中也没遇到什么问题。</p>
<h3 id="Ubuntu_Linux_X64_超快安装">Ubuntu Linux X64 超快安装</h3><p>最好还是完整安装，这种快速安装未必适合所有人。安装之前，同样也要确定满足以上所述的vim版本、python支持等条件。和上面一样使用Vundle安装YCM，安装CMake和python头文件。</p>
<p>编译YCM，如果需要对C-family的语义支持：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~/.<span class="keyword">vim</span>/bundle/YouCompleteMe</span><br><span class="line">./install.<span class="keyword">sh</span> --clang-completer</span><br></pre></td></tr></table></figure></p>
<p>如果不需要对C-family的语义支持：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~/.<span class="keyword">vim</span>/bundle/YouCompleteMe</span><br><span class="line">./install.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p>
<p>如果需要支持C#，添加 <code>--omnisharp-complete</code>。如果需要支持Go添加<code>--gocode-completer</code></p>
<h2 id="配置">配置</h2><p>YCM使用TAB键接受补全，一直按TAB则会循环所有的匹配补全项。shift+TAB则会反向循环。注意：如果使用控制台Vim（非GVim或MacVim等），控制台不会将shift+Tab传递给Vim，因此会无反应，需要重新映射按键。此外，如果同时使用ultisnaps，可能会有冲突，需要进行一些设置。可以使用Ctrl+Space来触发补全，不过会和输入法冲突，也需要设置。</p>
<p>YCM会寻找当前打开的文件的同级目录下或上级目录中的<code>ycm_extra_conf.py</code>这个文件，找到后会加载为Python模块，且只加载一次。YCM调用该模块中的FlagsForFile方法。该模块必须提供带有编译当前文件的必要信息的这个方法。需要修改<code>.ycm_extra_conf.py</code>文件中的flags部分，使用-isystem添加系统的头文件进行解析，使用-I添加第三方的头文件进行解析，在flags部分后添加如下内容：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'-isystem'</span>,</span><br><span class="line"><span class="string">'/usr/include'</span>,</span><br></pre></td></tr></table></figure>
<p>使用命令<code>:YcmDiags</code>可以打开location-list查看警告和错误信息。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> completeopt=longest,menu	"让Vim的补全菜单行为与一般IDE一致(参考VimTip1228)</span><br><span class="line">autocmd InsertLeave * <span class="keyword">if</span> pumvisible() == 0|pclose|endif	"离开插入模式后自动关闭预览窗口</span><br><span class="line">inoremap &lt;expr&gt; &lt;CR&gt;       pumvisible() ? <span class="string">"\&lt;C-y&gt;"</span> : <span class="string">"\&lt;CR&gt;"</span>	"回车即选中当前项</span><br><span class="line">"上下左右键的行为 会显示其他信息</span><br><span class="line">inoremap &lt;expr&gt; &lt;Down&gt;     pumvisible() ? <span class="string">"\&lt;C-n&gt;"</span> : <span class="string">"\&lt;Down&gt;"</span></span><br><span class="line">inoremap &lt;expr&gt; &lt;Up&gt;       pumvisible() ? <span class="string">"\&lt;C-p&gt;"</span> : <span class="string">"\&lt;Up&gt;"</span></span><br><span class="line">inoremap &lt;expr&gt; &lt;PageDown&gt; pumvisible() ? <span class="string">"\&lt;PageDown&gt;\&lt;C-p&gt;\&lt;C-n&gt;"</span> : <span class="string">"\&lt;PageDown&gt;"</span></span><br><span class="line">inoremap &lt;expr&gt; &lt;PageUp&gt;   pumvisible() ? <span class="string">"\&lt;PageUp&gt;\&lt;C-p&gt;\&lt;C-n&gt;"</span> : <span class="string">"\&lt;PageUp&gt;"</span></span><br><span class="line">" 跳转到定义处</span><br><span class="line">nnoremap &lt;leader&gt;jd :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br><span class="line">nnoremap &lt;F6&gt; :YcmForceCompileAndDiagnostics&lt;CR&gt;	"force recomile with syntastic</span><br><span class="line"><span class="string">" nnoremap &lt;leader&gt;lo :lopen&lt;CR&gt;	"</span><span class="keyword">open</span> locationlist</span><br><span class="line"><span class="string">" nnoremap &lt;leader&gt;lc :lclose&lt;CR&gt;	"</span><span class="keyword">close</span> locationlist</span><br><span class="line">inoremap &lt;leader&gt;&lt;leader&gt; &lt;C-x&gt;&lt;C-o&gt;</span><br><span class="line"></span><br><span class="line">let <span class="keyword">g</span>:ycm_global_ycm_extra_conf = '~/.vim/data/ycm/.ycm_extra_conf.py'</span><br><span class="line">" 不显示开启vim时检查ycm_extra_conf文件的信息  </span><br><span class="line">let <span class="keyword">g</span>:ycm_confirm_extra_conf=0</span><br><span class="line">" 开启基于tag的补全，可以在这之后添加需要的标签路径  </span><br><span class="line">let <span class="keyword">g</span>:ycm_collect_identifiers_from_tags_files=1</span><br><span class="line">"注释和字符串中的文字也会被收入补全</span><br><span class="line">let <span class="keyword">g</span>:ycm_collect_identifiers_from_comments_and_strings = 0</span><br><span class="line">" 输入第2个字符开始补全</span><br><span class="line">let <span class="keyword">g</span>:ycm_min_num_of_chars_for_completion=2</span><br><span class="line">" 禁止缓存匹配项,每次都重新生成匹配项</span><br><span class="line">let <span class="keyword">g</span>:ycm_cache_omnifunc=0</span><br><span class="line">" 开启语义补全</span><br><span class="line">let <span class="keyword">g</span>:ycm_seed_identifiers_with_syntax=1	</span><br><span class="line">"在注释输入中也能补全</span><br><span class="line">let <span class="keyword">g</span>:ycm_complete_in_comments = 1</span><br><span class="line">"在字符串输入中也能补全</span><br><span class="line">let <span class="keyword">g</span>:ycm_complete_in_strings = 1</span><br><span class="line">" 设置在下面几种格式的文件上屏蔽ycm</span><br><span class="line">let <span class="keyword">g</span>:ycm_filetype_blacklist = &#123;</span><br><span class="line">      \ 'tagbar' : 1,</span><br><span class="line">      \ 'nerdtree' : 1,</span><br><span class="line">      \&#125;</span><br><span class="line">"youcompleteme  默认<span class="keyword">tab</span>  s-<span class="keyword">tab</span> 和 ultisnips 冲突</span><br><span class="line">let <span class="keyword">g</span>:ycm_key_list_select_completion = ['&lt;Down&gt;']</span><br><span class="line">let <span class="keyword">g</span>:ycm_key_list_previous_completion = ['&lt;Up&gt;']</span><br><span class="line">" 修改对C函数的补全快捷键，默认是CTRL + space，修改为ALT + ;</span><br><span class="line">let <span class="keyword">g</span>:ycm_key_invoke_completion = '&lt;<span class="keyword">M</span>-;&gt;'</span><br><span class="line"></span><br><span class="line">" SirVer/ultisnips 代码片断</span><br><span class="line">" Trigger configuration. <span class="keyword">Do</span> not <span class="keyword">use</span> &lt;<span class="keyword">tab</span>&gt; <span class="keyword">if</span> you <span class="keyword">use</span> https:<span class="comment">//github.com/Valloric/YouCompleteMe.</span></span><br><span class="line">let <span class="keyword">g</span>:UltiSnipsExpandTrigger=<span class="string">"&lt;tab&gt;"</span></span><br><span class="line">let <span class="keyword">g</span>:UltiSnipsJumpForwardTrigger=<span class="string">"&lt;tab&gt;"</span></span><br><span class="line">let <span class="keyword">g</span>:UltiSnipsJumpBackwardTrigger=<span class="string">"&lt;s-tab&gt;"</span></span><br><span class="line">let <span class="keyword">g</span>:UltiSnipsListSnippets=<span class="string">"&lt;c-e&gt;"</span></span><br><span class="line">"定义存放代码片段的文件夹，使用自定义和默认的，将会的到全局，有冲突的会提示</span><br><span class="line">let <span class="keyword">g</span>:UltiSnipsSnippetDirectories=[<span class="string">"bundle/vim-snippets/UltiSnips"</span>]</span><br><span class="line"></span><br><span class="line">" 参考https:<span class="comment">//github.com/Valloric/YouCompleteMe/issues/36#issuecomment-62941322</span></span><br><span class="line">" 解决ultisnips和ycm <span class="keyword">tab</span>冲突，如果不使用下面的办法解决可以参考</span><br><span class="line">" https:<span class="comment">//github.com/Valloric/YouCompleteMe/issues/36#issuecomment-63205056的配置</span></span><br><span class="line">" begin</span><br><span class="line">" let <span class="keyword">g</span>:ycm_key_list_select_completion=['&lt;C-<span class="keyword">n</span>&gt;', '&lt;Down&gt;']</span><br><span class="line">" let <span class="keyword">g</span>:ycm_key_list_previous_completion=['&lt;C-p&gt;', '&lt;Up&gt;']</span><br><span class="line"><span class="string">" let g:UltiSnipsExpandTrigger="</span>&lt;<span class="keyword">Tab</span>&gt;"</span><br><span class="line"><span class="string">" let g:UltiSnipsJumpForwardTrigger="</span>&lt;<span class="keyword">Tab</span>&gt;"                                           </span><br><span class="line"><span class="string">" let g:UltiSnipsJumpBackwardTrigger="</span>&lt;S-<span class="keyword">Tab</span>&gt;"</span><br><span class="line">" end</span><br><span class="line">" UltiSnips completion function that tries to <span class="keyword">expand</span> a snippet. <span class="keyword">If</span> there's <span class="keyword">no</span></span><br><span class="line">" snippet <span class="keyword">for</span> expanding, it checks <span class="keyword">for</span> completion <span class="keyword">window</span> and <span class="keyword">if</span> it'<span class="literal">s</span></span><br><span class="line">" shown, selects first element. <span class="keyword">If</span> there's <span class="keyword">no</span> completion <span class="keyword">window</span> it tries to</span><br><span class="line">" jump to next placeholder. <span class="keyword">If</span> there's <span class="keyword">no</span> placeholder it just returns <span class="keyword">TAB</span> key </span><br><span class="line">function! <span class="keyword">g</span>:UltiSnips_Complete()</span><br><span class="line">    call UltiSnips#ExpandSnippet()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">g</span>:ulti_expand_res == 0</span><br><span class="line">        <span class="keyword">if</span> pumvisible()</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"\&lt;C-n&gt;"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            call UltiSnips#JumpForwards()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">g</span>:ulti_jump_forwards_res == 0</span><br><span class="line">               <span class="keyword">return</span> <span class="string">"\&lt;TAB&gt;"</span></span><br><span class="line">            endif</span><br><span class="line">        endif</span><br><span class="line">    endif</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">au BufEnter * exec <span class="string">"inoremap &lt;silent&gt; "</span> . <span class="keyword">g</span>:UltiSnipsExpandTrigger . <span class="string">" &lt;C-R&gt;=g:UltiSnips_Complete()&lt;cr&gt;"</span></span><br><span class="line"></span><br><span class="line">" <span class="keyword">Expand</span> snippet or <span class="literal">return</span></span><br><span class="line">let <span class="keyword">g</span>:ulti_expand_res = 1</span><br><span class="line">function! Ulti_ExpandOrEnter()</span><br><span class="line">    call UltiSnips#ExpandSnippet()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">g</span>:ulti_expand_res</span><br><span class="line">        <span class="keyword">return</span> ''</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\&lt;return&gt;"</span></span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">" <span class="keyword">Set</span> &lt;space&gt; <span class="keyword">as</span> primary trigger</span><br><span class="line">inoremap &lt;<span class="keyword">return</span>&gt; &lt;C-R&gt;=Ulti_ExpandOrEnter()&lt;CR&gt;</span><br></pre></td></tr></table></figure>
<h2 id="YCM_&amp;_Eclim">YCM &amp; Eclim</h2><p>YCM配合Eclim可以实现对Java代码的自动提示，首先需要下载<a href="http://eclim.org/install.html" target="_blank" rel="external">Eclim</a>，下载好后执行<code>java -jar eclim_2.4.1.jar</code>，卸载的话，后面再加个参数<code>uninstaller</code>就行。按提示一步步安装就好了，安装好后首先要启动eclimd，它存放在eclipse的根目录下。</p>
<p>对不同的自动补全插件eclim都提供了<a href="http://eclim.org/vim/code_completion.html" target="_blank" rel="external">配置方法</a>，对于YCM我们只需要在vimrc中添加一行<code>let g:EclimCompletionMethod = &#39;omnifunc&#39;</code>就可以了。</p>
<p>打开vim执行<code>:ProjectCreate /path/to/project -n java</code>创建一个新的工程。这个工程的结构和eclipse类似。<code>:ProjectList</code>命令可以查看工程列表。</p>
<p>这个插件很有意思，可以在eclipse中嵌入vim，又可以在vim中享受eclipse一样的自动补全。对于Java来说，提供了一些以<code>Java</code>，<code>Project</code>，<code>New</code>，<code>Mvn</code>为前缀的命名。可以输入<code>:Java</code>按Tab键尝试一下。不过，我觉得还是使用eclipse配合viPlugin插件更方便些。</p>
<p>参考：</p>
<ol>
<li><a href="http://www.cnblogs.com/zhongcq/p/3630047.html" target="_blank" rel="external">Vim自动补全插件——YouCompleteMe安装与配置</a></li>
<li><a href="http://blog.csdn.net/leaf5022/article/details/21290509" target="_blank" rel="external">Vim智能补全插件YouCompleteMe安装</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Vim 自动补全；Vim YouCompleteMe 安装；Vim YouCompleteMe 配置；]]>
    
    </summary>
    
      <category term="Vim" scheme="http://howiefh.github.io/tags/Vim/"/>
    
      <category term="Vim" scheme="http://howiefh.github.io/categories/Vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shiro & CAS 实现单点登录]]></title>
    <link href="http://howiefh.github.io/2015/05/19/shiro-cas-single-sign-on/"/>
    <id>http://howiefh.github.io/2015/05/19/shiro-cas-single-sign-on/</id>
    <published>2015-05-18T16:11:12.000Z</published>
    <updated>2015-07-05T13:39:27.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概览">概览</h2><p>单点登录主要用于多系统集成，即在多个系统中，用户只需要到一个中央服务器登录一次即可访问这些系统中的任何一个，无须多次登录。</p>
<p>本文使用开源框架<a href="https://github.com/Jasig/cas/releases" target="_blank" rel="external">Jasig CAS</a>来完成单点登录。下载地址：<a href="https://www.apereo.org/cas/download" target="_blank" rel="external">https://www.apereo.org/cas/download</a>。在写本文时，使用的cas server版本为4.0.1</p>
<a id="more"></a>
<h2 id="部署服务器">部署服务器</h2><p>本文服务器使用Tomcat7，下载了<a href="http://downloads.jasig.org/cas/cas-server-4.0.0-release.zip" target="_blank" rel="external">cas-server-4.0.0-release.zip</a>，将其解压，找到modules目录下面的cas-server-webapp-4.0.0.war直接复制到webapps文件夹下即可。启动Tomcat，访问<a href="http://localhost:8080/cas-server-webapp-4.0.0，使用casuser/Mellon登录，即可登录成功。" target="_blank" rel="external">http://localhost:8080/cas-server-webapp-4.0.0，使用casuser/Mellon登录，即可登录成功。</a></p>
<p>Tomcat默认没有开启HTTPS协议，所以这里直接用了HTTP协议访问。为了能使客户端在HTTP协议下单点登录成功，需要修改一下配置：</p>
<ul>
<li><p>WEB-INF\spring-configuration\ticketGrantingTicketCookieGenerator.xml和WEB-INF\spring-configuration\warnCookieGenerator.xml：将<code>p:cookieSecure=&quot;true&quot;</code>改为<code>p:cookieSecure=&quot;false&quot;</code></p>
</li>
<li><p>WEB-INF\deployerConfigContext.xml：<code>&lt;bean class=&quot;org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler&quot; p:httpClient-ref=&quot;httpClient&quot; /&gt;</code>添加<code>p:requireSecure=&quot;false&quot;</code></p>
</li>
</ul>
<p>至此，一个简单的单点登录服务器就基本部署好了。</p>
<h2 id="部署客户端">部署客户端</h2><p>客户端需要添加对<a href="http://shiro.apache.org/cas.html" target="_blank" rel="external">shiro-cas</a>和cas-client-core这两个包的依赖。这里主要讲跟CAS相关的配置。</p>
<p>之后配置web.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutHttpSessionListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 该过滤器用于实现单点登出功能，可选配置。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>自定义Realm：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyCasRealm</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">CasRealm</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> userService;</span><br><span class="line"></span><br><span class="line">    public void setUserService(<span class="type">UserService</span> userService) &#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">AuthorizationInfo</span> doGetAuthorizationInfo(<span class="type">PrincipalCollection</span> principals) &#123;</span><br><span class="line">        <span class="type">String</span> username = (<span class="type">String</span>)principals.getPrimaryPrincipal();</span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> authorizationInfo = <span class="keyword">new</span> <span class="type">SimpleAuthorizationInfo</span>();</span><br><span class="line">        authorizationInfo.setRoles(userService.findRoles(username));</span><br><span class="line">        authorizationInfo.setStringPermissions(userService.findPermissions(username));</span><br><span class="line">        <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"casRealm"</span> <span class="attribute">class</span>=<span class="value">"package.for.your.MyCasRealm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"userService"</span> <span class="attribute">ref</span>=<span class="value">"userService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cachingEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authenticationCachingEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authenticationCacheName"</span> <span class="attribute">value</span>=<span class="value">"authenticationCache"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authorizationCachingEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authorizationCacheName"</span> <span class="attribute">value</span>=<span class="value">"authorizationCache"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该地址为cas server地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"casServerUrlPrefix"</span> <span class="attribute">value</span>=<span class="value">"$&#123;shiro.casServer.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 该地址为是当前应用 CAS 服务 URL，即用于接收并处理登录成功后的 Ticket 的，</span><br><span class="line">    必须和loginUrl中的service参数保持一致，否则服务器会判断service不匹配--&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"casService"</span> <span class="attribute">value</span>=<span class="value">"$&#123;shiro.client.cas&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>配置CAS过滤器<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"casFilter"</span> class=<span class="string">"org.apache.shiro.cas.CasFilter"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"failureUrl"</span> value=<span class="string">"/casFailure.jsp"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"shiroFilter"</span> class=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"securityManager"</span> <span class="keyword">ref</span>=<span class="string">"securityManager"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"loginUrl"</span> value=<span class="string">"$&#123;shiro.login.url&#125;"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"successUrl"</span> value=<span class="string">"$&#123;shiro.login.success.url&#125;"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"filters"</span>&gt;</span><br><span class="line">        &lt;util:map&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"cas"</span> value-<span class="keyword">ref</span>=<span class="string">"casFilter"</span>/&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"logout"</span> value-<span class="keyword">ref</span>=<span class="string">"logoutFilter"</span> /&gt;</span><br><span class="line">        &lt;/util:map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"filterChainDefinitions"</span>&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            /casFailure.jsp = anon</span><br><span class="line">            /cas = cas</span><br><span class="line">            /logout = logout</span><br><span class="line">            /** = user</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>上面登录url我的配置的是<code>http://localhost:8080/cas-server/login?service=http://localhost:8080/cas-client/cas</code>，service参数是之后服务将会跳转的地址。</p>
<p><code>/cas=cas</code>：即/cas 地址是服务器端回调地址，使用 CasFilter 获取 Ticket 进行登录。</p>
<p>之后通过eclipse部署，访问<a href="http://localhost:8080/cas-client" target="_blank" rel="external">http://localhost:8080/cas-client</a> 即可测试。为了看到单点登录的效果，可以直接复制一份webapps中的client为client2，只需要修改上述配置中的地址即可。如果用户已经登录，那么访问<a href="http://localhost:8080/cas-client2发现不会再跳转到登录页面了，用户已经是登录状态了。" target="_blank" rel="external">http://localhost:8080/cas-client2发现不会再跳转到登录页面了，用户已经是登录状态了。</a></p>
<p>还需要注意一个问题，就是cas server默认是开启单点登出的但是这里却没有这样的效果，APP1登出了，但是APP2仍能访问，如果查看浏览器的cookie的话，会发现有两个sessionid，一个是JSESSIONID，容器原生的，另一个是shiro中配置的:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 会话Cookie模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionIdCookie"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">SingleSignOutFilter发现是logoutRequest请求后，原来SingleSignOutHandler中创建的原生的session已经被销毁了，因为从a登出的，a的shiro session也会销毁，</span><br><span class="line">    但是b的shiro的session还没有被销毁，于是再访问b还是能访问，单点登出就有问题了--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"JSESSIONID"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"httpOnly"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxAge"</span> <span class="attribute">value</span>=<span class="value">"-1"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果我们把sid改为JSESSIONID会怎么样，答案是如果改为JSESSIONID会导致重定向循环，原因是当登录时，shiro发现浏览器发出的请求中的JSESSIONID没有或已经过期，于是生成一个JSESSIONID给浏览器，同时链接被重定向到服务器进行认证，认证成功后返回到客户端服务器的cas service url，并且带有一个ticket参数。因为有SingleSignOutFilter，当发现这是一个tocken请求时，SingleSignOutHandler会调用request.getSession()获取的是原生Session，如果没有原生session的话，又会创建并将JSESSIONID保存到浏览器cookie中，当客户端服务器向cas服务器验证ticket之后，客户端服务器重定向到之前的页面，这时shiro发现JSESSIONID是SingleSignOutHandler中生成的，在自己维护的session中查不到，又会重新生成新的session，然后login，然后又会重定向到cas服务器认证，然后再重定向到客户端服务器的cas service url，不同的是SingleSignOutHandler中这次调用session.getSession(true)不会新创建一个了，之后就如此循环。如果使用sid又会导致当单点登出时候，如果有a、b两个客户端服务器，从a登出，会跳转到cas服务器登出，cas服务器会对所有通过它认证的service调用销毁session的方法，但是b的shiro的session还没有被销毁，于是再访问b还是能访问，单点登出就有问题了</p>
<p>之所以这样是因为我设置shiro的session管理器为DefaultWebSessionManager，这个管理器直接抛弃了容器的session管理器，自己来维护session，所以就会出现上述描述的问题了。如果我们不做设置，那么shiro将使用默认的session管理器ServletContainerSessionManager：Web 环境，其直接使用 Servlet 容器的会话。这样单点登出就可以正常使用了。</p>
<p>此外如果我们非要使用DefaultWebSessionManager的话，我们就要重写一个SingleSignOutFilter、SingleSignOutHandler和SessionMappingStorage了。</p>
<p>如果没有使用Spring框架，则可以参考如下配置web.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-app</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">	<span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/javaee"</span> <span class="attribute">xmlns:web</span>=<span class="value">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span><br><span class="line">	<span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span><br><span class="line">	<span class="attribute">id</span>=<span class="value">"WebApp_ID"</span> <span class="attribute">version</span>=<span class="value">"2.5"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">display-name</span>&gt;</span>YPshop Authority Manage<span class="tag">&lt;/<span class="title">display-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">context-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">param-name</span>&gt;</span>webAppRootKey<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">param-value</span>&gt;</span>authority.root<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- ======================== 单点登录开始 ======================== --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 说明：这种客户端的配置方式是不需要Spring支持的 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 参考资料：http://blog.csdn.net/yaoweijq/article/details/6003187 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">listener</span>&gt;</span>  </span><br><span class="line">      <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutHttpSessionListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span>   </span><br><span class="line">	<span class="tag">&lt;/<span class="title">listener</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="title">filter</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>   </span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span>   </span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>  </span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>   </span><br><span class="line">	    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>   </span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="title">filter</span>&gt;</span>  </span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Authentication Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>   </span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.jasig.cas.client.authentication.AuthenticationFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span>   </span><br><span class="line">	    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span>  </span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>casServerLoginUrl<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>   </span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>https://localhost:8443/cas-server/login<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>   </span><br><span class="line">	    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>  </span><br><span class="line">	    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span>  </span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>serverName<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>   </span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>https://localhost:8443<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>   </span><br><span class="line">	    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter</span>&gt;</span> </span><br><span class="line">	<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>  </span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Authentication Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>  </span><br><span class="line">	    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="title">filter</span>&gt;</span>  </span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Validation Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>   </span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span>   </span><br><span class="line">	    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span>  </span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>casServerUrlPrefix<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>   </span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>https://localhost:8443/cas-server<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>   </span><br><span class="line">	    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span>  </span><br><span class="line">	    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span>  </span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>serverName<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span>   </span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>https://localhost:8443<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span>   </span><br><span class="line">	    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter</span>&gt;</span>  </span><br><span class="line">	<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>  </span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Validation Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>   </span><br><span class="line">	    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>   </span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。 比如AssertionHolder.getAssertion().getPrincipal().getName()。 --&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Assertion Thread Local Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.jasig.cas.client.util.AssertionThreadLocalFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Assertion Thread Local Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- ======================== 单点登录结束 ======================== --&gt;</span></span><br><span class="line">	</span><br><span class="line">	<span class="tag">&lt;<span class="title">welcome-file-list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="title">welcome-file</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="title">welcome-file</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">welcome-file-list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">distributable</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="进阶">进阶</h2><h3 id="使用HTTPS协议">使用HTTPS协议</h3><p>首先我们需要生成数字证书<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -keystore "D:\localhost.keystore" -alias localhost -keyalg RSA</span><br><span class="line">输入密钥库口令:</span><br><span class="line">再次输入新口令:</span><br><span class="line">您的名字与姓氏是什么?</span><br><span class="line">[<span class="link_reference">Unknown</span>]:<span class="link_url"> localhost</span></span><br><span class="line">您的组织单位名称是什么?</span><br><span class="line">[<span class="link_reference">Unknown</span>]:<span class="link_url"> xa</span></span><br><span class="line">您的组织名称是什么?</span><br><span class="line">[<span class="link_reference">Unknown</span>]:<span class="link_url"> xa</span></span><br><span class="line">您所在的城市或区域名称是什么?</span><br><span class="line">[<span class="link_reference">Unknown</span>]:<span class="link_url"> xi'an</span></span><br><span class="line">您所在的省/市/自治区名称是什么?</span><br><span class="line">[<span class="link_reference">Unknown</span>]:<span class="link_url"> xi'an</span></span><br><span class="line">该单位的双字母国家/地区代码是什么?</span><br><span class="line">[<span class="link_reference">Unknown</span>]:<span class="link_url"> cn</span></span><br><span class="line">CN=localhost, OU=xa, O=xa, L=xi'an, ST=xi'an, C=cn 是否正确</span><br><span class="line">?</span><br><span class="line">[<span class="link_reference">否</span>]:<span class="link_url"> y</span></span><br><span class="line">输入 <span class="xml"><span class="tag">&lt;<span class="title">localhost</span>&gt;</span></span> 的密钥口令</span><br><span class="line">(如果和密钥库口令相同, 按回车):</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是 “您的名字与姓氏是什么?”这个地方不能随便填的，如果运行过程中提示“Caused by: java.security.cert.CertificateException: No name matching localhost found”那么就是因为这里设置错了，当然除了localhost也可以写其他的，如helloworld.com，但是需要能解析出来，可以直接在hosts中加<code>127.0.0.1 helloworld.com</code></p>
<p>然后，由于Tomcat默认没有开HTTPS，所以我们需要在server.xml文件中找到8443出现的地方。然后修改如下<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector <span class="variable">port=</span><span class="string">"8443"</span> <span class="variable">protocol=</span><span class="string">"HTTP/1.1"</span> <span class="variable">SSLEnabled=</span><span class="string">"true"</span></span><br><span class="line">    <span class="variable">maxThreads=</span><span class="string">"150"</span> <span class="variable">scheme=</span><span class="string">"https"</span> <span class="variable">secure=</span><span class="string">"true"</span></span><br><span class="line">    <span class="variable">clientAuth=</span><span class="string">"false"</span> <span class="variable">sslProtocol=</span><span class="string">"TLS"</span></span><br><span class="line">    <span class="variable">keystoreFile=</span><span class="string">"D:\localhost.keystore"</span> <span class="variable">keystorePass=</span><span class="string">"123456"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>keystorePass 就是生成 keystore 时设置的密码。</p>
<p>如果出现下面的问题，修改server.xml中的protocol为<code>org.apache.coyote.http11.Http11Protocol</code></p>
<p>Failed to initialize end point associated with ProtocolHandler [“http-apr-8443”]<br>java.lang.Exception: Connector attribute SSLCertificateFile must be defined when using SSL with APR</p>
<p>因为 CAS client 需要使用该证书进行验证，所以我们要使用 localhost.keystore 导出数字证书（公钥）到 D:\localhost.cer。再将将证书导入到 JDK 中。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keytool -export -alias localhost -<span class="keyword">file</span> <span class="keyword">D</span>:\localhost.cer -keystore <span class="keyword">D</span>:\localhost.keystore</span><br><span class="line"><span class="keyword">cd</span> <span class="keyword">D</span>:\jdk1.7.0_21\jre\lib\security</span><br><span class="line">keytool -import -alias localhost -<span class="keyword">file</span> <span class="keyword">D</span>:\localhost.cer -noprompt -trustcacerts -storetype jks -keystore cacerts -storepass 123456</span><br></pre></td></tr></table></figure>
<p>如果导入失败，可以先把 security 目录下的 cacerts 删掉</p>
<p>搞定证书之后，我们需要将之前client中配置的地址修改一下。然后还可以添加ssl过滤器。</p>
<p>如果遇到以下异常，一般是证书导入错误造成的，请尝试重新导入，如果还是不行，有可能是运行应用的 JDK 和安装数字证书的 JDK 不是同一个造成的：</p>
<p>Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</p>
<h3 id="单点登出重定向">单点登出重定向</h3><p>客户端中配置logout过滤器<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"logoutFilter"</span> <span class="variable">class=</span><span class="string">"org.apache.shiro.web.filter.authc.LogoutFilter"</span>&gt;</span><br><span class="line">    &lt;property <span class="variable">name=</span><span class="string">"redirectUrl"</span> <span class="variable">value=</span><span class="string">"<span class="subst">$&#123;shiro.logout.url&#125;</span>"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>WEB-INF/cas-servlet.xml中将 <code>cas.logout.followServiceRedirects</code>修改为true即可在登出后重定向到service参数提供的地址</p>
<h3 id="单点登出">单点登出</h3><p>单点登出重定向是很好解决了，但是在客户端与shiro集成过程中，如客户端部署部分所述，如果shiro没有使用 ServletContainerSessionManager 管理session，单点登出就会有问题了。最简单奏效的办法就是改用 ServletContainerSessionManager 了，但是我们偏要用 DefaultWebSessionManager 呢，那就应该要参考org.jasig.cas.client.session这个包中的几个类，重新实现单点登出了。我的思路是，添加一个shiro过滤器，继承自AdviceFilter在preHandle方法中实现逻辑：如果请求中包含了ticket参数，记录ticket和sessionID的映射；如果请求中包含logoutRequest参数，标记session为无效；如果session不为空，且被标记为无效，则登出。如果请求中包含了logoutRequest参数，那么这个请求是从cas服务器发出的，所以这里不能直接用subject.logout()，因为subject跟线程绑定，客户端对cas服务器端的请求会创建一个新的subject。</p>
<p>那么CAS单点登出是怎么实现的呢，下面是我对CAS单点登出的简单理解：</p>
<p>在TicketGrantingTicketImpl有一个HashMap<string, service=""> services字段，以id和通过认证的客户端service为键值对。当我们要登出时LogoutManagerImpl通过for (final String ticketId : services.keySet())向每个service发送一个POST请求，请求中包含一个logoutRequest参数，参数的值由SamlCompliantLogoutMessageCreator创建。客户端的 SingleSignOutFilter会判断请求中是否包含了logoutRequest参数，如果包含，那么销毁session。SingleSignOutHttpSessionListener实现了javax.servlet.http.HttpSessionListener接口，用于监听session销毁事件。</string,></p>
<p>我在配置的过程中发现单点登出有问题，首先在服务端打开 debug log，cas 服务器默认是打开单点登出功能的，所以正常的话日志中会记录<code>&lt;Sending logout request for: [https://localhost:8443/cas-client1/cas]&gt;</code>之类的内容，有日志记录发送了请求，一般服务器应该不会有什么问题了。那么有可能会是客户端的问题，我重新配置了一个客户端，这个客户端没有使用spring也没有使用shiro，只用了在部署客户端中提到的无spring的web.xml文件，发现从其他客户端登出，这个客户端也是登出的，所以这个配置是没有什么问题。后来在浏览器打开控制台才发现有两个SESSIONID一个是sid是在shiro中配置的，另一个是JSESSIONID，应该是容器原生的。再然后就下了3.2.2版本的cas-client-core，通过maven构建，导入eclipse中，开始调试。我们的cas-client要依赖这个cas-client-core工程，怎么设置可以参考<a href="http://howiefh.github.io/2014/02/08/eclipse-tips/">eclipse小技巧</a>。然后调试，一定要保证在cas-client的propertie 设置中的Deployment Assembly中已经没有之前的版本的cas-client-core的jar包了。调试的过程中才发现，SingleSignOutFilter销毁的是容器原生的session，但是shiro的session还在，所以如果是从其他客户端登出的，那这个客户端还是能够登录。</p>
<h3 id="通过数据库中的用户密码认证">通过数据库中的用户密码认证</h3><p>服务器端需要添加cas-server-support-jdbc和mysql-connector-java依赖。</p>
<p>cas-server-support-jdbc提供了org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler、org.jasig.cas.adaptors.jdbc.SearchModeSearchDatabaseAuthenticationHandler 和org.jasig.cas.adaptors.jdbc.QueryAndEncodeDatabaseAuthenticationHandler。他们都继承自AbstractJdbcUsernamePasswordAuthenticationHandler 能够通过配置sql语句验证用户凭证，后者更复杂些，能够配置盐，散列函数迭代次数。</p>
<p>下面说一下配置QueryDatabaseAuthenticationHandler，配置/src/main/webapp/WEB-INF/deployerConfigContext.xml，先注释掉原先的primaryAuthenticationHandler然后添加下面配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义数据库鉴权 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"primaryAuthenticationHandler"</span> <span class="attribute">class</span>=<span class="value">"org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sql"</span>  <span class="attribute">value</span>=<span class="value">"$&#123;auth.sql&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"passwordEncoder"</span> <span class="attribute">ref</span>=<span class="value">"MD5PasswordEncoder"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClassName"</span> <span class="attribute">value</span>=<span class="value">"$&#123;dataSource.driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"url"</span> <span class="attribute">value</span>=<span class="value">"$&#123;dataSource.url&#125;"</span>/&gt;</span>  </span><br><span class="line">     <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"username"</span> <span class="attribute">value</span>=<span class="value">"$&#123;dataSource.username&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"$&#123;dataSource.password&#125;"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line"> <span class="comment">&lt;!-- MD5加密 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"MD5PasswordEncoder"</span> <span class="attribute">class</span>=<span class="value">"org.jasig.cas.authentication.handler.DefaultPasswordEncoder"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"MD5"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">``` </span><br><span class="line">加密算法可以自定义。</span><br><span class="line"></span><br><span class="line">### 添加验证码</span><br><span class="line"></span><br><span class="line">验证码的实现使用了kaptcha，所以需要添加其依赖。</span><br><span class="line"></span><br><span class="line">web.xml添加如下配置</span><br></pre></td></tr></table></figure>
<p><servlet><br>    <servlet-name>Kaptcha</servlet-name><br>    <servlet-class>com.google.code.kaptcha.servlet.KaptchaServlet</servlet-class><br>    <!-- 设定宽度 --><br>    <init-param><br>        <param-name>kaptcha.image.width</param-name><br>        <param-value>100</param-value><br>    </init-param><br>    <!-- 设定高度 --><br>    <init-param><br>        <param-name>kaptcha.image.height</param-name><br>        <param-value>50</param-value><br>    </init-param><br>    <!-- 如果需要全部是数字 --><br>    <init-param><br>        <param-name>kaptcha.textproducer.char.string</param-name><br>        <param-value>0123456789</param-value><br>    </init-param><br>    <!-- 去掉干扰线 --><br>    <init-param><br>        <param-name>kaptcha.noise.impl</param-name><br>        <param-value>com.google.code.kaptcha.impl.NoNoise </param-value><br>    </init-param><br></servlet></p>
<p><servlet-mapping><br>    <servlet-name>Kaptcha</servlet-name><br>    <url-pattern>/captcha.jpg</url-pattern><br></servlet-mapping><br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在login-webflow.xml中找到viewLoginForm，在binder节点下面添加<span class="escape">`&lt;</span>binding property=<span class="string">"captcha"</span> /&gt;<span class="escape">`，</span>对应我们页面提交的验证码参数</span><br><span class="line"></span><br><span class="line">然后我们还要实现一个UsernamePasswordCaptchaCredential 类，继承UsernamePasswordCredential 在其中添加了captcha字段和相应setter和getter方法。</span><br></pre></td></tr></table></figure></p>
<p>public class UsernamePasswordCaptchaCredential extends UsernamePasswordCredential {<br>    private static final long serialVersionUID = -2988130322912201986L;<br>    @NotNull<br>    @Size(min=1,message = “required.captcha”)<br>    private String captcha;</p>
<pre><code>//<span class="built_in">set</span>、<span class="built_in">get</span>方法
</code></pre><p>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">接着回到 login-webflow<span class="class">.xml</span> ，找到credential的声明处，将org<span class="class">.jasig</span><span class="class">.cas</span><span class="class">.authentication</span><span class="class">.UsernamePasswordCredential</span>修改为刚刚实现的类全路径名。viewLoginForm 也需要修改</span><br></pre></td></tr></table></figure></p>
<p><transition on="submit" bind="true" validate="true" to="validatorCaptcha"><br>    <evaluate expression="authenticationViaFormAction.doBind(flowRequestContext, flowScope.credential)"><br></evaluate></transition><br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">再添加如下配置</span><br></pre></td></tr></table></figure></p>
<!-- 添加一个 validatorCaptcha 校验验证码的操作 -->
<p><action-state id="validatorCaptcha"><br>    <evaluate expression="authenticationViaFormAction.validatorCaptcha(flowRequestContext, flowScope.credential, messageContext)"></evaluate><br>    <transition on="error" to="generateLoginTicket"><br>    <transition on="success" to="realSubmit"><br></transition></transition></action-state><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们在配置中添加了一个 validatorCaptcha 的操作，同时可以看到 expression 是 authenticationViaFormAction.<span class="function"><span class="title">validatorCaptcha</span><span class="params">(...)</span></span>，所以我们需要在  authenticationViaFormAction 中添加一个校验验证码的方法 <span class="function"><span class="title">validatorCaptcha</span><span class="params">()</span></span>。authenticationViaFormAction 这个bean是配置在 cas-servlet<span class="class">.xml</span> 中的：</span><br></pre></td></tr></table></figure></p>
<p><bean id="authenticationViaFormAction" class="org.jasig.cas.web.flow.AuthenticationViaFormAction" p:centralauthenticationservice-ref="centralAuthenticationService" p:warncookiegenerator-ref="warnCookieGenerator" p:ticketregistry-ref="ticketRegistry"><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">我们可以看看 org<span class="class">.jasig</span><span class="class">.cas</span><span class="class">.web</span><span class="class">.flow</span><span class="class">.AuthenticationViaFormAction</span> 的源代码，里面有一个 submit 方法，这个就是我们提交表单时的方法了。继承AuthenticationViaFormAction实现一个新类</span><br></pre></td></tr></table></figure></bean></p>
<p>public class MyAuthenticationViaFormAction extends AuthenticationViaFormAction{</p>
<pre><code>public final String validatorCaptcha<span class="params">(final RequestContext context, final Credential credential,
        final MessageContext messageContext)</span>{

        final HttpServletRequest request = WebUtils.getHttpServletRequest<span class="params">(context)</span>;  
        HttpSession session = request.getSession<span class="params">()</span>;  
        String captcha = <span class="params">(String)</span>session.getAttribute<span class="params">(com.google.code.kaptcha.Constants.KAPTCHA_SESSION_KEY)</span>;  
        session.removeAttribute<span class="params">(com.google.code.kaptcha.Constants.KAPTCHA_SESSION_KEY)</span>;  

        UsernamePasswordCaptchaCredential upc = <span class="params">(UsernamePasswordCaptchaCredential)</span>credential;  
        String submitAuthcodeCaptcha =upc.getCaptcha<span class="params">()</span>; 


        <span class="keyword">if</span><span class="params">(!StringUtils.hasText<span class="params">(submitAuthcodeCaptcha)</span> || !StringUtils.hasText<span class="params">(submitAuthcodeCaptcha)</span>)</span>{
            messageContext.addMessage<span class="params">(new MessageBuilder<span class="params">()</span>.code<span class="params">(<span class="string">"required.captcha"</span>)</span>.build<span class="params">()</span>)</span>; 
            return <span class="string">"error"</span>;    
        }  
        <span class="keyword">if</span><span class="params">(submitAuthcodeCaptcha.equals<span class="params">(captcha)</span>)</span>{    
            return <span class="string">"success"</span>;  
        }  
        messageContext.addMessage<span class="params">(new MessageBuilder<span class="params">()</span>.code<span class="params">(<span class="string">"error.authentication.captcha.bad"</span>)</span>.build<span class="params">()</span>)</span>;
        return <span class="string">"error"</span>;    
}
</code></pre><p>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line">这边有抛出两个异常，这两个异常信息 required.captcha、error<span class="class">.authentication</span><span class="class">.captcha</span><span class="class">.bad</span> 需要在 messages_zh_CN<span class="class">.properties</span> 文件下添加</span><br></pre></td></tr></table></figure></p>
<p>required.captcha=必须输入验证码。<br>error.authentication.captcha.bad=您输入的验证码有误。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后把 authenticationViaFormAction 这个<span class="keyword">Bean路径修改为我们新添加的类的全路径名。</span><br><span class="line"></span></span><br><span class="line">当然最后，我们的页面也需要修改，找到casLoginView.jsp添加</span><br></pre></td></tr></table></figure></p>
<p><section class="row"><br>        <spring:message code="screen.welcome.label.captcha.accesskey" var="captchaAccessKey"><br>        <spring:message code="screen.welcome.label.captcha" var="captchaHolder"><br>        <form:input cssclass="required" csserrorclass="error" id="captcha" size="10" tabindex="3" path="captcha" placeholder="${captchaHolder }" accesskey="${captchaAccessKey}" autocomplete="off" htmlescape="true"><br>        <img alt="${captchaHolder }" src="captcha.jpg" onclick="this.src='captcha.jpg?'+Math.random();"><br></form:input></spring:message></spring:message></section><br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">以上添加验证码参考&lt;<span class="string">http:</span><span class="comment">//www.cnblogs.com/vhua/p/cas_3.html&gt;</span></span><br><span class="line"></span><br><span class="line">### 添加记住密码</span><br><span class="line"></span><br><span class="line">可以参考&lt;<span class="string">http:</span><span class="comment">//jasig.github.io/cas/development/installation/Configuring-LongTerm-Authentication.html&gt;</span></span><br><span class="line"></span><br><span class="line">在cas.properties中添加如下配置</span><br></pre></td></tr></table></figure></p>
<h1 id="Long_term_authentication_session_length_in_seconds">Long term authentication session length in seconds</h1><p>rememberMeDuration=1209600<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">spring-configuration文件夹下找到 ticketExpirationPolicies<span class="class">.xml</span> 和 ticketGrantingTicketCookieGenerator<span class="class">.xml</span> 需要在这两个配置文件中定义长期有效的session</span><br><span class="line"></span><br><span class="line">在 ticketExpirationPolicies.xml文件中更新如下配置</span><br></pre></td></tr></table></figure></p>
<bean id="standardSessionTGTExpirationPolicy" class="org.jasig.cas.ticket.support.TicketGrantingTicketExpirationPolicy" p:maxtimetoliveinseconds="${tgt.maxTimeToLiveInSeconds:28800}" p:timetokillinseconds="${tgt.timeToKillInSeconds:7200}">

<!--
   | The following policy applies to long term CAS SSO sessions.
   | Default duration is two weeks (1209600s).
   -->
<bean id="longTermSessionTGTExpirationPolicy" class="org.jasig.cas.ticket.support.TimeoutExpirationPolicy" c:timetokillinmilliseconds="#{ ${rememberMeDuration:1209600} * 1000 }">

<p><bean id="grantingTicketExpirationPolicy" class="org.jasig.cas.ticket.support.RememberMeDelegatingExpirationPolicy" p:sessionexpirationpolicy-ref="standardSessionTGTExpirationPolicy" p:remembermeexpirationpolicy-ref="longTermSessionTGTExpirationPolicy"><br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">更新<span class="tag">ticketGrantingTicketCookieGenerator</span><span class="class">.xml</span></span><br></pre></td></tr></table></figure></bean></p>
<p><bean id="ticketGrantingTicketCookieGenerator" class="org.jasig.cas.web.support.CookieRetrievingCookieGenerator" p:cookiesecure="true" p:cookiemaxage="-1" p:remembermemaxage="${rememberMeDuration:1209600}" p:cookiename="CASTGC" p:cookiepath="/cas"><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在 deployerConfigContext<span class="class">.xml</span> 中找到 PolicyBasedAuthenticationManager 使其包含RememberMeAuthenticationMetaDataPopulator组件</span><br></pre></td></tr></table></figure></bean></p>
<p><property name="authenticationMetaDataPopulators"><br>    <list><br>        <bean class="org.jasig.cas.authentication.SuccessfulHandlerMetaDataPopulator"><br>        <bean class="org.jasig.cas.authentication.principal.RememberMeAuthenticationMetaDataPopulator"><br>    </bean></bean></list><br></property><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">和添加验证码类似的，我们还需要修改login-webflow<span class="class">.xml</span></span><br><span class="line"></span><br><span class="line">找到credential 的声明修改如下</span><br></pre></td></tr></table></figure></p>
<p><var name="credential" class="org.jasig.cas.authentication.RememberMeUsernamePasswordCredential"><br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">由于之前已经实现了验证码，所以这里不需要修改了，只需让 UsernamePasswordCaptchaCredential继承RememberMeUsernamePasswordCredential即可</span><br><span class="line"></span><br><span class="line">找到viewLoginForm 在binder节点下添加<span class="escape">`&lt;</span>binding property=<span class="string">"rememberMe"</span> /&gt;<span class="escape">`</span><br><span class="line"></span></span><br><span class="line">更新 casLoginView.jsp</span><br></pre></td></tr></table></figure></var></p>
<p><section class="row check"><br>    <input id="rememberMe" name="rememberMe" value="false" tabindex="4" accesskey="<spring:message code=" screen.welcome.label.rememberme.accesskey"="">" type="checkbox" /><br>    <label for="rememberMe"><spring:message code="screen.welcome.label.rememberMe"></spring:message></label><br></section><br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">### 自定义primaryAuthenticationHandler</span></span><br><span class="line"></span><br><span class="line">虽然已经有QueryDatabaseAuthenticationHandler和QueryAndEncodeDatabaseAuthenticationHandler两个类，能够通过配置sql语句验证用户凭证，后者还能配置盐，散列函数迭代次数。但是我们可能还需要判断用户是否被锁定或被禁用了，我们可以参考QueryAndEncodeDatabaseAuthenticationHandler自定义一个AuthenticationHandler，继承AbstractJdbcUsernamePasswordAuthenticationHandler。添加两个字段名lockedFieldName和disabledFieldName通过这两个字段判断用户是否被锁定或被禁用，关键代码如下</span><br></pre></td></tr></table></figure></p>
<p>public class ValidUserQueryDBAuthenticationHandler extends AbstractJdbcUsernamePasswordAuthenticationHandler{<br>    ……<br>    private static final String DEFAULT_LOCKED_FIELD = “locked”;<br>    private static final String DEFAULT_DISABLED_FIELD = “disabled”;<br>    ……<br>    @NotNull<br>    protected String disabledFieldName = DEFAULT_DISABLED_FIELD;<br>    @NotNull<br>    protected String lockedFieldName = DEFAULT_LOCKED_FIELD;<br>    ……<br>    public ValidUserQueryDBAuthenticationHandler(final DataSource datasource, final String sql, final String algorithmName) {<br>        super();<br>        setDataSource(datasource);<br>        this.sql = sql;<br>        this.algorithmName = algorithmName;<br>    }</p>
<pre><code>@Override
<span class="keyword">protected</span> <span class="keyword">final</span> HandlerResult authenticateUsernamePasswordInternal(<span class="keyword">final</span> UsernamePasswordCredential transformedCredential)
        <span class="keyword">throws</span> GeneralSecurityException, PreventedException {
    <span class="keyword">final</span> <span class="keyword">String</span> username = getPrincipalNameTransformer().transform(transformedCredential.getUsername());

    <span class="keyword">try</span> {
        <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; values = getJdbcTemplate().queryForMap(<span class="keyword">this</span>.sql, username);

        <span class="keyword">if</span> (Boolean.TRUE.equals(values.<span class="built_in">get</span>(<span class="keyword">this</span>.disabledFieldName))) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountDisabledException(username + <span class="string">"  has been disabled."</span>);
        }
        <span class="keyword">if</span> (Boolean.TRUE.equals(values.<span class="built_in">get</span>(<span class="keyword">this</span>.lockedFieldName))) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountLockedException(username + <span class="string">"  has been locked."</span>);
        }

        <span class="keyword">final</span> <span class="keyword">String</span> digestedPassword = digestEncodedPassword(transformedCredential.getPassword(), values);
        <span class="keyword">if</span> (!values.<span class="built_in">get</span>(<span class="keyword">this</span>.passwordFieldName).equals(digestedPassword)) {
            <span class="keyword">throw</span> <span class="keyword">new</span> FailedLoginException(<span class="string">"Password does not match value on record."</span>);
        }
        <span class="keyword">return</span> createHandlerResult(transformedCredential,
                <span class="keyword">new</span> SimplePrincipal(username), <span class="keyword">null</span>);

    } <span class="keyword">catch</span> (<span class="keyword">final</span> IncorrectResultSizeDataAccessException e) {
        <span class="keyword">if</span> (e.getActualSize() == <span class="number">0</span>) {
            <span class="keyword">throw</span> <span class="keyword">new</span> AccountNotFoundException(username + <span class="string">" not found with SQL query"</span>);
        } <span class="keyword">else</span> {
            <span class="keyword">throw</span> <span class="keyword">new</span> FailedLoginException(<span class="string">"Multiple records found for "</span> + username);
        }
    } <span class="keyword">catch</span> (<span class="keyword">final</span> DataAccessException e) {
        <span class="keyword">throw</span> <span class="keyword">new</span> PreventedException(<span class="string">"SQL exception while executing query for "</span> + username, e);
    }

}

<span class="keyword">protected</span> <span class="keyword">String</span> digestEncodedPassword(<span class="keyword">final</span> <span class="keyword">String</span> encodedPassword, <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; values) {
    <span class="keyword">final</span> ConfigurableHashService hashService = <span class="keyword">new</span> DefaultHashService();

    <span class="keyword">if</span> (StringUtils.isNotBlank(<span class="keyword">this</span>.staticSalt)) {
        hashService.setPrivateSalt(ByteSource.Util.bytes(<span class="keyword">this</span>.staticSalt));
    }
    hashService.setHashAlgorithmName(<span class="keyword">this</span>.algorithmName);

    Long numOfIterations = <span class="keyword">this</span>.numberOfIterations;
    <span class="keyword">if</span> (values.containsKey(<span class="keyword">this</span>.numberOfIterationsFieldName)) {
        <span class="keyword">final</span> <span class="keyword">String</span> longAsStr = values.<span class="built_in">get</span>(<span class="keyword">this</span>.numberOfIterationsFieldName).toString();
        numOfIterations = Long.valueOf(longAsStr);
    }

    hashService.setHashIterations(numOfIterations.intValue());
    <span class="keyword">if</span> (!values.containsKey(<span class="keyword">this</span>.saltFieldName)) {
        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Specified field name for salt does not exist in the results"</span>);
    }

    <span class="keyword">final</span> <span class="keyword">String</span> dynaSalt = values.<span class="built_in">get</span>(<span class="keyword">this</span>.saltFieldName)==<span class="keyword">null</span>?<span class="string">""</span>:values.<span class="built_in">get</span>(<span class="keyword">this</span>.saltFieldName).toString();
    <span class="keyword">final</span> HashRequest request = <span class="keyword">new</span> HashRequest.Builder()
                                .setSalt(dynaSalt)
                                .setSource(encodedPassword)
                                .build();
    <span class="keyword">return</span> hashService.computeHash(request).toHex();
}

<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> setDisabledFieldName(<span class="keyword">final</span> <span class="keyword">String</span> disabledFieldName) { <span class="keyword">this</span>.disabledFieldName = disabledFieldName; }
<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> setLockedFieldName(<span class="keyword">final</span> <span class="keyword">String</span> lockedFieldName) { <span class="keyword">this</span>.lockedFieldName = lockedFieldName; }
</code></pre><p>}<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">然后更新配置<span class="tag">deployerConfigContext</span><span class="class">.xml</span></span><br></pre></td></tr></table></figure></p>
<p><bean id="primaryAuthenticationHandler" class="io.github.howiefh.cas.authentication.ValidUserQueryDBAuthenticationHandler"><br>    <constructor-arg ref="dataSource" index="0"></constructor-arg><br>    <constructor-arg value="${auth.sql}" index="1"></constructor-arg><br>    <constructor-arg value="MD5" index="2"></constructor-arg><br></bean><br>```</p>
<h3 id="自定义登录页面">自定义登录页面</h3><ol>
<li>在cas.properties 修改 cas.viewResolver.basename  值为 custom_view ，那样系统就会自动会查找 custom_view.properties 这个配置文件</li>
<li>直接复制原来的 default_views.properties 就行了，重命名为custom_view.properties</li>
<li>把 custom_view.properties 中的WEB-INF\view\jsp\default全部替换把这地址替换成 WEB-INF\view\jsp\custom</li>
<li>接下来把 cas\WEB-INF\view\jsp\default 下面的所有文件复制，然后重命名为我们需要的名称，cas\WEB-INF\view\jsp\custom</li>
</ol>
<p>主要修改casLoginView.jsp和cas.css即可</p>
<p>布局时遇到一个问题，就是将页脚固定在页面底部。可以参看<a href="http://www.w3cplus.com/css/css-sticky-foot-at-bottom-of-the-page" target="_blank" rel="external">如何将页脚固定在页面底部</a></p>
<h3 id="其它">其它</h3><p><a href="http://www.cnblogs.com/vhua/p/cas_4.html" target="_blank" rel="external">【SSO单点系列】（4）：CAS4.0 SERVER登录后用户信息的返回</a><br><a href="http://www.cnblogs.com/huangbin/p/3282643.html" target="_blank" rel="external">在多点环境下使用cas实现单点登陆及登出</a><br><a href="http://blog.csdn.net/tch918/article/details/22316175" target="_blank" rel="external">关于单点登录中的用户信息存储问题的探讨</a></p>
<h2 id="原理">原理</h2><p>从结构来看，CAS主要分为Server和Client。Server主要负责对用户的认证工作；Client负责处理客户端受保护资源的访问请求，登录时，重定向到Server进行认证。</p>
<p>基础模式的SSO访问流程步骤：</p>
<ol>
<li>访问服务：客户端发送请求访问应用系统提供的服务资源。</li>
<li>定向认证：客户端重定向用户请求到中心认证服务器。</li>
<li>用户认证：用户进行身份认证</li>
<li>发放票据：服务器会产生一个随机的 Service Ticket 。</li>
<li>验证票据： SSO 服务器验证票据 Service Ticket 的合法性，验证通过后，允许客户端访问服务。</li>
<li>传输用户信息： SSO 服务器验证票据通过后，传输用户认证结果信息给客户端。</li>
</ol>
<p>CAS最基本的协议过程：</p>
<p><img src="http://fh-1.qiniudn.com/cas-clip.jpg" alt="CAS 最基本的协议过程"></p>
<p>如上图： CAS Client 与受保护的客户端应用部署在一起，以 Filter 方式保护 Web 应用的受保护资源，过滤从客户端过来的每一个 Web 请求，同时， CAS Client 会分析 HTTP 请求中是否包含请求 Service Ticket( ST 上图中的 Ticket) ，如果没有，则说明该用户是没有经过认证的；于是 CAS Client 会重定向用户请求到 CAS Server （ Step 2 ），并传递 Service （要访问的目的资源地址）。 Step 3 是用户认证过程，如果用户提供了正确的 Credentials ， CAS Server 随机产生一个相当长度、唯一、不可伪造的 Service Ticket ，并缓存以待将来验证，并且重定向用户到 Service 所在地址（附带刚才产生的 Service Ticket ） , 并为客户端浏览器设置一个 Ticket Granted Cookie （ TGC ） ； CAS Client 在拿到 Service 和新产生的 Ticket 过后，在 Step 5 和 Step6 中与 CAS Server 进行身份核实，以确保 Service Ticket 的合法性。</p>
<p>在该协议中，所有与 CAS Server 的交互均采用 SSL 协议，以确保 ST 和 TGC 的安全性。协议工作过程中会有两次重定向的过程。但是 CAS Client 与 CAS Server 之间进行 Ticket 验证的过程对于用户是透明的（使用 HttpsURLConnection ）。</p>
<h3 id="相关概念">相关概念</h3><p>TGT、ST、PGT、PGTIOU、PT，其中TGT、ST是CAS1.0协议中就有的票据，PGT、PGTIOU、PT是CAS2.0协议中有的票据。</p>
<p>CAS为用户签发登录票据，CAS认证成功后，将TGT对象放入自己的缓存，CAS生成cookie即TGC，自后登录时如果有TGC的话，则说明用户之前登录过，如果没有，则用户需要重新登录。</p>
<ul>
<li>TGC （Ticket-granting cookie）：存放用户身份认证凭证的cookie，在浏览器和CAS Server用来明确用户身份的凭证。</li>
<li>ST（Service Ticket）：CAS服务器通过浏览器分发给客户端服务器的票据。一个特定服务只能有一个唯一的ST。</li>
<li>PGT（Proxy Granting Ticket）：由 CAS Server 颁发给拥有 ST 凭证的服务， PGT 绑定一个用户的特定服务，使其拥有向 CAS Server 申请，获得 PT 的能力。</li>
<li>PGTIOU（全称 Proxy Granting Ticket I Owe You）：作用是将通过凭证校验时的应答信息由 CAS Server 返回给 CAS Client ，同时，与该 PGTIOU 对应的 PGT 将通过回调链接传给 Web 应用。 Web 应用负责维护 PGTIOU 与 PGT 之间映射关系的内容表。PGTIOU是CAS的serviceValidate接口验证ST成功后，CAS会生成验证ST成功的xml消息，返回给Proxy Service，xml消息中含有PGTIOU，proxy service收到Xml消息后，会从中解析出PGTIOU的值，然后以其为key，在map中找出PGT的值，赋值给代表用户信息的Assertion对象的pgtId，同时在map中将其删除。</li>
<li>PT（Proxy Ticket）：是应用程序代理用户身份对目标程序进行访问的凭证；</li>
</ul>
<p>CAS 基本流程图（没有使用PROXY代理）</p>
<p><img src="http://fh-1.qiniudn.com/cas-noproxy.png" alt="CAS 基本流程图（没有使用PROXY代理）"></p>
<p>对于客户端来说会通过客户端session判断用户是否已认证，没有的话跳转到服务器认证，对于服务器，通过SSO session判断用户是否认证，没有的话跳到登录页面。</p>
<p>CAS 基本流程图（使用PROXY代理）</p>
<p><img src="http://fh-1.qiniudn.com/cas-proxy.png" alt="CAS 基本流程图（使用PROXY代理）"></p>
<p>这一节参考：</p>
<p><a href="http://www.cnblogs.com/vhua/p/cas_6.html" target="_blank" rel="external">【SSO单点系列】（6）：CAS4.0 单点流程序列图（中文版）以及相关术语解释（TGT、ST、PGT、PT、PGTIOU）</a><br><a href="http://www.coin163.com/java/cas/cas.html" target="_blank" rel="external">CAS实现SSO单点登录原理</a></p>
<p>代码:<a href="https://github.com/howiefh/framework/tree/shiro-cas-sso" target="_blank" rel="external">github</a></p>
</bean></bean>]]></content>
    <summary type="html">
    <![CDATA[Shiro; CAS; SSO; Shrio 单点登录；单点登出；单点登录 验证码；单点登录 记住密码；单点登陆 查询数据库; 单点登录 自定义]]>
    
    </summary>
    
      <category term="CAS" scheme="http://howiefh.github.io/tags/CAS/"/>
    
      <category term="SSO" scheme="http://howiefh.github.io/tags/SSO/"/>
    
      <category term="Shiro" scheme="http://howiefh.github.io/tags/Shiro/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="Shiro" scheme="http://howiefh.github.io/categories/Java/Shiro/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shiro笔记]]></title>
    <link href="http://howiefh.github.io/2015/05/12/shiro-note/"/>
    <id>http://howiefh.github.io/2015/05/12/shiro-note/</id>
    <published>2015-05-12T02:03:26.000Z</published>
    <updated>2015-05-21T16:13:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>Apache Shiro是一个强大易用的Java安全框架，可以帮助我们完成：认证、授权、加密、会话管理、与Web集成、缓存等。</p>
<p><img src="http://fh-1.qiniudn.com/shiro/shiro-func.png" alt="Shiro基本功能"></p>
<ul>
<li>Authentication：身份认证/登录，验证用户是不是拥有相应的身份；</li>
<li>Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</li>
<li>Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</li>
<li>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li>
<li>Web Support：Web支持，可以非常容易的集成到Web环境；</li>
<li>Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</li>
<li>Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li>
<li>Testing：提供测试支持；</li>
<li>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li>
<li>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>
</ul>
<a id="more"></a>
<p><strong>记住一点，Shiro不会去维护用户、维护权限；这些需要我们自己去设计/提供；然后通过相应的接口注入给Shiro即可。</strong></p>
<p>Shiro的三个核心组件：Subject, SecurityManager 和 Realms. 如下图： </p>
<p><img src="http://fh-1.qiniudn.com/shiro/shiro-core.png" alt="Shiro框架图"></p>
<p>Subject：即“当前操作用户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是Shiro的“用户”概念。Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。与Subject的所有交互都会委托给SecurityManager。 </p>
<p>SecurityManager：它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。可以把它看成 DispatcherServlet 前端控制器 </p>
<p>Realm： Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。 </p>
<p>Shiro完整架构图： </p>
<p><img src="http://fh-1.qiniudn.com/shiro/shiro-frame.png" alt="Shiro框架图"></p>
<ul>
<li><p>Subject (org.apache.shiro.subject.Subject)<br>  正在与软件交互的一个特定的实体“view”（用户、第三方服务、时钟守护任务等）。</p>
</li>
<li><p>SecurityManager (org.apache.shiro.mgt.SecurityManager)<br>  如同上面提到的，SecurityManager 是 Shiro 的核心，它基本上就是一把“保护伞”用来协调它管理的组件使之平稳地一起工作，它也管理着 Shiro 中每一个程序用户的视图，所以它知道每个用户如何执行安全操作。</p>
</li>
<li><p>Authenticator(org.apache.shiro.authc.Authenticator)<br>  Authenticator 是一个组件，负责执行和反馈用户的认证（登录），如果一个用户尝试登录，Authenticator 就开始执行。Authenticator 知道如何协调一个或多个保存有相关用户/帐号信息的 Realm，从这些 Realm中获取这些数据来验证用户的身份以确保用户确实是其表述的那个人。</p>
</li>
<li><p>Authentication Strategy(org.apache.shiro.authc.pam.AuthenticationStrategy)<br>  如果配置了多个 Realm，AuthenticationStrategy 将会协调 Realm 确定在一个身份验证成功或失败的条件（例如，如果在一个方面验证成功了但其他失败了，这次尝试是成功的吗？是不是需要所有方面的验证都成功？还是只需要第一个？）</p>
</li>
<li><p>Authorizer(org.apache.shiro.authz.Authorizer)<br>  Authorizer 是负责程序中用户访问控制的组件，它是最终判断一个用户是否允许做某件事的途径，像 Authenticator 一样，Authorizer 也知道如何通过协调多种后台数据源来访问角色和权限信息，Authorizer 利用这些信息来准确判断一个用户是否可以执行给定的动作。</p>
</li>
<li><p>SessionManager(org.apache.shiro.session.mgt.SessionManager)<br>  SessionManager 知道如何创建并管理用户 Session 生命周期而在所有环境中为用户提供一个强有力的 Session 体验。这在安全框架领域是独一无二—Shiro 具备管理在任何环境下管理用户 Session 的能力，即使没有 Web/Servlet 或者 EJB 容器。默认情况下，Shiro 将使用现有的session（如Servlet Container），但如果环境中没有，比如在一个独立的程序或非 web 环境中，它将使用它自己建立的 session 提供相同的作用，sessionDAO 用来使用任何数据源使 session 持久化。</p>
</li>
<li><p>SessionDAO(org.apache.shiro.session.mgt.eis.SessionDAO)<br>  SessionDAO 代表 SessionManager 执行 Session 持久（CRUD）动作，它允许任何存储的数据挂接到 session 管理基础上。</p>
</li>
<li><p>CacheManager(org.apache.shiro.cache.CacheManager)<br>  CacheManager 为 Shiro 的其他组件提供创建缓存实例和管理缓存生命周期的功能。因为 Shiro 的认证、授权、会话管理支持多种数据源，所以访问数据源时，使用缓存来提高访问效率是上乘的选择。当下主流开源或企业级缓存框架都可以继承到 Shiro 中，来获取更快更高效的用户体验。</p>
</li>
<li><p>Cryptography (<code>org.apache.shiro.crypto.*</code>)<br>  Cryptography 在安全框架中是一个自然的附加产物，Shiro 的 crypto 包包含了易用且易懂的加密方式，Hashes（即digests）和不同的编码实现。该包里所有的类都易于理解和使用，曾经用过 Java 自身的加密支持的人都知道那是一个具有挑战性的工作，而 Shiro 的加密 API 简化了 java 复杂的工作方式，将加密变得易用。</p>
</li>
<li><p>Realms (org.apache.shiro.realm.Realm)<br>  如同上面提到的，Realm 是 shiro 和你的应用程序安全数据之间的“桥”或“连接”，当实际要与安全相关的数据进行交互如用户执行身份认证（登录）和授权验证（访问控制）时，shiro 从程序配置的一个或多个Realm 中查找这些数据，你需要配置多少个 Realm 便可配置多少个 Realm（通常一个数据源一个），shiro 将会在认证和授权中协调它们。</p>
</li>
</ul>
<h2 id="身份验证">身份验证</h2><p>认证就是验证用户身份的过程。在认证过程中，用户需要提交实体信息(Principals)和凭据信息(Credentials)以检验用户是否合法。最常见的“实体/凭证”组合便是“用户名/密码”组合。 </p>
<h3 id="Shiro认证过程">Shiro认证过程</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager</span></span><br><span class="line">Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory<span class="params">(<span class="string">"classpath:shiro.ini"</span>)</span>;</span><br><span class="line"><span class="comment">//2、得到SecurityManager实例 并绑定给SecurityUtils</span></span><br><span class="line">SecurityManager securityManager = factory.getInstance<span class="params">()</span>;</span><br><span class="line">SecurityUtils.setSecurityManager<span class="params">(securityManager)</span>;</span><br><span class="line"><span class="comment">//3、获取当前执行用户:</span></span><br><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;</span><br><span class="line"><span class="comment">//做点跟 Session 相关的事</span></span><br><span class="line">Session session = currentUser.getSession<span class="params">()</span>;</span><br><span class="line">session.setAttribute<span class="params">(<span class="string">"someKey"</span>, <span class="string">"aValue"</span>)</span>;</span><br><span class="line">String value = <span class="params">(String)</span> session.getAttribute<span class="params">(<span class="string">"someKey"</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(value.equals<span class="params">(<span class="string">"aValue"</span>)</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"Retrieved the correct value! ["</span> + value + <span class="string">"]"</span>)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> <span class="params">(!currentUser.isAuthenticated<span class="params">()</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//4、创建用户名/密码身份验证Token（即用户身份/凭证）</span></span><br><span class="line">    UsernamePasswordToken token = new UsernamePasswordToken<span class="params">(</span><br><span class="line">            <span class="string">"lonestarr"</span>, <span class="string">"vespa"</span>)</span>;</span><br><span class="line">    token.setRememberMe<span class="params">(<span class="literal">true</span>)</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="comment">//5、登录、即身份验证</span></span><br><span class="line">        currentUser.login<span class="params">(token)</span>;</span><br><span class="line">    &#125; catch <span class="params">(UnknownAccountException uae)</span> &#123;</span><br><span class="line">        <span class="built_in">log</span>.info<span class="params">(<span class="string">"There is no user with username of "</span> + token.getPrincipal<span class="params">()</span>)</span>;</span><br><span class="line">    &#125; catch <span class="params">(IncorrectCredentialsException ice)</span> &#123;</span><br><span class="line">        <span class="built_in">log</span>.info<span class="params">(<span class="string">"Password for account "</span> + token.getPrincipal<span class="params">()</span> + <span class="string">" was incorrect!"</span>)</span>;</span><br><span class="line">    &#125; catch <span class="params">(LockedAccountException lae)</span> &#123;</span><br><span class="line">        <span class="built_in">log</span>.info<span class="params">(<span class="string">"The account for username "</span> + token.getPrincipal<span class="params">()</span> + <span class="string">" is locked. "</span> + <span class="string">"Please contact your administrator to unlock it."</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 捕获更多异常</span></span><br><span class="line">    catch <span class="params">(AuthenticationException ae)</span> &#123;</span><br><span class="line">        <span class="comment">// 无定义?错误?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 打印主要识别信息 (本例是 username):</span></span><br><span class="line"><span class="built_in">log</span>.info<span class="params">(<span class="string">"User ["</span> + currentUser.getPrincipal<span class="params">()</span> + <span class="string">"] logged in successfully."</span>)</span>;</span><br><span class="line"><span class="comment">// 测试角色:</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(currentUser.hasRole<span class="params">(<span class="string">"schwartz"</span>)</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"May the Schwartz be with you!"</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"Hello, mere mortal."</span>)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 测试一个权限 (非（ instance-level） 实例级别)</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(currentUser.isPermitted<span class="params">(<span class="string">"lightsaber:weild"</span>)</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"You may use a lightsaber ring. Use it wisely."</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"Sorry, lightsaber rings are for schwartz masters only."</span>)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 一个(非常强大)的实例级别的权限:</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(currentUser.isPermitted<span class="params">(<span class="string">"winnebago:drive:eagle5"</span>)</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'. "</span></span><br><span class="line">            + <span class="string">"Here are the keys - have fun!"</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"Sorry, you aren't allowed to drive the 'eagle5' winnebago!"</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6、完成 - 退出t!</span></span><br><span class="line">currentUser.logout<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>shiro.ini文件：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Users and their (optional) assigned roles</span></span><br><span class="line"><span class="comment"># username = password, role1, role2, ..., roleN</span></span><br><span class="line">[users]</span><br><span class="line"><span class="constant">root</span> = secret, admin</span><br><span class="line"><span class="constant">guest</span> = guest, guest</span><br><span class="line"><span class="constant">presidentskroob</span> = 12345, president</span><br><span class="line"><span class="constant">darkhelmet</span> = ludicrousspeed, darklord, schwartz</span><br><span class="line"><span class="constant">lonestarr</span> = vespa, goodguy, schwartz</span><br><span class="line"><span class="comment"># Roles with assigned permissions</span></span><br><span class="line"><span class="comment"># roleName = perm1, perm2, ..., permN</span></span><br><span class="line">[roles]</span><br><span class="line"><span class="constant">admin</span> = *</span><br><span class="line"><span class="constant">schwartz</span> = lightsaber:*</span><br><span class="line"><span class="constant">goodguy</span> = winnebago:drive:eagle5</span><br></pre></td></tr></table></figure></p>
<p>身份验证的主要流程就是：</p>
<ol>
<li>收集用户身份/凭证，即如用户名/密码；</li>
<li>调用 Subject.login 进行登录，如果失败将得到相应的 AuthenticationException 异常，根<br>据异常提示用户错误信息；否则登录成功；</li>
<li>最后调用 Subject.logout 进行退出操作。</li>
</ol>
<p><strong>收集实体/凭据信息</strong> </p>
<p>UsernamePasswordToken支持最常见的用户名/密码的认证机制。同时，由于它实现了RememberMeAuthenticationToken接口，我们可以通过令牌设置“记住我”的功能。但是，“已记住”和“已认证”是有区别的：已记住的用户仅仅是非匿名用户，你可以通过subject.getPrincipals()获取用户信息。但是它并非是完全认证通过的用户，当你访问需要认证用户的功能时，你仍然需要重新提交认证信息。这一区别可以参考亚马逊网站，网站会默认记住登录的用户，再次访问网站时，对于非敏感的页面功能，页面上会显示记住的用户信息，但是当你访问网站账户信息时仍然需要再次进行登录认证。 subject.isAuthenticated()和subject.isRemembered()的值总是相反的。</p>
<p><strong>提交实体/凭据信息</strong> </p>
<p>收集了实体/凭据信息之后，我们可以通过SecurityUtils工具类，获取当前的用户，然后通过调用login方法提交认证。 </p>
<p><strong>认证处理</strong> </p>
<p>如果login方法执行完毕且没有抛出任何异常信息，那么便认为用户认证通过。之后在应用程序任意地方调用SecurityUtils.getSubject() 都可以获取到当前认证通过的用户实例，使用subject.isAuthenticated()判断用户是否已验证都将返回true. 相反，如果login方法执行过程中抛出异常，那么将认为认证失败。Shiro有着丰富的层次鲜明的异常类来描述认证失败的原因，如代码示例。 </p>
<p><strong>登出操作</strong> </p>
<p>登出操作可以通过调用subject.logout()来删除你的登录信息，当执行完登出操作后，Session信息将被清空，subject将被视作为匿名用户。 </p>
<p>以上，是Shiro认证在应用程序中的处理过程，下面将详细解说Shiro认证的内部处理机制。 </p>
<p><img src="http://fh-1.qiniudn.com/shiro/shiro-authentication.png" alt="身份认证流程"></p>
<p>如上图，我们通过Shiro架构图的认证部分，来说明Shiro认证内部的处理顺序： </p>
<ol>
<li>应用程序构建了一个终端用户认证信息的AuthenticationToken 实例后，调用Subject.login方法。 </li>
<li>Subject的实例通常是DelegatingSubject类（或子类）的实例对象，在认证开始时，会委托应用程序设置的securityManager实例调用securityManager.login(token)方法。 </li>
<li>SecurityManager接受到token(令牌)信息后会委托内置的Authenticator的实例（通常都是ModularRealmAuthenticator类的实例）调用authenticator.authenticate(token). ModularRealmAuthenticator在认证过程中会对设置的一个或多个Realm实例进行适配，它实际上为Shiro提供了一个可拔插的认证机制。</li>
<li>如果在应用程序中配置了多个Realm，ModularRealmAuthenticator会根据配置的AuthenticationStrategy(认证策略)来进行多Realm的认证过程。在Realm被调用后，AuthenticationStrategy将对每一个Realm的结果作出响应。注：如果应用程序中仅配置了一个Realm，Realm将被直接调用而无需再配置认证策略。</li>
<li>判断每一个Realm是否支持提交的token，如果支持，Realm将调用getAuthenticationInfo(token); getAuthenticationInfo 方法就是实际认证处理，我们通过覆盖Realm的doGetAuthenticationInfo方法来编写我们自定义的认证处理。 </li>
</ol>
<p>Realm接口中需要实现的方法。</p>
<p>String getName(); //返回一个唯一的 Realm 名字<br>boolean supports(AuthenticationToken token); //判断此 Realm 是否支持此 Token<br>AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException; //根据 Token 获取认证信息</p>
<p><img src="http://fh-1.qiniudn.com/shiro/shiro-realm.png" alt="Realm"></p>
<p>一般继承AuthorizingRealm即可，需要实现getAuthenticationInfo(AuthenticationToken token)和doGetAuthenticationInfo(PrincipalCollection principals)两个方法</p>
<p>其中主要默认实现如下：<br>org.apache.shiro.realm.text.IniRealm：[users]部分指定用户名/密码及其角色；[roles]部分指定角色即权限信息；<br>org.apache.shiro.realm.text.PropertiesRealm：user.username=password,role1,role2 指定用户名/密码及其角色；role.role1=permission1,permission2 指定角色及权限信息；<br>org.apache.shiro.realm.jdbc.JdbcRealm：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line">jdbcRealm=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.realm</span><span class="class">.jdbc</span><span class="class">.JdbcRealm</span></span><br><span class="line">dataSource=com<span class="class">.alibaba</span><span class="class">.druid</span><span class="class">.pool</span><span class="class">.DruidDataSource</span></span><br><span class="line">dataSource.driverClassName=com<span class="class">.mysql</span><span class="class">.jdbc</span><span class="class">.Driver</span></span><br><span class="line">dataSource.url=jdbc:mysql:<span class="comment">//localhost:3306/shiro</span></span><br><span class="line">dataSource.username=root</span><br><span class="line"><span class="id">#dataSource</span>.password=</span><br><span class="line">jdbcRealm.dataSource=<span class="variable">$dataSource</span></span><br><span class="line">securityManager.realms=<span class="variable">$jdbcRealm</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用多个Realm的处理机制：">使用多个Realm的处理机制：</h3><p>有些网站既可以用用户名也可以用邮箱、手机登陆，通过多个Realm就可以实现。</p>
<h4 id="Authenticator">Authenticator</h4><p>默认实现是ModularRealmAuthenticator,它既支持单一Realm也支持多个Realm。如果仅配置了一个Realm，ModularRealmAuthenticator 会直接调用该Realm处理认证信息，如果配置了多个Realm，它会根据认证策略来适配Realm，找到合适的Realm执行认证信息。 </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main]  </span><br><span class="line">#指定 securityManager 的 authenticator 实现</span><br><span class="line">authenticator=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.authc</span><span class="class">.pam</span><span class="class">.ModularRealmAuthenticator</span></span><br><span class="line">securityManager.authenticator=<span class="variable">$authenticator</span></span><br></pre></td></tr></table></figure>
<h4 id="AuthenticationStrategy（认证策略）">AuthenticationStrategy（认证策略）</h4><p>当应用程序配置了多个Realm时，ModularRealmAuthenticator将根据认证策略来判断认证成功或是失败。<br>例如，如果只有一个Realm验证成功，而其他Realm验证失败，那么这次认证是否成功呢？如果大多数的Realm验证成功了，认证是否就认为成功呢？或者，一个Realm验证成功后，是否还需要判断其他Realm的结果？认证策略就是根据应用程序的需要对这些问题作出决断。 </p>
<p>认证策略是一个无状态的组件，在认证过程中会经过4次的调用： </p>
<ul>
<li>在所有Realm被调用之前</li>
<li>在调用Realm的getAuthenticationInfo 方法之前</li>
<li>在调用Realm的getAuthenticationInfo 方法之后</li>
<li>在所有Realm被调用之后</li>
</ul>
<p>认证策略的另外一项工作就是聚合所有Realm的结果信息封装至一个AuthenticationInfo实例中，并将此信息返回，以此作为Subject的身份信息。 </p>
<p>Shiro有3中认证策略的具体实现： </p>
<ul>
<li>AtLeastOneSuccessfulStrategy    只要有一个（或更多）的Realm验证成功，那么认证将被视为成功</li>
<li>FirstSuccessfulStrategy    第一个Realm验证成功，整体认证将被视为成功，且后续Realm将被忽略</li>
<li>AllSuccessfulStrategy    所有Realm成功，认证才视为成功</li>
</ul>
<p>ModularRealmAuthenticator 内置的认证策略默认实现是AtLeastOneSuccessfulStrategy 方式，因为这种方式也是被广泛使用的一种认证策略。当然，你也可以通过配置文件定义你需要的策略，如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[main]  </span><br><span class="line">authcStrategy = org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.authc</span><span class="class">.pam</span><span class="class">.FirstSuccessfulStrategy</span>  </span><br><span class="line">securityManager<span class="class">.authenticator</span><span class="class">.authenticationStrategy</span> = <span class="variable">$authcStrategy</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Realm的顺序">Realm的顺序</h4><p>由刚才提到的认证策略，可以看到Realm在ModularRealmAuthenticator 里面的顺序对认证是有影响的。 </p>
<p>ModularRealmAuthenticator 会读取配置在SecurityManager里的Realm。当执行认证是，它会遍历Realm集合，对所有支持提交的token的Realm调用getAuthenticationInfo 。 </p>
<p>因此，如果Realm的顺序对你使用的认证策略结果有影响，那么你应该在配置文件中明确定义Realm的顺序</p>
<h2 id="授权">授权</h2><p>授权即访问控制，它将判断用户在应用程序中对资源是否拥有相应的访问权限。<br>如，判断一个用户有查看页面的权限，编辑数据的权限，拥有某一按钮的权限，以及是否拥有打印的权限等等。 </p>
<h3 id="授权的三要素">授权的三要素</h3><p>授权有着三个核心元素：权限(permissions)、角色(roles)和用户(users)。 </p>
<p>权限 </p>
<p>权限是Apache Shiro安全机制最核心的元素。它在应用程序中明确声明了被允许的行为和表现。一个格式良好的权限声明可以清晰表达出用户对该资源拥有的权限。</p>
<p>大多数的资源会支持典型的CRUD操作（create,read,update,delete）,但是任何操作建立在特定的资源上才是有意义的。因此，权限声明的根本思想就是建立在资源以及操作上。 </p>
<p>而我们通过权限声明仅仅能了解这个权限可以在应用程序中做些什么，而不能确定谁拥有此权限。权限只描述行为。</p>
<p>于是，我们就需要在应用程序中对用户和权限建立关联。通常的做法就是将权限分配给某个角色，然后将这个角色关联一个或多个用户。 </p>
<p><strong>权限声明及粒度</strong> </p>
<p>Shiro权限声明通常是使用以冒号分隔的表达式。就像前文所讲，一个权限表达式可以清晰的指定资源类型，允许的操作，可访问的数据。同时，Shiro权限表达式支持简单的通配符，可以更加灵活的进行权限设置。 </p>
<p>字符串通配符权限<br>规则：“资源标识符：操作：对象实例 ID” 即对哪个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，<code>:</code>表示资源/操作/实例的分割；<code>,</code>表示操作的分割；<code>*</code>表示任意资源/操作/实例。</p>
<p>下面以实例来说明权限表达式。<br>可查询用户数据 <code>User:view</code><br>可查询或编辑用户数据 <code>User:view,edit</code><br>可对用户数据进行所有操作 <code>User:* 或 user</code><br>可编辑id为123的用户数据 <code>User:edit:123</code></p>
<p>注意：通过“system:user:update,delete”验证“system:user:update, system:user:delete”是没问题的，但是反过来是规则不成立。</p>
<h3 id="角色">角色</h3><p>Shiro支持两种角色模式： </p>
<ol>
<li>传统角色：一个角色代表着一系列的操作，当需要对某一操作进行授权验证时，只需判断是否是该角色即可。这种角色权限相对简单、模糊，不利于扩展。 </li>
<li>权限角色：一个角色拥有一个权限的集合。授权验证时，需要判断当前角色是否拥有该权限。这种角色权限可以对该角色进行详细的权限描述，适合更复杂的权限设计。 </li>
</ol>
<p><a href="www.waylau.com/new-rbac-resource-based-access-control/">新的RBAC：基于资源的权限管理(Resource-Based Access Control)</a></p>
<h3 id="用户">用户</h3><p>一个用户本质上是程序中的“谁”，如同我们前面提到的，Subject 实际上是 shiro 的“用户”。</p>
<p>用户（Subjects）通过与角色或权限关联确定是否被允许执行程序内特定的动作，程序数据模型确切定义了 Subject 是否允许做什么事情。Shiro 依赖一个 Realm 实现将你的数据模型关联转换成 Shiro 可以理解的内容</p>
<h3 id="授权实现">授权实现</h3><p>Shiro支持三种方式实现授权过程： </p>
<ul>
<li>编码实现：if(subject.hasRole(“admin”)){//有权限}</li>
<li>注解实现：@RequiresRoles(“admin”)public void hello() {//有权限}</li>
<li>JSP Taglig实现：<code>&lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;!— 有权限 —&gt;&lt;/shiro:hasRole&gt;</code></li>
</ul>
<h4 id="基于编码的授权实现">基于编码的授权实现</h4><p><strong>基于传统角色授权实现</strong></p>
<p>当需要验证用户是否拥有某个角色时，可以调用Subject 实例的<code>hasRole*</code>方法验证。 </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;  </span><br><span class="line"><span class="keyword">if</span> <span class="params">(currentUser.hasRole<span class="params">(<span class="string">"administrator"</span>)</span>)</span> &#123;  </span><br><span class="line">    <span class="comment">//显示 admin 按钮</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">//不显示按钮?  灰色吗？ </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关验证方法如下： </p>
<table>
<thead>
<tr>
<th>Subject方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hasRole(String roleName)</code></td>
<td>当用户拥有指定角色时，返回true</td>
</tr>
<tr>
<td><code>hasRoles(List&lt;String&gt; roleNames)</code></td>
<td>按照列表顺序返回相应的一个boolean值数组</td>
</tr>
<tr>
<td><code>hasAllRoles(Collection&lt;String&gt; roleNames)</code></td>
<td>如果用户拥有所有指定角色时，返回true</td>
</tr>
</tbody>
</table>
<p>断言支持 </p>
<p>Shiro还支持以断言的方式进行授权验证。断言成功，不返回任何值，程序继续执行；断言失败时，将抛出异常信息。使用断言，可以使我们的代码更加简洁。 </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;  </span><br><span class="line"><span class="comment">//保证当前用户是一个银行出纳员</span></span><br><span class="line"><span class="comment">//因此允许开立帐户：</span></span><br><span class="line">currentUser.checkRole<span class="params">(<span class="string">"bankTeller"</span>)</span>;  </span><br><span class="line">openBankAccount<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>断言的相关方法： </p>
<table>
<thead>
<tr>
<th>Subject方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>checkRole(String roleName)</code></td>
<td>断言用户是否拥有指定角色</td>
</tr>
<tr>
<td><code>checkRoles(Collection&lt;String&gt; roleNames)</code></td>
<td>断言用户是否拥有所有指定角色</td>
</tr>
<tr>
<td><code>checkRoles(String... roleNames)</code></td>
<td>对上一方法的方法重载</td>
</tr>
</tbody>
</table>
<p><strong>基于权限角色授权实现</strong> </p>
<p>相比传统角色模式，基于权限的角色模式耦合性要更低些，它不会因角色的改变而对源代码进行修改，因此，基于权限的角色模式是更好的访问控制方式。 </p>
<p>它的代码实现有以下几种实现方式： </p>
<p><strong>基于权限对象的实现</strong> </p>
<p>创建org.apache.shiro.authz.Permission的实例，将该实例对象作为参数传递给Subject.isPermitted()进行验证。 </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Permission printPermission = new PrinterPermission<span class="params">(<span class="string">"laserjet4400n"</span>, <span class="string">"print"</span>)</span>;</span><br><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(currentUser.isPermitted<span class="params">(printPermission)</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//显示 打印 按钮</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不显示按钮?  灰色吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关方法如下： </p>
<table>
<thead>
<tr>
<th>Subject方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isPermitted(Permission p)</code></td>
<td>Subject拥有制定权限时，返回treu</td>
</tr>
<tr>
<td><code>isPermitted(List&lt;Permission&gt; perms)</code></td>
<td>返回对应权限的boolean数组</td>
</tr>
<tr>
<td><code>isPermittedAll(Collection&lt;Permission&gt; perms)</code></td>
<td>Subject拥有所有制定权限时，返回true</td>
</tr>
</tbody>
</table>
<p><strong>基于字符串的实现</strong> </p>
<p>相比笨重的基于对象的实现方式，基于字符串的实现便显得更加简洁。 </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(currentUser.isPermitted<span class="params">(<span class="string">"printer:print:laserjet4400n"</span>)</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//显示 打印 按钮</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不显示按钮?  灰色吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用冒号分隔的权限表达式是org.apache.shiro.authz.permission.WildcardPermission 默认支持的实现方式。 </p>
<p>这里分别代表了 资源类型:操作:资源ID </p>
<p>类似基于对象的实现相关方法</p>
<table>
<thead>
<tr>
<th>Subject 方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>isPermitted(String perm)</td>
<td>如果Subject被允许执行字符串表达的动作或资源访问权限，返回真，否则返回假；</td>
</tr>
<tr>
<td>isPermitted(String… perms)</td>
<td>按照参数顺序返回isPermitted的结果数组，当许多字符串权限需要检查时非常有用（如定制一个复杂的视图时）；</td>
</tr>
<tr>
<td>isPermittedAll(String… perms)</td>
<td>当Subject具备所有字符串定义的权限时返回真，否则返回假。</td>
</tr>
</tbody>
</table>
<p><strong>基于权限对象的断言实现</strong> </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;</span><br><span class="line"><span class="comment">//担保允许当前用户</span></span><br><span class="line"><span class="comment">//开一个银行帐户：</span></span><br><span class="line">Permission p = new AccountPermission<span class="params">(<span class="string">"open"</span>)</span>;</span><br><span class="line">currentUser.checkPermission<span class="params">(p)</span>;</span><br><span class="line">openBankAccount<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><strong>基于字符串的断言实现</strong> </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;</span><br><span class="line"><span class="comment">//担保允许当前用户</span></span><br><span class="line"><span class="comment">//开一个银行帐户：</span></span><br><span class="line">currentUser.checkPermission<span class="params">(<span class="string">"account:open"</span>)</span>;</span><br><span class="line">openBankAccount<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><strong>断言实现的相关方法</strong> </p>
<table>
<thead>
<tr>
<th>Subject方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>checkPermission(Permission p)</code></td>
<td>断言用户是否拥有制定权限</td>
</tr>
<tr>
<td><code>checkPermission(String perm)</code></td>
<td>断言用户是否拥有制定权限</td>
</tr>
<tr>
<td><code>checkPermissions(Collection&lt;Permission&gt; perms)</code></td>
<td>断言用户是否拥有所有指定权限</td>
</tr>
<tr>
<td><code>checkPermissions(String... perms)</code></td>
<td>断言用户是否拥有所有指定权限</td>
</tr>
</tbody>
</table>
<h4 id="基于注解的授权实现">基于注解的授权实现</h4><p>Shiro注解支持AspectJ、Spring、Google-Guice等，可根据应用进行不同的配置。 </p>
<p>相关的注解：<br>@RequiresAuthentication<br>可以用户类/属性/方法，用于表明当前用户需是经过认证的用户。 </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RequiresAuthentication</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account userAccount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个方法只会被调用在</span></span><br><span class="line">    <span class="comment">//Subject 保证被认证的情况下</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于判断了SecurityUtils.getSubject().isAuthenticated()</p>
<p>@RequiresGuest<br>表明该用户需为”guest”用户 </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RequiresGuest</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">signUp</span><span class="params">(User newUser)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个方法只会被调用在</span></span><br><span class="line">    <span class="comment">//Subject 未知/匿名的情况下</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于判断了principals == null || principals.isEmpty()</p>
<p>@RequiresPermissions<br>当前用户需拥指定权限 </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RequiresPermissions</span>(<span class="string">"account:create"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">createAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个方法只会被调用在</span></span><br><span class="line">    <span class="comment">//Subject 允许创建一个 account 的情况下</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于判断了subject.isPermitted(“account:create”)</p>
<p>@RequiresRoles<br>当前用户需拥有指定角色<br>相当于判断了subject.hasRole(“administrator”)</p>
<p>@RequiresUser<br>当前用户需为已认证用户或已记住用户 </p>
<h4 id="基于JSP_TAG的授权实现">基于JSP TAG的授权实现</h4><p>Shiro提供了一套JSP标签库来实现页面级的授权控制。标签库描述文件 (TLD)被打包在 META-INF/shiro.tld 文件中的 shiro-web.jar 文件中。 </p>
<p>在使用Shiro标签库前，首先需要在JSP引入shiro标签： </p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">%</span>@ taglib prefix=<span class="string">"shiro"</span> uri=<span class="string">"http://shiro.apache.org/tags"</span> <span class="preprocessor">%</span>&gt;</span><br></pre></td></tr></table></figure>
<p>下面一一介绍Shiro的标签： </p>
<p>guest标签:验证当前用户是否为“访客”，即未认证（包含未记住）的用户<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">shiro:guest</span>&gt;</span>  </span><br><span class="line">    Hi there!  Please <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"login.jsp"</span>&gt;</span>Login<span class="tag">&lt;/<span class="title">a</span>&gt;</span> or <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"signup.jsp"</span>&gt;</span>Signup<span class="tag">&lt;/<span class="title">a</span>&gt;</span> today!  </span><br><span class="line"><span class="tag">&lt;/<span class="title">shiro:guest</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>user标签:认证通过或已记住的用户<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">shiro:user</span>&gt;</span>  </span><br><span class="line">    Welcome back John!  Not John? Click <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"login.jsp"</span>&gt;</span>here<span class="tag">&lt;<span class="title">a</span>&gt;</span> to login.  </span><br><span class="line"><span class="tag">&lt;/<span class="title">shiro:user</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>authenticated标签:已认证通过的用户。不包含已记住的用户，这是与user标签的区别所在。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">shiro:authenticated</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"updateAccount.jsp"</span>&gt;</span>Update your contact information<span class="tag">&lt;/<span class="title">a</span>&gt;</span>.  </span><br><span class="line"><span class="tag">&lt;/<span class="title">shiro:authenticated</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>notAuthenticated标签:未认证通过用户，与authenticated标签相对应。与guest标签的区别是，该标签包含已记住用户。<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;shiro:notAuthenticated&gt;</span>  </span><br><span class="line">    Please <span class="variable">&lt;a href="login.jsp"&gt;</span>login<span class="variable">&lt;/a&gt;</span> <span class="keyword">in</span> order <span class="keyword">to</span> update your credit card information.  </span><br><span class="line"><span class="variable">&lt;/shiro:notAuthenticated&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>principal 标签:输出当前用户信息，通常为登录帐号信息<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, <span class="tag">&lt;<span class="title">shiro:principal</span>/&gt;</span>, how are you today?</span><br></pre></td></tr></table></figure></p>
<p>principal property<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, &lt;shiro:principal <span class="class"><span class="keyword">type</span></span>=<span class="string">"com.foo.User"</span> property=<span class="string">"firstName"</span>/&gt;, how are you today?</span><br></pre></td></tr></table></figure></p>
<p>很大程度上等价于<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hello</span>, &lt;%= <span class="type">SecurityUtils</span>.getSubject<span class="literal">()</span>.getPrincipals<span class="literal">()</span>.oneByType(com.foo.<span class="type">User</span>.<span class="keyword">class</span>).getFirstName<span class="literal">()</span>.toString<span class="literal">()</span> %&gt;, how are you today?</span><br></pre></td></tr></table></figure></p>
<p>hasRole标签:验证当前用户是否属于该角色<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">shiro:hasRole</span> <span class="attribute">name</span>=<span class="value">"administrator"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"admin.jsp"</span>&gt;</span>Administer the system<span class="tag">&lt;/<span class="title">a</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">shiro:hasRole</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>lacksRole标签:与hasRole标签逻辑相反，当用户不属于该角色时验证通过<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:lacksRole name=<span class="string">"administrator"</span>&gt;  </span><br><span class="line">    Sorry, you are <span class="operator">not</span> allowed <span class="built_in">to</span> administer <span class="operator">the</span> <span class="keyword">system</span>.  </span><br><span class="line">&lt;/shiro:lacksRole&gt;</span><br></pre></td></tr></table></figure></p>
<p>hasAnyRole标签:验证当前用户是否属于以下任意一个角色。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasAnyRoles <span class="property">name</span>=<span class="string">"developer, project manager, administrator"</span>&gt;  </span><br><span class="line">    You are either a developer, project manager, <span class="keyword">or</span> administrator.  </span><br><span class="line">&lt;/shiro:lacksRole&gt;</span><br></pre></td></tr></table></figure></p>
<p>hasPermission标签:验证当前用户是否拥有制定权限<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">shiro:hasPermission</span> <span class="attribute">name</span>=<span class="value">"user:create"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"createUser.jsp"</span>&gt;</span>Create a new User<span class="tag">&lt;/<span class="title">a</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>lacksPermission标签:与hasPermission标签逻辑相反，当前用户没有制定权限时，验证通过<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">shiro:hasPermission</span> <span class="attribute">name</span>=<span class="value">"user:create"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"createUser.jsp"</span>&gt;</span>Create a new User<span class="tag">&lt;/<span class="title">a</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="授权流程">授权流程</h3><p><img src="http://fh-1.qiniudn.com/shiro/Shiro-AuthorizationSequence.png" alt="授权流程"></p>
<ol>
<li>程序或框架代码调用一个 Subject 的<code>hasRole*</code>、<code>checkRole*</code>、<code>isPermitted*</code>或者<code>checkPermission*</code>方法，传递所需的权限或角色。</li>
<li>Subject实例，通常是一个 DelegatingSubject（或子类），通过调用securityManager 与各 <code>hasRole*</code>、<code>checkRole*</code>、<code>isPermitted*</code>或<code>checkPermission*</code> 基本一致的方法将权限或角色传递给程序的 SecurityManager(实现了 org.apache.shiro.authz.Authorizer 接口)。 </li>
<li>接下来SecurityManager会委托内置的Authorizer的实例（默认是ModularRealmAuthorizer 类的实例，类似认证实例，它同样支持一个或多个Realm实例认证）调用相应的授权方法。 </li>
<li>每一个Realm将检查是否实现了相同的 Authorizer 接口。然后，将调用Reaml自己的相应的授权验证方法。 </li>
</ol>
<p>当使用多个Realm时，不同于认证策略处理方式，授权处理过程中： </p>
<ol>
<li>当Realm实现了Authorizer接口<ol>
<li>当调用Realm出现异常时，将立即抛出异常，结束授权验证。 </li>
<li>只要有一个Realm验证成功，那么将认为授权成功，立即返回，结束认证。 </li>
</ol>
</li>
<li>如果 Realm 没有实现 Authorizer 接口，将被忽略。</li>
</ol>
<p><strong>授权顺序</strong></p>
<p>ModularRealmAuthorizer 拥有 SecurityManager 配置的 Realm 实例的入口，当执行一个授权操作时，它将在整个集合中进行迭代（iteration），对于每一个实现 Authorizer 接口的 Realm，调用Realm 各自的 Authorizer 方法（如 hasRole、 checkRole、 isPermitted或 checkPermission）。</p>
<p><strong>配置全局的 PermissionResolver</strong></p>
<p>当执行一个基于字符串的权限检查时，大部分 Shiro 默认的 Realm 将会在执行权限隐含逻辑之前首先把这个字符串转换成一个常用的权限实例。</p>
<p>为了这个转换目的，Shiro 支持 PermissionResolver，大部分 Shiro Realm 使用 PermissionResolver 来支持它们对Authorizer 接口中基于字符串权限方法的实现：当这些方法在Realm上被调用时，将使用PermissionResolver 将字符串转换为权限实例，并执行检查。默认使用内部的 WildcardPermissionResolver</p>
<h2 id="Realms">Realms</h2><p>在认证、授权内部实现机制中都有提到，最终处理都将交给Realm进行处理。因为在Shiro中，最终是通过Realm来获取应用程序中的用户、角色及权限信息的。通常情况下，在Realm中会直接从我们的数据源中获取Shiro需要的验证信息。可以说，Realm是专用于安全框架的DAO. </p>
<h3 id="认证实现">认证实现</h3><p>正如前文所提到的，Shiro的认证过程最终会交由Realm执行，这时会调用Realm的getAuthenticationInfo(token)方法。在一个 Realm 执行一个验证尝试之前，它的supports)方法被调用。只有在返回值为 true 的时候它的getAuthenticationInfo(token) 方法才会执行。因此想要禁用认证过程主要supports始终返回false即可。 </p>
<p>该方法主要执行以下操作: </p>
<ol>
<li>检查提交的进行认证的令牌信息 </li>
<li>根据令牌信息从数据源(通常为数据库)中获取用户信息 </li>
<li>确定令牌支持的 credentials (凭证数据)和存储的数据相符。 </li>
<li>验证通过将返回一个封装了用户信息的AuthenticationInfo实例。 </li>
<li>验证失败则抛出AuthenticationException异常信息。 </li>
</ol>
<p>而在我们的应用程序中要做的就是自定义一个Realm类，继承AuthorizingRealm抽象类，重载doGetAuthenticationInfo()，重写获取用户信息的方法。 </p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) throws AuthenticationException &#123;  </span><br><span class="line">    <span class="built_in">String</span> username <span class="subst">=</span> (<span class="built_in">String</span>)token<span class="built_in">.</span>getPrincipal();</span><br><span class="line">    User user <span class="subst">=</span> userService<span class="built_in">.</span>findByUsername(username);</span><br><span class="line">    <span class="keyword">if</span>(user <span class="subst">==</span> <span class="built_in">null</span>) &#123;</span><br><span class="line">        throw <span class="literal">new</span> UnknownAccountException();<span class="comment">//没找到帐号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Boolean</span><span class="built_in">.</span><span class="literal">TRUE</span><span class="built_in">.</span><span class="keyword">equals</span>(user<span class="built_in">.</span>getLocked())) &#123;</span><br><span class="line">        throw <span class="literal">new</span> LockedAccountException(); <span class="comment">//帐号锁定</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配，如果觉得人家的不好可以自定义实现</span></span><br><span class="line">    SimpleAuthenticationInfo authenticationInfo <span class="subst">=</span> <span class="literal">new</span> SimpleAuthenticationInfo(</span><br><span class="line">            user<span class="built_in">.</span>getUsername(), <span class="comment">//用户名</span></span><br><span class="line">            user<span class="built_in">.</span>getPassword(), <span class="comment">//密码</span></span><br><span class="line">            ByteSource<span class="built_in">.</span>Util<span class="built_in">.</span><span class="built_in">bytes</span>(user<span class="built_in">.</span>getCredentialsSalt()),<span class="comment">//salt=username+salt</span></span><br><span class="line">            getName()  <span class="comment">//realm name</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>凭证匹配</strong></p>
<p>在上述 realm 认证工作流中，一个 Realm 必须较验 Subject 提交的凭证（如密码）是否与存储在数据中的凭证相匹配，如果匹配，验证成功，系统保留已认证的终端用户身份。</p>
<p>AuthenticatingRealm 以及它的子类支持用 CredentialsMatcher 来执行一个凭证对比。</p>
<p>在找到用户数据之后，它和提交的 AuthenticationToken 一起传递给一个 CredentialsMatcher ，后者用来检查提交的数据和存储的数据是否相匹配。Shiro某些 CredentialsMatcher 实现可以使你开箱即用，比如 SimpleCredentialsMatcher(直接比较明文) 和 HashedCredentialsMatcher(可以指定hash策略) 实现</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Realm</span> myRealm = <span class="keyword">new</span> com.company.shiro.realm.<span class="type">MyRealm</span><span class="literal">()</span>;</span><br><span class="line"><span class="type">CredentialsMatcher</span> customMatcher = <span class="keyword">new</span> com.company.shiro.realm.<span class="type">CustomCredentialsMatcher</span><span class="literal">()</span>;</span><br><span class="line">myRealm.setCredentialsMatcher(customMatcher);</span><br></pre></td></tr></table></figure>
<h3 id="授权实现-1">授权实现</h3><p>而授权实现则与认证实现非常相似，在我们自定义的Realm中，重载doGetAuthorizationInfo()方法，重写获取用户权限的方法即可。 </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected AuthorizationInfo doGetAuthorizationInfo<span class="params">(PrincipalCollection principals)</span>&#123;  </span><br><span class="line">    String username = <span class="params">(String)</span>principals.getPrimaryPrincipal<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo<span class="params">()</span>;</span><br><span class="line">    authorizationInfo.setRoles<span class="params">(userService.findRoles<span class="params">(username)</span>)</span>;</span><br><span class="line">    authorizationInfo.setStringPermissions<span class="params">(userService.findPermissions<span class="params">(username)</span>)</span>;</span><br><span class="line">    return authorizationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="会话管理">会话管理</h2><p>Shiro 提供了完整的企业级会话管理功能，不依赖于底层容器（如 web 容器 tomcat），不管JavaSE 还是 JavaEE 环境都可以使用，提供了会话管理、会话事件监听、会话存储/持久化、容器无关的集群、失效/过期支持、对 Web 的透明支持、SSO 单点登录的支持等特性。</p>
<h3 id="会话">　会话</h3><p>登录成功后使用 Subject.getSession()即可获取会话；其等价于 Subject.getSession(true)，即如果当前没有创建 Session 对象会创建一个；另外 Subject.getSession(false)，如果当前没有创建 Session 则返回 null</p>
<ul>
<li>session.getId(); //获取会话唯一标识</li>
<li>session.getHost(); //获取 Subject的主机地址,该地址是通过 HostAuthenticationToken.getHost()提供的</li>
<li>session.getTimeout(); //获取过期时间</li>
<li>session.setTimeout(毫秒); //设置会话过期时间</li>
<li>session.getStartTimestamp(); //获取会话启动时间</li>
<li>session.getLastAccessTime(); //获取最后访问时间</li>
<li>session.touch(); //更新最后访问时间</li>
<li>session.stop(); //销毁会话。</li>
<li>session.setAttribute(“key”, “123”); //设置session属性</li>
<li>session.getAttribute(“key”));  //获取session属性</li>
<li>session.removeAttribute(“key”);  //删除会话属性</li>
</ul>
<h3 id="会话管理器">会话管理器</h3><p>SessionManager，名如其意，在应用程序中为所有的 subject 管理Session —— 创建，删除，失效及验证，等等。如同其他在Shiro 中的核心结构组件一样，SessionManager 也是一个由 SecurityManager 维护的顶级组件。</p>
<ul>
<li>Session start(SessionContext context); //启动会话</li>
<li>Session getSession(SessionKey key) throws SessionException; //根据会话 Key 获取会话</li>
</ul>
<p>Shiro 提供了三个默认实现：</p>
<ul>
<li>DefaultSessionManager：DefaultSecurityManager 使用的默认实现，用于 JavaSE 环境；</li>
<li>ServletContainerSessionManager：DefaultWebSecurityManager 使用的默认实现，用于Web环境，其直接使用 Servlet 容器的会话；</li>
<li>DefaultWebSessionManager：用于Web环境的实现，可以替代 ServletContainerSessionManager，自己维护着会话，直接废弃了 Servlet 容器的会话管理。</li>
</ul>
<p>另外可以设置会话的全局过期时间（毫秒为单位），默认 30 分钟：sessionManager. globalSessionTimeout=1800000<br>另外如果使用 ServletContainerSessionManager 进行会话管理，Session 的超时依赖于底层 Servlet 容器的超时时间，可以在 web.xml 中配置其会话的超时时间（分钟为单位）：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="title">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在 Servlet 容器中，默认使用 JSESSIONID Cookie 维护会话，且会话默认是跟容器绑定的；在某些情况下可能需要使用自己的会话机制， 此时我们可以使用 DefaultWebSessionManager来维护会话：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sessionIdCookie=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.web</span><span class="class">.servlet</span><span class="class">.SimpleCookie</span></span><br><span class="line">sessionManager=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.web</span><span class="class">.session</span><span class="class">.mgt</span><span class="class">.DefaultWebSessionManager</span></span><br><span class="line">sessionIdCookie.name=sid</span><br><span class="line"><span class="id">#sessionIdCookie</span>.domain=sishuok<span class="class">.com</span></span><br><span class="line"><span class="id">#sessionIdCookie</span>.path=</span><br><span class="line">sessionIdCookie.maxAge=<span class="number">1800</span></span><br><span class="line">sessionIdCookie.httpOnly=true</span><br><span class="line">sessionManager.sessionIdCookie=<span class="variable">$sessionIdCookie</span></span><br><span class="line">sessionManager.sessionIdCookieEnabled=true</span><br><span class="line">securityManager.sessionManager=<span class="variable">$sessionManager</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sessionIdCookie 是 sessionManager 创建会话 Cookie 的模板：</li>
<li>sessionIdCookie.name：设置 Cookie 名字，默认为 JSESSIONID；</li>
<li>sessionIdCookie.domain：设置 Cookie 的域名，默认空，即当前访问的域名；</li>
<li>sessionIdCookie.path：设置 Cookie 的路径，默认空，即存储在域名根下；</li>
<li>sessionIdCookie.maxAge：设置 Cookie 的过期时间，秒为单位，默认-1 表示关闭浏览器时过期 Cookie；</li>
<li>sessionIdCookie.httpOnly：如果设置为 true，则客户端不会暴露给客户端脚本代码，使用HttpOnly cookie有助于减少某些类型的跨站点脚本攻击； 此特性需要实现了 Servlet 2.5 MR6及以上版本的规范的 Servlet 容器支持；</li>
<li>sessionManager.sessionIdCookieEnabled：是否启用/禁用 Session Id Cookie，默认是启用的；如果禁用后将不会设置 Session Id Cookie，即默认使用了 Servlet 容器的 JSESSIONID，且通过 URL 重写（URL 中的“;JSESSIONID=id”部分）保存 Session Id。（这里设为false，url并没有重写，需要设置什么吗？)</li>
</ul>
<h3 id="会话监听器">会话监听器</h3><p>会话监听器用于监听会话创建、过期及停止事件。可以实现SessionListener中的onStart、onExpiration、onStop方法</p>
<h3 id="会话存储/持久化">会话存储/持久化</h3><p>Shiro 提供 SessionDAO 用于会话的 CRUD，即 DAO（Data Access Object）模式实现</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">- <span class="constant">SessionDAO</span></span><br><span class="line"></span>    -<span class="ruby">- <span class="constant">AbstractSessionDAO</span> </span><br><span class="line"></span>        -<span class="ruby">- <span class="constant">CachingSessionDAO</span></span><br><span class="line"></span>            -<span class="ruby">- <span class="constant">EnterpriseCacheSessionDAO</span></span><br><span class="line"></span>        -<span class="ruby">- <span class="constant">MemorySessionDAO</span></span></span><br></pre></td></tr></table></figure>
<p>AbstractSessionDAO提供了SessionDAO的基础实现，如生成会话 ID等；CachingSessionDAO 提供了对开发者透明的会话缓存的功能，只需要设置相应的 CacheManager 即可；MemorySessionDAO 直接在内存中进行会话维护；而 EnterpriseCacheSessionDAO 提供了缓存功能的会话维护，默认情况下使用 MapCache 实现，内部使用 ConcurrentHashMap 保存缓存的会话。</p>
<p>Shiro 提供了使用 Ehcache 进行会话存储，Ehcache 可以配合 TerraCotta 实现容器无关的分布式集群。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sessionDAO=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.session</span><span class="class">.mgt</span><span class="class">.eis</span><span class="class">.EnterpriseCacheSessionDAO</span></span><br><span class="line">sessionDAO. activeSessionsCacheName=shiro-activeSessionCache</span><br><span class="line">sessionManager.sessionDAO=<span class="variable">$sessionDAO</span></span><br><span class="line">cacheManager = org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.cache</span><span class="class">.ehcache</span><span class="class">.EhCacheManager</span></span><br><span class="line">cacheManager.cacheManagerConfigFile=classpath:ehcache<span class="class">.xml</span></span><br><span class="line">securityManager<span class="class">.cacheManager</span> = <span class="variable">$cacheManager</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sessionDAO. activeSessionsCacheName：设置Session 缓存名字，默认就是shiro-activeSessionCache；</li>
<li>cacheManager：缓存管理器，用于管理缓存的，此处使用 Ehcache 实现；</li>
<li>cacheManager.cacheManagerConfigFile：设置 ehcache 缓存的配置文件；</li>
<li>securityManager.cacheManager：设置 SecurityManager 的 cacheManager，会自动设置实现了CacheManagerAware 接口的相应对象，如 SessionDAO 的 cacheManager；</li>
</ul>
<p>ehcache.xml：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache <span class="variable">name=</span><span class="string">"shiro-activeSessionCache"</span></span><br><span class="line">    <span class="variable">maxEntriesLocalHeap=</span><span class="string">"10000"</span></span><br><span class="line">    <span class="variable">overflowToDisk=</span><span class="string">"false"</span></span><br><span class="line">    <span class="variable">eternal=</span><span class="string">"false"</span></span><br><span class="line">    <span class="variable">diskPersistent=</span><span class="string">"false"</span></span><br><span class="line">    <span class="variable">timeToLiveSeconds=</span><span class="string">"0"</span></span><br><span class="line">    <span class="variable">timeToIdleSeconds=</span><span class="string">"0"</span></span><br><span class="line">    <span class="variable">statistics=</span><span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Cache 的名字为 shiro-activeSessionCache，即设置的 sessionDAO 的 activeSessionsCacheName 属性值。</p>
<p>用于生成会话 ID，默认就是 JavaUuidSessionIdGenerator，使用 java.util.UUID 生成。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionIdGenerator=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.session</span><span class="class">.mgt</span><span class="class">.eis</span><span class="class">.JavaUuidSessionIdGenerator</span></span><br><span class="line">sessionDAO.sessionIdGenerator=<span class="variable">$sessionIdGenerator</span></span><br></pre></td></tr></table></figure></p>
<h3 id="会话验证">会话验证</h3><p>Shiro 提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话；出于性能考虑，一般情况下都是获取会话时来验证会话是否过期并停止会话的；但是如在 web环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro 提供了会话验证调度器 SessionValidationScheduler 来做这件事情。</p>
<p>可以通过如下 ini 配置开启会话验证：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sessionValidationScheduler=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.session</span><span class="class">.mgt</span><span class="class">.ExecutorServiceSessionValidationScheduler</span></span><br><span class="line">sessionValidationScheduler<span class="class">.interval</span> = <span class="number">3600000</span></span><br><span class="line">sessionValidationScheduler.sessionManager=<span class="variable">$sessionManager</span></span><br><span class="line">sessionManager.globalSessionTimeout=<span class="number">1800000</span></span><br><span class="line">sessionManager.sessionValidationSchedulerEnabled=true</span><br><span class="line">sessionManager.sessionValidationScheduler=<span class="variable">$sessionValidationScheduler</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>sessionValidationScheduler：会话验证调度器，sessionManager 默认就是使用 ExecutorServiceSessionValidationScheduler， 其使用 JDK 的 ScheduledExecutorService 进行定期调度并验证会话是否过期；</li>
<li>sessionValidationScheduler.interval：设置调度时间间隔，单位毫秒，默认就是 1 小时；</li>
<li>sessionValidationScheduler.sessionManager：设置会话验证调度器进行会话验证时的会话管理器；</li>
<li>sessionManager.globalSessionTimeout：设置全局会话超时时间，默认 30 分钟，即如果 30 分钟内没有访问会话将过期；</li>
<li>sessionManager.sessionValidationSchedulerEnabled：是否开启会话验证器，默认是开启的；</li>
<li>sessionManager.sessionValidationScheduler：设置会话验证调度器，默认就是使用 ExecutorServiceSessionValidationScheduler。</li>
</ul>
<p>Shiro 也提供了使用 Quartz 会话验证调度器,使用时需要导入 shiro-quartz 依赖：</p>
<p>如上会话验证调度器实现都是直接调用 AbstractValidatingSessionManager 的 validateSessions 方法进行验证，其直接调用 SessionDAO 的 getActiveSessions 方法获取所有会话进行验证，如果会话比较多，会影响性能；可以考虑如分页获取会话并进行验证</p>
<p>如果在会话过期时不想删除过期的会话，可以通过如下 ini 配置进行设置：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionManager.<span class="variable">deleteInvalidSessions=</span><span class="constant">false</span></span><br></pre></td></tr></table></figure></p>
<p>会话工厂<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionFactory=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.session</span><span class="class">.mgt</span><span class="class">.OnlineSessionFactory</span></span><br><span class="line">sessionManager.sessionFactory=<span class="variable">$sessionFactory</span></span><br></pre></td></tr></table></figure></p>
<h2 id="编码/加密">编码/加密</h2><h3 id="编码/解码">编码/解码</h3><p>Shiro 内部的一些数据的存储/表示都使用了 base64 和 16 进制字符串。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="keyword">str </span>= <span class="string">"hello"</span><span class="comment">; </span></span><br><span class="line"><span class="keyword">String </span><span class="keyword">base64Encoded </span>= <span class="keyword">Base64.encodeToString(str.getBytes()); </span></span><br><span class="line"><span class="keyword">String </span><span class="keyword">str2 </span>= <span class="keyword">Base64.decodeToString(base64Encoded); </span></span><br><span class="line"><span class="label">Assert.assertEquals</span>(<span class="keyword">str, </span><span class="keyword">str2);</span></span><br></pre></td></tr></table></figure>
<p>还有一个可能经常用到的类 CodecSupport，提供了 toBytes(str,  “utf-8”)  /  toString(bytes, “utf-8”)用于在 byte 数组/String 之间转换。</p>
<h3 id="散列算法">散列算法</h3><p>散列算法一般用于生成数据的摘要信息，是一种不可逆的算法，一般适合存储密码之类的 数据，常见的散列算法如 MD5、SHA 等。一般进行散列时最好提供一个 salt（盐），因为md5解密网站很容易通过散列值得到密码。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"hello"</span>; </span><br><span class="line"><span class="keyword">String</span> salt = <span class="string">"123"</span>; </span><br><span class="line"><span class="keyword">String</span> md5 =<span class="keyword">new</span> Md5Hash(<span class="built_in">str</span>, salt, <span class="number">2</span>).toString();<span class="comment">//还可以转换为  toBase64()/toHex()  做两次hash</span></span><br></pre></td></tr></table></figure>
<p>除了Md5外还有Sha256/Sha1/Sha512</p>
<p>通用的散列支持<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"hello"</span>; </span><br><span class="line"><span class="keyword">String</span> salt = <span class="string">"123"</span>; </span><br><span class="line"><span class="comment">//内部使用Java的 MessageDigest </span></span><br><span class="line"><span class="keyword">String</span> simpleHash =<span class="keyword">new</span> SimpleHash(<span class="string">"SHA-1"</span>, <span class="built_in">str</span>, salt).toString();</span><br></pre></td></tr></table></figure></p>
<p>为了方便使用，Shiro 提供了 HashService，默认提供了 DefaultHashService 实现</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultHashService hashService =new DefaultHashService<span class="params">()</span>; <span class="comment">//默认算法 SHA-512 </span></span><br><span class="line">hashService.setHashAlgorithmName<span class="params">(<span class="string">"SHA-512"</span>)</span>; </span><br><span class="line">hashService.setPrivateSalt<span class="params">(newSimpleByteSource<span class="params">(<span class="string">"123"</span>)</span>)</span>; <span class="comment">//私盐，默认无</span></span><br><span class="line">hashService.setGeneratePublicSalt<span class="params">(<span class="literal">true</span>)</span>;<span class="comment">//是否生成公盐，默认 false </span></span><br><span class="line">hashService.setRandomNumberGenerator<span class="params">(new  SecureRandomNumberGenerator<span class="params">()</span>)</span>;<span class="comment">//用于生成公盐。默认就这个</span></span><br><span class="line">hashService.setHashIterations<span class="params">(<span class="number">1</span>)</span>; <span class="comment">//生成 Hash 值的迭代次数</span></span><br><span class="line">HashRequest request =new HashRequest.Builder<span class="params">()</span> </span><br><span class="line">.setAlgorithmName<span class="params">(<span class="string">"MD5"</span>)</span>.setSource<span class="params">(ByteSource.Util.bytes<span class="params">(<span class="string">"hello"</span>)</span>)</span> </span><br><span class="line">.setSalt<span class="params">(ByteSource.Util.bytes<span class="params">(<span class="string">"123"</span>)</span>)</span>.setIterations<span class="params">(<span class="number">2</span>)</span>.build<span class="params">()</span>; </span><br><span class="line">String hex =hashService.computeHash<span class="params">(request)</span>.toHex<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="加密/解密">加密/解密</h3><p>Shiro 还提供对称式加密/解密算法的支持，如 AES、Blowfish 等；当前还没有提供对非对称加密/解密算法支持，未来版本可能提供。</p>
<p>AES算法<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AesCipherService aesCipherService =new AesCipherService<span class="params">()</span>; </span><br><span class="line">aesCipherService.setKeySize<span class="params">(<span class="number">128</span>)</span>; <span class="comment">//设置 key 长度</span></span><br><span class="line"><span class="comment">//生成 key </span></span><br><span class="line">Keykey = aesCipherService.generateNewKey<span class="params">()</span>; </span><br><span class="line">String <span class="built_in">text</span> = <span class="string">"hello"</span>; </span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line">String encrptText = aesCipherService.encrypt<span class="params">(text.getBytes<span class="params">()</span>, key.getEncoded<span class="params">()</span>)</span>.toHex<span class="params">()</span>; </span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line">String text2 = new String<span class="params">(aesCipherService.decrypt<span class="params">(Hex.decode<span class="params">(encrptText)</span>, key.getEncoded<span class="params">()</span>)</span>.getBytes<span class="params">()</span>)</span>; </span><br><span class="line">Assert.assertEquals<span class="params">(text, text2)</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="PasswordService/CredentialsMatcher">PasswordService/CredentialsMatcher</h3><p>Shiro 提供了 PasswordService 及 CredentialsMatcher 用于提供加密密码及验证密码服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PasswordService</span> </span>&#123; </span><br><span class="line"><span class="comment">//输入明文密码得到密文密码</span></span><br><span class="line"><span class="function">String <span class="title">encryptPassword</span><span class="params">(ObjectplaintextPassword)</span> <span class="keyword">throws</span> IllegalArgumentException</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CredentialsMatcher</span> </span>&#123; </span><br><span class="line"><span class="comment">//匹配用户输入的 token 的凭证（未加密）与系统提供的凭证（已加密）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">doCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Shiro 默认提供了 PasswordService 实现 DefaultPasswordService；CredentialsMatcher 实现PasswordMatcher及HashedCredentialsMatcher（更强大）。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[main] </span><br><span class="line">passwordService=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.authc</span><span class="class">.credential</span><span class="class">.DefaultPasswordService</span> </span><br><span class="line">hashService=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.crypto</span><span class="class">.hash</span><span class="class">.DefaultHashService</span> </span><br><span class="line">passwordService.hashService=<span class="variable">$hashService</span> </span><br><span class="line">hashFormat=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.crypto</span><span class="class">.hash</span><span class="class">.format</span><span class="class">.Shiro1CryptFormat</span> </span><br><span class="line">passwordService.hashFormat=<span class="variable">$hashFormat</span> </span><br><span class="line">hashFormatFactory=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.crypto</span><span class="class">.hash</span><span class="class">.format</span><span class="class">.DefaultHashFormatFactory</span> </span><br><span class="line">passwordService.hashFormatFactory=<span class="variable">$hashFormatFactory</span> </span><br><span class="line">passwordMatcher=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.authc</span><span class="class">.credential</span><span class="class">.PasswordMatcher</span> </span><br><span class="line">passwordMatcher.passwordService=<span class="variable">$passwordService</span> </span><br><span class="line">myRealm=com<span class="class">.github</span><span class="class">.zhangkaitao</span><span class="class">.shiro</span><span class="class">.chapter5</span><span class="class">.hash</span><span class="class">.realm</span><span class="class">.MyRealm</span> </span><br><span class="line">myRealm.passwordService=<span class="variable">$passwordService</span> </span><br><span class="line">myRealm.credentialsMatcher=<span class="variable">$passwordMatcher</span> </span><br><span class="line">securityManager.realms=<span class="variable">$myRealm</span></span><br></pre></td></tr></table></figure>
<ol>
<li>passwordService 使用 DefaultPasswordService，如果有必要也可以自定义；</li>
<li>hashService 定义散列密码使用的 HashService，默认使用 DefaultHashService（默认SHA-256 算法）；</li>
<li>hashFormat 用于对散列出的值进行格式化，默认使用 Shiro1CryptFormat，另外提供了Base64Format 和 HexFormat，对于有 salt 的密码请自定义实现 ParsableHashFormat 然后把salt 格式化到散列值中；</li>
<li>hashFormatFactory 用于根据散列值得到散列的密码和 salt； 因为如果使用如 SHA 算法，那么会生成一个 salt，此 salt 需要保存到散列后的值中以便之后与传入的密码比较时使用；默认使用 DefaultHashFormatFactory；</li>
<li>passwordMatcher 使用 PasswordMatcher，其是一个 CredentialsMatcher 实现；</li>
<li>将 credentialsMatcher 赋值给 myRealm， myRealm 间接继承了 AuthenticatingRealm， 其在调用getAuthenticationInfo 方法获取到AuthenticationInfo信息后，会使用 credentialsMatcher 来验证凭据是否匹配，如果不匹配将抛出 IncorrectCredentialsException 异常。</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[main] </span><br><span class="line">credentialsMatcher=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.authc</span><span class="class">.credential</span><span class="class">.HashedCredentialsMatcher</span> </span><br><span class="line">credentialsMatcher.hashAlgorithmName=md5 </span><br><span class="line">credentialsMatcher.hashIterations=<span class="number">2</span> </span><br><span class="line">credentialsMatcher.storedCredentialsHexEncoded=true </span><br><span class="line">myRealm=com<span class="class">.github</span><span class="class">.zhangkaitao</span><span class="class">.shiro</span><span class="class">.chapter5</span><span class="class">.hash</span><span class="class">.realm</span><span class="class">.MyRealm2</span> </span><br><span class="line">myRealm.credentialsMatcher=<span class="variable">$credentialsMatcher</span> </span><br><span class="line">securityManager.realms=<span class="variable">$myRealm</span></span><br></pre></td></tr></table></figure>
<ol>
<li>通过 credentialsMatcher.hashAlgorithmName=md5 指定散列算法为 md5，需要和生成密码时的一样；</li>
<li>credentialsMatcher.hashIterations=2，散列迭代次数，需要和生成密码时的意义；</li>
<li>credentialsMatcher.storedCredentialsHexEncoded=true 表示是否存储散列后的密码为 16 进制，需要和生成密码时的一样，默认是 base64；</li>
</ol>
<p>此处最需要注意的就是 HashedCredentialsMatcher 的算法需要和生成密码时的算法一样。 另外 HashedCredentialsMatcher 会自动根据AuthenticationInfo 的类型是否是 SaltedAuthenticationInfo 来获取 credentialsSalt 盐。</p>
<h2 id="配置">配置</h2><p>Apache Shiro的配置主要分为四部分： </p>
<ol>
<li>对象和属性的定义与配置</li>
<li>URL的过滤器配置</li>
<li>静态用户配置</li>
<li>静态角色配置</li>
</ol>
<p>其中，由于用户、角色一般由后台进行操作的动态数据，因此Shiro配置一般仅包含前两项的配置。 </p>
<p>Apache Shiro的大多数组件是基于POJO的，因此我们可以使用POJO兼容的任何配置机制进行配置，例如：Java代码、Sping XML、YAML、JSON、ini文件等等。</p>
<p>Shiro 是从根对象 SecurityManager 进行身份验证和授权的；也就是所有操作都是自它开始的，这个对象是线程安全且整个应用只需要一个即可</p>
<p><strong>INI配置</strong></p>
<ol>
<li>对象名=全限定类名 相当于调用 public 无参构造器创建对象</li>
<li>对象名.属性名=值 相当于调用 setter 方法设置常量值</li>
<li>对象名.属性名=$对象引用 相当于调用 setter 方法设置对象引用</li>
</ol>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line"><span class="comment">#提供了对根对象 securityManager 及其依赖的配置</span></span><br><span class="line"><span class="variable">securityManager=</span>org.apache.shiro.mgt.DefaultSecurityManager</span><br><span class="line">…………</span><br><span class="line">dataSource.<span class="variable">driverClassName=</span>com.mysql.jdbc.Driver</span><br><span class="line"><span class="comment">#常量值注入</span></span><br><span class="line">jdbcRealm.<span class="variable">permissionsLookupEnabled=</span><span class="constant">true</span></span><br><span class="line">…………</span><br><span class="line"><span class="comment">#对象引用值注入</span></span><br><span class="line">securityManager.<span class="variable">realms=</span>$jdbcRealm</span><br><span class="line">…………</span><br><span class="line"><span class="comment">#嵌套属性注入</span></span><br><span class="line">securityManager.authenticator.<span class="variable">authenticationStrategy=</span>$authenticationStrategy</span><br><span class="line"><span class="comment">#byte数组注入</span></span><br><span class="line"><span class="comment">#base64 byte[]</span></span><br><span class="line">authenticator.<span class="variable">bytes=</span><span class="variable">aGVsbG8=</span></span><br><span class="line"><span class="comment">#hex byte[]</span></span><br><span class="line">authenticator.<span class="variable">bytes=</span><span class="number">0</span>x68656c6c6f</span><br><span class="line"><span class="comment">#Array/Set/List注入</span></span><br><span class="line">authenticator.<span class="variable">array=</span><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">authenticator.<span class="variable">set=</span>$jdbcRealm,$jdbcRealm</span><br><span class="line"><span class="comment">#Map注入</span></span><br><span class="line">authenticator.<span class="variable">map=</span>$jdbcRealm:$jdbcRealm,<span class="number">1</span>:<span class="number">1</span>,key:abc</span><br><span class="line">[users]</span><br><span class="line"><span class="comment">#提供了对用户/密码及其角色的配置，用户名=密码，角色 1，角色 2</span></span><br><span class="line"><span class="variable">username=</span>password,role1,role2</span><br><span class="line">[roles]</span><br><span class="line"><span class="comment">#提供了角色及权限之间关系的配置，角色=权限 1，权限 2</span></span><br><span class="line"><span class="variable">role1=</span>permission1,permission2</span><br><span class="line">[urls]</span><br><span class="line"><span class="comment">#用于 web，提供了对 web url 拦截相关的配置，url=拦截器[参数]，拦截器</span></span><br><span class="line">/index.<span class="variable">html =</span> anon</span><br><span class="line">/admin<span class="comment">/** = authc, roles[admin], perms["permission1"]</span></span><br></pre></td></tr></table></figure>
<p>XML配置： </p>
<p>主要是对Shiro各个组件的实现进行定义配置，主要组件在前文已做过简单介绍，这里不再一一说明。 </p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"securityManager"</span> class=<span class="string">"org.apache.shiro.mgt.DefaultSecurityManager"</span>&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"cacheManager"</span> <span class="keyword">ref</span>=<span class="string">"cacheManager"</span>/&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"sessionMode"</span> value=<span class="string">"native"</span>/&gt;  </span><br><span class="line">        &lt;!-- <span class="type">Single</span> realm app.  <span class="type">If</span> you have multiple realms, use the 'realms' property instead. --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"realm"</span> <span class="keyword">ref</span>=<span class="string">"myRealm"</span>/&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"sessionManager"</span> <span class="keyword">ref</span>=<span class="string">"sessionManager"</span>/&gt;   </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>Shiro过滤器的配置 </p>
<p>Shiro主要是通过URL过滤来进行安全管理，这里的配置便是指定具体授权规则定义。 </p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="property">id</span>=<span class="string">"shiroFilter"</span> <span class="type">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;  </span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"securityManager"</span> <span class="keyword">ref</span>=<span class="string">"securityManager"</span>/&gt;  </span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"loginUrl"</span> value=<span class="string">"/login.jsp"</span>/&gt;  </span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"successUrl"</span> value=<span class="string">"/home.jsp"</span>/&gt;  </span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"unauthorizedUrl"</span> value=<span class="string">"/unauthorized.jsp"</span>/&gt; <span class="comment">--&gt;  </span></span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;  </span><br><span class="line">        &lt;value&gt;  </span><br><span class="line">            <span class="comment"># some example chain definitions:  </span></span><br><span class="line">            /admin/** = authc, roles[admin]  </span><br><span class="line">            /docs/** = authc, perms[document:<span class="command">read</span>]  </span><br><span class="line">            /** = authc  </span><br><span class="line">            <span class="comment"># more URL-to-FilterChain definitions here  </span></span><br><span class="line">        &lt;/value&gt;  </span><br><span class="line">    &lt;/<span class="keyword">property</span>&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>URL过滤器配置说明： </p>
<p>Shiro可以通过配置文件实现基于URL的授权验证。FilterChain定义格式： <code>URL_Ant_Path_Expression = Path_Specific_Filter_Chain</code> </p>
<p>每个URL配置，表示匹配该URL的应用程序请求将由对应的过滤器进行验证。 </p>
<p>例如：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[urls] </span><br><span class="line">/index.html = anon </span><br><span class="line">/user/create = anon </span><br><span class="line">/user/<span class="keyword">*</span><span class="keyword">*</span> = authc </span><br><span class="line">/admin/<span class="keyword">*</span><span class="keyword">*</span> = authc, roles[administrator] </span><br><span class="line">/rest/<span class="keyword">*</span><span class="keyword">*</span> = authc, rest </span><br><span class="line">/remoting/rpc/<span class="keyword">*</span><span class="keyword">*</span> = authc, perms[<span class="string">"remote:invoke"</span>]</span><br></pre></td></tr></table></figure></p>
<p>URL表达式说明 </p>
<ol>
<li>URL目录是基于HttpServletRequest.getContextPath()此目录设置 </li>
<li>URL可使用通配符，**代表任意子目录 </li>
<li>Shiro验证URL时，URL匹配成功便不再继续匹配查找。所以要注意配置文件中的URL顺序，尤其在使用通配符时。 </li>
</ol>
<p>URL 路径表达式按事先定义好的顺序判断传入的请求，并遵循 FIRST MATCH WINS 这一原则。例如<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/account/<span class="keyword">*</span><span class="keyword">*</span> = ssl, authc</span><br><span class="line">/account/signup = anon</span><br></pre></td></tr></table></figure></p>
<p>如果传入的请求旨在访问 <code>/account/signup/index.html</code>（所有 ‘anon’ymous 用户都能访问），那么它将永不会被处理！原因是因为<code>/account/*</code>  的模式第一个匹配了传入的请求，“短路”了其余的定义。 </p>
<p>Filter Chain定义说明 </p>
<ol>
<li>一个URL可以配置多个Filter，使用逗号分隔 </li>
<li>当设置多个过滤器时，全部验证通过，才视为通过 </li>
<li>部分过滤器可指定参数，如perms，roles </li>
</ol>
<p>Shiro内置的FilterChain </p>
<table>
<thead>
<tr>
<th>Filter Name</th>
<th>Class</th>
</tr>
</thead>
<tbody>
<tr>
<td>anon</td>
<td>org.apache.shiro.web.filter.authc.AnonymousFilter</td>
</tr>
<tr>
<td>authc</td>
<td>org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td>
</tr>
<tr>
<td>authcBasic</td>
<td>org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td>
</tr>
<tr>
<td>logout</td>
<td>org.apache.shiro.web.filter.authc.LogoutFilter</td>
</tr>
<tr>
<td>noSessionCreation</td>
<td>org.apache.shiro.web.filter.session.NoSessionCreationFilter</td>
</tr>
<tr>
<td>perms</td>
<td>org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td>
</tr>
<tr>
<td>port</td>
<td>org.apache.shiro.web.filter.authz.PortFilter</td>
</tr>
<tr>
<td>rest</td>
<td>org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td>
</tr>
<tr>
<td>roles</td>
<td>org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td>
</tr>
<tr>
<td>ssl</td>
<td>org.apache.shiro.web.filter.authz.SslFilter</td>
</tr>
<tr>
<td>user</td>
<td>org.apache.shiro.web.filter.authc.UserFilter</td>
</tr>
</tbody>
</table>
<p>OncePerRequestFilter（及其所有子类）支持 Enabling/Disabling 所有请求及 per-request 基础。 一般为所有的请求启用或禁用一个过滤器是通过设置其 enabled 属性为true 或 false。</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">main</span>]</span><br><span class="line">ssl.<span class="literal">enabled</span>=<span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h2 id="缓存">缓存</h2><ul>
<li>CacheManager - 负责所有缓存的主要管理组件，它返回 Cache 实例。</li>
<li>Cache - 维护key/value 对。</li>
<li>CacheManagerAware - 通过想要接收和使用 CacheManager 实例的组件来实现。</li>
</ul>
<p>CacheManager 返回Cache 实例，各种不同的Shiro 组件使用这些Cache 实例来缓存必要的数据。任何实现了 CacheManagerAware 的 Shiro 组件将会自动地接收一个配置好的 CacheManager，该 CacheManager 能够用来获取 Cache 实例。</p>
<h3 id="Realm缓存">Realm缓存</h3><p>Shiro 的 SecurityManager 实现及所有 AuthorizingRealm 实现都实现了 CacheManagerAware 。如果你在 SecurityManager 上设置了 CacheManger，它反过来也会将它设置到实现了CacheManagerAware 的各种不同的 Realm 上（OO delegation）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">userRealm=com<span class="class">.github</span><span class="class">.zhangkaitao</span><span class="class">.shiro</span><span class="class">.chapter11</span><span class="class">.realm</span><span class="class">.UserRealm</span></span><br><span class="line">userRealm.credentialsMatcher=<span class="variable">$credentialsMatcher</span></span><br><span class="line">userRealm.cachingEnabled=true</span><br><span class="line">userRealm.authenticationCachingEnabled=true</span><br><span class="line">userRealm.authenticationCacheName=authenticationCache</span><br><span class="line">userRealm.authorizationCachingEnabled=true</span><br><span class="line">userRealm.authorizationCacheName=authorizationCache</span><br><span class="line">securityManager.realms=<span class="variable">$userRealm</span></span><br><span class="line">cacheManager=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.cache</span><span class="class">.ehcache</span><span class="class">.EhCacheManager</span></span><br><span class="line">cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache<span class="class">.xml</span></span><br><span class="line">securityManager.cacheManager=<span class="variable">$cacheManager</span></span><br></pre></td></tr></table></figure>
<ul>
<li>userRealm.cachingEnabled：启用缓存，默认 false；</li>
<li>userRealm.authenticationCachingEnabled：启用身份验证缓存，即缓存 AuthenticationInfo 信息，默认 false；</li>
<li>userRealm.authenticationCacheName：缓存 AuthenticationInfo 信息的缓存名称；</li>
<li>userRealm. authorizationCachingEnabled：启用授权缓存，即缓存 AuthorizationInfo 信息，默认 false；</li>
<li>userRealm. authorizationCacheName：缓存 AuthorizationInfo 信息的缓存名称；</li>
<li>cacheManager：缓存管理器，此处使用 EhCacheManager，即 Ehcache 实现，需要导入相应的 Ehcache 依赖，请参考 pom.xml；</li>
</ul>
<p>如果凭证数据或授权数据发生改变，需要调用Realm的clearCachedAuthenticationInfo 和 clearCachedAuthorizationInfo方法</p>
<h3 id="Session缓存">Session缓存</h3><p>如 securityManager 实现了 SessionsSecurityManager，其会自动判断 SessionManager 是否实现了 CacheManagerAware 接口，如果实现了会把 CacheManager 设置给它。然后sessionManager 会判断相应的 sessionDAO（如继承自 CachingSessionDAO）是否实现了CacheManagerAware， 如果实现了会把 CacheManager 设置给它</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionDAO=com<span class="class">.github</span><span class="class">.zhangkaitao</span><span class="class">.shiro</span><span class="class">.chapter11</span><span class="class">.session</span><span class="class">.dao</span><span class="class">.MySessionDAO</span></span><br><span class="line">sessionDAO.activeSessionsCacheName=shiro-activeSessionCache</span><br></pre></td></tr></table></figure>
<p>activeSessionsCacheName 默认就是 shiro-activeSessionCache。</p>
<h2 id="与Spring的集成">与Spring的集成</h2><h3 id="JavaSE">JavaSE</h3><p>spring-shiro.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 缓存管理器 使用 Ehcache 实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"cacheManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.cache.ehcache.EhCacheManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cacheManagerConfigFile"</span> <span class="attribute">value</span>=<span class="value">"classpath:ehcache.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 凭证匹配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"credentialsMatcher"</span> <span class="attribute">class</span>=<span class="value">"com.github.zhangkaitao.shiro.chapter12.credentials.RetryLimitHashedCredentialsMatcher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"cacheManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hashAlgorithmName"</span> <span class="attribute">value</span>=<span class="value">"md5"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hashIterations"</span> <span class="attribute">value</span>=<span class="value">"2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"storedCredentialsHexEncoded"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Realm 实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"userRealm"</span> <span class="attribute">class</span>=<span class="value">"com.github.zhangkaitao.shiro.chapter12.realm.UserRealm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"userService"</span> <span class="attribute">ref</span>=<span class="value">"userService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"credentialsMatcher"</span> <span class="attribute">ref</span>=<span class="value">"credentialsMatcher"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cachingEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authenticationCachingEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authenticationCacheName"</span> <span class="attribute">value</span>=<span class="value">"authenticationCache"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authorizationCachingEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authorizationCacheName"</span> <span class="attribute">value</span>=<span class="value">"authorizationCache"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话 ID 生成器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionIdGenerator"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话 DAO --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionDAO"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"activeSessionsCacheName"</span> <span class="attribute">value</span>=<span class="value">"shiro-activeSessionCache"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionIdGenerator"</span> <span class="attribute">ref</span>=<span class="value">"sessionIdGenerator"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话验证调度器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionValidationScheduler"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionValidationInterval"</span> <span class="attribute">value</span>=<span class="value">"1800000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionManager"</span> <span class="attribute">ref</span>=<span class="value">"sessionManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.session.mgt.DefaultSessionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"globalSessionTimeout"</span> <span class="attribute">value</span>=<span class="value">"1800000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"deleteInvalidSessions"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionValidationSchedulerEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionValidationScheduler"</span> <span class="attribute">ref</span>=<span class="value">"sessionValidationScheduler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionDAO"</span> <span class="attribute">ref</span>=<span class="value">"sessionDAO"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"securityManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.mgt.DefaultSecurityManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"realms"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">list</span>&gt;</span><span class="tag">&lt;<span class="title">ref</span> <span class="attribute">bean</span>=<span class="value">"userRealm"</span>/&gt;</span><span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionManager"</span> <span class="attribute">ref</span>=<span class="value">"sessionManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cacheManager"</span> <span class="attribute">ref</span>=<span class="value">"cacheManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 相当于调用 SecurityUtils.setSecurityManager(securityManager) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"staticMethod"</span> <span class="attribute">value</span>=<span class="value">"org.apache.shiro.SecurityUtils.setSecurityManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"arguments"</span> <span class="attribute">ref</span>=<span class="value">"securityManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Shiro 生命周期处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"lifecycleBeanPostProcessor"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.spring.LifecycleBeanPostProcessor"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>LifecycleBeanPostProcessor 用于在实现了 Initializable 接口的 Shiro bean 初始化时调用 Initializable 接口回调，在实现了 Destroyable 接口的 Shiro bean 销毁时调用 Destroyable 接口回调。 如 UserRealm 就实现了 Initializable， 而 DefaultSecurityManager 实现了 Destroyable。具体可以查看它们的继承关系。 </p>
<h3 id="Web应用">Web应用</h3><p>spring-shiro-web.xml，只列出了和JavaSE不同的项，其中会话管理器和安全管理器和JavaSE稍有不同，其他几个是新加的<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 会话 Cookie 模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionIdCookie"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"sid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"httpOnly"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxAge"</span> <span class="attribute">value</span>=<span class="value">"180000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.session.mgt.DefaultWebSessionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"globalSessionTimeout"</span> <span class="attribute">value</span>=<span class="value">"1800000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"deleteInvalidSessions"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionValidationSchedulerEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionValidationScheduler"</span> <span class="attribute">ref</span>=<span class="value">"sessionValidationScheduler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionDAO"</span> <span class="attribute">ref</span>=<span class="value">"sessionDAO"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionIdCookieEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionIdCookie"</span> <span class="attribute">ref</span>=<span class="value">"sessionIdCookie"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"securityManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"realm"</span> <span class="attribute">ref</span>=<span class="value">"userRealm"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionManager"</span> <span class="attribute">ref</span>=<span class="value">"sessionManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cacheManager"</span> <span class="attribute">ref</span>=<span class="value">"cacheManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 基于 Form 表单的身份验证过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"formAuthenticationFilter"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.filter.authc.FormAuthenticationFilter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"usernameParam"</span> <span class="attribute">value</span>=<span class="value">"username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"passwordParam"</span> <span class="attribute">value</span>=<span class="value">"password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"loginUrl"</span> <span class="attribute">value</span>=<span class="value">"/login.jsp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Shiro 的 Web 过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"shiroFilter"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"securityManager"</span> <span class="attribute">ref</span>=<span class="value">"securityManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"loginUrl"</span> <span class="attribute">value</span>=<span class="value">"/login.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"unauthorizedUrl"</span> <span class="attribute">value</span>=<span class="value">"/unauthorized.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"filters"</span>&gt;</span> <span class="comment">&lt;!-- 对应ini文件[filters] --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">util:map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"authc"</span> <span class="attribute">value-ref</span>=<span class="value">"formAuthenticationFilter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">util:map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">value</span>&gt;</span></span><br><span class="line">        /index.jsp = anon</span><br><span class="line">        /unauthorized.jsp = anon</span><br><span class="line">        /login.jsp = authc</span><br><span class="line">        /logout = logout</span><br><span class="line">        /** = user</span><br><span class="line">        <span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>还要在web.xml中添加shiro过滤器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Shiro filter--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">filter</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>  </span><br><span class="line">        org.springframework.web.filter.DelegatingFilterProxy  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是上述配置所做的事情：</p>
<ol>
<li>EnvironmentLoaderListener 初始化一个Shiro WebEnvironment 实例（其中包含 Shiro 需要的一切操作，包括 SecurityManager ），使得它在 ServletContext 中能够被访问。如果你需要在任何时候获得WebEnvironment 实例，你可以调用WebUtils.getRequiredWebEnvironment（ServletContext）。</li>
<li>ShiroFilter 将使用此 WebEnvironment 对任何过滤的请求执行所有必要的安全操作。</li>
<li>最后，filter-mapping 的定义确保了所有的请求被 ShiroFilter 过滤，建议大多数 Web 应用程序使用以确保任何请求是安全的。</li>
</ol>
<p>通常为了shiro能够很好的工作，这个配置应该在其他过滤器之前</p>
<h3 id="Shiro_权限注解">Shiro 权限注解</h3><p>Shiro 提供了相应的注解用于权限控制，如果使用这些注解就需要使用 AOP 的功能来进行判断，如 Spring AOP；Shiro 提供了 Spring AOP 集成用于权限注解的解析和验证。为了测试，此处使用了 Spring MVC 来测试 Shiro 注解，当然 Shiro 注解不仅仅可以在 web 环境使用，在独立的 JavaSE 中也是可以用的</p>
<p>在spring-mvc.xml中添加权限注解的支持<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config proxy-target-class=<span class="string">"true"</span>&gt;&lt;/aop:config&gt;</span><br><span class="line">&lt;bean class=<span class="string">"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"securityManager"</span> <span class="keyword">ref</span>=<span class="string">"securityManager"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="RememberMe">RememberMe</h3><p>spring-shiro-web.xml 配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"rememberMeCookie"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"rememberMe"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"httpOnly"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxAge"</span> <span class="attribute">value</span>=<span class="value">"2592000"</span>/&gt;</span><span class="comment">&lt;!-- 30 天 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- rememberMe 管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"rememberMeManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.mgt.CookieRememberMeManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cipherKey"</span> <span class="attribute">value</span>=<span class="value">"#&#123;T(org.apache.shiro.codec.Base64).decode('4AvVhmFLUs0KTA3Kprsdag==')&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cookie"</span> <span class="attribute">ref</span>=<span class="value">"rememberMeCookie"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"securityManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">    ……</span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"rememberMeManager"</span> <span class="attribute">ref</span>=<span class="value">"rememberMeManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"formAuthenticationFilter"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.filter.authc.FormAuthenticationFilter"</span>&gt;</span></span><br><span class="line">    ……</span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"rememberMeParam"</span> <span class="attribute">value</span>=<span class="value">"rememberMe"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>rememberMe 管理器，cipherKey 是加密 rememberMe Cookie 的密钥；默认 AES 算法；设置 securityManager 安全管理器的 rememberMeManager；rememberMeParam，即 rememberMe 请求参数名，请求参数是 boolean 类型，true 表示 rememberMe。</p>
<p><code>/authenticated.jsp = authc</code> 表示访问该地址用户必须身份验证通过（ Subject.isAuthenticated()==true）；而<code>/** = user</code>表示访问该地址的用户是身份验证通过或 RememberMe 登录的都可以。</p>
]]></content>
    <summary type="html">
    <![CDATA[Shiro; Java安全框架; 认证、授权、加密和会话管理]]>
    
    </summary>
    
      <category term="Shiro" scheme="http://howiefh.github.io/tags/Shiro/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="Shiro" scheme="http://howiefh.github.io/categories/Java/Shiro/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FreeMarker-XML处理笔记]]></title>
    <link href="http://howiefh.github.io/2015/05/03/freemarker-XML-processing-note/"/>
    <id>http://howiefh.github.io/2015/05/03/freemarker-XML-processing-note/</id>
    <published>2015-05-03T01:20:51.000Z</published>
    <updated>2015-05-21T15:55:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="揭示XML文档">揭示XML文档</h2><p>test.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Test Book<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">chapter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">title</span>&gt;</span>Ch1<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">para</span>&gt;</span>p1.1<span class="tag">&lt;/<span class="title">para</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">para</span>&gt;</span>p1.2<span class="tag">&lt;/<span class="title">para</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">para</span>&gt;</span>p1.3<span class="tag">&lt;/<span class="title">para</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">chapter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">chapter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">title</span>&gt;</span>Ch2<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">para</span>&gt;</span>p2.1<span class="tag">&lt;/<span class="title">para</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">para</span>&gt;</span>p2.2<span class="tag">&lt;/<span class="title">para</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">chapter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">book</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>根节点是“文档”而不是book</li>
<li>如果 B 是 A 的直接后继，我们说 B 节点是 A 节点的 child 子节点，A节点是B节点的parent父节点。</li>
<li>元素，文本，注释，处理指令都是DOM树的节点</li>
</ul>
<a id="more"></a>
<h3 id="将XML放到数据模型中">将XML放到数据模型中</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map root = new HashMap<span class="params">()</span>;</span><br><span class="line">root.put<span class="params">(<span class="string">"doc"</span>, freemarker.ext.dom.NodeModel.parse<span class="params">(new File<span class="params">(<span class="string">"test.xml"</span>)</span>)</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>parse 方法默认移除注释和处理指令节点。参见 API 文档获取详细信息。</li>
<li>NodeModel 也允许你直接包装 org.w3c.dom.Node。首先你也许想用静态的实用方法清空 DOM 树，比如 NodeModel.simplify 或你自定义的清空规则。</li>
</ul>
<h2 id="必要的XML处理">必要的XML处理</h2><h3 id="通过例子来学习">通过例子来学习</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>$&#123;doc.book.title&#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>尝试访问有子元素的元素将导致错误<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>$&#123;doc.book&#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>doc.book.chapter是存储两个元素节点的序列<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>$&#123;doc.book.chapter[0].title&#125;<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>$&#123;doc.book.chapter[1].title&#125;<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">doc.book.chapter</span> <span class="attribute">as</span> <span class="attribute">ch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">h2</span>&gt;</span>$&#123;ch.title&#125;<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>就算只有一个元素节点，也可以当做一个序列<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>$&#123;doc.book[0].title[0]&#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果 book 没有 chapter，那么book.chapter 就是一个空序列，所以 doc.book.chapter 就不会是 false，它就一直是 true！类似地，<code>&lt;#if doc.book.somethingTotallyNonsense??&gt;&lt;/#if&gt;</code>也不会是false。来检查是否有子节点，可以使用doc.book.chapter[0]??（或doc.book.chapter?size == 0）。当然你可以使用类似所有的控制处理操作符（比如 doc.book.author[0]!”Anonymous”），只是不要忘了那个[0]。</p>
<p>一个完整示例<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#assign</span> <span class="attribute">book</span> = <span class="attribute">doc.book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>$&#123;book.title&#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">book.chapter</span> <span class="attribute">as</span> <span class="attribute">ch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">h2</span>&gt;</span>$&#123;ch.title&#125;<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">#list</span> <span class="attribute">ch.para</span> <span class="attribute">as</span> <span class="attribute">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span>&gt;</span>$&#123;p&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>得到所有的para<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> doc.book.chapter.para <span class="keyword">as</span> p&gt;</span><br><span class="line">&lt;p&gt;<span class="label">$&#123;p&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="访问属性">访问属性</h3><p>如果test.xml中title是属性而不是元素，只需在其前加@即可。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#assign</span> <span class="attribute">book</span> = <span class="attribute">doc.book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>$&#123;book.@title&#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">book.chapter</span> <span class="attribute">as</span> <span class="attribute">ch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">h2</span>&gt;</span>$&#123;ch.@title&#125;<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">#list</span> <span class="attribute">ch.para</span> <span class="attribute">as</span> <span class="attribute">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span>&gt;</span>$&#123;p&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果你很好奇是否 foo 含有属性 bar，那么你不得不写 foo.@bar[0]??来验证。（ foo.@bar??是不对的，因为它总是返回 true）。类似地，如果你想要一个bar属性的默认值，那么你就不得不写 foo.@bar[0]!”theDefaultValue”。</p>
<h3 id="探索DOM">探索DOM</h3><p>枚举所有book的子元素<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="symbol">#list</span> doc.book?children as c&gt;</span><br><span class="line">- <span class="char">$&#123;</span>c?node_type&#125; &lt;<span class="symbol">#if</span> c?node_type = <span class="string">'element'</span>&gt;<span class="char">$&#123;</span>c?node_name&#125;&lt;/<span class="symbol">#if</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">#list</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>children：子元素序列<br>node_type：节点类型，”element”， “text”， “comment”， “pi”<br>node_name：节点名称</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;book <span class="variable">foo=</span><span class="string">"Foo"</span> <span class="variable">bar=</span><span class="string">"Bar"</span> <span class="variable">baaz=</span><span class="string">"Baaz"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以通过元素的自变量@@获取元素的属性序列</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> doc.book.@@ <span class="keyword">as</span> attr&gt;</span><br><span class="line">- <span class="label">$&#123;attr</span>?node_name&#125; = <span class="label">$&#123;attr&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure>
<p>返回元素的子节点序列可以用*</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> doc.book.* <span class="keyword">as</span> c&gt;</span><br><span class="line">- <span class="label">$&#123;c</span>?node_name&#125;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以使用内建函数 parent 来获得元素的父节点。你可以使用内建函数 root 来快速返回到文档节点<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="comment">#assign e = doc.book.chapter[0].para[0]&gt;</span></span><br><span class="line">$&#123;e?node_name&#125;</span><br><span class="line">$&#123;e?<span class="keyword">parent</span>?node_name&#125;</span><br><span class="line">$&#123;e?<span class="keyword">parent</span>?<span class="keyword">parent</span>?node_name&#125;</span><br><span class="line">$&#123;e?<span class="keyword">parent</span>?<span class="keyword">parent</span>?<span class="keyword">parent</span>?node_name&#125;</span><br><span class="line">$&#123;e?root?node_name&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用XPath表达式">使用XPath表达式</h3><p>XPath 表达式仅在 Jaxen（推荐使用，但是使用至少 Jaxen 1.1-beta-8 版本，不能再老了） 或 Apache Xalan 库可用时有效。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">doc</span>["<span class="attribute">book</span>/<span class="attribute">chapter</span>[<span class="attribute">title</span>=<span class="value">'Ch1'</span><span class="value">]</span>/<span class="attribute">para</span>"] <span class="attribute">as</span> <span class="attribute">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">p</span>&gt;</span></span>$&#123;p&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span></span><br><span class="line">$&#123;doc[<span class="link_label">"book/chapter[title='Ch1'</span>]/para[<span class="link_label">1</span>]"][0]&#125;</span><br><span class="line">$&#123;doc.book["chapter[title='Ch1']/para[1]"]&#125;</span><br></pre></td></tr></table></figure>
<p>注意 XPath 序列的项索引从 1 开始，而 FTL 的序列项索引是用 0 开始的。</p>
<p>如果使用 Jaxen 而不是 Xalan，那么 FreeMarker 的变量在使用 XPath 变量引用时是可见的<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="id">#assign</span> currentTitle = <span class="string">"Ch1"</span>&gt;</span><br><span class="line">&lt;<span class="id">#list</span> doc[<span class="string">"book/chapter[title=$currentTitle]/para"</span>] as p&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意$currentTitle 不是 FreeMarker 的插值，因为那里没有{和}。那是 XPath 表达式。</p>
<p>一些 XPath 表达式的结果不是节点集，而是字符串，数字或者布尔值。获取para元素的总数<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;</span>x[<span class="string">"count(//para)"</span>]&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="XML命名空间">XML命名空间</h3><p>如果元素book是命名空间 <a href="http://example.com/ebook，那么你不得不关联一个前缀，要在模板的顶部使用" target="_blank" rel="external">http://example.com/ebook，那么你不得不关联一个前缀，要在模板的顶部使用</a> ftl 指令的 the ns_prefixes 参数：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">#ftl ns_prefixes=&#123;</span></span><br><span class="line"><span class="string">"e"</span>:<span class="string">"http://example.com/ebook"</span>,</span><br><span class="line"><span class="string">"f"</span>:<span class="string">"http://example.com/form"</span>,</span><br><span class="line"><span class="string">"vg"</span>:<span class="string">"http://example.com/vectorGraphics"</span>&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>现在你可以编写如 doc[“e:book”]的表达式。使用保留前缀D可以设置默认命名空间。XPath不支持默认命名空间</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">#ftl</span> <span class="attribute">ns_prefixes</span>=</span></span><span class="expression">&#123;<span class="string">"D"</span>:<span class="string">"http://example.com/ebook"</span>&#125;</span><span class="xml"><span class="tag">&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>注意当你使用默认命名空间时，那么你可以使用保留前缀 N 来选择不属于任意节点空间的元素。比如 doc.book[“N:foo”]。这对 XPath 表达式不起作用</p>
<h3 id="转义">转义</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#escape</span> <span class="attribute">x</span> <span class="attribute">as</span> <span class="attribute">x</span>?<span class="attribute">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#assign</span> <span class="attribute">book</span> = <span class="attribute">doc.book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>$&#123;book.title&#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">book.chapter</span> <span class="attribute">as</span> <span class="attribute">ch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>$&#123;ch.title&#125;<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">ch.para</span> <span class="attribute">as</span> <span class="attribute">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>$&#123;p&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#escape</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="声明的XML处理">声明的XML处理</h2><p>最经常使用来处理声明方式的指令就是 recurse 指令，这个指令获取节点变量，并把它作为是参数，从第一个子元素开始，一个接一个地“访问”所有它的子元素。“访问”一个节点意味着它调用了用户自定义的指令（比如宏），它的名字和子节点（ ?node_name）的名字相同。我们这么说，用户自定义指令操作节点。使用用户自定义指令处理的节点作为特殊变量.node 是可用的。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="comment">#recurse doc&gt;</span></span><br><span class="line">&lt;<span class="comment">#macro book&gt;</span></span><br><span class="line">    Book <span class="keyword">element</span> <span class="operator">with</span> title $&#123;.node.title&#125;</span><br><span class="line">    &lt;<span class="comment">#recurse&gt;</span></span><br><span class="line">    End book</span><br><span class="line">&lt;/<span class="comment">#macro&gt;</span></span><br><span class="line">&lt;<span class="comment">#macro title&gt;</span></span><br><span class="line">    Title <span class="keyword">element</span></span><br><span class="line">&lt;/<span class="comment">#macro&gt;</span></span><br><span class="line">&lt;<span class="comment">#macro chapter&gt;</span></span><br><span class="line">    Chapter <span class="keyword">element</span> <span class="operator">with</span> title: $&#123;.node.title&#125;</span><br><span class="line">&lt;/<span class="comment">#macro&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你调用 recurse 而不用参数，那么它使用.node，也就是说，它访问现在处理这个节点的所有子节点。</p>
<p>所有文本节点的节点名字都是@text。转义HTML<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">macro</span> <span class="keyword">@text</span>&gt;$&#123;.node?html&#125;&lt;/#<span class="keyword">macro</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="默认处理器">默认处理器</h3><ul>
<li>文本节点： 打印其中的文本。要注意，在很多应用程序中，这对你来说并不好，因为你应该在你发送它们到输出（使用?html 或?xml 或?rtf 等，这基于输出的格式）前转义这些文本。</li>
<li>处理指令节点： 如果你定义了自定义指令，可以通过调用处理器调用@pi，否则将什么都不做（忽略这些节点）。</li>
<li>注释节点，文档类型节点：什么都不做（忽略这些节点）。</li>
<li>文档节点：调用 recurse，也就是说，访问文档节点的所有子节点。</li>
</ul>
<p>元素节点的情形，这意味着如果你定义了一个称为@element 的宏（或其他种类的用户自定义指令），没有其他特定的处理器时，那么它会捕捉所有元素节点。如果你没有@element 处理器，那么你必须为所有可能的元素定义处理器。</p>
<p>属性节点在 recurse 指令中不可见，所以不需要为它们编写处理器。</p>
<h3 id="访问单独节点">访问单独节点</h3><p>使用visit指令你可以访问单独的节点</p>
<h3 id="XML_命名空间">XML 命名空间</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">book </span>xmlns=<span class="string">"http://example.com/ebook"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>考虑命名空间</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">#ftl</span> <span class="attribute">ns_prefixes</span>=</span></span><span class="expression">&#123;<span class="string">"e"</span>:<span class="string">"http://example.com/ebook"</span>&#125;</span><span class="xml"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#recurse</span> <span class="attribute">doc</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#macro</span> "<span class="attribute">e:book</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span><span class="tag">&lt;<span class="title">#recurse</span> <span class="attribute">.node</span>["<span class="attribute">e:title</span>"]&gt;</span><span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="tag">&lt;<span class="title">#recurse</span> <span class="attribute">.node</span>["<span class="attribute">e:title</span>"]&gt;</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#recurse</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#macro</span> "<span class="attribute">e:chapter</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span><span class="tag">&lt;<span class="title">#recurse</span> <span class="attribute">.node</span>["<span class="attribute">e:title</span>"]&gt;</span><span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#recurse</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#macro</span> "<span class="attribute">e:para</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">#recurse</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#macro</span> "<span class="attribute">e:title</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#--</span></span><br><span class="line"><span class="attribute">We</span> <span class="attribute">have</span> <span class="attribute">handled</span> <span class="attribute">this</span> <span class="attribute">element</span> <span class="attribute">imperatively</span>,</span><br><span class="line"><span class="attribute">so</span> <span class="attribute">we</span> <span class="attribute">do</span> <span class="attribute">nothing</span> <span class="attribute">here.</span></span><br><span class="line"><span class="attribute">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#macro</span> @<span class="attribute">text</span>&gt;</span>$</span><span class="expression">&#123;<span class="variable">.node</span>?<span class="variable">html</span>&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>设置为默认命名空间</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="subst">&lt;</span><span class="variable">#ftl</span> ns_prefixes<span class="subst">=</span>&#123;<span class="string">"D"</span>:<span class="string">"http://example.com/ebook"</span>&#125;<span class="subst">&gt;</span></span><br><span class="line"><span class="subst">&lt;</span><span class="variable">#recurse</span> doc<span class="subst">&gt;</span></span><br><span class="line"><span class="subst">&lt;</span><span class="variable">#macro</span> book<span class="subst">&gt;</span></span><br><span class="line"><span class="attribute">...</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[FreeMarker;Java模板引擎;XML处理]]>
    
    </summary>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/tags/FreeMarker/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/categories/Java/FreeMarker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FreeMarker-程序开发指南笔记]]></title>
    <link href="http://howiefh.github.io/2015/05/02/freemarker-program-development-note/"/>
    <id>http://howiefh.github.io/2015/05/02/freemarker-program-development-note/</id>
    <published>2015-05-02T01:20:06.000Z</published>
    <updated>2015-05-21T15:54:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="快速入门">快速入门</h2><ul>
<li>使用 java.lang.String 来构建字符串。</li>
<li>使用 java.lang.Number 来派生数字类型。</li>
<li>使用 java.lang.Boolean 来构建布尔值。</li>
<li>使用 java.util.List 或 Java 数组来构建序列。</li>
<li>使用 java.util.Map 来构建哈希表。</li>
<li>使用你自己定义的 bean 类来构建哈希表， bean 中的项和 bean 的属性对应。例如product 中的 price 属性可以用 product.price 来获取。</li>
</ul>
<a id="more"></a>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> freemarker.<span class="keyword">template</span>.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestFTLDemo &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws Exception &#123;</span><br><span class="line">		<span class="comment">/* 在整个应用的生命周期中，这个工作你应该只做一次。 */</span></span><br><span class="line">		<span class="comment">/* 创建和调整配置。 */</span></span><br><span class="line">		Configuration cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">		cfg.setDirectoryForTemplateLoading(<span class="keyword">new</span> File(</span><br><span class="line">				<span class="string">"/where/you/store/templates"</span>));</span><br><span class="line">		cfg.setObjectWrapper(<span class="keyword">new</span> DefaultObjectWrapper());</span><br><span class="line">		<span class="comment">/* 在整个应用的生命周期中，这个工作你可以执行多次 */</span></span><br><span class="line">		<span class="comment">/* 获取或创建模板 */</span></span><br><span class="line">		Template temp = cfg.getTemplate(<span class="string">"test.ftl"</span>);</span><br><span class="line">		<span class="comment">/* 创建数据模型 */</span></span><br><span class="line">		Map root = <span class="keyword">new</span> HashMap();</span><br><span class="line">		root.put(<span class="string">"user"</span>, <span class="string">"Big Joe"</span>);</span><br><span class="line">		Map latest = <span class="keyword">new</span> HashMap();</span><br><span class="line">		root.put(<span class="string">"latestProduct"</span>, latest);</span><br><span class="line">		latest.put(<span class="string">"url"</span>, <span class="string">"products/greenmouse.html"</span>);</span><br><span class="line">		latest.put(<span class="string">"name"</span>, <span class="string">"green mouse"</span>);</span><br><span class="line">		<span class="comment">/* 将模板和数据模型合并 */</span></span><br><span class="line">		Writer <span class="keyword">out</span> = <span class="keyword">new</span> OutputStreamWriter(System.<span class="keyword">out</span>);</span><br><span class="line">		temp.process(root, <span class="keyword">out</span>);</span><br><span class="line">		<span class="keyword">out</span>.flush();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据模型">数据模型</h2><p>在内部，模板中可用的变量都是实现了freemarker.template.TemplateModel 接口的 Java 对象。但在你自己的数据模型中，可以使用基本的 Java 集合类作为变量， 因为这些变量会在内部被替换为适当的TemplateModel 类型。这种功能特性被称作是 object wrapping 对象包装。对象包装功能可以透明地把任何类型的对象转换为实现了 TemplateModel 接口类型的实例。要注意一个类可以实现多个TemplateModel 接口，这就是为什么 FTL 变量可以有多种类型</p>
<h3 id="标量">标量</h3><p>布尔值、数字、字符串、日期这四种标量每一种标量类型都是 TemplateTypeModel 接口的实现，这里的 Type 就是类型的名称（比如Boolean,Number,Scalar,Date）。 这些接口只定义了一个方法 type getAsType()；它返回变量的 Java 类型（boolean，Number， String 和 Date 各自代表的值）的值。这些接口的有一个实现类SimpleType 类。但是没有 SimpleBooleanModel 类型；为了代表布尔值，可以使用TemplateBooleanModel.TRUE 和 TemplateBooleanModel.FALSE 来单独使用。</p>
<p>Date有个问题，就是模板不知道它是date还是time还是datetime。TemplateDateModel 接口有两个方法：分别是java.util.Date getAsDate() 和int getDateType()。这个接口典型的实现是存储一个 java.util.Date 对象，加上一个整数来辨别“数据库存储的类型”。这个整数的值也必须是 TemplateDateModel 接口中的常量之一：DATE，TIME，DATETIME和UNKNOWN。通过内建函数date、time、datetime和string可以解决这个问题。</p>
<h3 id="容器">容器</h3><h4 id="哈希表">哈希表</h4><p>哈希表是实现了 TemplateHashModel 接口的 Java 对象。TemplateHashModel 接口有两个方法：TemplateModel get(String key)，boolean isEmpty()。</p>
<p>TemplateHashModelEx 接口扩展了 TemplateHashModel 接口。它增加了更多的方法，使得可以使用内建函数 values 和 keys 来枚举哈希表中的子变量。经常使用的实现类是 SimpleHash，该类实现了 TemplateHashModelEx 接口。 </p>
<h4 id="序列">序列</h4><p>序列是实现了 TemplateSequenceModel 接口的 Java 对象。它包含两个方法：TemplateModel get(int index)和 int size()。</p>
<p>经常使用的实现类是 SimpleSequence， 该类内部使用一个 java.util.List 类型的对象存储它的子变量。</p>
<h4 id="集合">集合</h4><p>集合是实现了 TemplateCollectionModel 接口的 Java 对象。这个接口只定义了一个方法：TemplateModelIterator iterator() 。TemplateModelIterator 接口和 java.util.Iterator 相似，但是它返回 TemplateModels 而不是Object，而且它能抛出TemplateModelException 异常。通常使用的实现类是 SimpleCollection。</p>
<h3 id="方法">方法</h3><p>方法变量在存于实现了 TemplateMethodModel 接口的模板中。这个接口仅包含一个方法： TemplateModel exec(java.util.List arguments)。当使用方法调用表达式调用方法时，exec 方法将会被调用。形参将会包含 FTL方法调用形参的值。exec 方法的返回值给出了 FTL 方法调用表达式的返回值。TemplateMethodModelEx 接口扩展了 TemplateMethodModel 接口。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexOfMethod</span> <span class="keyword">implements</span> <span class="title">TemplateMethodModel</span> </span>&#123;</span><br><span class="line">	public TemplateModel exec(<span class="built_in">List</span> args) throws TemplateModelException &#123;</span><br><span class="line">		<span class="keyword">if</span> (args.size() != <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TemplateModelException(<span class="string">"Wrong arguments"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SimpleNumber(((<span class="built_in">String</span>) args.<span class="literal">get</span>(<span class="number">1</span>)).indexOf((<span class="built_in">String</span>) args.<span class="literal">get</span>(<span class="number">0</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">root.put(<span class="string">"indexOf"</span>, <span class="keyword">new</span> IndexOfMethod());</span><br></pre></td></tr></table></figure>
<p>在模板中调用<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">#</span><span class="built_in">assign</span> x = <span class="string">"something"</span>&gt;</span><br><span class="line">$&#123;indexOf<span class="params">(<span class="string">"met"</span>, x)</span>&#125;</span><br><span class="line">$&#123;indexOf<span class="params">(<span class="string">"foo"</span>, x)</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="指令">指令</h3><p>可以使用 TemplateDirectiveModel 接口在 Java 代码中实现自定义指令。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * FreeMarker 的用户自定义指令在逐步改变 它嵌套内容的输出转换为大写形式</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * &lt;b&gt;指令内容&lt;/b&gt;</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 指令参数：无</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 循环变量：无</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 指令嵌套内容：是</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">UpperDirective</span> <span class="title">implements</span> <span class="title">TemplateDirectiveModel</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Environment env, Map <span class="keyword">params</span>, TemplateModel[] loopVars,</span><br><span class="line">			TemplateDirectiveBody body</span>) throws TemplateException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 检查参数是否传入</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">params</span>.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TemplateModelException(<span class="string">"This directive doesn't allow parameters."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (loopVars.length != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TemplateModelException(<span class="string">"This directive doesn't allow loop variables."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 是否有非空的嵌入内容</span></span><br><span class="line">		<span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 执行嵌入体部分，和 FTL 中的&lt;#nested&gt;一样，除了</span></span><br><span class="line">			<span class="comment">// 我们使用我们自己的 writer 来代替当前的 output writer.</span></span><br><span class="line">			body.render(<span class="keyword">new</span> UpperCaseFilterWriter(env.getOut()));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"missing body"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * &#123;@link Writer&#125;改变字符流到大写形式， 而且把它发送到另外一个&#123;@link Writer&#125;中。</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UpperCaseFilterWriter</span> <span class="title">extends</span> <span class="title">Writer</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> final Writer <span class="keyword">out</span>;</span><br><span class="line">		UpperCaseFilterWriter(Writer <span class="keyword">out</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">out</span> = <span class="keyword">out</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>(<span class="params"><span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len</span>) throws IOException </span>&#123;</span><br><span class="line">			<span class="keyword">char</span>[] transformedCbuf = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">				transformedCbuf[i] = Character.toUpperCase(cbuf[i + off]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">out</span>.write(transformedCbuf);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span>(<span class="params"></span>) throws IOException </span>&#123;</span><br><span class="line">			<span class="keyword">out</span>.flush();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span>(<span class="params"></span>) throws IOException </span>&#123;</span><br><span class="line">			<span class="keyword">out</span>.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">root.put(<span class="string">"upper"</span>, <span class="keyword">new</span> UpperDirective());</span><br></pre></td></tr></table></figure>
<p>然后在模板中使用<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[@<span class="atom">upper</span>]</span><br><span class="line"><span class="atom">hello</span> <span class="atom">world</span>!</span><br><span class="line">[#<span class="atom">list</span> [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"white"</span>,<span class="string">"black"</span>] <span class="atom">as</span> <span class="atom">color</span>]</span><br><span class="line">$&#123;<span class="atom">color</span>&#125;</span><br><span class="line">[/#<span class="atom">list</span>]</span><br><span class="line">[/@<span class="atom">upper</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="节点">节点</h3><p>节点变量有下列属性， 它们都由 TemplateNodeModel 接口的方法提供。</p>
<ul>
<li>基本属性：<ul>
<li>TemplateSequenceModel getChildNodes()：一个节点的子节点序列（除非这个节点是叶子节点，这时方法返回一个空序列或者是 null）。子节点本身应该也是节点变量。</li>
<li>TemplateNodeModel getParentNode()：一个节点只有一个父节点（除非这个节点是节点树的根节点，这时方法返回 null）。</li>
</ul>
</li>
<li>可选属性。如果一个属性在具体的使用中没有意义，那对应的方法应该返回 null：<ul>
<li>String getNodeName()：节点名称也是宏的名称，当使用 recurse和 visit 指令时，它用来控制节点。因此， 如果想通过节点使用这些指令，那么节点的名称是必须的。</li>
<li>String getNodeType()：在 XML 技术中： “element”， “text”，”comment”等类型。 如果这些信息可用，就是通过 recurse 和 visit 指令来查找节点的默认处理宏。而且，它对其他有具体用途的应用程序也是有用的。</li>
<li>String getNamespaceURI()：这个节点所属的命名空间（和用于库的 FTL 命名空间无关）。例如，在 XML 中，这就是元素和属性所属 XML 命名空间的 URI。 这个信息如果可用，就是通过 recurse 和 visit 指令来查找存储控制宏的 FTL 命名空间。</li>
</ul>
</li>
</ul>
<p>在 FTL 这里，节点属性的直接使用可以通过内建函数 node 完成， 还有 visit 和 recurse 宏。</p>
<h3 id="对象包装">对象包装</h3><p>Template.process()可以接收任何Java对象，不一定是TemplateModel，因为末班实现是会用合适的TemplateModel对象来替换原有对象。替换在获取自变量时必须会发生，因为getter方法返回TemplateModel，而不是Object。</p>
<p>替换策略通过ObjectWrapper实现，</p>
<ul>
<li>ObjectWrapper.DEFAULT_WRAPPER：它使用 SimpleScalar 来替换String， SimpleNumber 来替换 Number， SimpleSequence 来替换 List和数组，SimpleHash 来替换Map，TemplateBooleanModel.TRUE 或 TemplateBooleanModel.FALSE 来替换 Boolean，freemarker.ext.dom.NodeModel 来替换 W3C 组织定义的 DOM 模型节点类型。对于Jython 类型的对象，包装器会调用 freemarker.ext.jython.JythonWrapper。而对于其他对象，则会调用 BEAN_WRAPPER。</li>
<li>ObjectWrapper.BEANS_WRAPPER：它可以通过 Java 的反射机制来获取到Java Bean 的属性和其他任意对象类型的成员变量。</li>
</ul>
<p>如果在数据模型中放了任意的对象，那么DEFAULT_WRAPPER 就会调用BEANS_WRAPPER 来包装这个对象</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.put(<span class="string">"person"</span>, new <span class="keyword">Person</span>(1, <span class="string">"Jack"</span>));</span><br></pre></td></tr></table></figure>
<p>Person类有两个字段id和name。这里Person类必须是public的，而且字段需要提供getter方法。如果还有公开方法，那么公开方法名不能和字段名相同。否则会抛出异常。</p>
<h2 id="配置">配置</h2><p>配置对象是freemarker.template.Configuration 的实例，可以通过构造方法来创建它。一个应用程序通常只使用一个共享的 Configuration 实例。</p>
<h3 id="共享变量">共享变量</h3><p>Shared variables 共享变量是为所有模板所定义的变量。可以使用setSharedVariable 方法向配置实例中添加共享变量。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfg.setSharedVariable<span class="params">(<span class="string">"wrap"</span>, new WrapDirective<span class="params">()</span>)</span>;</span><br><span class="line">cfg.setSharedVariable<span class="params">(<span class="string">"company"</span>, <span class="string">"Foo Inc."</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>如果配置对象在多线程环境中使用，不要使用 TemplateModel 实现类来作为共享变量，因为它是线程不安全的。这也是基于 Servlet 的 Web 站点的典型情况。</p>
<h3 id="配置信息">配置信息</h3><p>Settings 配置信息是影响 FreeMarker 行为的已经被命名的值。</p>
<p>Environment中能覆盖Template中的配置信息，Template中能覆盖Configuration中的配置信息。</p>
<p>Configuration可以通过setter方法或setSetting方法设置配置信息。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myCfg.setLocale<span class="params">(java.util.Locale.ITALY)</span>;</span><br><span class="line">myCfg.setNumberFormat<span class="params">(<span class="string">"0.####"</span>)</span>;</span><br><span class="line">myCfg.setSetting<span class="params">(<span class="string">"locale"</span>,<span class="string">"it_IT"</span>)</span>;</span><br><span class="line">myCfg.setSetting<span class="params">(<span class="string">"number_format"</span>,<span class="string">"0.####"</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>Template层不需要设置配置信息。</p>
<p>Environment层这里有两种设置方法</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Environment <span class="keyword">env</span> =</span><br><span class="line">myTemplate.createProcessingEnvironment(root, out);</span><br><span class="line"><span class="keyword">env</span>.setLocale(java.util.Locale.ITALY);</span><br><span class="line"><span class="keyword">env</span>.setNumberFormat(<span class="string">"0.####"</span>);</span><br><span class="line"><span class="keyword">env</span>.process(); <span class="comment">// 处理模板</span></span><br></pre></td></tr></table></figure>
<p>或在模板中直接使用指令<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="id">#setting</span> locale=<span class="string">"it_IT"</span>&gt;</span><br><span class="line">&lt;<span class="id">#setting</span> number_format=<span class="string">"0.####"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="模板加载">模板加载</h3><h4 id="内建模板加载器">内建模板加载器</h4><p>在 Configuration 中可以使用下面的方法来方便建立三种模板加载。（每种方法都会在其内部新建一个模板加载器对象，然后创建 Configuration 实例来使用它。）</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDirectoryForTemplateLoading</span><span class="params">(File dir)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setClassForTemplateLoading</span><span class="params">(Class cl, String prefix)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setServletContextForTemplateLoading</span><span class="params">(Object servletContext, String path)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述的第一种方法在磁盘的文件系统上设置了一个明确的目录，它确定了从哪里加载模板。</p>
<p>第二种调用方法使用了一个 Class 类型的参数和一个前缀。这是让你来指定什么时候通过相同的机制来加载模板，不过是用 Java 的 ClassLoader 来加载类。 这就意味着传入的 Class 参数会被用来调用 Class.getResource()方法来找到模板。参数 prefix是给模板的名称来加前缀的。在实际运行的环境中，类加载机制是首选用来加载模板的方法，因为通常情况下，从类路径下加载文件的这种机制， 要比从文件系统的特定目录位置加载安全而且简单。 在最终的应用程序中，所有代码都使用.jar 文件打包也是不错的，这样用户就可以直接执行包含所有资源的.jar 文件了。</p>
<p>第三种调用方式需要 Web 应用的上下文和一个基路径作为参数，这个基路径是 Web 应用根路径（ WEB-INF 目录的上级目录）的相对路径。那么加载器将会从 Web 应用目录开始加载模板。尽管加载方法对没有打包的.war 文件起作用，因为它使用了ServletContext.getResource()方法来访问模板，注意这里我们指的是“目录”。</p>
<h4 id="从多个位置加载">从多个位置加载</h4><p>如果需要从多个位置加载模板，那就不得不为每个位置都实例化模板加载器对象，将它们包装到一个被成为 MultiTemplateLoader 的特殊模板加载器</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileTemplateLoader</span> ftl1 = <span class="keyword">new</span> <span class="type">FileTemplateLoader</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"/tmp/templates"</span>));</span><br><span class="line"><span class="type">FileTemplateLoader</span> ftl2 = <span class="keyword">new</span> <span class="type">FileTemplateLoader</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"/usr/data/templates"</span>));</span><br><span class="line"><span class="type">ClassTemplateLoader</span> ctl = <span class="keyword">new</span> <span class="type">ClassTemplateLoader</span>(getClass<span class="literal">()</span>, <span class="string">""</span>);</span><br><span class="line"><span class="type">TemplateLoader</span><span class="literal">[]</span> loaders = <span class="keyword">new</span> <span class="type">TemplateLoader</span><span class="literal">[]</span> &#123; ftl1, ftl2, ctl &#125;;</span><br><span class="line"><span class="type">MultiTemplateLoader</span> mtl = <span class="keyword">new</span> <span class="type">MultiTemplateLoader</span>(loaders);</span><br><span class="line">cfg.setTemplateLoader(mtl);</span><br></pre></td></tr></table></figure>
<p>FreeMarker 将会尝试从/tmp/templates 目录加载模板，如果在这个目录下没有发现请求的模板，它就会继续尝试从/usr/data/templates 目录下加载，如果还是没有发现请求的模板，那么它就会使用类加载器来加载模板。</p>
<h4 id="从其他资源加载模板">从其他资源加载模板</h4><p>需要自己实现加载器实现freemarker.cache.TemplateLoader 或freemarker.cache.URLTemplateLoader 接口</p>
<h4 id="模板路径">模板路径</h4><p>强烈建议模板加载器使用 URL 风格的路径</p>
<h3 id="模板缓存">模板缓存</h3><p>FreeMarker 是会缓存模板的（假设使用 Configuration 对象的方法来创建 Template 对象）。这就是说当调用 getTemplate 方法时， FreeMarker 不但返回了Template 对象的结果，而且还会将它存储在缓存中，当下一次再以相同（或相等）路径调用 getTemplate 方法时，那么它只返回缓存的 Template 实例， 而不会再次加载和解析模板文件了。</p>
<p>如果更改了模板文件，当下次调用模板时， FreeMarker 将会自动重新载入和解析模板。然而，要检查模板文件是否改变内容了是需要时间的，有一个 Configuration 级别的设置被称作为“更新延迟”可以用来配置这个时间。这个时间就是从上次对某个模板检查更新后， FreeMarker 再次检查模板所要间隔的时间。 其默认值是 5 秒。如果想要看到模板立即更新的效果，那么就要把它设置为 0。要注意某些模板加载器也许在模板更新时可能会有问题。例如，典型的例子就是在基于类加载器的模板加载器就不会注意到模板文件内容的改变。</p>
<p>当调用了 getTemplate 方法时，与此同时 FreeMarker 意识到这个模板文件已经被<br>移除了，所以这个模板也会从缓存中移除。 如果 Java 虚拟机认为会有内存溢出时，默认情况它会将任意的模板从缓存中移除。此外，你还可以使用 Configuration 对象的clearTemplateCache 方法手动清空缓存。</p>
<p>何时将一个被缓存了的模板清除的实际应用策略是由配置的属性 cache_storage来确定的，通过这个属性可以配置任何 CacheStorage 的实现。对于大多数用户来说，使用 freemarker.cache.MruCacheStorage 就足够了。这个缓存存储实现了二级最近使用的缓存。在第一级缓存中，组件都被强烈引用到特定的最大数目（引用次数最多的组件不会被 Java 虚拟机抛弃，而引用次数很少的组件则相反）。当超过最大数量时，最近最少使用的组件将被送至二级缓存中，在那里它们被很少引用，直到达到另一个最大的数目。引用强度的大小可以由构造方法来指定。例如，设置强烈部分为 20，轻微部分为 250：</p>
<p>或者，使用 MruCacheStorage 缓存，它是默认的缓存存储实现。当创建了一个新的 Configuration 对象时，它使用一个 maxStrongSize 值为0 的 MruCacheStorage 缓存来初始化，maxSoftSize 的值是Integer.MAX_VALUE（也就是说在实际中，是无限大 的）。 但是使用非 0 的 maxStrongSize 对于高负载的服务器来说也许是一个更好的策略，对于少量引用的组件来说，如果资源消耗已经很高的话， Java 虚拟机往往会引发更高的资源消耗，因为它不断从缓存中抛出经常使用的模板，这些模板还不得不再次加载和解析。</p>
<h3 id="错误控制">错误控制</h3><h4 id="可能的异常">可能的异常</h4><p>当加载和解析模板时发生异常： 调用了 Configuration.getTemplate(…) 方法， FreeMarker 就要把模板文件加载到内存中然后来解析它（除非模板已经在Configuration 对象中被缓存了）。 在这期间，有两种异常可能发生：</p>
<ul>
<li>因模板文件没有找到而发生的 IOException 异常，或在读取文件时发生其他的 I/O 问题。比如没有读取文件的权限，或者是磁盘错误。这些错误的发出者是TemplateLoader 对象，可以将它设置到 Configuration 对象中。（为了正确起见：这里所说的”文件”，是简化形式。例如，模板也可以存储在关系型数据库的表中。这是 TemplateLoader 所要做的事。）</li>
<li>根据FTL语言的规则，模板文件发生语法错误时会导致 freemarker.core.ParseException 异常。当获得 Template 对象（ Configuration.getTemplate(…)）时，这种错误就会发生，而不是当执行（Template.process(…) ）模板的时候。这种异常是IOException 异常的一个子类。</li>
</ul>
<p>当执行（处理）模板时发生的异常，也就是当调用了 Template.process(…)方法时会发生的两种异常：</p>
<ul>
<li>当试图写入输出对象时发生错误而导致的 IOException 异常。</li>
<li>当执行模板时发生的其它问题而导致的freemarker.template.TemplatException 异常。比如，一个频繁发生的错误，就是当模板引用一个不存在的变量。默认情况下，当TemplatException 异常发生时， FreeMarker 会用普通文本格式在输出中打印出 FTL 的错误信息和堆栈跟踪信息。然后通过再次抛出 TemplatException异常而中止模板的执行，然后就可以捕捉到 Template.process(…)方法抛出的异常了。而这种行为是可以来定制的。FreeMarker也会经常写 TemplatException 异常的日志。</li>
</ul>
<h4 id="根据_TemplateException_来制定处理方式">根据 TemplateException 来制定处理方式</h4><p>Configuration中通过setTemplateExceptionHandler可以制定处理方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTemplateExceptionHandler</span> <span class="keyword">implements</span> <span class="title">TemplateExceptionHandler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTemplateException</span><span class="params">(TemplateException te, Environment env,</span><br><span class="line">			java.io.Writer out)</span> <span class="keyword">throws</span> TemplateException </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			out.write(<span class="string">"[ERROR: "</span> + te.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TemplateException(<span class="string">"Failed to print error message. Cause: "</span> + e, env);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">cfg.setTemplateExceptionHandler(<span class="keyword">new</span> MyTemplateExceptionHandler());</span><br></pre></td></tr></table></figure>
<p>FreeMarker 本身带有这些预先编写的错误控制器：</p>
<ul>
<li>TemplateExceptionHandler.DEBUG_HANDLER：打印堆栈跟踪信息（包括 FTL 错误信息和 FTL 堆栈跟踪信息）和重新抛出的异常。这是默认的异常控制器（也就是说，在所有新的 Configuration 对象中，它是初始配置的）。</li>
<li>TemplateExceptionHandler.HTML_DEBUG_HANDLER：DEBUG_HANDLER 相同，但是它可以格式化堆栈跟踪信息，那么就可以在 Web 浏览器中来阅读错误信息。当你在制作 HTML 页面时，建议使用它而不是DEBUG_HANDLER。</li>
<li>TemplateExceptionHandler.IGNORE_HANDLER：简单地压制所有异常（但是要记住， FreeMarker 仍然会写日志）。它对处理异常没有任何作用，也不会重新抛出异常。</li>
<li>TemplateExceptionHandler.RETHROW_HANDLER：简单重新抛出所有异常而不会做其它的事情。这个控制器对 Web 应用程序（假设你在发生异常之后不想继续执行模板）来说非常好，因为它在生成的页面发生错误的情况下，给了你很多对 Web应用程序的控制权。</li>
</ul>
<h4 id="在模板中明确地处理错误">在模板中明确地处理错误</h4><p>你可以在模板中直接控制错误。通常这不是一个好习惯（尽量保持模板简单，技术含量不要太高），但有时仍然需要：</p>
<ul>
<li>控制不存在/为空的变量：请阅读模板开发指南/模板/表达式/处理不存在的值部分。</li>
<li>在发生障碍的“ porlets” 中留存下来</li>
</ul>
<h2 id="其他">其他</h2><h3 id="变量">变量</h3><p>当你想要读取一个变量时， FreeMarker 将会以这种顺序来查找，直到发现了完全匹配的的变量名称才会停下来</p>
<ol>
<li>在 Environment 对象中：<ol>
<li>如果在循环中，在循环变量的集合中。循环变量是由 （ 如 list 指令）来创建的。</li>
<li>如果在宏中，在宏的局部变量集合中。局部变量可以由 local 指令创建。而且，宏的参数也是局部变量。</li>
<li>在当前的命名空间中。可以使用 assign 指令将变量放到一个命名空间中。</li>
<li>在由 global 指令创建的变量集合中。FTL 将它们视为数据模型的普通成员变量一样来控制它们。也就是说，它们在所有的命名空间中都可见，你也可以像访问一个数据模型中的数据一样来访问它们。</li>
</ol>
</li>
<li>在传递给 process 方法的数据模型对象中。</li>
<li>在 Configuration 对象存储的共享变量集合中。</li>
</ol>
<p>1.4, 2,3 共同构成了全局变量的集合</p>
<h3 id="编码">编码</h3><p>输入编码</p>
<p>可以使用配置对象的setEncoding(Locale locale, String encoding)方法来填充编码表；编码表初始化时是空的。默认的初始编码是系统属性 file.encoding 的值，但是可以通过 setDefaultEncoding 方法来设置一个不同的默认值。</p>
<p>输出编码</p>
<p>原则上， FreeMarker 不处理输出内容的字符集问题，因为 FreeMarker 将输出内容都写入了 java.io.Writer 对象中。而 Writer 对象是由封装了 FreeMarker（比如 Web应用框架）的软件生成的，那么输出内容的字符集就是由封装软件来控制的。而 FreeMarker有一个称为 output_encoding（开始于 FreeMarker 2.3.1 版本之后）的设置。封装软件应该使用这个设置（ Writer 对象使用的字符集） 来通知 FreeMarker 在输出中（ 否则 FreeMarker 不能找到它）使用哪种字符集。 </p>
<p>为独立模板设置编码</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Writer</span> w = new <span class="type">OutputStreamWriter</span>(<span class="keyword">out</span>, outputCharset);</span><br><span class="line"><span class="type">Environment</span> env = <span class="keyword">template</span>.createProcessingEnvironment(dataModel, w);</span><br><span class="line">env.setOutputEncoding(outputCharset);</span><br><span class="line">env.process();</span><br></pre></td></tr></table></figure>
<h3 id="多线程">多线程</h3><p>在多线程运行环境中， Configuration 实例， Template 实例和数据模型应该是永远不能改变（只读）的对象。也就是说， 创建和初始化它们（如使用 set…方法） 之后， 就不能再修改它们了（ 比如不能再次调用 set…方法）。 </p>
<p>不鼓励你编写修改数据模型对象或共享变量的方法。多试试使用存储在环境对象（这个对象是为独立的 Template.process 调用而创建的，用来存储模板处理的运行状态）中的变量，所以最好不要修改那些由多线程使用的数据。</p>
<h3 id="Bean_的包装">Bean 的包装</h3><p>当 出 现 下 面 这 些 情 况 时 ， 你 会 想 使 用 BeansWrapper 包 装 器 来 代 替 DefaultObjectWrapper：<br>在模板执行期间，数据模型中的 Collection 和 Map 应该被允许修改。（ DefaultObjectWrapper 会阻止这样做，因为当它包装对象时创建了数据集合的拷贝，而这些拷贝都是只读的。）<br>如果 array， Collection 和 Map 对象的标识符当在模板中被传递到被包装对象的方法时，必须被保留下来。 也就是说，那些方法必须得到之前包装好的同类对象。<br>如果在之前列出的 Java API 中的类（ 如 String， Map， List 等），应该在模板中可见。还有，默认情况下它们是不可见的，但是可以设置获取的可见程度</p>
<h4 id="安全性">安全性</h4><p>默认情况下，不能访问模板制作时认为是不安全的一些方法。比如，不能使用同步方法（ wait， notify， notifyAll），线程和线程组的管理方法（ stop， suspend，resume， setDaemon ， setPriority ），反射相关方法（ Field setXxx ，Method.invoke， Constructor.newInstance， Class.newInstance，Class.getClassLoader 等）， System 和 Runtime 类中各种有危险性的方法（ exec， exit， halt， load 等）。 BeansWrapper 也有一些安全级别（被称作“方法暴露的级别”）， 默认的级别被称作为 EXPOSE_SAFE，它可能对大多数应用程序来说是适用的。没有安全保证的级别称作是 EXPOSE_ALL，它允许你调用上述的不安全的方法。一个严格的级别是 EXPOSE_PROPERTIES_ONLY，它只会暴露出 bean 属性的 getters方法。最后，一个称作是 EXPOSE_NOTHING 的级别，它不会暴露任何属性和方法。这种情况下，你可以通过哈希表模型接口访问的那些数据只是 map 和资源包中的项，还有，可以从通用 get(Object) 方法和 get(String)方法调用返回的对象，所提供的受影响的对象就有这样的方法。</p>
<h4 id="访问静态变量">访问静态变量</h4><p>从 BeansWrapper.getStaticModels() 方法返回的 TemplateHashModel 对象可以用来创建哈希表模型来访问静态方法和任意类型的字段。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BeansWrapper wrapper = BeansWrapper.getDefaultInstance<span class="params">()</span>;</span><br><span class="line">TemplateHashModel staticModels = wrapper.getStaticModels<span class="params">()</span>;</span><br><span class="line">TemplateHashModel fileStatics = <span class="params">(TemplateHashModel)</span> staticModels.get<span class="params">(<span class="string">"java.io.File"</span>)</span>;</span><br><span class="line">root.put<span class="params">(<span class="string">"File"</span>, fileStatics)</span>;</span><br></pre></td></tr></table></figure></p>
<p>模板中使用<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="id">#list</span> File.<span class="function"><span class="title">listRoots</span><span class="params">()</span></span> as fileSystemRoot&gt;...&lt;/#list&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果使用，将带来更多自由<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.put<span class="params">(<span class="string">"statics"</span>, BeansWrapper.getDefaultInstance<span class="params">()</span>.getStaticModels<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>可以这样使用<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;</span>statics[<span class="string">"java.lang.System"</span>].currentTimeMillis()&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这样会有更多的安全隐患，比如，如果方法暴露级别对 EXPOSE_ALL 是很弱的，那么某些人可以使用这个模型调用 System.exit()方法。</p>
<h4 id="访问枚举类型">访问枚举类型</h4><p>BeansWrapper.getDefaultInstance()返回的对象可以被用作创建访问枚举类型值的哈希表模型</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BeansWrapper wrapper = BeansWrapper.getDefaultInstance<span class="params">()</span>;</span><br><span class="line">TemplateHashModel enumModels = wrapper.getEnumModels<span class="params">()</span>;</span><br><span class="line">TemplateHashModel roundingModeEnums = <span class="params">(TemplateHashModel)</span>enumModels.get<span class="params">(<span class="string">"java.math.RoundingMode"</span>)</span>;</span><br><span class="line">root.put<span class="params">(<span class="string">"RoundingMode"</span>, roundingModeEnums)</span>;</span><br></pre></td></tr></table></figure>
<p>使用<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">RoundingMode</span><span class="class">.UP</span></span><br></pre></td></tr></table></figure></p>
<p>更自由的方式<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.put<span class="params">(<span class="string">"enums"</span>, BeansWrapper.getDefaultInstance<span class="params">()</span>.getEnumModels<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>使用</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;</span>enums[<span class="string">"java.math.RoundingMode"</span>].<span class="constant">UP&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="日志">日志</h3><p>默认情况下， FreeMarker 会按如下顺序来查找日志包，而且会自动使用第一个发现的包： SLF4J，Apache Commons Logging，Log4J，Avalon， java.util.logging。 然而，如果在 freemarker.log.Logger 类用合适的参数中调用静态的 selectLoggerLibrary 方法，而且在使用任何 FreeMarker 类之前记录信息，你可以明确地选择一个日志包，或者关闭日志功能。</p>
<h3 id="在_Servlet_中使用_FreeMarker">在 Servlet 中使用 FreeMarker</h3><ol>
<li>复制 freemarker.jar 到（从 FreeMarker 发布包的 lib 目录中）你的 Web<br>应用程序的 WEB-INF/lib 目录下。</li>
<li>将下面的部分添加到 Web 应用程序的 WEB-INF/web.xml 文件中（调整它是否<br>需要）。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span></span><br><span class="line">freemarker.ext.servlet.FreemarkerServlet</span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- FreemarkerServlet 设置: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>TemplatePath<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>/<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>NoCache<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>ContentType<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>text/html; charset=UTF-8<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 强制使用 UTF-8 作为输出编码格式! --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- FreeMarker 设置: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>template_update_delay<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 0 只对开发使用! 否则使用大一点的值. --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>default_encoding<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>ISO-8859-1<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 模板文件的编码方式. --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>number_format<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>0.##########<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="title">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>*.ftl<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- 为了阻止从 Servlet 容器外部访问 MVC 的视图层组件。</span><br><span class="line">RequestDispatcher.forward/include 应该起到作用。</span><br><span class="line">移除下面的代码可能开放安全漏洞!</span><br><span class="line">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">security-constraint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-resource-collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-resource-name</span>&gt;</span></span><br><span class="line">FreeMarker MVC Views</span><br><span class="line"><span class="tag">&lt;/<span class="title">web-resource-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>*.ftl<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-resource-collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">auth-constraint</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 不允许任何人访问这里 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">auth-constraint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">security-constraint</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>它是怎么工作的？让我们来看看 JSP 是怎么工作的。许多 servlet 容器处理 JSP 时使用一个映射为<em>.jsp 的 servlet 请求 URL 格式。 这样 servlet 就会接收所有 URL 是以.jsp结尾的请求，查找请求 URL 地址中的 JSP 文件，内部编译完后交给 Servlet，然后调用 生 成 信 息 的 serlvet 来 生 成 页 面 。 这 里 为 URL 类 型 是 </em>.ftl 映射的 FreemarkerServlet 也是相同功能，只是 FTL 文件不会编译给 Servlet，而是给 Template 对象，之后 Template 对象的 process 方法就会被调用来生成<br>页面。</p>
<p>Freemarker现在页面中寻找变量，其次在 HttpServletRequest中寻找，然后在 HttpSession，最后在ServletContext中</p>
<p>FreemarkerServlet 也会在数据模型中放置 3 个哈希表，这样你就可以直接访问 3 个对象中的属性了。这些哈希表变量是： Request， Session， Application（和ServletContext 对应）。它还会暴露另外一个名为 RequestParameters 的哈希表，这个哈希表提供访问 HTTP 请求中的参数。</p>
<p>FreemarkerServlet 也有很多初始参数。它可以被设置从任意路径来加载模板，从类路径下，或相对于 Web 应用程序的目录。你可以设置模板使用的字符集。你还可以设置想使用的对象包装器等。</p>
<p>通过子类别， FreemarkerServlet 易于定制特殊需要。那就是说，你需要对所有模板添加一个额外的可用变量，使用 servlet 的子类，覆盖 preTemplateProcess()方法，在模板被执行前，将你需要的额外数据放到模型中。或者在 servlet 的子类中，在Configuration 中设置这些全局的变量作为共享变量。</p>
<h4 id="包含其它Web应用程序资源中的内容">包含其它Web应用程序资源中的内容</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">@include_page</span> <span class="attribute">path</span>=<span class="value">"path/to/some.jsp"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>和使用 JSP 指令是相同的：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:<span class="preprocessor">include</span> page=<span class="string">"path/to/some.jsp"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;@include_page ...&gt;</code>会开始一个独立的 HTTP 请求处理。</p>
<p>除了参数 path 之外，你也可以用布尔值（当不指定时默认是 true）指定一个名为 inherit_params 可选的参数来指定被包含的页面对当前的请求是否可见 HTTP 请求中的参数。</p>
<p>最后，你可以指定一个名为 params 的可选参数，来指定被包含页面可见的新请求参数。 如果也传递继承的参数，那么指定参数的值将会得到前缀名称相同的继承参数的值。params 的值必须是一个哈希表类型，它其中的每个值可以是字符串，或者是字符串序列（如果你需要多值参数）。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;@include_page <span class="variable">path=</span><span class="string">"path/to/some.jsp"</span> <span class="variable">inherit_params=</span><span class="constant">true</span> <span class="variable">params=</span>&#123;<span class="string">"foo"</span>: <span class="string">"99"</span>, <span class="string">"bar"</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>]&#125;/&gt;</span><br></pre></td></tr></table></figure>
<p>如果“foo”有值“111”和“123”，那么现在它会有“99”，“111”，“123”。</p>
<h4 id="在_FTL_中使用_JSP_客户化标签">在 FTL 中使用 JSP 客户化标签</h4><p>FreemarkerServlet 将一个哈希表类型的 JspTaglibs 放到数据模型中，就可以使用它来访问 JSP 标签库了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="id">#assign</span> html=JspTaglibs[<span class="string">"/WEB-INF/struts-html.tld"</span>]&gt;</span><br><span class="line">&lt;<span class="id">#assign</span> bean=JspTaglibs[<span class="string">"/WEB-INF/struts-bean.tld"</span>]&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;&lt;@bean<span class="class">.message</span> key=<span class="string">"welcome.title"</span>/&gt;&lt;/h1&gt;</span><br><span class="line">&lt;@<span class="tag">html</span>.errors/&gt;</span><br><span class="line">&lt;@<span class="tag">html</span><span class="class">.form</span> action=<span class="string">"/query"</span>&gt;</span><br><span class="line">Keyword: &lt;@<span class="tag">html</span><span class="class">.text</span> property=<span class="string">"keyword"</span>/&gt;&lt;br&gt;</span><br><span class="line">Exclude: &lt;@<span class="tag">html</span><span class="class">.text</span> property=<span class="string">"exclude"</span>/&gt;&lt;br&gt;</span><br><span class="line">&lt;@<span class="tag">html</span><span class="class">.submit</span> value=<span class="string">"Send"</span>/&gt;</span><br><span class="line">&lt;/@<span class="tag">html</span>.form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>因为 JSP 客户化标签是在 JSP 环境中来书写操作的，它们假设变量（在 JSP 中常被指代“beans”）被存储在 4 个范围中： page 范围， request 范围， session 范围和 application 范围。FTL 没有这样的表示法（ 4 种范围），但是 FreemarkerServlet 给客户化标签提供仿真的环境，这样就可以维持 JSP 范围中的“ beans”和 FTL 变量之间的对应关系。对于自定义的JSP标签，请求，会话和应用范围是和真实JSP相同的：javax.servlet.ServletContext，HttpSession 和 ServerRequest 对象中的属性。从 FTL 的角度来看，这三种范围都在数据模型中</p>
]]></content>
    <summary type="html">
    <![CDATA[FreeMarker;Java模板引擎;程序开发]]>
    
    </summary>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/tags/FreeMarker/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/categories/Java/FreeMarker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FreeMarker-模板开发笔记]]></title>
    <link href="http://howiefh.github.io/2015/04/30/freemarker-template-development-note/"/>
    <id>http://howiefh.github.io/2015/04/30/freemarker-template-development-note/</id>
    <published>2015-04-30T01:19:31.000Z</published>
    <updated>2015-05-21T15:56:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概览">概览</h2><h3 id="if">if</h3><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">Welcome</span> <span class="char">$&#123;</span>user&#125;&lt;<span class="symbol">#if</span> user == <span class="comment">"Big Joe"</span>&gt;, our beloved leader&lt;/<span class="symbol">#if</span>&gt;!</span><br></pre></td></tr></table></figure>
<h3 id="list">list</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">animals</span> <span class="attribute">as</span> <span class="attribute">being</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>$&#123;being.name&#125;<span class="tag">&lt;<span class="title">td</span>&gt;</span>$&#123;being.price&#125; Euros</span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="include">include</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">#<span class="keyword">include</span> "/copyright_footer.html"&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="数值和类型">数值和类型</h2><h3 id="支持的类型">支持的类型</h3><ul>
<li>标量：<ul>
<li>字符串</li>
<li>数字</li>
<li>布尔值</li>
<li>日期</li>
</ul>
</li>
<li>容器：<ul>
<li>哈希表</li>
<li>序列</li>
<li>集</li>
</ul>
</li>
<li>子程序：<ul>
<li>方法和函数：方法是来自于数据模型（它们反射了 Java 对象的方法），而函数是定义在模板内的（使用了函数指令-这也是高级主题），但二者可以用同一种方式来使用。内置的方法<code>${avg(6, 10, 20)}</code></li>
<li>用户自定义指令：按经验来说，如果能够实现，请先用自定义指令而不要用函数/方法。 <code>&lt;@box title=&quot;Attention!&quot;&gt; hello &lt;/@box&gt;</code></li>
</ul>
</li>
<li>其它/很少使用：<ul>
<li>节点</li>
</ul>
</li>
</ul>
<h2 id="模板">模板</h2><p>模板（ FTL 编程）是由如下部分混合而成的：</p>
<ul>
<li>Text 文本：文本会照着原样来输出。</li>
<li>Interpolation 插值： 这部分的输出会被计算的值来替换。插值由${和}所分隔（或者#{和}，这种风格已经不建议再使用了）。</li>
<li>FTL tags 标签： FTL 标签和 HTML 标签很相似，但是它们却是给 FreeMarker 的指示， 而且不会打印在输出内容中。</li>
<li>Comments 注释： FTL 的注释和 HTML 的注释也很相似，但它们是由<code>&lt;#--</code>和<code>--&gt;</code>来分隔的。注释会被 FreeMarker 所忽略，更不会在输出内容中显示。</li>
</ul>
<p>FTL 标签不可以在其他 FTL 标签和插值中使用。下面这样写就是错的：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="id">#if</span> &lt;<span class="id">#include</span> <span class="string">'foo'</span>&gt;=<span class="string">'bar'</span>&gt;...&lt;/#<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>注释可以放在 FTL 标签和插值中间。<br>插值可以在文本区域和字符串中出现，但是不能在标签中使用<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;#if $&#123;isBig&#125;&gt;</span><span class="tag">&lt;/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的就是错误的，正确的应该这样写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">#<span class="keyword">if</span> isBig&gt;&lt;/<span class="keyword">if</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>FreeMarker可以忽略标签、插值内的空格，但是<code>&lt;</code>、<code>&lt;\</code>和指令之间的空格不能忽略</p>
<h3 id="快速浏览">快速浏览</h3><ul>
<li>直接指定值<ul>
<li>字符串： “Foo” 或者 ‘Foo’ 或者 “It’s \”quoted\”” 或者<br>r”C:\raw\string”</li>
<li>数字： 123.45</li>
<li>布尔值： true, false</li>
<li>序列： [“foo”, “bar”, 123.45], 1..100</li>
<li>哈希表： {“name”:”green mouse”, “price”:150}</li>
</ul>
</li>
<li>检索变量<ul>
<li>顶层变量： user</li>
<li>从哈希表中检索数据： user.name, user[“name”]</li>
<li>从序列中检索： products[5]</li>
<li>特殊变量： .main  。 特殊变量是由 FreeMarker 引擎本身定义的，为了使用它们，可以按照如下语法形式来进行： .variable_name。</li>
</ul>
</li>
<li>字符串操作<ul>
<li>插值（ 或连接）： “Hello ${user}!”（或”Free” + “Marker”）</li>
<li>获取一个字符： name[0]</li>
</ul>
</li>
<li>序列操作<ul>
<li>连接： users + [“guest”]</li>
<li>序列切分： products[10..19] 或 products[5..]</li>
</ul>
</li>
<li>哈希表操作<ul>
<li>连接： passwords + {“joe”:”secret42”}</li>
</ul>
</li>
<li>算数运算: (x * 1.5 + 10) / 2 - y % 100</li>
<li>比较运算 ： <code>x == y, x != y, x &lt; y, x &gt; y, x &gt;= y, x &lt;= y, x &amp;lt; y,</code> 等等</li>
<li>逻辑操作： !registered &amp;&amp; (firstVisit || fromEurope)</li>
<li>内建函数： name?upper_case</li>
<li>方法调用： repeat(“What”, 3)</li>
<li>处理不存在的值<ul>
<li>默认值： name!”unknown” 或者(user.name)!”unknown” 或者<br>name! 或者 (user.name)!</li>
<li>检测不存在的值： name?? 或者(user.name)??</li>
</ul>
</li>
<li>运算符的优先级</li>
</ul>
<p>最高优先级运算符:  [subvarName][subStringRange].?(methodParams)<br>一元前缀运算符: +expr -expr !expr<br>乘除法，求模: * / %<br>加减法: + -<br>关系运算符: <code>&lt; &gt; &lt;= &gt;= (相当于: gt, lt, 等)</code><br>相等，不等: == (也可以是: =) !=<br>逻辑与: &amp;&amp;<br>逻辑或: ||<br>数字范围: ..</p>
<h3 id="字符串">字符串</h3><p>可以使用转义字符<code>\\</code>、<code>\&quot;</code>等。一种特殊的字符串就是原生字符串。在原生字符串中，反斜杠和${没有特殊的含义，它们被视为普通的字符。 为了表明字符串是原生字符串，在开始的引号或单引号之前放置字母 r，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">r"$&#123;foo&#125;"</span>&#125;</span><br><span class="line">$&#123;<span class="string">r"C:\foo\bar"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>将会打印：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$<span class="list">&#123;foo&#125;</span></span><br><span class="line"><span class="keyword">C</span>:\foo\bar</span><br></pre></td></tr></table></figure></p>
<p>连接<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">"Hello <span class="subst">$&#123;user&#125;</span>!"</span>&#125;</span><br><span class="line">$&#123;<span class="string">"<span class="subst">$&#123;user&#125;</span><span class="subst">$&#123;user&#125;</span><span class="subst">$&#123;user&#125;</span><span class="subst">$&#123;user&#125;</span>"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">"Hello "</span> + <span class="literal">user</span> + <span class="string">"!"</span>&#125;</span><br><span class="line">$&#123;<span class="literal">user</span> + <span class="literal">user</span> + <span class="literal">user</span> + <span class="literal">user</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果上是一样的</p>
<p>可以使用${user[0]}获取某个字符，也可以使用${user[2..5]}和${user[2..]}获取子串</p>
<h3 id="数字">数字</h3><p>数值文字 08, +8, 8.00 和 8 是完全相等的，它们都是数字 8。因此${08}, ${+8}, ${8.00}和${8}打印的都是相同的。</p>
<h3 id="序列">序列</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> [<span class="string">"winter"</span>, <span class="string">"spring"</span>, <span class="string">"summer"</span>, <span class="string">"autumn"</span>] <span class="keyword">as</span> x&gt;</span><br><span class="line"><span class="label">$&#123;x&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure>
<p>列表中的项目是表达式，那么也可以这样做： [2 + 2, [1, 2, 3, 4], “whatnot”]，其中第一个子变量是数字 4，第二个子变量是一个序列，第三个子变量是字符串”whatnot”。<br>也可以用 start..end 定义存储数字范围的序列，这里的 start 和 end 是处理数字值表达式，比如 2..5 和[2, 3, 4, 5]是相同的，但是使用前者会更有效率（ 内存占用少而且速度快）。</p>
<p>序列的连接可以使用+号来进行<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> [<span class="string">"Joe"</span>, <span class="string">"Fred"</span>] + [<span class="string">"Julia"</span>, <span class="string">"Kate"</span>] <span class="keyword">as</span> user&gt;</span><br><span class="line">- <span class="label">$&#123;user&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>序列切分<br>使用 [firstindex..lastindex] 可以获取序列中的一部分，这里的firstindex 和lastindex 表达式的结果是数字。</p>
<h3 id="哈希表">哈希表</h3><p>在模板中指定一个哈希表，就可以遍历用逗号分隔开的“键/值”对，把列表放到花括号内。键和值成对出现并以冒号分隔。看这个例子：{“name”:”green mouse”, “price”:150}。注意到名字和值都是表达式，但是用来检索的名字就必须是字符串类型的。</p>
<p>两种方式从哈希表中检索数据:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">book.name</span></span><br><span class="line"><span class="title">book["name"]</span></span><br></pre></td></tr></table></figure></p>
<p>哈希表也可以使用+连接，如果有相同键，+后面出现的会覆盖之前的<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">#assign</span> <span class="attribute">ages</span> = </span></span><span class="expression">&#123;<span class="string">"Joe"</span>:23, <span class="string">"Fred"</span>:25&#125;</span><span class="xml"><span class="tag"> + </span></span><span class="expression">&#123;<span class="string">"Joe"</span>:30, <span class="string">"Julia"</span>:18&#125;</span><span class="xml"><span class="tag">&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="+、-、*、/、%"><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></h3><p>内建函数int可以取出整数部分<code>${(x/2)?int}</code></p>
<h3 id="比较">比较</h3><p>为了避免大于、小于被当做标签处理，可以用圆括号包含表达式<code>&lt;#if (x&gt;y)&gt;&lt;/if&gt;</code>。也可以用lt、<br>lte、gt、gte来比较</p>
<h2 id="内建函数">内建函数</h2><p>内建函数以?形式提供变量的不同形式或者其他信息。</p>
<ul>
<li>字符串使用的内建函数：<ul>
<li>html: 字符串中所有的特殊 HTML 字符都需要用实体引用来代替（比如<code>&lt;</code>代替&lt;）。</li>
<li>cap_first:字符串的第一个字母变为大写形式</li>
<li>lower_case:字符串的小写形式</li>
<li>upper_case:字符串的大写形式</li>
<li>trim:去掉字符串首尾的空格</li>
</ul>
</li>
<li>序列使用的内建函数：<ul>
<li>size：序列中元素的个数</li>
</ul>
</li>
<li>数字使用的内建函数：<ul>
<li>int:数字的整数部分（比如-1.9?int 就是-1）</li>
</ul>
</li>
</ul>
<h2 id="方法调用">方法调用</h2><ul>
<li>avg求均值</li>
<li>repeat重复输出3次What<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;</span>repeat(<span class="string">"What"</span>, <span class="number">3</span>)&#125;</span><br><span class="line"><span class="variable">$&#123;</span>avg(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="处理不存在的变量">处理不存在的变量</h2><p>一个不存在的变量和一个是 null 的变量， 对于 FreeMarker 来说是一样的，所以这里所指的丢失包含这两种情况。<br>就像下面的例子，当 user 从数据模型中丢失时，模板将会将user 的值表示为字符串”Anonymous”。（若 user 并没有丢失，那么模板就会表现<br>出”Anonymous”不存在一样）：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;h1&gt;</span>Welcome $&#123;<span class="keyword">user</span>!<span class="string">"Anonymous"</span>&#125;!<span class="variable">&lt;/h1&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当然也可以在变量名后面通过放置??来询问 FreeMarker 一个变量是否存在。 将它和 if 指令合并，那么如果 user 变量不存在的话将会忽略整个问候代码段：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;#if user??&gt;</span><span class="variable">&lt;h1&gt;</span>Welcome $&#123;<span class="keyword">user</span>&#125;!<span class="variable">&lt;/h1&gt;</span><span class="variable">&lt;/#if&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>关于多级访问的变量，比 如 animals.python.price，书写代码：animals.python.price!0，仅当 animals.python 存在而仅仅最后一个子变量 price 可能不存在（这种情况下我们假设价格是 0）。 如果 animals 或者 python<br>不存在，那么模板处理过程将会以“未定义的变量”错误而停止。为了防止这种情况的发生，可以这样来书写代码(animals.python.price)!0。这种情况下当 animals 或<br>python 不存在时表达式的结果仍然是 0。 对于??也是同样用来的处理这种逻辑的</p>
<h3 id="默认值">默认值</h3><p>使用形式概览：unsafe_expr!default_expr 或 unsafe_expr! 或 (unsafe_expr)!default_expr 或(unsafe_expr)!</p>
<p>hits!0 或 colors![“red”, “green”, “blue”]</p>
<p>由于 FreeMarker 2.3.x 版本的源码中的小失误所以必须这么来做。 !（作为默认值操作）的优先级非常低。 这就意味着${x!1 + y}会被 FreeMarker 误解为${x!(1 + y)}，而真实的意义是${(x!1) + y}。 这个源码的错误在 FreeMarker 2.4 中会得到修正。</p>
<h2 id="插值">插值</h2><p>字符串<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#escape</span> <span class="attribute">x</span> <span class="attribute">as</span> <span class="attribute">x</span>?<span class="attribute">html</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>Title: $&#123;book.title&#125;<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>Description:</span><br><span class="line"><span class="tag">&lt;<span class="title">#noescape</span>&gt;</span>$&#123;book.description&#125;<span class="tag">&lt;/<span class="title">#noescape</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>Comments:<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">comments</span> <span class="attribute">as</span> <span class="attribute">comment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"comment"</span>&gt;</span></span><br><span class="line">$&#123;comment&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="title">#escape</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果插值在文本区 （也就是说，不再字符串表达式中）， 如果 escapse 指令起作用了，即将被插入的字符串会被自动转义（将&amp;转为&amp;）。如果你要生成 HTML，那么强烈建议你利用它来阻止跨站脚本攻击和非格式良好的 HTML 页面。使用 noescape 可以抵消 escape 的转义。如果你想把所有的输出为大写的话可以x.upper_case</p>
<p>数字</p>
<p>小数的分隔符是根据所在地的标准确定的，如匈牙利的分隔符是<code>,</code>。那么<code>{1.5}</code>会输出<code>1,5</code></p>
<p>可以通过string内置函数来设置输出的格式。</p>
<h2 id="其他">其他</h2><h3 id="自定义指令">自定义指令</h3><p>自定义指令可以使用 macro 指令来定义，这是模板设计者所关心的内容。 Java 程序员若不想在模板中实现定义指令，而是在 Java 语言中实现指令的定义， 这时可以使用freemarker.template.TemplateDirectiveModel 类来扩展</p>
<p>定义宏<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#macro</span> <span class="attribute">greet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">font</span> <span class="attribute">size</span>=<span class="value">"+2"</span>&gt;</span>Hello Joe!<span class="tag">&lt;/<span class="title">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用自定义指令<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;@greet&gt;</span><span class="tag">&lt;/@greet&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;@greet/&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="参数">参数</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro greet <span class="keyword">person</span>&gt;</span><br><span class="line">&lt;font size=<span class="string">"+2"</span>&gt;Hello $&#123;<span class="keyword">person</span>&#125;!&lt;/font&gt;</span><br><span class="line">&lt;/#macro&gt;</span><br></pre></td></tr></table></figure>
<p>使用<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;@greet <span class="keyword">person</span>=<span class="string">"Joe"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">font</span> <span class="attribute">size</span>=<span class="value">"+2"</span>&gt;</span>Hello Joe!<span class="tag">&lt;/<span class="title">font</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用自定义指令提供的参数必须与宏定义的参数对应，如果多于宏定义中的参数则报错；如果少于宏定义中的参数，并且宏中也没有指定有默认值的话，会报错，指定了默认值的话不会报错。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro greet <span class="keyword">person</span> color=<span class="string">"red"</span>&gt;</span><br><span class="line">&lt;font size=<span class="string">"+2"</span> color=<span class="string">"$&#123;color&#125;"</span>&gt;Hello $&#123;<span class="keyword">person</span>&#125;!&lt;/font&gt;</span><br><span class="line">&lt;/#macro&gt;</span><br></pre></td></tr></table></figure>
<p>使用下面的指令是对的，如果没有color=”red”的话则会报错<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;@greet <span class="keyword">person</span>=<span class="string">"Joe"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>someParam=foo 和 someParam=”${foo}”是不同的。第一种情况，是把变量 foo 的值作为参数的值来使 用。第二种情况则是使用插值形式的字符串，那么参数值就是字符串了</p>
<h4 id="嵌套内容">嵌套内容</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#macro</span> <span class="attribute">border</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">border</span>=<span class="value">4</span> <span class="attribute">cellspacing</span>=<span class="value">0</span> <span class="attribute">cellpadding</span>=<span class="value">4</span>&gt;</span><span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#nested</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;#nested&gt;</code>指令执行位于开始和结束标记指令之间的模板代码段。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">@border</span>&gt;</span>The bordered text<span class="tag">&lt;/<span class="title">@border</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">border</span>=<span class="value">4</span> <span class="attribute">cellspacing</span>=<span class="value">0</span> <span class="attribute">cellpadding</span>=<span class="value">4</span>&gt;</span><span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span></span><br><span class="line">The bordered text<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>nested可以多次被调用</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;#macro do_thrice&gt;</span></span><br><span class="line"><span class="tag">&lt;#nested&gt;</span></span><br><span class="line"><span class="tag">&lt;#nested&gt;</span></span><br><span class="line"><span class="tag">&lt;#nested&gt;</span></span><br><span class="line"><span class="tag">&lt;/#macro&gt;</span></span><br><span class="line"><span class="tag">&lt;@do_thrice&gt;</span></span><br><span class="line"><span class="keyword">Anything</span>.</span><br><span class="line"><span class="tag">&lt;/@do_thrice&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Anything</span>.</span><br><span class="line"><span class="variable">Anything</span>.</span><br><span class="line"><span class="variable">Anything</span>.</span><br></pre></td></tr></table></figure></p>
<p>嵌套的内容可以是任意有效的 FTL，包含其他的用户自定义指令，这样也是对的：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;@border&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;@do_thrice&gt;</span><br><span class="line">&lt;li&gt;&lt;@greet <span class="keyword">person</span>=<span class="string">"Joe"</span>/&gt;</span><br><span class="line">&lt;/@do_thrice&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/@border&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">macro</span> <span class="keyword">repeat</span> <span class="keyword">count</span>&gt;</span><br><span class="line">&lt;#<span class="keyword">local</span> y = <span class="string">"test"</span>&gt;</span><br><span class="line">&lt;#<span class="keyword">list</span> 1..<span class="keyword">count</span> <span class="keyword">as</span> x&gt;</span><br><span class="line"><span class="label">$&#123;y&#125;</span> <span class="label">$&#123;count&#125;</span>/<span class="label">$&#123;x&#125;</span>: &lt;#nested&gt;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line">&lt;/#<span class="keyword">macro</span>&gt;</span><br><span class="line">&lt;@<span class="keyword">repeat</span> <span class="keyword">count</span>=3&gt;<span class="label">$&#123;y</span>!<span class="string">"?"</span>&#125; <span class="label">$&#123;x</span>!<span class="string">"?"</span>&#125; <span class="label">$&#123;count</span>!<span class="string">"?"</span>&#125;&lt;/@<span class="keyword">repeat</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在宏的外部，宏中的局部变量是不可见的</p>
<h4 id="宏和循环变量">宏和循环变量</h4><p>自定义指令也可以有循环变量。比如我们来扩展先前例子中的 do_thrice 指令，就可以拿到当前的循环变量的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="comment">#macro do_thrice&gt;</span></span><br><span class="line">&lt;<span class="comment">#nested 1&gt;</span></span><br><span class="line">&lt;<span class="comment">#nested 2&gt;</span></span><br><span class="line">&lt;<span class="comment">#nested 3&gt;</span></span><br><span class="line">&lt;/<span class="comment">#macro&gt;</span></span><br><span class="line">&lt;@<span class="keyword">do</span>_thrice ; x&gt; &lt;<span class="comment">#-- 用户自定义指令 使用";"代替"as" --&gt;</span></span><br><span class="line"><span class="variable">$&#123;x&#125;</span> Anything.</span><br><span class="line">&lt;/@<span class="keyword">do</span>_thrice&gt;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="variable">Anything</span>.</span><br><span class="line"><span class="number">2</span> <span class="variable">Anything</span>.</span><br><span class="line"><span class="number">3</span> <span class="variable">Anything</span>.</span><br></pre></td></tr></table></figure></p>
<p>nested 指令（当然参数可以是任意的表达式）的参数。 循环变量的名称是在自定义指令的开始标记（ <code>&lt;@...&gt;</code>）的参数后面通过分号确定的。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">macro</span> <span class="keyword">repeat</span> <span class="keyword">count</span>&gt;</span><br><span class="line">&lt;#<span class="keyword">list</span> 1..<span class="keyword">count</span> <span class="keyword">as</span> x&gt;</span><br><span class="line">&lt;#nested x, x/2, x==<span class="keyword">count</span>&gt;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line">&lt;/#<span class="keyword">macro</span>&gt;</span><br><span class="line">&lt;@<span class="keyword">repeat</span> <span class="keyword">count</span>=4 ; c, halfc, last&gt;</span><br><span class="line"><span class="label">$&#123;c&#125;</span>. <span class="label">$&#123;halfc&#125;</span>&lt;#<span class="keyword">if</span> last&gt; Last!&lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/@<span class="keyword">repeat</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如果在分号后面指定了比 nested 指令还多的变量，那么最后的循环变量将不会被创建（在嵌套内容中不会被定义）。如果分号后的指定了比nested指令少的变量，没有问题。</p>
<h4 id="在模板中可以定义三种类型的变量">在模板中可以定义三种类型的变量</h4><ul>
<li>简单变量： 它能从模板中的任何位置来访问，或者从使用 include 指令引入的<br>模板访问。可以使用 assign 或 macro 指令来创建或替换这些变量。</li>
<li>局部变量： 它们只能被设置在宏定义体内，而且只在宏内可见。一个局部变量的生<br>存周期只是宏的调用过程。可以使用 local 指令在宏定义体内创建或替换局部变<br>量。</li>
<li>循环变量：循环变量是由指令（如 list）自动创建的，而且它们只在指令的开始<br>和结束标记内有效。宏的参数是局部变量而不是循环变量。</li>
</ul>
<h3 id="命名空间">命名空间</h3><p>当运行 FTL 模板时，就会有使用 assign 和 macro 指令创建的变量的集合（可能是空的），可以从前一章节来看如何使用它们。像这样的变量集合被称为 namespace 命名空间。在简单的情况下可以只使用一个命名空间，称之为 main namespace 主命名空间。</p>
<h4 id="创建一个库">创建一个库</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="subst">&lt;</span><span class="variable">#macro</span> copyright <span class="built_in">date</span><span class="subst">&gt;</span></span><br><span class="line"><span class="subst">&lt;</span>p<span class="subst">&gt;</span>Copyright (C) $&#123;<span class="built_in">date</span>&#125; Julia Smith<span class="built_in">. </span><span class="literal">All</span> rights reserved<span class="built_in">.</span><span class="subst">&lt;</span>/p<span class="subst">&gt;</span></span><br><span class="line"><span class="subst">&lt;</span><span class="subst">/</span><span class="variable">#macro</span><span class="subst">&gt;</span></span><br><span class="line"><span class="subst">&lt;</span><span class="variable">#assign</span> mail <span class="subst">=</span> <span class="string">"jsmith@acme.com"</span><span class="subst">&gt;</span></span><br></pre></td></tr></table></figure>
<p>把上面的这些定义存储在文件 lib/my_test.ftl 中（目录是你存放模板的位置）。假设想在aWebPage.ftl中使用这个模板。如果在aWebPage.ftl 使用<code>&lt;#include &quot;/lib/my_test.ftl&quot;&gt;</code>，那么就会在主命名空间中创建两个变量，所以就不得不使用import 指令来代替 include 了。它会为 lib/my_test.ftl 创建一个空的命名空间，然后在那里执行。在 aWebPage.ftl中就可以用下面的代码。如果在主命名空间中有一个变量，名为 mail 或 copyright， 那么就不会引起混乱了</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="literal">import</span> <span class="string">"/lib/my_test.ftl"</span> <span class="literal">as</span> my&gt;</span><br><span class="line">&lt;#-- 被称为<span class="string">"my"</span>的哈希表就会是那个<span class="string">"大门"</span> --&gt;</span><br><span class="line">&lt;<span class="annotation">@my</span>.copyright date=<span class="string">"1999-2002"</span>/&gt;</span><br><span class="line">$&#123;my.mail&#125;</span><br></pre></td></tr></table></figure>
<h4 id="命名空间和数据模型">命名空间和数据模型</h4><p>数据模型中的变量在任何位置都是可见的。数据模型user在lib/my_test.ftl和aWebPage.ftl 都能访问。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;#macro copyright date&gt;</span></span><br><span class="line"><span class="tag">&lt;p&gt;</span><span class="keyword">Copyright</span> (C) <span class="cbracket">$&#123;date&#125;</span> <span class="cbracket">$&#123;user&#125;</span>. <span class="literal">All</span> rights reserved.&lt;/p&gt;</span><br><span class="line"><span class="tag">&lt;/#macro&gt;</span></span><br><span class="line"><span class="tag">&lt;#assign mail = "$&#123;user&#125;@acme.com"&gt;</span></span><br></pre></td></tr></table></figure>
<p>在模板的命名空间（可以使用 assign 或 macro 指令来创建的变量）中的变量有着比数据模型中的变量更高的优先级，可以覆盖数据模型。如果想在模板中创建任何命名空间都能访问的变量，那么可以使用global指令</p>
<h4 id="命名空间的生命周期">命名空间的生命周期</h4><p>命名空间由使用的 import 指令中所写的路径来识别。如果想多次 import 这个路径，那么只会为第一次的 import 引用创建命名空间执行模板。 后面相同路径的 import 只是创建一个哈希表当作访问相同命名空间的“门”。</p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="symbol">#import</span> <span class="comment">"/lib/my_test.ftl"</span> as my&gt;</span><br><span class="line">&lt;<span class="symbol">#import</span> <span class="comment">"/lib/my_test.ftl"</span> as foo&gt;</span><br><span class="line">&lt;<span class="symbol">#import</span> <span class="comment">"/lib/my_test.ftl"</span> as bar&gt;</span><br><span class="line"><span class="char">$&#123;</span>my.mail&#125;, <span class="char">$&#123;</span>foo.mail&#125;, <span class="char">$&#123;</span>bar.mail&#125;</span><br><span class="line">&lt;<span class="symbol">#assign</span> mail=<span class="comment">"jsmith@other.com"</span> in my&gt;</span><br><span class="line"><span class="char">$&#123;</span>my.mail&#125;, <span class="char">$&#123;</span>foo.mail&#125;, <span class="char">$&#123;</span>bar.mail&#125;</span><br></pre></td></tr></table></figure>
<p>还要注意命名空间是不分层次的，它们相互之间是独立存在的。那么，如果在命名空间N1 中 import 命名空间 N2，那 N2 也不在 N1 中， N1 只是可以通过哈希表来访问 N2。 这和在主命名空间中 importN2，然后直接访问命名空间 N2 是一样的过程。</p>
<p>每一次模板执行工作都是一个分离且有序的过程，它们仅仅存在一段很短的时间， 同时页面用以呈现内容，然后就和所有填充过的命名空间一起消失了。</p>
<h4 id="编写类库">编写类库</h4><p>命名和Java包命名规范相似，存放路径一般是</p>
<p>/lib/example.sourceforge.net/example.ftl 或<br>/lib/geocities.com/jsmith/example.ftl</p>
<h3 id="空白处理">空白处理</h3><p>FreeMarker 提供下面的工具来处理这个问题：</p>
<ul>
<li>忽略某些模板文件的空白的工具（ 解析阶段空白就被移除了）：<ul>
<li>剥离空白： 这个特性会自动忽略在 FTL 标签周围多余的空白。这个特性可以通过模板来随时使用和禁用。</li>
<li>微调指令： t， rt 和 lt， 使用这些指令可以明确地告诉 FreeMarker 去忽略某些空白。可以阅读参考手册来获取更多信息。</li>
<li>FTL 参数 strip_text：这将从模板中删除所有顶级文本。对模板来说这很有用，它只包含某些定义的宏（还有以他一些没有输出的指令），因为它可以移除宏定义和其他顶级指令中的换行符，这样可以提高模板的可读性。</li>
</ul>
</li>
<li>从输出中移除空白的工具（移除临近的空白）：<ul>
<li>compress 指令</li>
</ul>
</li>
</ul>
<h3 id="替换（方括号）语法">替换（方括号）语法</h3><p>这个特性从 FreeMarker 2.3.4 版本后才可用。<br>FreeMarker 支持一个替换的语法。就是在 FreeMarker 的指令和注释中用[和]来代替<code>&lt;</code>和<code>&gt;</code>，例如下面这个例子：</p>
<ul>
<li>调用预定义指令： [#list animals as being]…[/#list]</li>
<li>调用自定义指令： [@myMacro /]</li>
<li>注释： [#— the comment —]</li>
</ul>
<p>为了使用这种语法从而代替默认语法，从模板开始，使用 ftl 指令都要使用这用语法。[#ftl]</p>
<p>2.4 版本中的默认配置将会自动检测，也就是说第一个 FreeMarker 标签决定了语法形式（它可以是任意的，而不仅仅是 ftl）。</p>
]]></content>
    <summary type="html">
    <![CDATA[FreeMarker;Java模板引擎;模板开发]]>
    
    </summary>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/tags/FreeMarker/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/categories/Java/FreeMarker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解Java虚拟机笔记三（JVM性能监控与故障处理工具）]]></title>
    <link href="http://howiefh.github.io/2015/04/09/jvm-note-3/"/>
    <id>http://howiefh.github.io/2015/04/09/jvm-note-3/</id>
    <published>2015-04-09T08:00:22.000Z</published>
    <updated>2015-04-12T11:52:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>大多工具都是对jdk/lib/tools.jar类库的一层包装，SUN JDK监控和故障处理工具：</p>
<ol>
<li>jps：JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</li>
<li>jstat：JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据</li>
<li>jinfo：Configuration Info for Java，显示虚拟机配置信息</li>
<li>jmap：Memory Map for Java，生成虚拟机的内存转储快照(heap dump文件)</li>
<li>jhat：JVM Heap Dump Browser，用于分析heap dump文件，会建立一个HTTP/HTML服务器，让用户可以在浏览器查看分析结果</li>
<li>jstack：Stack Trace for Java，显示虚拟机的线程快照</li>
</ol>
<p>然后还有两个GUI工具：</p>
<ol>
<li>jconsole：略微过时的JVM各状态查看工具</li>
<li>visualVM：Sun出品的强大的JVM工具，推荐使用！</li>
</ol>
<a id="more"></a>
<h2 id="JDK的命令行工具">JDK的命令行工具</h2><h3 id="jps：虚拟机进程状况工具">jps：虚拟机进程状况工具</h3><p>它和Unix的ps命令有类似功能：</p>
<p><strong>它可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Claas，main()函数所在的类）的名称，以及这些进程的内地虚拟机的唯一ID（LVMID，Local Virtual Machine Identifier）。</strong></p>
<p>命令格式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">jps</span> <span class="attr_selector">[options]</span> <span class="attr_selector">[hostid]</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q</td>
<td>只输出LVMID，省略主类的名称</td>
</tr>
<tr>
<td>-m</td>
<td>输出虚拟机进程启动时传递给主类main()函数的参数</td>
</tr>
<tr>
<td>-l</td>
<td>输出主类的全名，如果进程执行的是jar包，输出jar包路径</td>
</tr>
<tr>
<td>-v</td>
<td>输出虚拟机进程启动时JVM参数</td>
</tr>
</tbody>
</table>
<h3 id="jstat：虚拟机统计信息监视工具">jstat：虚拟机统计信息监视工具</h3><p>jstat的全称是JVM Statistics Monitoring Tool，它用于监视虚拟机各种运行状态信息。可以显示<strong>本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</strong>，在没有GUI图形界面，只提供纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。</p>
<p>命令格式：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat <span class="comment">[options vmid <span class="comment">[interval<span class="comment">[s|ms]</span> <span class="comment">[count]</span>]</span> ]</span></span><br></pre></td></tr></table></figure>
<p>假如我想监控gc，每250ms查询一次，一共查询20次，进程号为1234。命令就是:<code>jstat -gc 1234 250 20</code>。如何监控远程机器呢？很简单，使用jstatd。和mysql类似，mysql是客户端，mysqld是服务器端。所以当远程机器开始了jstatd，就相当于开启了远程虚拟机进程的监控，本地可通过RMI查看远程机器的运行时数据，非常方便。</p>
<p>在这里，option主要分为3类：</p>
<ol>
<li>类装载</li>
<li>垃圾收集</li>
<li>运行期编译状况</li>
</ol>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-class</td>
<td>监视类装载、卸载数量、总空间及类装载所耗费的时间</td>
</tr>
<tr>
<td>-gc</td>
<td>监视Java堆状况，包括Eden区、2个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td>
</tr>
<tr>
<td>-gccapacity</td>
<td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大和最新空间</td>
</tr>
<tr>
<td>-gcutil</td>
<td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td>
</tr>
<tr>
<td>-gccause</td>
<td>监视内容与-gc基本相同，但会额外输出导致上一次GC产生的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代GC状况</td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>监视内容与-gcnew基本相同，输出主要关注使用到的最大和最小空间</td>
</tr>
<tr>
<td>-gcold</td>
<td>监视老年代GC的状况</td>
</tr>
<tr>
<td>-gcoldcapacity</td>
<td>监视内容与-gcold基本相同，输出主要关注使用到的最大和最小空间</td>
</tr>
<tr>
<td>-gcpermcapacity</td>
<td>输出永久代使用到的最大和最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出JIT编译期编译过的方法、耗时等信息</td>
</tr>
<tr>
<td>-printcomplilation</td>
<td>输出已经被JIT编译的方法</td>
</tr>
</tbody>
</table>
<h3 id="jinfo：Java配置信息工具">jinfo：Java配置信息工具</h3><p>jinfo全称为Configuration Info for Java，它的作用是<strong>实时地查看和调整虚拟机的各项参数</strong>。</p>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [ <span class="keyword">option</span> ] pid</span><br></pre></td></tr></table></figure>
<p>使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的-flag选项进行查询了（如果只限于JDK1.6或以上版本的话，使用java -XX:+PrintFlasFinal查看参数默认值也是一个很好的选择），jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来。可以使用-flag [+-] name或-flag name=value修改一部分运行期可写的虚拟机参数值。</p>
<h3 id="jmap：Java内存映像工具">jmap：Java内存映像工具</h3><p>jmap全称为Memory Map for Java，它<strong>用于生成堆转储快照（一般称为heap dump或者dump文件）</strong>。jmap的作用并不仅仅是为了获取dump文件供其他工具分析当前JVM的内存情况，它还可以<strong>查询finalize执行队列，Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等</strong>。它的命令格式为：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [ <span class="keyword">option</span> ] vmid</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-dump</td>
<td>生成java堆转储快照。格式为：-dump:[live,]format=b,file=<filename>，其中live子参数说明是否只dump出存活的对象</filename></td>
</tr>
<tr>
<td>-finalizerinfo</td>
<td>显示在F-Queue中等待Filalizer线程执行finalize方法的对象，只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-heap</td>
<td>显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等，只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-histo</td>
<td>显示堆中统计信息，包括类、实例数量和合计容量</td>
</tr>
<tr>
<td>-permstat</td>
<td>以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效</td>
</tr>
</tbody>
</table>
<p>比如我得到dump快照，就可以先通过jps拿到虚拟机的LVMID，然后使用<code>jmap -dump:format=b,file=haha.bin &lt;LVMID&gt;</code>就可以了。</p>
<h3 id="jhat：虚拟机堆转储快照分析工具">jhat：虚拟机堆转储快照分析工具</h3><p>jhat命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的http/html服务器，生成dump文件的分析结果后，可以在浏览器中查看。但一般情况下，这个命令使用的几率不会太大。首先对于线上服务器来说，生成dump快照后，分析快照是一个很耗时且吃硬件的过程，如果dump快照过于复杂，甚至会影响线上服务；其次jhat的分析功能相对来说比较简陋。建议是将这个dump快照拷贝到线下，然后使用更强大的GUI工具来直观分析，比如Eclipse Memory Analyzer、IBM HeapAnalyzer等工具。</p>
<p>如果打开后，可以在本地localhost:7000查看结果。拉到最下面有个Heap Histogram，点进去就可以看到虚拟机中所有对象实例的数目和大小。</p>
<h3 id="jstack：Java堆栈跟踪工具">jstack：Java堆栈跟踪工具</h3><p>jstack全称为Stack Trace for Java，它<strong>用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内存每一个线程正在执行的方法堆栈的集合</strong>。生成线程快照的主要目的就是<strong>定位线程出现长时间停顿的原因</strong>，比如线程间死锁、死循环、请求外部资源导致的长时间等待都是导致线程长时间停顿的常见原因。</p>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [ <span class="keyword">option</span> ] vmid</span><br></pre></td></tr></table></figure>
<p>option选项说明如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F</td>
<td>当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l</td>
<td>除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m</td>
<td>如果调用到本地方法的话，可以显示C/C++的堆栈</td>
</tr>
</tbody>
</table>
<p>在JDK 1.5中，java.lang.Thread类新增了一个叫做getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象，使用这个方法可以通过简单的几行代码就完成jstack的大部分功能。</p>
<h3 id="JDK的可视化工具">JDK的可视化工具</h3><p>JDK除了提供大量的命令行工具外，还提供了两个功能强大的可视化工具：JConsole和VisualVM，这两个工具是JDK的正式成员</p>
<p>其实现在Sun主推VisualVM了，因为JConsole稍微有点老。而且可视化工具基本不需要学习，稍微看看就知道啥情况。说白了就是把上面的jdk工具，比如jstat、jmap、jstack结果套个GUI。</p>
<p>其中看了感觉比较有价值的是BTrace这个插件，它竟然可以动态的在项目中插入调试信息</p>
]]></content>
    <summary type="html">
    <![CDATA[深入理解Java虚拟机; JVM性能监控与故障处理工具;]]>
    
    </summary>
    
      <category term="JVM" scheme="http://howiefh.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解Java虚拟机笔记二（垃圾收集器与内存分配策略）]]></title>
    <link href="http://howiefh.github.io/2015/04/08/jvm-note-2/"/>
    <id>http://howiefh.github.io/2015/04/08/jvm-note-2/</id>
    <published>2015-04-08T14:40:22.000Z</published>
    <updated>2015-04-12T11:52:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>程序计数器、虚拟机栈、本地方法栈这些区域不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。垃圾收集器关注的是堆和方法区中的垃圾。</p>
<a id="more"></a>
<h2 id="对象已死吗">对象已死吗</h2><h3 id="引用计数器">引用计数器</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>这种计数法无法解决循环引用的问题</p>
<h3 id="可达性分析算法">可达性分析算法</h3><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<h3 id="再谈引用">再谈引用</h3><p>在Java1.2之前，引用的定义是这样的：</p>
<blockquote>
<p>如果reference类型的数据中存储的数值代表的是另外一块内存中的起始地址，就称这块内存代表着一个引用。</p>
</blockquote>
<p>我们可以看到，这个引用的定义是非常狭隘的，和指针类似，只有引用、非引用区分。所以，在JAVA1.2以后提出了新的引用定义：</p>
<ul>
<li>强引用：在代码中普遍存在的，类似<code>Object obj = new Object();</code>。只要强引用还存在，垃圾回收期就永远不会回收被引用的对象</li>
<li>软引用：用来描述一些还有用，但并非必须的对象。这样当系统要发生内存溢出异常之前，就会把软引用列进第二次垃圾回收的计划中。SoftReference</li>
<li>弱引用：比软引用还弱的引用，被弱引用的对象只能存活到下一次垃圾回收之前。WeakReference</li>
<li>虚引用：最弱的一种引用关系了。使用虚引用的唯一目的就是在这个对象回收前收到一个系统回收通知。PhantomReference</li>
</ul>
<p>《Java编程思想》中也有相关<a href="http://howiefh.github.io/2014/10/30/thinking-in-java-note-5/#持有引用">内容</a></p>
<h3 id="生存还是死亡">生存还是死亡</h3><p>即使是不可达对象，也并非是非死不可的，这时候它们暂时处于”缓刑“阶段，真正宣告一个对象死亡，至少要经过<strong>两次标记过程</strong>：</p>
<p>如果对象在进行根搜索后发现跟root不同根，就被标记一次，同时进行筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()已经被JVM调用过（说明一个对象的finalize()方法只能执行一次），JVM会将这两种情况视为“没有必要执行”。如果这个对象有必要执行finalize()方法，JVM就会把它放在F-Queue中，稍后JVM会触发一个低优先级的线程去执行。<strong>但是去执行并并不承诺会等待它运行结束，因为如果一个对象在finalize()方法中执行缓慢，甚至发生了死循环，就会导致F-Queue其他对象永久处于等待状态，更严重的话可能会拖垮整个内存回收系统。</strong>finalize()是对象逃脱死亡命运的最后一次机会，稍后GC将会对F-Queue进行第二次小规模的标记，如果在finalize()中将自己和root挂在一个根上（比如把自己赋值给某个类变量或者对象的成员变量），那么在这第二次标记将会被移除出“即将回收的集合”：如果对象还没有逃脱，那么就基本上真的被回收了。</p>
<p><img src="http://fh-1.qiniudn.com/gc_mark.png" alt="两次标记过程"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"haha, i'm still alive!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span>(<span class="params"></span>) throws Throwable </span>&#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对象第一次拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对象第二次拯救自己，但是却跪了。因为finalize只能执行一次呀，亲！！</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*output: </span><br><span class="line">finalize method executed!</span><br><span class="line">haha, i'm still alive!</span><br><span class="line">5555, i'm dead!</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>我们可以清楚的看到，第一次在finalize()中赋值给类变量，所以和root同根自救了一次，但是因为finalize()只会执行一次，所以第二次标记时，JVM发现已经调用这个对象的finalize()，就知道没必要再执行finalize了，然后就被回收了。</p>
<p>作者非常不推荐使用finalize()方法自救对象，因为这是Java刚诞生为了使C/C++程序员更容易接受它作的一个妥协。它的运行带价高昂，不确定性大，无法保证各个对象的调用顺序。<strong>有些教材中提到它使用“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方法都可以做的更好、更及时，完全可以忘掉Java有finalize()。</strong></p>
<h3 id="方法回收区">方法回收区</h3><p>Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾回收，主要是因为在方法区进行垃圾回收的“性价比”很低：在堆中，尤其是在新生代中，常规应用进行一次垃圾回收一般可以回收70%-95%的空间，而永久代的垃圾回收效率也远低于此。</p>
<p>永久代的垃圾收集主要回收两部分内容：</p>
<ul>
<li>废弃常量：以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</li>
<li><p>无用的类：判断一个类是无用的类，条件比废弃变量要苛刻的多，要同时满足下面3个条件才能算是“无用的类”：</p>
<ol>
<li>该类所有的实例都已经被回收，意思是堆上没有该对象的实例了</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法（因为通过反射，就一定要加载该类）</li>
</ol>
</li>
</ul>
<p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<h2 id="垃圾收集算法">垃圾收集算法</h2><ul>
<li>标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。有两个问题：一是效率不高；而是会产生内存碎片，当需要大的连续内存空间时，即使碎片内存总和远大于需求，也会触将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。实现简单，运行高效，但是空间缩小为原来的一半了。<strong>现在的商业JVM采用这种算法来回收新生代，IBM经过调研发现，新生代的对象98%都是朝生夕死的，所有并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。</strong>当回收时，将Eden和Survivor还存活着的对象一次性拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。<strong>HotSpot虚拟机默认Eden和Survivor的大小比例是8：1</strong>，也就是每次新生代中可用内存空间为整个内存空间的9/10，只有10%的内存是用来浪费的。当然了，我们无法保证每次回收只有少于10%的对象存活，当存活对象大于10%，就会借用其他内存（这里指老年代）进行分配担保。分配担保就相当于现实生活中的担保。</li>
<li>标记-整理算法：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。（老年代就是采用这个方法）</li>
<li>分代收集算法：当前商业虚拟机的垃圾回收都采用分代收集算法，这种算法没有啥特别的，就是<strong>根据对象的存活周期的不同将内存划分为几块</strong>，一般是把Java堆分为新生代和老年代，这样就可以根据每个代不同的特点采用最适当的回收算法。比如新生代存活对象少，就采用Eden-Survivor复制算法；老年代存活对象少，复制的话代价太大，就可以采用标记-整理算法。</li>
</ul>
<p>总结：<br>标记-清除：简单，效率低，有内存碎片<br>复制：新生代，实现简单，运行高效，空间利用率低<br>标记-整理：老年代</p>
<h2 id="HotSpot_的算法实现">HotSpot 的算法实现</h2><h3 id="枚举根节点">枚举根节点</h3><p>可达性分析在逐个检查引用链和GC停顿（保证分析工作的一致性）上浪费时间较多。主流Java虚拟机使用的都是准确式GC，虚拟机应当有办法直接得知哪些地方存放着对象的引用。HotSpot是通过一个OopMap的数据结构来达到这个目的的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p>
<h3 id="安全点">安全点</h3><p>HotSpot没有为每条指令都生成OopMap，那样占用空间太多，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p>
<p>另一个问题是如何让所有线程都跑到最近的安全点停顿。这里有两种方案可供选择：<strong>抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）</strong>，其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p>
<h3 id="安全区域">安全区域</h3><p>如果线程没有在执行呢，比如线程处于Sleep状态或者Blocked状态，就需要安全区域解决了。安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p>
<p>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<h2 id="垃圾收集器">垃圾收集器</h2><p><img src="http://fh-1.qiniudn.com/hotspot_gc.jpg" alt="HotSpot虚拟机的垃圾收集器"></p>
<h3 id="Serial收集器">Serial收集器</h3><p>最基本，历史最悠久。新生代的，单线程的，只会用一个CPU或一个线程工作，并且收集时，必须暂停所有的工作线程，直到收集结束。它依然是虚拟机运行在Client端的默认新生代收集器。简单而高效，因为它不需要考虑线程切换，只专注一次把收集工作搞定，而且在Client端，新生代的内存一般只有几十M或者一两百M的样子，完成一次收集工作完全可以控制在几十毫秒或者一百毫秒左右，不会有很大的停顿感。</p>
<h3 id="ParNew收集器">ParNew收集器</h3><p>这个本质上就是Serial收集器的多线程版本。许多运行在Server模式下的虚拟机中首选的<strong>新生代收集器</strong>，其中还有一个与性能无关<strong>但很重要的原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作</strong>。（原因是Parallel Scavenge收集器和后面的G1收集器都没有使用传统的GC收集器代码框架，而是另外独立实现的，其余几种收集器则共用了框架代码）。ParNew收集器也是使用<code>-XX:+UseConcMarkSweepGC</code>选项后的默认新生代收集器，当然也可以使用<code>-XX:+UseParNewGC</code>选项来显式指定使用</p>
<p>单CPU的话一般会考虑用Serial，多CPU的话一般考虑用ParNew，<strong>它默认开启的收集器线程数和CPU核数相同，当你想控制的时候，可以使用```-XX:ParallelGCThreads参数来限制收集器的线程数。</strong></p>
<p>然后提前解释一下<strong>并行</strong>和<strong>并发</strong>的概念，因为后面会有几个并发和并行的收集器：</p>
<ul>
<li>并行(Parallel)：指多条垃圾收集线程并行工作，<strong>但此时用户线程仍然处于等待状态</strong>。所以，遇到 Parallel 关键字的话，都是并行。所以当它们工作的时候，用户线程是阻塞的。所以也是 stop the world</li>
<li>并发(Concurrent)：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会根据时间片轮转交替进行），用户程序继续运行，而垃圾收集程序运行在另外一个CPU上。所以遇到 concurrent 关键字就是 GC 线程和用户线程在一段时间内交叉运行，不会将用户线程阻塞，不是 stop the world</li>
</ul>
<h3 id="Parallel_Scavenge收集器">Parallel Scavenge收集器</h3><p>Parallel Scavenge也是<strong>一个新生代收集器</strong>，它也是<strong>使用复制算法</strong>的收集器，同时也是<strong>并行的多线程收集器</strong>。它的目标是达到可控制的CPU吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾回收时间）。比如虚拟机运行了100分钟，垃圾回收使用了1分钟，那么吞吐量就是99%。</p>
<p>这就说说一下应用场景了。</p>
<ul>
<li>停顿时间（垃圾回收时间）： 停顿时间越短越适合于用户交互的程序，良好的响应速度能提升用户体验</li>
<li>高吞吐量： 可以最高效率的利用CPU时间，尽快的完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务</li>
</ul>
<p>为了这两个目的，Parallel Scavenge收集器提供了2个参数：</p>
<ul>
<li>-XX:MaxGCPauseMillis:大于0的毫秒数，收集器将尽力保证内存回收时间不超过这个值。不过不要异想天开认为把这个值设的特别小，就能使系统垃圾收集速度更快，GC停顿时间缩短肯定是有代价的，它会牺牲吞吐量和新生代空间来实现。</li>
<li>-XX:GCTimeRatio:大于0小于100的整数.假如设为N，那么垃圾收集时间占总时间的比率就是1/(1+N),比如设置为19,占比就是1/(1+19)=5%，默认值是99，即1%。</li>
<li>-XX:+UseAdaptiveSizePolicy:这也是一个有用的参数，放在这里说一下。它是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小(-Xmn)、Eden、Survivor区的比例(-XX:SurvivorRatio)、晋升老年代对象年龄(-XX:PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以一同最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。<strong>自适应调节策略也是Parallel Scavenge收集器和ParNew收集器的一个重要区别</strong></li>
</ul>
<h3 id="Serial_Old_收集器">Serial Old 收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记-整理“算法。这个收集器的主要意义就是被Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用；另外一个就是CMS的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。</p>
<h3 id="Parallel_Old收集器">Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。是在JDK 1.6之后才提供的。前面说过，Parallel Scavenge收集器采用了独立的架构，无法和CMS配合使用。那么，在JDK 1.6以前，Parallel Scavenge只能和Serial Old配合使用。因为Serial Old是单线程的，所以在多CPU情况下无法发挥性能，所以根本实现不了高吞吐量的需求，直到JDK 1.6推出了Parallel Old之后，Parallel Scavenge收集器和Parallel Old搭配，才真正实现了对吞吐量优先的控制。所以，<strong>在注重吞吐量及CPU资源敏感的场合，都可以考虑Parallel Scavenge和Parallel Old组合</strong>。</p>
<h3 id="CMS（Comcurrent_Mark_Sweep）收集器">CMS（Comcurrent Mark Sweep）收集器</h3><p>CMS收集器是<strong>以获取最短回收停顿时间为目标的收集器</strong>。目前很大一部分的Java应用都集中在互联网站或者B/S系统上，这类应用<strong>尤其重视服务的响应速度，希望系统停顿时间最短，给用户最佳的用户体验。而CMS收集器就非常符合这类应用的需求</strong></p>
<p>从名字上可以看出，”Mark Sweep“是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤：</p>
<ol>
<li>初始标记(stop the world):初始标记仅仅只是标记一下GC roots能直接关联到的对象，速度很快</li>
<li>并发标记:并发标记就是进行GC Roots Tracing的过程</li>
<li>重新标记(stop the world):重新标记则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变化的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍微长一些，但远比并发标记的时间短</li>
<li>并发清除:垃圾清除</li>
</ol>
<p>由于整个过程中，并发标记和并发清除时间最长，收集器线程可以和用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>CMS收集器的优点在于<strong>并发收集、低停顿</strong>，但是也不是完美的，主要有3个显著的缺点：</p>
<ol>
<li>CMS收集器对CPU资源非常敏感。默认情况下，CMS的收集线程数=(CPU数目+3)/4，当CPU个数大于4的时候，CMS的收集线程不会超过整个CPU占用率的25%。但是在CPU个数比较小的情况下，CPU占用就会突然增大，这样对于初始标记和并发标记这样”Stop The World”的过程来说，用户就会明显感觉到停顿。虽然有了解决方法，但已经废除了，就不多说了。</li>
<li><strong>CMS收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生</strong>。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，它<strong>需要预留一部分空间提供并发收集时的线程使用。在JDK1.5默认设置下，CMS收集器在老年代使用了68%的空间会被激活，这是一个偏保守的设置。</strong>如果在应用中，老年代增长不是太快，可以适当调高这个参数-XX:CMSInitiatingOccupancyFraction。要是CMS运行期间预留的内存无法满足程序的需要，就会出现”Concurrent Mode Failure”失败，这时候JVM会启动后备方案：临时启动Serial Old收集器来重新进行老年代的垃圾收集，因为是单线程，停顿时间就会更长了。所以如果大量出现”Concurrent Mode Failure”，就可以将这个值调低</li>
<li>CMS是基于<strong>标记-清除</strong>算法实现的收集器，所以会产生内存碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦：老年代还有空间但是没有连续的足够大的空间，于是不得不触发一次Full GC。为了解决这个问题，有一个开关叫做-XX:+UseCMSCompactAtFullCollection，用于在Full GC时开启内存碎片的合并整理过程。当然，这个内存整理没法并发，只有”Stop The World”了。另外，虚拟机还设计了一个参数-XX:CMSFullGCsBeforeCompaction,用于指定在多少次不压缩的Full GC后，跟着来一次带压缩的。</li>
</ol>
<h3 id="G1收集器">G1收集器</h3><p>G1是一款面向服务端应用的垃圾收集器。与其他GC收集器相比，G1具备如下特点。</p>
<p>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。<br>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。<br>空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。<br>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
<p>G1收集器的运作大致可划分为以下几个步骤：</p>
<p>初始标记（Initial Marking）<br>并发标记（Concurrent Marking）<br>最终标记（Final Marking）<br>筛选回收（Live Data Counting and Evacuation）</p>
<p>总结：</p>
<p>Serial收集器：新生代；复制算法；单线程；GC区域名称(GCLogging)：DefNew；优点：简单高效，Client模式下的默认新生代收集器；缺点：进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World”。<br>ParNew收集器：新生代；复制算法；多线程；GC区域名称(GCLogging)：ParNew；优点：Server模式下的虚拟机中首选的新生代收集器。除了Serial收集器外，目前只有它能与CMS收集器配合工作；缺点：在单CPU的环境中绝对不会有比Serial收集器更好的效果<br>Parallel Scavenge收集器：新生代；复制算法；多线程；GC区域名称(GCLogging)：PSYoungGen；优点：吞吐量优先。缺点：无法与CMS配合使用<br>Serial Old收集器：老年代；标记-整理算法（Mark-Compact）；单线程；<br>GC区域名称(GCLogging)：Tenured；优点：与Parallel Scavenge配合；作为CMS的后备方案。缺点：性能较低<br>Parallel Old收集器：老年代；标记-整理算法（Mark-Compact）；多线程；GC区域名称(GCLogging)：ParOldGen；优点：与Parallel Scavenge配合，真正成为吞吐量优先的收集器组合。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。<br>CMS收集器：老年代；标记-清楚算法（Mark-Sweep）；多线程；GC区域名称(GCLogging)：ParOldGen；优点：响应速度快、停顿时间短。；缺点：1.对CPU资源敏感；2.无法处理浮动垃圾，因为GC标记和用户线程并发运行着；3.空间碎片多<br>G1：新生代，老年代；标记-整理，复制；多线程；优点：并行与并发，分代收集，空间整合，可预测的停顿</p>
<h2 id="理解GC日志">理解GC日志</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33.125</span>: [GC [DefNew: <span class="number">3324</span><span class="keyword">K</span>-&gt;<span class="number">152</span><span class="keyword">K</span>(<span class="number">3712</span><span class="keyword">K</span>), <span class="number">0.0025925</span> secs] <span class="number">3324</span><span class="keyword">K</span>-&gt;<span class="number">152</span><span class="keyword">K</span>(<span class="number">11904</span><span class="keyword">K</span>), <span class="number">0.0031680</span> secs]<span class="number">100.667</span>: [<span class="keyword">Full</span> GC [Tenured: <span class="number">0</span><span class="keyword">K</span>-&gt;<span class="number">210</span><span class="keyword">K</span>(<span class="number">10240</span><span class="keyword">K</span>), <span class="number">0.0149142</span> secs] <span class="number">4603</span><span class="keyword">K</span>-&gt;<span class="number">210</span><span class="keyword">K</span>(<span class="number">19456</span><span class="keyword">K</span>), [Perm : <span class="number">2999</span><span class="keyword">K</span>-&gt;<span class="number">2999</span><span class="keyword">K</span>(<span class="number">21248</span><span class="keyword">K</span>)], <span class="number">0.0150007</span> secs] [<span class="keyword">Times</span>: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure>
<p>最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p>
<p>GC日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“[Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“[Full GC（System）”。</p>
<p>接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的</p>
<p>后面方括号内部的“3324K-&gt;152K（3712K）”含义是“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-&gt;152K（11904K）”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）”。</p>
<p>再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“[Times：user=0.01 sys=0.00，real=0.02 secs]”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致</p>
<h3 id="垃圾收集器参数总结">垃圾收集器参数总结</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>UseSerialGC</td>
<td>虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseParNewGC</td>
<td>打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseConcMarkSweepGC</td>
<td>打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后壁收集器使用</td>
</tr>
<tr>
<td>UseParallelGC</td>
<td>虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old（PS MarkSweep）的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseParallelOldGC</td>
<td>打开此开关后，使用Parallel Scavenge+Parallel Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>SurvivorRatio</td>
<td>新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor=8:1</td>
</tr>
<tr>
<td>PretenureSizeThreshold</td>
<td>直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td>
</tr>
<tr>
<td>MaxTenuringThreshold</td>
<td>晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄加1，当超过这个参数值时就进入老年代</td>
</tr>
<tr>
<td>UseAdaptiveSizePolicy</td>
<td></td>
</tr>
</tbody>
</table>
<p>动态调整Java堆中各个区域的大小以及进入老年代的年龄<br>HandlePromotionFailure | 是否允许分配担保失败，即老年代的剩余空间不足以应对新生代的整个Eden和Survivor区的所有对象都存活的极端情况<br>ParallelGCThreads |  设置并行GC时进行内存回收的线程数<br>GCTimeRatio | GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效<br>MaxGCPauseMillis   | 设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效<br>CMSinitiatingOccupancyFraction | 设置CMS收集器在老年代空间被使用多少后出发垃圾收集。默认值为68%，仅在使用CMS收集器时生效<br>UseCMSCompactAtFullCollection  | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效<br>CMSFullGCsBeforeCompaction | 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效</p>
<h2 id="内存分配与回收策略">内存分配与回收策略</h2><p>对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中。</p>
<h3 id="对象优先在Eden分配">对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<p>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<p>请看下面例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@VM</span> param -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span><br><span class="line"> * </span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEdenAllocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] alloc1, alloc2, alloc3, alloc4;</span><br><span class="line"></span><br><span class="line">        alloc1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        alloc2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        alloc3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        alloc4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看vm的参数：</p>
<p>-XX:+UseSerialGC： 保证使用Serial/SerialOld收集器作为例子<br>-Xms20M -Xmx20M -Xmn10M： 限制堆为20M，10M新生代10M老年代<br>-XX:SurvivorRatio=8： 新生代Eden区与一个Survivor区比例8:1<br>-XX:+PrintGCDetails： 收集器日志参数</p>
<p>输出如下：</p>
<p>[GC[DefNew: 6817K-&gt;484K(9216K), 0.0038248 secs] 6817K-&gt;6628K(19456K), 0.0038598 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>Heap<br> def new generation   total 9216K, used 5072K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)<br>  eden space 8192K,  56% used [0x00000000f9a00000, 0x00000000f9e7af60, 0x00000000fa200000)<br>  from space 1024K,  47% used [0x00000000fa300000, 0x00000000fa379110, 0x00000000fa400000)<br>  to   space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)<br> tenured generation   total 10240K, used 6144K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)<br>   the space 10240K,  60% used [0x00000000fa400000, 0x00000000faa00030, 0x00000000faa00200, 0x00000000fae00000)<br> compacting perm gen  total 21248K, used 2519K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)<br>   the space 21248K,  11% used [0x00000000fae00000, 0x00000000fb075e08, 0x00000000fb076000, 0x00000000fc2c0000)<br>No shared spaces configured.</p>
<p>分析如下：</p>
<p>分配alloc4时发生一次minorGC，Eden区从6817K减少到484K。由于alloc1、alloc2、alloc3都是存活的所以没有对象可收。<br>这次GC发生的原因是给allo-cation4分配内存的时候，发现Eden已经被占用了6MB，剩余空间已不足以分配allocation4所需的4MB内存，因此发生Minor GC。<br>GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。<br>这次GC结束后，4MB的allocation4对象顺利分配在Eden中，因此程序执行完的结果是Eden占用4MB（被allocation4占用），Survivor空闲，老年代被占用6MB（被allocation1、allocation2、allocation3占用）</p>
<h3 id="大对象直接进入老年代">大对象直接进入老年代</h3><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>
<p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Sur-vivor区之间发生大量的内存复制。注意PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效</p>
<h3 id="长期存活的对象将进入老年代">长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。</p>
<h3 id="动态对象年龄判定">动态对象年龄判定</h3><p>虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h3 id="空间分配担保">空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。</p>
<p>在JDK 6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p>
]]></content>
    <summary type="html">
    <![CDATA[深入理解Java虚拟机; 垃圾收集器与内存分配策略]]>
    
    </summary>
    
      <category term="JVM" scheme="http://howiefh.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解Java虚拟机笔记一（Java内存区域与内存溢出异常）]]></title>
    <link href="http://howiefh.github.io/2015/04/07/jvm-note-1/"/>
    <id>http://howiefh.github.io/2015/04/07/jvm-note-1/</id>
    <published>2015-04-07T15:31:59.000Z</published>
    <updated>2015-04-12T11:52:39.000Z</updated>
    <content type="html"><![CDATA[<h2 id="运行时数据区域">运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中，会把内存分为不同的数据区域。如下图所示：</p>
<p><img src="http://fh-1.qiniudn.com/jvm_model.jpg" alt="Java虚拟机运行时数据区"></p>
<a id="more"></a>
<h3 id="程序计数器">程序计数器</h3><p>它是一块较小的内存空间，作用可以当做是<strong>当前线程所执行的字节码的行号指示器</strong>。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一跳需要执行的字节码指令，<strong>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器</strong>（字节码行号记录器）。</p>
<p>因为java虚拟机的多线程是通过时间片轮转占用cpu，所以一个处理器只会执行一条线程的指令。为了线程切换后能恢复到正确的位置，每个线程都需要一个独立的程序计数器，这样能使各个线程之间的计数器互不影响，独立存储。这类区域为<strong>线程私有内存</strong>。</p>
<ul>
<li>如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令地址</li>
<li>如果线程正在执行的是 Native 方法，这个计数器值为空（Undefined）</li>
</ul>
<p><strong>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域</strong>。</p>
<h3 id="Java虚拟机栈">Java虚拟机栈</h3><p>Java虚拟机栈也是<strong>线程私有</strong>的，它的生命周期和线程相同。</p>
<p>Java虚拟机栈描述的是<strong>Java方法执行的内存模型</strong>：每个方法被执行的时候都会创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机中从入栈到出栈的过程。</p>
<p>局部变量表存放了基本数据类型、对象引用和returnAddress类型（指向一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p>
<ul>
<li><strong>如果线程请求的栈深度太深，超出了虚拟机所允许的深度，就会出现StackOverFlowError（比如无限递归。因为每一层栈帧都占用一定空间，而 Xss 规定了栈的最大空间，超出这个值就会报错）</strong></li>
<li><strong>虚拟机栈可以动态扩展，如果扩展到无法申请足够的内存空间，会出现OOM</strong></li>
</ul>
<h3 id="本地方法栈">本地方法栈</h3><p>本地方法栈与虚拟机栈的作用是非常类似的，区别是<strong>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务</strong>。因为虚拟机规范没有对这块有太多规定，所以不同的虚拟机可以自由实现它。有的虚拟机（Sun的HotSpot虚拟机）直接就把<strong>本地方法栈和虚拟机栈合二为一</strong>了。</p>
<h3 id="Java堆">Java堆</h3><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块，它是<strong>所有线程共享的，在虚拟机启动时候创建</strong>。Java堆唯一的目的就是<strong>存放对象实例（当然还有数组）</strong>，Java堆是垃圾收集器管理的主要区域。堆可分为老年代和新生代，再细分还可以分为Eden空间、From Survivor空间、To Survivor空间等。主流虚拟机都可扩展（-Xmx和-Xms）</p>
<p><strong>如果堆上没有内存可以完成对象实例的分配，并且堆已经达到了最大容量，无法向OS继续申请的时候，就会抛出OOM异常</strong>。</p>
<h3 id="方法区">方法区</h3><p>方法区与Java堆一样，是<strong>所有线程共享</strong>的内存区域，它用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p>
<p>对于习惯在 HotSpot虚拟机上开发部署程序的开发者来说，很多人倾向于把方法区成为“永久代（Perm Generation）”，但<strong>本质上两者并不等价，仅仅是因为 HotSpot 团队选择把 GC 分代收集扩展到方法区，或者说使用永久代来实现方法区而已</strong>，目的是为了让 HotSpot 的垃圾回收器可以像管理 Java 堆一样管理这部分内存，不能再编写这部分内存的内存管理代码。对于其他虚拟机（比如 JRockit、IMB J9）来说，是不存在永久代的概念的。</p>
<p>其实 JVM 规范并没有规定如何实现方法区，但是从目前状况来看：<strong>使用永久代来实现方法区不是一个好的做法。因为这样更容易遇到内存溢出问题（永久代有-XX:MaxPermSize 的上限，而 J9和 Jrockit 只要没有触碰到进程可用内存的上限，例如32位的4GB，就不会出现问题）</strong>，同时有极少数方法（比如 String.intern()，这个函数能直接操纵方法区中的常量池）会因为这个原因在不同虚拟机有不同的表现。因此，HotSpot 团队有了<em>放弃永久代并逐步改为采用 Native Memory 来实现方法区的规划</em>，在目前已经发布的 JDK1.7 的 HotSpot 中，已经把放在永久代的字符串常量池移出。</p>
<p><strong>当方法区无法满足分寸分配需求时，就会抛出OOM异常</strong>。</p>
<h4 id="运行时常量池">运行时常量池</h4><p><strong>方法区的一部分</strong>。class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(class文件中)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在<strong>类加载后存放到方法区的运行时常量池中</strong>。除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>运行时常量池相对于class文件常量池的另外一个重要特性是具备动态性，Java语言并不要求常量一定是在编译期产生，也就是说，并非是预置入class文件中常量池的内容内能进入方法区的运行时常量池，<strong>运行期间也可以将新的常量放入池中，用的比较多是有String.intern()</strong>，可以去看下文档。说的很清楚：</p>
<h3 id="直接内存">直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分</strong>，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>
<p>JDK 1.4中新加入了NIO(NEW Input/Output)类，引入了一种基于通道与缓冲区的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，<strong>因为避免了在Java堆和Native堆中来回复制数据</strong>。</p>
<p>服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OOM。</p>
<h3 id="总结">总结</h3><ul>
<li>程序计数器：行号指示器；空间小，最快；线程私有；不会有OOM</li>
<li>Java虚拟机栈：Java方法执行的内存模型,用于存储局部变量表、操作栈、动态链接、方法出口等信息；线程私有；StackOverFlowError,OOM</li>
<li>本地方法栈：和Java虚拟机栈发挥的作用非常相似，但是市委Native方法服务。</li>
<li>Java堆：存放对象实例；线程共享；OOM</li>
<li>方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；线程共享；OOM</li>
<li>运行时常量池：方法区的一部分；线程共享；存放编译期生成的各种字面量和符号引用；OOM</li>
<li>直接内存：直接内存并不是虚拟机运行时数据区的一部分，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现；新NIO利用了直接内存，效率高</li>
</ul>
<h2 id="HotSpot虚拟机对象探秘">HotSpot虚拟机对象探秘</h2><p>探讨Java堆中对象分配、布局和访问的全过程。</p>
<h3 id="对象的创建">对象的创建</h3><ol>
<li>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，就得执行类的加载过程，这个过程在第七章讲了。TODO 添加第七章链接</li>
<li><p>类加载检查过之后，虚拟机就为这个新生对象分配内存。目前有两种做法，使用哪种方式是由 GC 回收器是否带有压缩整理功能决定的：</p>
<ul>
<li>指针碰撞（Bump the Pointer）：假设Java堆中内存是绝对规整的 ，没用过的内存和用过的内存用一个指针划分（<em>需要保证 java 堆中的内存是规整的，一般情况是使用的 GC 回收器有压缩整理功能</em>），分配内存仅仅是将指针向空闲空间那边挪动一段与对象大小相等的距离。假如需要分配8个字节，指针就往后挪8个字节</li>
<li>空闲列表（Free List）：假设Java堆中内存是不规整的，已使用内存和空闲内存交错，虚拟机维护一个列表，记录哪些内存是可用的，分配的时候从列表中遍历，找到合适的内存分配，然后更新列表</li>
</ul>
</li>
<li><p>分配内存过程中还需要解决线程安全问题。 就刚才的一个修改指针操作，就会带来隐患：对象 A 正分配内存呢，突然对象 B 又同时使用了原来的指针来分配 B 的内存。解决方案也有两种：</p>
<ul>
<li>同步处理——实际上虚拟机采用 CAS 配上失败重试来保证更新操作的原子性</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，成为本地线程分配缓存（Thread Local Allocation Buffer，TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配，用完并分配新的TLAB时，才需要同步锁定（虚拟机是否使用 TLAB，可以通过<code>-XX:+/-UseTLAB</code> 参数来设置）</li>
</ul>
</li>
<li><p>给内存分配了空间之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。</p>
</li>
<li><p>接下来要对对象进行必要的设置，比如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的 hashcode 值是多少、对象的 GC 分代年龄等信息，这些信息都放在对象头中。</p>
</li>
<li><p>上面的步骤都完成后，从虚拟机角度来看，一个新的对象已经产生了，但是从 Java 程序的视角来看，对象创建才刚刚开始——<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
</li>
</ol>
<h3 id="对象的内存布局">对象的内存布局</h3><p>首先我们要知道的是：<strong>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instantce Data）、对齐补充（Padding）。</strong></p>
<ol>
<li>对象头（Header）：包含两部分信息。第一部分用于存储对象自身的运行时数据，如 hashcode 值、GC 分代的年龄、锁状态标志、线程持有的锁等，官方称为“Mark Word”。第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
<li>实例数据（Instance Data）：就是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li>
<li>内存对齐，对象的大小必须是8字节的整数倍</li>
</ol>
<h3 id="对象的访问定位">对象的访问定位</h3><ol>
<li>假如代码出现在方法体中，那么Object obj就会存在在<strong>Java虚拟机栈的本地变量表</strong>中，作为一个引用类型数据。</li>
<li>new Object()则存在在<strong>Java堆</strong>上。另外，在Java堆上还必须包含能查找到该对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在<strong>方法区</strong>中。</li>
<li><p>由于引用类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式可能不同，主流的有：</p>
<ol>
<li>使用句柄：Java堆中划分一块区域作为句柄池，引用存储的是对象的句柄地址，而句柄中含有对象实例数据和类型数据各自的数据信息</li>
<li>直接指针：引用中直接存储的就是对象的地址，同时还必须包括方法区类型信息的指针</li>
</ol>
</li>
</ol>
<p>下面是对应的图片：</p>
<p><img src="http://fh-1.qiniudn.com/reference_handler.jpg" alt="通过句柄访问对象"><br><img src="http://fh-1.qiniudn.com/direct_reference.jpg" alt="通过直接指针访问对象"></p>
<p>对于引用类型的实现，不同的实现方法有不同的特点：</p>
<ol>
<li>使用句柄：Java堆会划出一块区域作为句柄池，引用中存储的是稳定的句柄地址，而句柄中包含了<strong>对象实例数据（也在Java堆）和类型数据（方法区中）</strong>各自的地址信息。在对象被移动（垃圾回收时移动对象是非常普遍的行为）时只需要改变句柄中的实例数据指针，而引用本身核方法区的类型数据指针都不需要修改</li>
<li>直接指针：速度更快，因为不需要间接寻址。对于效率而言是更好的，Sun HotSpot就是使用这种方式实现对象访问的。但在其他虚拟机中，使用句柄方式也非常常见。</li>
</ol>
<h2 id="实战">实战</h2><p>下面我们会演示几个小程序，目的有两个：</p>
<ol>
<li>通过代码验证Java虚拟机规范中描述的各个运行时区域存储的内容</li>
<li>希望以后遇到类似问题时，能根据异常的信息快速判断是哪个区域的内存溢出，知道怎样的代码可能会导致这些区域的内存溢出，以及出现这些异常后改如何处理</li>
</ol>
<h3 id="Java堆溢出">Java堆溢出</h3><p>这个顾名思义，是最常见的。因为Java堆上存储的是对象实例，所以只要保证GC roots到该对象有路径可达，就会在不断创建对象的过程中达到Java堆的最大容量而导致溢出。下面是实例代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main (String[] args)&#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;OOMObject&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">list</span>.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看到，发生了OOM异常。要解决这个异常，一般是把内存快照dump（通过-XX:+HeapDumpOnOutOfMemoryError）下来用工具（Eclipse Memmory Analyzer）分析，确认<strong>内存中的对象是否是必要的</strong>，也就是要先分清到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory overflow）。</p>
<ul>
<li>如果是内存泄露：使用工具查看泄露对象到GC Roots的引用链。于是就可以顺藤摸瓜找到泄漏对象是通过怎样的路径关联GC Roots的，从而准确定位泄露代码的位置</li>
<li>如果是内存溢出：就应当检查虚拟机的堆参数（-Xmx和-Xms），与机器物理内存对比看是否可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长等情况，尝试减少程序运行期间的内存消耗</li>
</ul>
<h3 id="虚拟机栈和本地方法栈溢出">虚拟机栈和本地方法栈溢出</h3><p>-Xss可以设置栈容量。</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverFlowError异常</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，将抛出OutOfMemoryError异常</li>
</ul>
<p>通过调用无限递归调用，单线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError。通过不断创建线程倒是可以产生内存溢出异常，不过和栈空间是否足够大并不存在任何联系。</p>
<h3 id="方法区和运行时常量池溢出">方法区和运行时常量池溢出</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class RuntimeConstantPoolOOM&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（<span class="keyword">String</span>[]args）&#123;</span><br><span class="line">        <span class="keyword">String</span> str1=<span class="keyword">new</span> StringBuilder（<span class="string">"计算机"</span>）.<span class="built_in">append</span>（<span class="string">"软件"</span>）.toString（）；</span><br><span class="line">        System.out.<span class="built_in">println</span>（str1.intern（）==str1）；</span><br><span class="line">        <span class="keyword">String</span> str2=<span class="keyword">new</span> StringBuilder（<span class="string">"ja"</span>）.<span class="built_in">append</span>（<span class="string">"va"</span>）.toString（）；</span><br><span class="line">        System.out.<span class="built_in">println</span>（str2.intern（）==str2）；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在JDK 1.6中运行，会得到两个false，而在JDK 1.7中运行，会得到一个true和一个false。产生差异的原因是：在JDK 1.6中，intern（）方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。<strong>而JDK 1.7（以及部分其他虚拟机，例如JRockit）的intern（）实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern（）返回的引用和由StringBuilder创建的那个字符串实例是同一个</strong>。对str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString（）之前已经出现过，字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。</p>
<p>方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p>
<h3 id="本机直接内存溢出">本机直接内存溢出</h3><p>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p>
]]></content>
    <summary type="html">
    <![CDATA[深入理解Java虚拟机;Java内存区域与内存溢出异常;]]>
    
    </summary>
    
      <category term="JVM" scheme="http://howiefh.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JSP/Servlet及相关技术笔记]]></title>
    <link href="http://howiefh.github.io/2015/03/13/jsp-servlet-note/"/>
    <id>http://howiefh.github.io/2015/03/13/jsp-servlet-note/</id>
    <published>2015-03-13T02:04:54.000Z</published>
    <updated>2015-04-12T12:00:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="web应用">web应用</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`<span class="variable">&lt;webDemo&gt;</span>` : web应用名称</span><br><span class="line">|<span class="string">--WEB-INF</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">--classes : 保存单个`*.class`文件</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">--lib     : 保存jar包</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">--web.xml : 配置描述符，servlet3.0后不再是必须</span><br><span class="line"></span>|<span class="string">--`&lt;a.jsp&gt;` : jsp页面</span></span><br></pre></td></tr></table></figure>
<h2 id="java脚本">java脚本</h2><p><code>&lt;% %&gt;</code>中的内容即java脚本，会被系统编译在Servlet类中的service方法中。<br>每个jsp页面其实还是servlet</p>
<a id="more"></a>
<h2 id="jsp注释">jsp注释</h2><p><code>&lt;%-- 注释内容 --%&gt;</code>不会被输出到浏览器中</p>
<h2 id="jsp声明">jsp声明</h2><p><code>&lt;%! 声明部分 %&gt;</code>声明部分用于声明变量和方法。声明的变量和方法对应于编译后Servlet类中的成员变量和方法。</p>
<p>jsp页面会编译成Servlet类，每个Servlet在容器中只有一个实例：在jsp中声明的变量是成员变量，成员变量，成员变量只在创建实例时初始化，该变量的值将一直保存，直到实例销毁。</p>
<h2 id="输出jsp表达式">输出jsp表达式</h2><p><code>&lt;%= 表达式 %&gt;</code> 不可以有分号，编译时会转换为Servlet中的输出语句。</p>
<h2 id="jsp_3个编译指令">jsp 3个编译指令</h2><ul>
<li>page：该指令是针对当前页面的指令</li>
<li>include：用于指定包含另一个页面</li>
<li>taglib：用于定义和访问自定义标签</li>
</ul>
<p>编译指令的语法格式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">%@</span> 编译指令名 属性名=<span class="value">"属性值"</span><span class="value">...</span> %&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="page指令">page指令</h3><ul>
<li>language：声明当前jsp页面使用的脚本语言种类，默认是java。</li>
<li>extends：指定jsp页面编译所产生的java类所继承的父类，或所实现的接口。</li>
<li>import：用于导入包，<code>java.lang.*、javax.servlet.*、javax.servlet.jsp.*、javax.servlet.http.*</code></li>
<li>session：设定这个jsp页面是否需要http session</li>
<li>buffer：指定输出缓存区大小，jsp内部对象：out用于缓存jsp页面对客户端浏览器的输出。默认值为8kb，可以设置为none，也可设为其它值，单位kb。</li>
<li>autoFlush：当缓存即将溢出时，是否需要强制输出缓存区的内容。设置为true时为正常输出；如果设置为false，则会在溢出时产生异常。</li>
<li>info：设置jsp程序的信息，可调用getServletInfo()方法获取该值，因为jsp页面实质就是Servlet。</li>
<li>errorPage：指定错误处理页面。如果本页面产生异常或错误，而该jsp页面没有对应处理代码，将会自动调用指定的页面。实质是jsp的异常处理机制，jsp脚本不要求强制处理异常，即使是受检查的。</li>
<li>isErrorPage：设置本jsp页面是否为错误处理程序，如果该页面已经是错误处理页面，则无需errorPage属性。</li>
<li>contentType：用于设定生成网页的文件格式和编码字符集，即MIME类型和页面字符集类型，默认MIME类型是text/html，默认的字符集类型为ISO-8859-1。</li>
<li>pageEncoding：指定生成网页的编码字符集。</li>
</ul>
<h3 id="include指令">include指令</h3><p>include指令会将包含的页面加入到本页面，融合成一个页面，因此被包含页面甚至不需要是一个完整的页面，可以是静态页面，也可以是动态的jsp页面。</p>
<p>语法</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="variable">%@</span>include <span class="keyword">file</span>=<span class="string">"relativeUrlSpec"</span><span class="variable">%&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意，静态include会将包含页面的编译指令也包含进来，如果两个页面的编译指令冲突，那么页面就会出错</strong>。</p>
<h2 id="jsp7个动作指令">jsp7个动作指令</h2><ul>
<li>jsp:forward：执行页面转向，将请求的处理转发到下一个页面。</li>
<li>jsp:param：用于传递参数，必须与其他支持参数的标签一起使用。</li>
<li>jsp:include：用于动态引入一个jsp页面。</li>
<li>jsp:plugin：用于下载JavaBean或Applet到客户端执行。很少会用到。</li>
<li>jsp:useBean：创建一个JavaBean实例。</li>
<li>jsp:setProperty：设置JavaBean实例的属性。</li>
<li>jsp:getProperty：获取JavaBean实例的属性。</li>
</ul>
<h3 id="forward指令">forward指令</h3><p>既可以转发到静态的html页面，也可以转发到动态的jsp页面，或者转发到容器中的Servlet。</p>
<p>jsp1.0：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">jsp:forward</span> <span class="attribute">page</span>=<span class="value">"&#123;relativeURL|</span></span></span>&lt;%=<span class="ruby">expression</span>%&gt;<span class="xml"><span class="tag"><span class="value">&#125;"</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>jsp1.1</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">jsp:forward</span> <span class="attribute">page</span>=<span class="value">"&#123;relativeURL|</span></span></span>&lt;%=<span class="ruby">expression</span>%&gt;<span class="xml"><span class="tag"><span class="value">&#125;"</span>&gt;</span></span><br><span class="line">&#123;<span class="tag">&lt;<span class="title">jsp:param</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"value"</span>/&gt;</span>&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">jsp:forward</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>第二种用于转发时添加额外的请求参数。</p>
<p><strong>执行forward指令时，用户请求的地址依然没有发生改变，但页面内容却完全变为被forward目标页的内容</strong>。</p>
<p>执行forward指令时，客户端请求参数不会丢失。</p>
<p><strong>实际上forward并没有重新向新页面发送请求，它只是完全采用了新页面来对用户生成响应—请求依然是一次，所以请求参数、属性没丢失</strong>。</p>
<h3 id="include指令-1">include指令</h3><p><strong>动态include指令，也用于包含某个页面，它不会导入include页面的编译指令，仅仅将被导入页面的body内容插入本页面</strong>。</p>
<p>语法</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">jsp:include</span> <span class="attribute">page</span>=<span class="value">"&#123;relativeURL|</span></span></span>&lt;%=<span class="ruby">expression</span>%&gt;<span class="xml"><span class="tag"><span class="value">&#125;"</span> <span class="attribute">flush</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">//或</span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:include</span> <span class="attribute">page</span>=<span class="value">"&#123;relativeURL|</span></span></span>&lt;%=<span class="ruby">expression</span>%&gt;<span class="xml"><span class="tag"><span class="value">&#125;"</span> <span class="attribute">flush</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:param</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"value"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">jsp:include</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>编译为servlet后，只是使用一个include方法来插入目标页面内容，而不是将目标页面完全融入本页面中。</p>
<p><strong>静态导入和动态导入的三点区别</strong>：</p>
<ul>
<li>静态导入是将导入页面的代码完全融入，两个页面融合成一个整体servlet；而动态导入则在servlet中使用include方法来引入被导入页面的内容。</li>
<li>静态导入时被导入页面的编译指令会起作用；而动态导入时被导入页面的编译指令则失去作用，只是插入被导入页面的body内容。</li>
<li>动态包含还可以增加额外的参数。</li>
</ul>
<p>forward 指令和 include 指令动作十分相似。forward 指令使用_jspx_page_context的forward() 方法来引入目标页面。include用JspRuntimeLibrary 的include()方法引入目标页面。区别在于：forward拿目标页面代替原有页面，而include则拿目标页面插入原有页面。</p>
<h3 id="useBean、setProperty、getProperty指令">useBean、setProperty、getProperty指令</h3><p>这三个指令都是与JavaBean相关的指令，其中useBean指令用于在JSP页面中初始化一个Java实例；setProperty指令用于为JavaBean实例的属性设置值；getProperty指令用于输出JavaBean实例的属性。</p>
<p>useBean语法格式如下：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean <span class="variable">id=</span><span class="string">"name"</span> <span class="variable">class=</span><span class="string">"classname"</span> <span class="variable">scope=</span><span class="string">"page|request|session|application"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>其中id是JavaBean的实例名，class属性确定JavaBean的实现类。Scope属性用于指定JavaBean实例的作用范围：</p>
<p>page：仅在该页面有效。<br>request：在本次请求有效。<br>session：在本次session内有效。<br>application：在本次应用内一直有效。</p>
<p>setProperty语法格式如下：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:setProperty <span class="variable">property=</span><span class="string">"ProtertyName"</span> <span class="variable">name=</span><span class="string">"BeanName"</span> <span class="variable">value=</span><span class="string">"value"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>name属性是需要设定JavaBean的实例名；property属性确定需要设置的属性名；value属性则确定需要设置的属性值。</p>
<p>getProperty语法格式如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:getProperty <span class="keyword">property</span>=<span class="string">"ProtertyName"</span> <span class="property">name</span>=<span class="string">"BeanName"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>name属性确定需要输出的JavaBean的实例名，property属性确定需要输出的属性名。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 创建lee.Person 实例，该实例的名称是p1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:useBean</span> <span class="attribute">id</span>=<span class="value">"p1"</span> <span class="attribute">class</span>=<span class="value">"Person"</span> <span class="attribute">scope</span>=<span class="value">"page"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:setProperty</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">property</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"waw"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:setProperty</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">property</span>=<span class="value">"age"</span> <span class="attribute">value</span>=<span class="value">"29"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:getProperty</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">property</span>=<span class="value">"name"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:getProperty</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">property</span>=<span class="value">"age"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不使用这三个标签，也可以通过jsp脚本完成相同功能。</p>
<h3 id="param指令">param指令</h3><p>和jsp:include、jsp:forward、jsp:plugin指令结合使用，语法：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:<span class="built_in">param</span> name=<span class="string">"paramName"</span> <span class="built_in">value</span>=<span class="string">"paramValue"</span> /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="jsp脚本中的9个内置对象">jsp脚本中的9个内置对象</h2><p>jsp页面对应的Servlet的<code>_jspService()</code>方法来创建内置对象。</p>
<ul>
<li>application：javax.servlet.ServletContext的实例，<strong>该实例代表JSP所属的Web应用本身，可用于JSP页面，或者Servlet之间交换信息</strong>。常用的方法有getAttribute(String attName)、setAttribute(String attName , String attValue)和getInitParameter(String paramName)等。</li>
<li>config：javax.servlet.ServletConfig的实例，该实例代表该JSP的配置信息。常用的方法有getInitParameter(String paramName)和getInitParameternames()等方法。事实上，JSP页面通常无须配置，也就不存在配置信息。因此，该对象更多地在Servlet中有效。</li>
<li>exception：java.lang.Throwable的实例，该实例代表其他页面中的异常和错误。<strong>只有当页面是错误处理页面，即编译指令page的isErrorPage属性为true时，该对象才可以使用</strong>。常用的方法有getMessage()和printStackTrace()等。</li>
<li>out：javax.servlet.jsp.JspWriter的实例，该实例代表JSP页面的输出流，用于输出内容，形成HTML页面。</li>
<li>page：代表该页面本身，通常没有太大用处。也就是Servlet中的this，其类型就是生成的Servlet类，能用page的地方就可用this。</li>
<li>pageContext：javax.servlet.jsp.PageContext的实例，该对象代表该JSP页面上下文，使用该对象可以访问页面中的共享数据。常用的方法有getServletContext()和getServletConfig()等。</li>
<li>request：javax.servlet.http.HttpServletRequest的实例，该对象封装了一次请求，客户端的请求参数都被封装在该对象里。这是一个常用的对象，获取客户端请求参数必须使用该对象。常用的方法有getParameter(String paramName)、getParameterValues(String paramName)、setAttribute(String atttName,Object attrValue)、getAttribute(String attrName)和setCharacterEncoding(String env)等。</li>
<li>response：javax.servlet.http.HttpServletResponse的实例，代表服务器对客户端的响应。通常很少使用该对象直接响应，而是使用out对象，除非需要生成非字符响应。而response对象常用于重定向，常用的方法有getOutputStream()、sendRedirect(java.lang.String location)等。</li>
<li>session：javax.servlet.http.HttpSession的实例，该对象代表一次会话。当客户端浏览器与站点建立连接时，会话开始；当客户端关闭浏览器时，会话结束。常用的方法有：getAttribute(String attrName)、setAttribute(String attrName, Object attrValue)等。</li>
</ul>
<p>request、response是<code>_jspService()</code>方法的形参，其它都是其局部变量。</p>
<p><strong>由于jsp内置对象都是在<code>_jspService()</code>方法中完成初始化的，因此只能在jsp脚本、jsp输出表达式中使用这些内置变量。千万不要在jsp声明中使用它们</strong>。</p>
<h3 id="application">application</h3><p>对于每次客户端请求而言，<strong>Web服务器大致需要完成如下几个步骤</strong>：</p>
<ol>
<li>启动单独的线程。</li>
<li>使用I/O流读取用户的请求数据。</li>
<li>从请求数据中解析参数。</li>
<li>处理用户请求。</li>
<li>生成响应数据。</li>
<li>使用IO流向客户端发送请求数据。</li>
</ol>
<p>在上面6个步骤中，第1、2和6步是通用的，可以由Web服务器来完成，但第3、4和5步则存在差异：因为不同请求里包含的请求参数不同，处理用户请求的方式也不同，所生成的响应自然也不同。Web服务器会调用Servlet的<code>_jspService()</code>方法来完成第3、4和5步，<strong>当我们编写JSP页面时，页面里的静态内容、JSP脚本都会转换成<code>_jspService()</code>方法的执行代码，这些执行代码负责完成解析参数、处理请求、生成响应等业务功能，而Web服务器则负责完成多线程、网络通信等底层功能</strong>。</p>
<p>为了解决JSP、Servlet之间如何交换数据的问题，几乎所有Web服务器（包括Java、ASP、PHP、Ruby等）都会提供4个类似Map的结构，分别是application、session、request、page，并允许JSP、Servlet将数据放入这4个类似Map的结构中，并允许从这4个Map结构中取出数据。这4个Map结构的区别是范围不同。</p>
<ul>
<li>application：对于整个Web应用有效，一旦JSP、Servlet将数据放入application中，该数据将可以被该应用下其他所有的JSP、Servlet访问。</li>
<li>session：仅对一次会话有效，一旦JSP、Servlet将数据放入session中，该数据将可以被本次会话的其他所有的JSP、Servlet访问。</li>
<li>request：仅对本次请求有效，一旦JSP、Servlet将数据放入request中，该数据将可以被该次请求的其他JSP、Servlet访问。</li>
<li>page：仅对当前页面有效，一旦JSP、Servlet将数据放入page中，该数据只可以被当前页面的JSP脚本、声明部分访问。</li>
</ul>
<p>application对象通常有如下两个作用：</p>
<ul>
<li>在整个Web应用的多个JSP、Servlet之间共享数据。</li>
<li>访问Web应用的配置参数。</li>
</ul>
<ol>
<li><p>让多个jsp、servlet共享数据</p>
<p> application通过setAttribute(String attrName,Object value)方法将一个值设置成application的attrName属性，该属性的值对整个Web应用有效，因此该Web应用的每个JSP页面或Servlet都可以访问该属性，访问属性的方法为getAttribute(String attrName)。<br> <strong>由于在Servlet中并没有application内置对象，所以可以通过<code>ServletContext sc = getServletConfig().getServletContext()</code>显式获取了该Web应用的ServletContext实例</strong>，每个Web应用只有一个ServletContext实例，在JSP页面中可通过application内置对象访问该实例，而Servlet中则必须通过代码获取。<br> 编译Servlet时可能由于没有添加环境出现异常，如果安装了Java EE 6 SDK，只需将Java EE 6 SDK路径的javaee.jar文件添加到CLASSPATH环境变量中；如果没有安装Java EE SDK，可以将Tomcat 7的lib路径下的jsp-api.jar、servlet-api.jar两个文件添加到CLASSPATH环境变量中。<br> <strong>虽然使用application（即ServletContext实例）可以方便多个JSP、Servlet共享数据，但不要仅为了JSP、Servlet共享数据就将数据放入application中！由于application代表整个Web应用，所以通常只应该把Web应用的状态数据放入application里</strong>。</p>
</li>
<li><p>获得Web应用配置参数</p>
<p> 一些配置信息可以放在web.xml文件中，使用context-param元素配置，每个<context-param…>元素配置一个参数，该元素下有如下两个子元素。</context-param…></p>
<ul>
<li>param-name：配置Web参数名。</li>
<li>param-value：配置Web参数值。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置第一个参数：user --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">context-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>user<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">context-param</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 配置第二个参数：pass --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">context-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>pass<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>32147<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
之后可以通过application的 getInitParameter(String paramName)方法获取配置参数。<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String user = application.getInitParameter(<span class="string">"user"</span>);</span><br><span class="line">String <span class="keyword">pwd</span> = application.getInitParameter(<span class="string">"pass"</span>);</span><br><span class="line">out.println(user + <span class="string">" "</span> + <span class="keyword">pwd</span>);</span><br><span class="line"><span class="variable">%&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="config">config</h3><p>config对象代表当前JSP配置信息，但JSP页面通常无须配置，因此也就不存在配置信息。该对象在JSP页面中比较少用，但在Servlet中则用处相对较大，因为Servlet需要在web.xml文件中进行配置，可以指定配置参数。</p>
<p>在jsp输出config的getServletName()方法的返回值为jsp，所有的JSP页面都有相同的名字：jsp</p>
<p>config对象是ServletConfig的实例，该接口用于获取配置参数的方法是getInitParameter(String paramName)</p>
<p>配置JSP也是在web.xml文件中进行的，JSP被当成Servlet配置，为Servlet配置参数使用init-param元素，该元素可以接受param-name和param-value两个子元素，分别指定参数名和参数值。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 指定Servlet名字 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>config<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 指定将哪个JSP页面配置成Servlet --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">jsp-file</span>&gt;</span>/configTest2.jsp<span class="tag">&lt;/<span class="title">jsp-file</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置名为name的参数，值为yeeku --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>yeeku<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置名为age的参数，值为30 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>age<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>30<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 指定将config Servlet配置到/config路径 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>config<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/config<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的配置文件片段为该Servlet（其实是JSP）配置了2个参数：name和age。上面的配置片段把configTest2.jsp页面配置成名为config的Servlet，并将该Servlet映射到/config处，这就允许我们通过/config来访问该页面。</p>
<p>通过config可以访问到web.xml文件中的配置参数。实际上，我们也可以直接访问configTest2.jsp页面。</p>
<p>如果希望JSP页面可以获取web.xml配置文件中的配置信息，则必须通过为该JSP配置的路径来访问该页面，因为只有这样访问JSP页面才会让配置参数起作用。</p>
<h3 id="exception">exception</h3><p>exception对象是Throwable的实例，代表JSP脚本中产生的错误和异常，是JSP页面异常机制的一部分。</p>
<p>exception对象仅在异常处理页面中才有效，即isErrorPage为true时。</p>
<p>编译为servlet后，这些脚本已经处于<code>_jspService()</code>方法的try块中。一旦try块捕捉到JSP脚本的异常，并且<code>_jspx_page_context</code>不为null，就会由该对象来处理该异常，如上面粗体字代码所示。<code>_jspx_page_context</code>对异常的处理也非常简单：如果该页面的page指令指定了errorPage属性，则将请求forward到errorPage属性指定的页面，否则使用系统页面来输出异常信息。只有jsp脚本、输出表达式才会对应于<code>_jspService()</code>方法里的代码，所以这两部分的代码无须处理checked异常。但是jsp的异常处理机制对jsp声明不起作用。</p>
<h3 id="out">out</h3><p>out对象代表一个页面输出流，通常用于在页面上输出变量值及常量。一般在使用输出表达式的地方，都可以使用out对象来达到同样效果。</p>
<h3 id="pageContext">pageContext</h3><p>这个对象代表页面上下文，该对象主要用于访问JSP之间的共享数据。使用pageContext可以访问page、request、session、application范围的变量。</p>
<p>pageContext是PageContext类的实例，它提供了如下两个方法来访问page、request、session、application范围的变量。</p>
<ul>
<li>getAttribute(String name)：取得page范围内的name属性。</li>
<li><p>getAttribute(String name,int scope)：取得指定范围内的name属性，其中scope可以是如下4个值。</p>
<ul>
<li>PageContext.PAGE_SCOPE：对应于page范围。</li>
<li>PageContext.REQUEST_SCOPE：对应于request范围。</li>
<li>PageContext.SESSION_SCOPE：对应于session范围。</li>
<li>PageContext.APPLICATION_SCOPE：对应于application范围。</li>
</ul>
</li>
</ul>
<p>与getAttribute()方法相对应，PageContext也提供了2个对应的setAttribute()方法，用于将指定变量放入page、request、session、application范围内。</p>
<p>pageContext还可用于获取其他内置对象，pageContext对象包含如下方法。</p>
<ul>
<li>ServletRequest getRequest()：获取request对象。</li>
<li>ServletResponse getResponse()：获取response对象。</li>
<li>ServletConfig getServletConfig()：获取config对象。</li>
<li>ServletContext getServletContext()：获取application对象。</li>
<li>HttpSession getSession()：获取session对象。</li>
</ul>
<p>因此一旦在JSP、Servlet编程中获取了pageContext对象，就可以通过它提供的上面方法来获取其他内置对象。</p>
<h3 id="request">request</h3><p>request对象是获取请求参数的重要途径。除此之外，request可代表本次请求范围，所以还可用于操作request范围的属性。</p>
<ol>
<li><p>获取请求头/请求参数</p>
<p> request是HttpServletRequest接口的实例，它提供了如下几个方法来获取请求参数。</p>
<ul>
<li>String getParameter(String paramName)：获取paramName请求参数的值。</li>
<li>Map getParameterMap()：获取所有请求参数名和参数值所组成的Map对象。</li>
<li>Enumeration getParameterNames()：获取所有请求参数名所组成的Enumeration对象。</li>
<li><p>String[] getParameterValues(String name)：paramName请求参数的值，当该请求参数有多个值时，该方法将返回多个值所组成的数组。</p>
<p>HttpServletRequest提供了如下方法来访问请求头。</p>
</li>
<li><p>String getHeader(String name)：根据指定请求头的值。</p>
</li>
<li>java.util.Enumeration<string> getHeaderNames()：获取所有请求头的名称。</string></li>
<li>java.util.Enumeration<string> getHeaders(String name)：获取指定请求头的多个值。</string></li>
<li><p>int getIntHeader(String name)：获取指定请求头的值，并将该值转为整数值。</p>
<p>对于开发人员来说，请求头和请求参数都是由用户发送到服务器的数据，区别在于请求头通常由浏览器自动添加，因此一次请求总是包含若干请求头；而请求参数则通常需要开发人员控制添加，让客户端发送请求参数通常分两种情况。</p>
<p><strong>GET方式的请求：直接在浏览器地址栏输入访问地址所发送的请求或提交表单发送请求时，该表单对应的form元素没有设置method属性，或设置method属性为get，这几种请求都是GET方式的请求。GET方式的请求会将请求参数的名和值转换成字符串，并附加在原URL之后，因此可以在地址栏中看到请求参数名和值。且GET请求传送的数据量较小，一般不能大于2KB</strong>。</p>
<p><strong>POST方式的请求：这种方式通常使用提交表单（由form HTML元素表示）的方式来发送，且需要设置form元素的method属性为post。POST方式传送的数据量较大，通常认为POST请求参数的大小不受限制，但往往取决于服务器的限制，POST请求传输的数据量总比GET传输的数据量大。而且POST方式发送的请求参数以及对应的值放在HTML HEADER中传输，用户不能在地址栏里看到请求参数值，安全性相对较高</strong>。</p>
<p>对比上面两种请求方式，由此可见我们通常应该采用POST方式发送请求。</p>
<p>并不是每个表单域都会生成请求参数的，而是有name属性的表单域才生成请求参数。关于表单域和请求参数的关系遵循如下4点：</p>
</li>
<li><p>每个有name属性的表单域对应一个请求参数。</p>
</li>
<li>如果有多个表单域有相同的name属性，则多个表单域只生成一个请求参数，只是该参数有多个值。</li>
<li>表单域的name属性指定请求参数名，value指定请求参数值。</li>
<li><p>如果某个表单域设置了disabled=”disabled”属性，则该表单域不再生成请求参数。</p>
<p>如果发送请求的表单页采用gb2312字符集，该表单页发送的请求也将采用gb2312字符集，所以本页面需要先执行如下方法。 <code>setCharacterEncoding(&quot;gb2312&quot;)</code>：设置request编码所用的字符集。<br>使用GET方法，如果请求参数值里包含非西欧字符，那么是不是应该先调用setCharacterEncoding()来设置request编码的字符集呢？读者可以试一下。答案是不行，如果GET方式的请求值里包含了非西欧字符，则获取这些参数比较复杂。为了获取GET请求里的中文参数值，必须借助于java.net.URLDecoder类。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">%</span></span><br><span class="line"><span class="comment">//获取请求里包含的查询字符串  </span></span><br><span class="line">String rawQueryStr = request.getQueryString<span class="params">()</span>;  </span><br><span class="line">out.println<span class="params">(<span class="string">"原始查询字符串为："</span> + rawQueryStr + <span class="string">"&lt;hr/&gt;"</span>)</span>;  </span><br><span class="line"><span class="comment">//使用URLDecoder解码字符串  </span></span><br><span class="line">String queryStr = java.net.URLDecoder.decode<span class="params">(rawQueryStr , <span class="string">"gbk"</span>)</span>; </span><br><span class="line">out.println<span class="params">(<span class="string">"解码后的查询字符串为："</span> + queryStr + <span class="string">"&lt;hr/&gt;"</span>)</span>;</span><br><span class="line"><span class="built_in">%</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可通过如下代码来取得name请求参数的参数值。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="comment">//获取原始的请求参数值  </span></span><br><span class="line"><span class="keyword">String</span> rawName = request.getParameter(<span class="string">"name"</span>);  </span><br><span class="line"><span class="comment">//将请求参数值使用ISO-8859-1字符串分解成字节数组  </span></span><br><span class="line"><span class="built_in">byte</span>[] rawBytes = rawName.getBytes(<span class="string">"ISO-8859-1"</span>);  </span><br><span class="line"><span class="comment">//将字节数组重新解码成字符串  </span></span><br><span class="line"><span class="keyword">String</span> name = <span class="keyword">new</span> <span class="keyword">String</span>(rawBytes , <span class="string">"gb2312"</span>); </span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>操作request范围的属性</p>
<p> HttpServletRequest还包含如下两个方法，用于设置和获取request范围的属性。</p>
<ul>
<li>setAttribute(String attName , Object attValue)：将attValue设置成request范围的属性。</li>
<li>Object getAttribute(String attName)：获取request范围的属性。<br>当forward用户请求时，请求的参数和请求属性都不会丢失。通过<code>setAttribute</code>方法设置的属性也不会丢失。</li>
</ul>
</li>
<li><p>执行forward或include</p>
<p> request还有一个功能就是执行forward和include，也就是代替JSP所提供的forward和include动作指令。<br> HttpServletRequest类提供了一个getRequestDispatcher (String path)方法，其中path就是希望forward或者include的目标路径，该方法返回RequestDispatcher，该对象提供了如下两个方法。</p>
<ul>
<li>forward(ServletRequest request, ServletResponse response)：执行forward。</li>
<li><p>include(ServletRequest request, ServletResponse response)：执行include。</p>
<p>使用request的getRequestDispatcher(String path)方法时，该path字符串必须以斜线开头。</p>
</li>
</ul>
</li>
</ol>
<h3 id="response">response</h3><p>response代表服务器对客户端的响应。大部分时候，程序无须使用response来响应客户端请求，因为有个更简单的响应对象—out，它代表页面输出流，直接使用out生成响应更简单。</p>
<p>但out是JspWriter的实例，JspWriter是Writer的子类，Writer是字符流，无法输出非字符内容。假如需要在JSP页面中动态生成一幅位图、或者输出一个PDF文档，使用out作为响应对象将无法完成，此时必须使用response作为响应输出。</p>
<p>除此之外，还可以使用response来重定向请求，以及用于向客户端增加Cookie。</p>
<ol>
<li><p>response响应生成非字符响应</p>
<p> response是HttpServletResponse接口的实例，该接口提供了一个getOutputStream()方法，该方法返回响应输出字节流。下面的方法可以输出图像。</p>
 <figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">%</span>-- 通过contentType属性指定响应数据是图片 --<span class="built_in">%</span>&gt; </span><br><span class="line">&lt;<span class="built_in">%</span>@ page contentType=<span class="string">"image/jpeg"</span> language=<span class="string">"java"</span><span class="built_in">%</span>&gt; </span><br><span class="line">&lt;<span class="built_in">%</span>@ page <span class="built_in">import</span>=<span class="string">"java.awt.image.*,javax.imageio.*,java.io.*,java.awt.*"</span><span class="built_in">%</span>&gt; </span><br><span class="line">&lt;<span class="built_in">%</span>  </span><br><span class="line"><span class="comment">//创建BufferedImage对象  </span></span><br><span class="line">BufferedImage image = new BufferedImage<span class="params">(<span class="number">340</span> , <span class="number">160</span>, BufferedImage.TYPE_INT_RGB)</span>;  </span><br><span class="line"><span class="comment">//以Image对象获取Graphics对象  </span></span><br><span class="line">Graphics g = image.getGraphics<span class="params">()</span>;  </span><br><span class="line"><span class="comment">//使用Graphics画图，所画的图像将会出现在image对象中  </span></span><br><span class="line">g.fillRect<span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">400</span>,<span class="number">400</span>)</span>;  </span><br><span class="line"><span class="comment">//设置颜色：红  </span></span><br><span class="line">g.setColor<span class="params">(new Color<span class="params">(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)</span>)</span>;  </span><br><span class="line"><span class="comment">//画出一段弧  </span></span><br><span class="line">g.fillArc<span class="params">(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>,<span class="number">100</span>, <span class="number">30</span>, <span class="number">120</span>)</span>;  </span><br><span class="line"><span class="comment">//设置颜色：绿  </span></span><br><span class="line">g.setColor<span class="params">(new Color<span class="params">(<span class="number">0</span> , <span class="number">255</span>, <span class="number">0</span>)</span>)</span>;  </span><br><span class="line"><span class="comment">//画出一段弧  </span></span><br><span class="line">g.fillArc<span class="params">(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>,<span class="number">100</span>, <span class="number">150</span>, <span class="number">120</span>)</span>;  </span><br><span class="line"><span class="comment">//设置颜色：蓝  </span></span><br><span class="line">g.setColor<span class="params">(new Color<span class="params">(<span class="number">0</span> , <span class="number">0</span>, <span class="number">255</span>)</span>)</span>;  </span><br><span class="line"><span class="comment">//画出一段弧  </span></span><br><span class="line">g.fillArc<span class="params">(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>,<span class="number">100</span>, <span class="number">270</span>, <span class="number">120</span>)</span>;  </span><br><span class="line"><span class="comment">//设置颜色：黑  </span></span><br><span class="line">g.setColor<span class="params">(new Color<span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span>)</span>;  </span><br><span class="line">g.setFont<span class="params">(new Font<span class="params">(<span class="string">"Arial Black"</span>, Font.PLAIN, <span class="number">16</span>)</span>)</span>;  </span><br><span class="line"><span class="comment">//画出三个字符串  </span></span><br><span class="line">g.drawString<span class="params">(<span class="string">"red:climb"</span> , <span class="number">200</span> , <span class="number">60</span>)</span>;  </span><br><span class="line">g.drawString<span class="params">(<span class="string">"green:swim"</span> , <span class="number">200</span> , <span class="number">100</span>)</span>;  </span><br><span class="line">g.drawString<span class="params">(<span class="string">"blue:jump"</span> , <span class="number">200</span> , <span class="number">140</span>)</span>;  </span><br><span class="line">g.dispose<span class="params">()</span>;  </span><br><span class="line"><span class="comment">//将图像输出到页面的响应  </span></span><br><span class="line">ImageIO.write<span class="params">(image , <span class="string">"jpg"</span> , response.getOutputStream<span class="params">()</span>)</span>;  </span><br><span class="line"><span class="built_in">%</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重定向</p>
<p> 重定向是response的另外一个用处，与forward不同的是，重定向会丢失所有的请求参数和request范围的属性，因为重定向将生成第二次请求，与前一次请求不在同一个request范围内，所以发送一次请求的请求参数和request范围的属性全部丢失。</p>
<p> HttpServletResponse提供了一个sendRedirect(String path)方法，该方法用于重定向到path资源，即重新向path资源发送请求。</p>
<p> forward和redirect对比</p>
<p> <strong>执行redirect后生成第二次请求，而forward依然是上一次请求。<br> redirect的目标页面不能访问原请求的请求参数，因为是第二次请求了，所有原请求的请求参数、request范围的属性全部丢失。forward的目标页面可以访问原请求的请求参数，因为依然是同一次请求，所有原请求的请求参数、request范围的属性全部存在。<br> 地址栏改为重定向的目标URL。相当于在浏览器地址栏里输入新的URL后按回车键。而forward地址栏里请求的URL不会改变</strong></p>
</li>
<li><p>增加Cookie</p>
<p> <strong>Cookie与session的不同之处在于：session会随浏览器的关闭而失效，但Cookie会一直存放在客户端机器上，除非超出Cookie的生命期限</strong>。</p>
<p> 增加Cookie也是使用response内置对象完成的，response对象提供了如下方法。<br> void addCookie(Cookie cookie)：增加Cookie。<br> 增加Cookie请按如下步骤进行。</p>
<ul>
<li>创建Cookie实例，Cookie的构造器为Cookie(String name, String value)。</li>
<li>设置Cookie的生命期限，即该Cookie在多长时间内有效。</li>
<li>向客户端写Cookie。<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">%</span></span><br><span class="line"><span class="comment">//增加cookie</span></span><br><span class="line">String name = request.getParameter<span class="params">(<span class="string">"name"</span>)</span>;  </span><br><span class="line"><span class="comment">//以获取到的请求参数为值，创建一个Cookie对象  </span></span><br><span class="line">Cookie c = new Cookie<span class="params">(<span class="string">"username"</span> , name)</span>;  </span><br><span class="line"><span class="comment">//设置Cookie对象的生存期限  </span></span><br><span class="line">c.setMaxAge<span class="params">(<span class="number">24</span> * <span class="number">3600</span>)</span>;  </span><br><span class="line"><span class="comment">//向客户端增加Cookie对象  </span></span><br><span class="line">response.addCookie<span class="params">(c)</span>;  </span><br><span class="line"><span class="built_in">%</span>&gt;</span><br></pre></td></tr></table></figure>
访问客户端Cookie使用request对象，request对象提供了getCookies()方法，该方法将返回客户端机器上所有Cookie组成的数组，遍历该数组的每个元素，找到希望访问的Cookie即可。<br>使用Cookie对象必须设置其生存期限，否则Cookie将会随浏览器的关闭而自动消失。<br>默认情况下，Cookie值不允许出现中文字符，如果我们需要值为中文内容的Cookie怎么办呢？同样可以借助于java.net.URLEncoder先对中文字符串进行编码，将编码后的结果设为Cookie值。当程序要读取Cookie时，则应该先读取，然后使用java.net.URLDecoder对其进行解码。</li>
</ul>
</li>
</ol>
<h3 id="session">session</h3><p><strong>session对象也是一个非常常用的对象，这个对象代表一次用户会话。一次用户会话的含义是：从客户端浏览器连接服务器开始，到客户端浏览器与服务器断开为止，这个过程就是一次会话</strong>。</p>
<p>session通常用于跟踪用户的会话信息，如判断用户是否登录系统，或者在购物车应用中，用于跟踪用户购买的商品等。</p>
<p>session对象是HttpSession的实例，HttpSession有如下两个常用的方法。</p>
<p>setAttribute(String attName，Object attValue)：设置session范围内attName属性的值为attValue。<br>getAttribute(String attName)：返回session范围内attName属性的值。</p>
<p>关于session还有一点需要指出，<strong>session机制通常用于保存客户端的状态信息，这些状态信息需要保存到Web服务器的硬盘上，所以要求session里的属性值必须是可序列化的，否则将会引发不可序列化的异常</strong>。</p>
<p>session的属性值可以是任何可序列化的Java对象。</p>
<h2 id="servlet介绍">servlet介绍</h2><h3 id="Servlet的开发">Servlet的开发</h3><p>前面介绍的JSP的本质就是Servlet，Servlet通常被称为服务器端小程序，是运行在服务器端的程序，用于处理及响应客户端的请求。</p>
<p>Servlet是个特殊的Java类，这个Java类必须继承HttpServlet。每个Servlet可以响应客户端的请求。Servlet提供不同的方法用于响应客户端请求。</p>
<ul>
<li>doGet：用于响应客户端的GET请求。</li>
<li>doPost：用于响应客户端的POST请求。</li>
<li>doPut：用于响应客户端的PUT请求。</li>
<li>doDelete：用于响应客户端的DELETE请求。</li>
</ul>
<p>事实上，客户端的请求通常只有GET和POST两种，Servlet为了响应这两种请求，必须重写doGet()和doPost()两个方法。如果Servlet为了响应4个方式的请求，则需要同时重写上面的4个方法。</p>
<p>大部分时候，Servlet对于所有请求的响应都是完全一样的。此时，可以采用重写一个方法来代替上面的几个方法：只需重写service()方法即可响应客户端的所有请求。</p>
<p>另外，HttpServlet还包含两个方法。</p>
<ul>
<li>init(ServletConfig config)：创建Servlet实例时，调用该方法的初始化Servlet资源。</li>
<li>destroy()：销毁Servlet实例时，自动调用该方法的回收资源。</li>
</ul>
<p>通常无须重写init()和destroy()两个方法，除非需要在初始化Servlet时，完成某些资源初始化的方法，才考虑重写init方法。如果需要在销毁Servlet之前，先完成某些资源的回收，比如关闭数据库连接等，才需要重写destroy方法。</p>
<p>不用为Servlet类编写构造器，如果需要对Servlet执行初始化操作，应将初始化操作放在Servlet的init()方法中定义。如果重写了init(ServletConfig config)方法，则应在重写该方法的第一行调用super.init(config)。该方法将调用HttpServlet的init方法。</p>
<p>Servlet和JSP的区别在于：</p>
<ul>
<li>Servlet中没有内置对象，原来JSP中的内置对象都必须由程序显式创建。</li>
<li>对于静态的HTML标签，Servlet都必须使用页面输出流逐行输出。</li>
</ul>
<p><strong>普通Servlet类里的service()方法的作用，完全等同于JSP生成Servlet类的<code>_jspService()</code>方法。因此原JSP页面的JSP脚本、静态HTML内容，在普通Servlet里都应该转换成service()方法的代码或输出语句；原JSP声明中的内容，对应为在Servlet中定义的成员变量或成员方法</strong>。</p>
<h3 id="servlet的配置">servlet的配置</h3><p>编辑好的Servlet源文件需编译成class文件才能响应用户请求。将编译后的.class文件放在WEB-INF/classes路径下，如果Servlet有包，则还应该将class文件放在对应的包路径下。</p>
<p>如果需要直接采用javac命令来编译Servlet类，则必须将Servlet API接口和类添加到系统的CLASSPATH环境变量里。也就是将Tomcat 7安装目录下lib目录中servlet-api. jar和jsp-api.jar添加到CLASSPATH环境变量中。</p>
<p>为了让Servlet能响应用户请求，还必须将Servlet配置在Web应用中。配置Servlet时，需要修改web.xml文件。</p>
<p>从Servlet 3.0开始，配置Servlet有两种方式：</p>
<ul>
<li>在Servlet类中使用@WebServlet Annotation进行配置。</li>
<li>通过在web.xml文件中进行配置。</li>
</ul>
<p>上面开发Servlet类时使用了@WebServlet Annotation修饰该Servlet类，使用@WebServlet时可指定如表所示的常用属性。</p>
<p>属    性          | 是否必需 | 说    明<br>asyncSupported    | 否       | 指定该Servlet是否支持异步操作模式。关于Servlet的异步调用请参考2.15节<br>displayName       | 否       | 指定该Servlet的显示名<br>initParams        | 否       | 用于为该Servlet配置参数<br>loadOnStartup     | 否       | 用于将该Servlet配置成 load-on-startup的Servlet<br>name              | 否       | 指定该Servlet的名称<br>urlPatterns/value | 否       | 这两个属性的作用完全相同。都指定该Servlet处理的URL</p>
<p>如果打算使用Annotation来配置Servlet，有两点需要指出：</p>
<ul>
<li>不要在web.xml文件的根元素（<code>&lt;web-app.../&gt;</code>）中指定metadata-complete=”true”。</li>
<li>不要在web.xml文件中配置该Servlet。</li>
</ul>
<p>如果打算使用web.xml文件来配置该Servlet，则需要配置如下两个部分。</p>
<ul>
<li>配置Servlet的名字：对应web.xml文件中的<code>&lt;servlet/&gt;</code>元素。</li>
<li>配置Servlet的URL：对应web.xml文件中的<code>&lt;servlet-mapping/&gt;</code>元素。这一步是可选的。但如果没有为Servlet配置URL，则该Servlet不能响应用户请求。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Servlet的名字 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 指定Servlet的名字，相当于指定@WebServlet的name属性 --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>firstServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 指定Servlet的实现类 --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>lee.FirstServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span> <span class="tag">&lt;/<span class="title">servlet</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 配置Servlet的URL --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 指定Servlet的名字 --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>firstServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 指定Servlet映射的URL地址，相当于指定@WebServlet的urlPatterns属性--&gt;</span>    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/aa<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过注解<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function"><span class="title">WebServlet</span><span class="params">(name=<span class="string">"firstServlet"</span>, urlPatterns=&#123;<span class="string">"/firstServlet"</span>&#125;)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="JSP/Servlet的生命周期">JSP/Servlet的生命周期</h3><p>创建Servlet实例有两个时机。</p>
<ul>
<li>客户端第一次请求某个Servlet时，系统创建该Servlet的实例：大部分的Servlet都是这种Servlet。</li>
<li>Web应用启动时立即创建Servlet实例，即load-on-startup Servlet。</li>
</ul>
<p><strong>每个Servlet的运行都遵循如下生命周期</strong>。</p>
<ol>
<li>创建Servlet实例。</li>
<li>Web容器调用Servlet的init方法，对Servlet进行初始化。</li>
<li>Servlet初始化后，将一直存在于容器中，用于响应客户端请求。如果客户端发送GET请求，容器调用Servlet的doGet方法处理并响应请求；如果客户端发送POST请求，容器调用Servlet的doPost方法处理并响应请求。或者统一使用service()方法处理来响应用户请求。</li>
<li>Web容器决定销毁Servlet时，先调用Servlet的destroy方法，通常在关闭Web应用之时销毁Servlet。</li>
</ol>
<h3 id="load-on-startup_Servlet">load-on-startup Servlet</h3><p>配置load-on-startup的Servlet有两种方式：</p>
<ul>
<li>在web.xml文件中通过<code>&lt;servlet.../&gt;</code>元素的<code>&lt;load-on-startup.../&gt;</code>子元素进行配置。</li>
<li>通过@WebServlet Annotation的loadOnStartup属性指定。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- Servlet名 --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>timerServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- Servlet的实现类 --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>lee.TimerServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 配置应用启动时，创建Servlet实例，相当于指定@WebServlet的loadOnStartup属性--&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="title">load-on-startup</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过注解<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function"><span class="title">WebServlet</span><span class="params">(loadOnStartup=<span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="访问Servlet的配置参数">访问Servlet的配置参数</h3><p>为Servlet配置参数有两种方式：</p>
<ul>
<li>通过@WebServlet的initParams属性来指定。</li>
<li>通过在web.xml文件的<code>&lt;servlet.../&gt;</code>元素中添加<code>&lt;init-param.../&gt;</code>子元素来指定。</li>
</ul>
<p>访问Servlet配置参数通过ServletConfig对象完成，ServletConfig提供如下方法。<br>java.lang.String getInitParameter(java.lang.String name)：用于获取初始化参数。<br>JSP的内置对象config就是此处的ServletConfig。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置Servlet名 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>testServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 指定Servlet的实现类 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>lee.TestServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置Servlet的初始化参数：user --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>user<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置Servlet的初始化参数：pass --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>pass<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>32147<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 确定Servlet名 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>testServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置Servlet映射的URL --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/testServlet<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过注解<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@WebServlet</span>(name=<span class="string">"testServlet"</span> </span><br><span class="line">    , urlPatterns=&#123;<span class="string">"/testServlet"</span>&#125;  </span><br><span class="line">    , initParams=&#123;  </span><br><span class="line">        <span class="variable">@WebInitParam</span>(name=<span class="string">"user"</span>, value=<span class="string">"root"</span>),  </span><br><span class="line">        <span class="variable">@WebInitParam</span>(name=<span class="string">"pass"</span>, value=<span class="string">"32147"</span>)&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="使用Servlet作为控制器">使用Servlet作为控制器</h3><p>在标准的MVC模式中，Servlet仅作为控制器使用。Java EE应用架构正是遵循MVC模式的，对于遵循MVC模式的Java EE应用而言，JSP仅作为表现层（View）技术，其作用有两点：</p>
<ul>
<li>负责收集用户请求参数。</li>
<li>将应用的处理结果、状态数据呈现给用户。</li>
</ul>
<p>Servlet则仅充当控制器（Controller）角色，它的作用类似于调度员：所有用户请求都发送给 Servlet，Servlet调用Model来处理用户请求，并调用JSP来呈现处理结果；或者Servlet直接调用JSP将应用的状态数据呈现给用户。</p>
<p>Model通常由JavaBean来充当，所有业务逻辑、数据访问逻辑都在Model中实现。实际上隐藏在Model下的可能还有很多丰富的组件，例如DAO组件、领域对象等。</p>
<p>下面是MVC中各个角色的对应组件。</p>
<p>M：Model，即模型，对应JavaBean。<br>V：View，即视图，对应JSP页面。<br>C：Controller，即控制器，对应Servlet。</p>
<h2 id="JSP_2的自定义标签">JSP 2的自定义标签</h2><p>在JSP 2中开发标签库只需如下几个步骤。</p>
<ul>
<li>开发自定义标签处理类；</li>
<li>建立一个<code>*.tld</code>文件，每个<code>*.tld</code>文件对应一个标签库，每个标签库可包含多个标签；</li>
<li>在JSP文件中使用自定义标签。</li>
</ul>
<h3 id="开发自定义标签类">开发自定义标签类</h3><p>自定义标签类应该继承一个父类：javax.servlet.jsp.tagext.SimpleTagSupport，除此之外，JSP自定义标签类还有如下要求：</p>
<ul>
<li>如果标签类包含属性，每个属性都有对应的getter和setter方法。</li>
<li>重写doTag()方法，这个方法负责生成页面内容。</li>
</ul>
<h3 id="建立TLD文件">建立TLD文件</h3><p>TLD是Tag Library Definition的缩写，即标签库定义，文件的后缀是tld，每个TLD文件对应一个标签库，一个标签库中可包含多个标签。TLD文件也称为标签库定义文件。</p>
<p>标签库定义文件的根元素是taglib，它可以包含多个tag子元素，每个tag子元素都定义一个标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">taglib</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee"</span> </span><br><span class="line"><span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>     </span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee web-jsptaglibrary_2_0.xsd"</span>     </span><br><span class="line"><span class="attribute">version</span>=<span class="value">"2.0"</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">tlib-version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="title">tlib-version</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">short-name</span>&gt;</span>mytaglib<span class="tag">&lt;/<span class="title">short-name</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 定义该标签库的URI --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">uri</span>&gt;</span>http://www.crazyit.org/mytaglib<span class="tag">&lt;/<span class="title">uri</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 定义第一个标签 --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">tag</span>&gt;</span>         </span><br><span class="line"><span class="comment">&lt;!-- 定义标签名 --&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="title">name</span>&gt;</span>helloWorld<span class="tag">&lt;/<span class="title">name</span>&gt;</span>         </span><br><span class="line"><span class="comment">&lt;!-- 定义标签处理类 --&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="title">tag-class</span>&gt;</span>lee.HelloWorldTag<span class="tag">&lt;/<span class="title">tag-class</span>&gt;</span>         </span><br><span class="line"><span class="comment">&lt;!-- 定义标签体为空 --&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="title">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="title">body-content</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="title">tag</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>taglib下有如下三个子元素。</p>
<ul>
<li>tlib-version：指定该标签库实现的版本，这是一个作为标识的内部版本号，对程序没有太大的作用。</li>
<li>short-name：该标签库的默认短名，该名称通常也没有太大的用处。</li>
<li>uri：这个属性非常重要，它指定该标签库的URI，相当于指定该标签库的唯一标识。如上面斜体字代码所示，JSP页面中使用标签库时就是根据该URI属性来定位标签库的。</li>
</ul>
<p>除此之外，taglib元素下可以包含多个tag元素，每个tag元素定义一个标签，tag元素下允许出现如下常用子元素。</p>
<ul>
<li>name：该标签库的名称，这个子元素很重要，JSP页面中就是根据该名称来使用此标签的。</li>
<li>tag-class：指定标签的处理类，毋庸置疑，这个子元素非常重要，它指定了标签由哪个标签处理类来处理。</li>
<li>body-content：这个子元素也很重要，它指定标签体内容。该子元素的值可以是如下几个。<ul>
<li>tagdependent：指定标签处理类自己负责处理标签体。</li>
<li>empty：指定该标签只能作为空标签使用。</li>
<li>scriptless：指定该标签的标签体可以是静态HTML元素、表达式语言，但不允许出现JSP脚本。</li>
<li>JSP：指定该标签的标签体可以使用JSP脚本。</li>
<li>dynamic-attributes：指定该标签是否支持动态属性。只有当定义动态属性标签时才需要该子元素。</li>
</ul>
</li>
</ul>
<p>因为JSP 2规范不再推荐使用JSP脚本，所以JSP 2自定义标签的标签体中不能包含JSP脚本。所以，实际上body-content元素的值不可以是JSP。</p>
<p>定义了上面的标签库定义文件后，将标签库文件放在Web应用的WEB-INF路径或任意子路径下，Java Web规范会自动加载该文件，则该文件定义的标签库也将生效。</p>
<h3 id="使用标签库">使用标签库</h3><p>在JSP页面中确定指定的标签需要两点。</p>
<ul>
<li>标签库URI：确定使用哪个标签库。</li>
<li>标签名：确定使用哪个标签。</li>
</ul>
<p>使用标签库分成以下两个步骤。</p>
<ul>
<li>导入标签库：使用taglib编译指令导入标签库，就是将标签库和指定前缀关联起来。</li>
<li>使用标签：在JSP页面中使用自定义标签。</li>
</ul>
<p>taglib的语法格式如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">%</span>@ taglib uri=<span class="string">"tagliburi"</span> prefix=<span class="string">"tagPrefix"</span> <span class="preprocessor">%</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中uri属性确定标签库的URI，这个URI可以确定一个标签库。而prefix属性指定标签库前缀，即所有使用该前缀的标签将由此标签库处理。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">%@</span> <span class="attribute">page</span> <span class="attribute">contentType</span>=<span class="value">"text/html; charset=GBK"</span> <span class="attribute">language</span>=<span class="value">"java"</span> <span class="attribute">errorPage</span>=<span class="value">""</span> %&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 导入标签库，指定mytag前缀的标签，由http://www.crazyit.org/mytaglib的标签库处理 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">%@</span> <span class="attribute">taglib</span> <span class="attribute">uri</span>=<span class="value">"http://www.crazyit.org/mytaglib"</span> <span class="attribute">prefix</span>=<span class="value">"mytag"</span><span class="value">%</span>&gt;</span> </span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/1999/xhtml"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">title</span>&gt;</span>自定义标签示范<span class="tag">&lt;/<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">bgcolor</span>=<span class="value">"#ffffc0"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>下面显示的是自定义标签中的内容<span class="tag">&lt;/<span class="title">h2</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 使用标签 ，其中mytag是标签前缀，根据taglib的编译指令，mytag前缀将由http://www.crazyit.org/mytaglib的标签库处理 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">mytag:helloWorld</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span> <span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="带属性的标签">带属性的标签</h3><p>带属性标签必须为每个属性提供对应的setter和getter方法。</p>
<p>对于有属性的标签，需要为<code>&lt;tag.../&gt;</code>元素增加<code>&lt;attribute.../&gt;</code>子元素，每个attribute子元素定义一个标签属性。<code>&lt;attribute.../&gt;</code>子元素通常还需要指定如下几个子元素。</p>
<ul>
<li>name：设置属性名，子元素的值是字符串内容。</li>
<li>required：设置该属性是否为必需属性，该子元素的值是true或false。</li>
<li>fragment：设置该属性是否支持JSP脚本、表达式等动态内容，子元素的值是true或false。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">tag</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 定义标签名 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>tagname<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 定义标签处理类 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">tag-class</span>&gt;</span>lee.Tag<span class="tag">&lt;/<span class="title">tag-class</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 定义标签体为空 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="title">body-content</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置标签属性:user --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">attribute</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">name</span>&gt;</span>user<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">required</span>&gt;</span>true<span class="tag">&lt;/<span class="title">required</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">fragment</span>&gt;</span>true<span class="tag">&lt;/<span class="title">fragment</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">attribute</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置标签属性:pass --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">attribute</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">name</span>&gt;</span>pass<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">required</span>&gt;</span>true<span class="tag">&lt;/<span class="title">required</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">fragment</span>&gt;</span>true<span class="tag">&lt;/<span class="title">fragment</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">attribute</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">tag</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JSTL是Sun提供的一套标签库，这套标签库的功能非常强大。另外，DisplayTag是Apache组织下的一套开源标签库，主要用于生成页面并显示效果。</p>
<h3 id="带标签体的标签">带标签体的标签</h3><p>带标签体的标签，可以在标签内嵌入其他内容（包括静态的HTML内容和动态的JSP内容），通常用于完成一些逻辑运算，例如判断和循环等。下面以一个迭代器标签为示例，介绍带标签体标签的开发过程。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">IteratorTag</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SimpleTagSupport</span>  &#123;</span></span><br><span class="line">    <span class="comment">//标签属性，用于指定需要被迭代的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> collection;</span><br><span class="line">    <span class="comment">//标签属性，指定迭代集合元素，为集合元素指定的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> item;</span><br><span class="line">    <span class="comment">//省略collection属性的setter和getter方法      ...      </span></span><br><span class="line">    <span class="comment">//省略item属性的setter和getter方法      ...      </span></span><br><span class="line">    <span class="comment">//标签的处理方法，简单标签处理类只需要重写doTag方法      </span></span><br><span class="line">    public void doTag() <span class="keyword">throws</span> <span class="type">JspException</span>, <span class="type">IOException</span>&#123;</span><br><span class="line">        <span class="comment">//从page scope中获取属性名为collection的集合</span></span><br><span class="line">        <span class="type">Collection</span> itemList = (<span class="type">Collection</span>)getJspContext().getAttribute(collection);</span><br><span class="line">        <span class="comment">//遍历集合          </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Object</span> s : itemList)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//将集合的元素设置到page 范围</span></span><br><span class="line">            getJspContext().setAttribute(item, s );</span><br><span class="line">            <span class="comment">//输出标签体              </span></span><br><span class="line">            getJspBody().invoke(<span class="literal">null</span>);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标签处理类的doTag方法首先从page范围内获取了指定名称的Collection对象，然后遍历Collection对象的元素，每次遍历都调用了getJspBody()方法，该方法返回该标签所包含的标签体：JspFragment对象，执行该对象的invoke()方法，即可输出标签体内容。该标签的作用是：遍历指定集合，每遍历一个集合元素，即输出标签体一次。</p>
<p>mytaglib.tld:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">tag</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 定义标签名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">name</span>&gt;</span>iterator<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义标签处理类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tag-class</span>&gt;</span>lee.IteratorTag<span class="tag">&lt;/<span class="title">tag-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义标签体不允许出现JSP脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body-content</span>&gt;</span>scriptless<span class="tag">&lt;/<span class="title">body-content</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置标签属性:collection --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">attribute</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>collection<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">required</span>&gt;</span>true<span class="tag">&lt;/<span class="title">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">fragment</span>&gt;</span>true<span class="tag">&lt;/<span class="title">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">attribute</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置标签属性:item --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">attribute</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>item<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">required</span>&gt;</span>true<span class="tag">&lt;/<span class="title">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">fragment</span>&gt;</span>true<span class="tag">&lt;/<span class="title">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">attribute</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">tag</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>iteratorTag.jsp:<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="vbscript">&lt;%@ page contentType=<span class="string">"text/html; charset=GBK"</span> language=<span class="string">"java"</span> errorPage=<span class="string">""</span> %&gt;</span><span class="xml"> </span><br><span class="line"></span><span class="vbscript">&lt;%@ page import=<span class="string">"java.util.*"</span>%&gt;</span><span class="xml"></span><br><span class="line"><span class="comment">&lt;!-- 导入标签库，指定mytag前缀的标签，由http://www.crazyit.org/mytaglib的标签库处理 --&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%@ taglib uri=<span class="string">"http://www.crazyit.org/mytaglib"</span> prefix=<span class="string">"mytag"</span>%&gt;</span><span class="xml"></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>带标签体的标签-迭代器标签<span class="tag">&lt;/<span class="title">h2</span>&gt;</span><span class="tag">&lt;<span class="title">hr</span>/&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%</span><br><span class="line">//创建一个List对象</span><br><span class="line">List&lt;<span class="built_in">String</span>&gt; a = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">a.add(<span class="string">"疯狂Java"</span>);</span><br><span class="line">a.add(<span class="string">"www.crazyit.org"</span>);</span><br><span class="line">a.add(<span class="string">"java"</span>);</span><br><span class="line">//将List对象放入page范围内</span><br><span class="line">pageContext.setAttribute(<span class="string">"a"</span> , a); </span><br><span class="line">%&gt;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">border</span>=<span class="value">"1"</span> <span class="attribute">bgcolor</span>=<span class="value">"#aaaadd"</span> <span class="attribute">width</span>=<span class="value">"300"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用迭代器标签，对a集合进行迭代 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">mytag:iterator</span> <span class="attribute">collection</span>=<span class="value">"a"</span> <span class="attribute">item</span>=<span class="value">"item"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>$&#123;pageScope.item&#125;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;/<span class="title">mytag:iterator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="以页面片段作为属性的标签">以页面片段作为属性的标签</h3><p>JSP 2规范的自定义标签还允许直接将一段”页面片段”作为属性，这种方式给自定义标签提供了更大的灵活性。</p>
<p>以”页面片段”为属性的标签与普通标签区别并不大，只有两个简单的改变：</p>
<ul>
<li>标签处理类中定义类型为JspFragment的属性，该属性代表了”页面片段”。</li>
<li>使用标签库时，通过<code>&lt;jsp:attribute.../&gt;</code>动作指令为标签库属性指定值。</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FragmentTag</span> <span class="title">extends</span> <span class="title">SimpleTagSupport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> JspFragment fragment;     </span><br><span class="line">    <span class="comment">//fragment属性的setter和getter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFragment</span>(<span class="params">JspFragment fragment</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fragment = fragment;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JspFragment <span class="title">getFragment</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.fragment;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span>(<span class="params"></span>) throws JspException, IOException </span>&#123;</span><br><span class="line">        JspWriter <span class="keyword">out</span> = getJspContext().getOut();</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"&lt;div style='padding:10px;border:1px solid black'&gt;"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"&lt;h3&gt;下面是动态传入的JSP片段&lt;/h3&gt;"</span>);</span><br><span class="line">        <span class="comment">//调用、输出"页面片段"</span></span><br><span class="line">        fragment.invoke( <span class="keyword">null</span> );</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"&lt;/div"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mytaglib.tld:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">tag</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义标签名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">name</span>&gt;</span>fragment<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义标签处理类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tag-class</span>&gt;</span>lee.FragmentTag<span class="tag">&lt;/<span class="title">tag-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定该标签不支持标签体 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="title">body-content</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义标签属性：fragment --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">attribute</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>fragment<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">required</span>&gt;</span>true<span class="tag">&lt;/<span class="title">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">fragment</span>&gt;</span>true<span class="tag">&lt;/<span class="title">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">attribute</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tag</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>fragmentTag.jsp:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>下面显示的是自定义标签中的内容<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">mytag:fragment</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用jsp:attribute标签传入fragment参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">jsp:attribute</span> <span class="attribute">name</span>=<span class="value">"fragment"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 下面是动态的JSP页面片段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">mytag:helloWorld</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">jsp:attribute</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">mytag:fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">mytag:fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">jsp:attribute</span> <span class="attribute">name</span>=<span class="value">"fragment"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 下面是动态的JSP页面片段 --&gt;</span></span><br><span class="line">        $&#123;pageContext.request.remoteAddr&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">jsp:attribute</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">mytag:fragment</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="动态属性的标签">动态属性的标签</h3><p>前面介绍带属性标签时，那些标签的属性个数是确定的，属性名也是确定的，绝大部分情况下这种带属性的标签能处理得很好，但在某些特殊情况下，我们需要传入自定义标签的属性个数是不确定的，属性名也不确定，这就需要借助于动态属性的标签了。</p>
<p>动态属性标签比普通标签多了如下两个额外要求：</p>
<ul>
<li>标签处理类还需要实现DynamicAttributes接口。</li>
<li>配置标签时通过<code>&lt;dynamic-attributes.../&gt;</code>子元素指定该标签支持动态属性。</li>
</ul>
<p>DynaAttributesTag.java<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class DynaAttributesTag extends SimpleTagSupport implements DynamicAttributes &#123;</span><br><span class="line">    <span class="comment">//保存每个属性名的集合</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;<span class="keyword">String</span>&gt; keys = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">    <span class="comment">//保存每个属性值的集合</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;<span class="keyword">Object</span>&gt; values = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">Object</span>&gt;();</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> doTag() <span class="keyword">throws</span> JspException, IOException &#123;</span><br><span class="line">        JspWriter out = getJspContext().getOut();</span><br><span class="line">        <span class="comment">//此处只是简单地输出每个属性</span></span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"&lt;ol&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; keys.<span class="built_in">size</span>(); i++ ) &#123;</span><br><span class="line">            <span class="keyword">String</span> <span class="variable">key</span> = keys.<span class="built_in">get</span>( i );</span><br><span class="line">            <span class="keyword">Object</span> value = values.<span class="built_in">get</span>( i );</span><br><span class="line">            out.<span class="built_in">println</span>( <span class="string">"&lt;li&gt;"</span> + <span class="variable">key</span> + <span class="string">" = "</span> + value + <span class="string">"&lt;/li&gt;"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"&lt;/ol&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setDynamicAttribute( <span class="keyword">String</span> uri, <span class="keyword">String</span> localName, <span class="keyword">Object</span> value ) <span class="keyword">throws</span> JspException &#123;</span><br><span class="line">        <span class="comment">//添加属性名</span></span><br><span class="line">        keys.<span class="built_in">add</span>( localName );</span><br><span class="line">        <span class="comment">//添加属性值</span></span><br><span class="line">        values.<span class="built_in">add</span>( value );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mytaglib.tld</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义接受动态属性的标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dynaAttr<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">tag-class</span>&gt;</span>lee.DynaAttributesTag<span class="tag">&lt;/<span class="title">tag-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="title">body-content</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定支持动态属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dynamic-attributes</span>&gt;</span>true<span class="tag">&lt;/<span class="title">dynamic-attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tag</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>dynaAttrTag.jsp</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入标签库，指定mytag前缀的标签，由http://www.crazyit.org/mytaglib的标签库处理 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">%@</span> <span class="attribute">taglib</span> <span class="attribute">uri</span>=<span class="value">"http://www.crazyit.org/mytaglib"</span> <span class="attribute">prefix</span>=<span class="value">"mytag"</span><span class="value">%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>下面显示的是自定义标签中的内容<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h4</span>&gt;</span>指定两个属性<span class="tag">&lt;/<span class="title">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">mytag:dynaAttr</span> <span class="attribute">name</span>=<span class="value">"crazyit"</span> <span class="attribute">url</span>=<span class="value">"crazyit.org"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">br</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">h4</span>&gt;</span>指定四个属性<span class="tag">&lt;/<span class="title">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">mytag:dynaAttr</span> 书名=<span class="value">"疯狂Java讲义"</span> 价格=<span class="value">"99.0"</span> 出版时间=<span class="value">"2008年"</span> 描述=<span class="value">"Java图书"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Filter介绍">Filter介绍</h2><p>Filter可认为是Servlet的一种”加强版”，它主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理，是个典型的处理链。Filter也可对用户请求生成响应，这一点与Servlet相同，但实际上很少会使用Filter向用户请求生成响应。使用Filter完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。</p>
<p>Filter有如下几个用处。</p>
<ul>
<li>在HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest。</li>
<li>根据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。</li>
<li>在HttpServletResponse到达客户端之前，拦截HttpServletResponse。</li>
<li>根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。</li>
</ul>
<p>Filter有如下几个种类。</p>
<ul>
<li>用户授权的Filter：Filter负责检查用户请求，根据请求过滤用户非法请求。</li>
<li>日志Filter：详细记录某些特殊的用户请求。</li>
<li>负责解码的Filter：包括对非标准编码的请求解码。</li>
<li>能改变XML内容的XSLT Filter等。</li>
<li>Filter可负责拦截多个请求或响应；一个请求或响应也可被多个Filter拦截。</li>
</ul>
<p>创建一个Filter只需两个步骤：</p>
<ul>
<li>创建Filter处理类。</li>
<li>web.xml文件中配置Filter。</li>
</ul>
<h3 id="创建Filter类">创建Filter类</h3><p>创建Filter必须实现javax.servlet.Filter接口，在该接口中定义了如下三个方法。</p>
<ul>
<li>void init（FilterConfig config）：用于完成Filter的初始化。</li>
<li>void destroy()：用于Filter销毁前，完成某些资源的回收。</li>
<li>void doFilter（ServletRequest request，ServletResponse response,FilterChain chain）：实现过滤功能，该方法就是对每个请求及响应增加的额外处理。</li>
</ul>
<h3 id="配置Filter">配置Filter</h3><p>前面已经提到，Filter可以认为是Servlet的”增强版”，因此配置Filter与配置Servlet非常相似，都需要配置如下两个部分：</p>
<ul>
<li>配置Filter名。</li>
<li>配置Filter拦截URL模式。</li>
</ul>
<p>区别在于，Servlet通常只配置一个URL，而Filter可以同时拦截多个请求的URL。因此，在配置Filter的URL模式时通常会使用模式字符串，使得Filter可以拦截多个请求。与配置Servlet相似的是，配置Filter同样有两种方式：</p>
<ul>
<li>在Filter类中通过Annotation进行配置。</li>
<li>在web.xml文件中通过配置文件进行配置。</li>
</ul>
<p>@WebFilter(filterName=”log”, urlPatterns={“/*”})<br>@WebFilter修饰一个Filter类，用于对Filter进行配置，它支持如表所示的常用属性</p>
<p>@WebFilter支持的常用属性</p>
<p>属    性          | 是否必需 | 说    明<br>asyncSupported    | 否       | 指定该Filter是否支持异步操作模式。关于Filter的异步调用请参考2.15节<br>dispatcherTypes   | 否       | 指定该Filter仅对那种dispatcher模式的请求进行过滤。该属性支持ASYNC、ERROR、FORWARD、INCLUDE、REQUEST 这5个值的任意组合。默认值为同时过滤5种模式的请求<br>displayName       | 否       | 指定该Filter的显示名<br>filterName        |          | 指定该Filter的名称<br>initParams        | 否       | 用于为该Filter配置参数<br>servletNames      | 否       | 该属性值可指定多个Servlet的名称，用于指定该Filter仅对这几个Servlet执行过滤<br>urlPatterns/value | 否       | 这两个属性的作用完全相同。都指定该Filter所拦截的URL</p>
<p>在web.xml文件中配置Filter与配置Servlet非常相似，需要为Filter指定它所过滤的URL，并且也可以为Filter配置参数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义Filter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Filter的名字，相当于指定@WebFilter的filterName属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>log<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Filter的实现类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>lee.LogFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义Filter拦截的URL地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Filter的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>log<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Filter负责拦截的URL，相当于指定@WebFilter的urlPatterns属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际上Filter和Servlet极其相似，区别只是Filter的doFilter()方法里多了一个FilterChain的参数，通过该参数可以控制是否放行用户请求。</p>
<p>假设系统有包含多个Servlet，这些Servlet都需要进行一些的通用处理：比如权限控制、记录日志等，这将导致在这些Servlet的service方法中有部分代码是相同的—为了解决这种代码重复的问题，我们可以考虑把这些通用处理提取到Filter中完成，这样各Servlet中剩下的只是特定请求相关的处理代码，而通用处理则交给Filter完成。</p>
<p>由于Filter和Servlet如此相似，所以Filter和Servlet具有完全相同的生命周期行为，且Filter也可以通过<init-param...>元素或@WebFilter的initParams属性来配置初始化参数，获取Filter的初始化参数则使用FilterConfig的getInitParameter()方法。</init-param...></p>
<p>对于Java Web应用来说，要实现伪静态非常简单：可以通过Filter拦截所有发向<em>.html请求，然后按某种规则将请求forward到实际的</em>.jsp页面即可。现有的URL Rewrite开源项目为这种思路提供了实现，使用URL Rewrite实现网站伪静态也很简单。</p>
<p>下载URL Rewrite应下载其src项（urlrewritefilter-3.2.0-src.zip），下载完成后得到一个urlrewritefilter-3.2.0-src.zip文件，将该压缩文件解压缩，得到如下文件结构。</p>
<ul>
<li>api：该路径下存放了URL Rewrite项目的API文档。</li>
<li>lib：该路径下存放了URL Rewrite项目的编译和运行所需的第三方类库。</li>
<li>manual：该路径下存放了URL Rewrite项目使用手册。</li>
<li>src：该路径下存放了URL Rewrite项目的源代码。</li>
<li>webapp：该路径是一个URL Rewrite的示例应用。</li>
<li>LICENSE.txt等杂项文档。</li>
</ul>
<p>web.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Url Rewrite的Filter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>UrlRewriteFilter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.tuckey.web.filters.urlrewrite.UrlRewriteFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置Url Rewrite的Filter拦截所有请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>UrlRewriteFilter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的配置片段指定使用URL Rewrite Filter拦截所有的用户请求。</p>
<p>在应用的WEB-INF路径下增加urlrewrite.xml文件，该文件定义了伪静态映射规则，这份伪静态规则是基于正则表达式的。</p>
<p>下面是本应用所使用的urlrewrite.xml伪静态规则文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE urlrewrite PUBLIC "-//tuckey.org//DTD UrlRewrite 3.2//EN" "http://tuckey.org/res/dtds/urlrewrite3.2.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">urlrewrite</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">rule</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 所有配置如下正则表达式的请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">from</span>&gt;</span>/userinf-(\w*).html<span class="tag">&lt;/<span class="title">from</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将被forward到如下JSP页面，其中$1代表上面第一个正则表达式所匹配的字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">to</span> <span class="attribute">type</span>=<span class="value">"forward"</span>&gt;</span>/userinf.jsp?username=$1<span class="tag">&lt;/<span class="title">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">urlrewrite</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的规则文件中只定义了一个简单的规则：所有发向/userinf-(\w<em>).html的请求都将被forward到user.jsp页面，并将(\w</em>)正则表达式所匹配的内容作为username参数值。根据这个伪静态规则，我们应该为该应用提供一个userinf.jsp页面，该页面只是一个模拟了一个显示用户信息的页面</p>
<p>userinf.jsp</p>
<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="vbscript">&lt;%@ page contentType=<span class="string">"text/html; charset=GBK"</span> language=<span class="string">"java"</span> errorPage=<span class="string">""</span> %&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%</span><br><span class="line">//获取请求参数</span><br><span class="line"><span class="built_in">String</span> user = <span class="built_in">request</span>.getParameter(<span class="string">"username"</span>);</span><br><span class="line">%&gt;</span><span class="xml"></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">title</span>&gt;</span> </span><span class="vbscript">&lt;%=user%&gt;</span><span class="xml">的个人信息 <span class="tag">&lt;/<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%</span><br><span class="line">//此处应该通过数据库读取该用户对应的信息</span><br><span class="line">//此处只是模拟，因此简单输出：</span><br><span class="line">out.println(<span class="string">"现在时间是："</span> + <span class="keyword">new</span> java.util.<span class="built_in">Date</span>() + <span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"用户名："</span> + user);  %&gt;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span> <span class="tag">&lt;/<span class="title">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Listener_介绍">Listener 介绍</h2><p>当Web应用在Web容器中运行时，Web应用内部会不断地发生各种事件：如Web应用被启动、Web应用被停止，用户session开始、用户session结束、用户请求到达等，通常来说，这些Web事件对开发者是透明的。</p>
<p>实际上，Servlet API提供了大量监听器来监听Web应用的内部事件，从而允许当Web内部事件发生时回调事件监听器内的方法。</p>
<p>使用Listener只需要两个步骤：</p>
<ul>
<li>定义Listener实现类。</li>
<li>通过Annotation或在web.xml文件中配置Listerner。</li>
</ul>
<h3 id="实现Listenner类">实现Listenner类</h3><p>常用的Web事件监听器接口有如下几个。</p>
<ul>
<li>ServletContextListener：用于监听Web应用的启动和关闭。</li>
<li>ServletContextAttributeListener：用于监听ServletContext范围（application）内属性的改变。</li>
<li>ServletRequestListener：用于监听用户请求。</li>
<li>ServletRequestAttributeListener：用于监听ServletRequest范围（request）内属性的改变。</li>
<li>HttpSessionListener：用于监听用户session的开始和结束。</li>
<li>HttpSessionAttributeListener：用于监听HttpSession范围（session）内属性的改变。</li>
</ul>
<p>下面先以ServletContextListener为例来介绍Listener的开发和使用，ServletContextListener用于监听Web应用的启动和关闭。该Listener类必须实现ServletContextListener接口，该接口包含如下两个方法。</p>
<ul>
<li>contextInitialized(ServletContextEvent sce)：启动Web应用时，系统调用Listener的该方法。</li>
<li>contextDestroyed(ServletContextEvent sce)：关闭Web应用时，系统调用Listener的该方法。</li>
</ul>
<h3 id="配置Listener">配置Listener</h3><p>为Web应用配置Listener也有两种方式：</p>
<ul>
<li>使用@WebListener修饰Listener实现类即可。</li>
<li>在web.xml文档中使用<listener...>元素进行配置。</listener...></li>
</ul>
<p>在web.xml中使用<listener...>元素进行配置时只要配置如下子元素即可。<br>listener-class：指定Listener实现类。</listener...></p>
<p>使用ServletContextAttributeListener</p>
<p>ServletContextAttributeListener用于监听ServletContext（application）范围内属性的变化，实现该接口的监听器需要实现如下三个方法。</p>
<ul>
<li>attributeAdded(ServletContextAttributeEvent event)：当程序把一个属性存入application范围时触发该方法。</li>
<li>attributeRemoved(ServletContextAttributeEvent event)：当程序把一个属性从application范围删除时触发该方法。</li>
<li>attributeReplaced(ServletContextAttributeEvent event)：当程序替换application范围内的属性时将触发该方法。</li>
</ul>
<h3 id="使用ServletRequestListener和ServletRequestAttributeListener">使用ServletRequestListener和ServletRequestAttributeListener</h3><p>ServletRequestListener用于监听用户请求的到达，实现该接口的监听器需要实现如下两个方法。</p>
<ul>
<li>requestInitialized(ServletRequestEvent sre)：用户请求到底、被初始化时触发该方法。</li>
<li>requestDestroyed(ServletRequestEvent sre)：用户请求结束、被销毁时触发该方法。</li>
</ul>
<p>ServletRequestAttributeListener则用于监听ServletRequest（request）范围内属性的变化，实现该接口的监听器需要实现attributeAdded、attributeRemoved、attributeReplaced三个方法。</p>
<h3 id="使用HttpSessionListener和HttpSessionAttributeListener">使用HttpSessionListener和HttpSessionAttributeListener</h3><p>HttpSessionListener用于监听用户session的创建和销毁，实现该接口的监听器需要实现如下两个方法。</p>
<ul>
<li>sessionCreated(HttpSessionEvent se)：用户与服务器的会话开始、创建时时触发该方法。</li>
<li>sessionDestroyed(HttpSessionEvent se)：用户与服务器的会话断开、销毁时触发该方法。</li>
</ul>
<p>HttpSessionAttributeListener则用于监听HttpSession（session）范围内属性的变化，实现该接口的监听器需要实现attributeAdded、attributeRemoved、attributeReplaced三个方法。</p>
<h2 id="JSP_2特性">JSP 2特性</h2><p>相比JSP 1.2，JSP 2主要增加了如下新特性。</p>
<ul>
<li>直接配置JSP属性。</li>
<li>表达式语言。</li>
<li>简化的自定义标签API。</li>
<li>Tag文件语法。</li>
</ul>
<p>如果需要使用JSP 2语法，其web.xml文件必须使用Servlet 2.4以上版本的配置文件。Servlet 2.4以上版本的配置文件的根元素写法如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  不再使用DTD，而是使用Schema描述，版本也升级为 2.4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-app</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee"</span> </span><br><span class="line"><span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span> <span class="attribute">version</span>=<span class="value">"2.4"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此处是Web应用的其他配置 --&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="title">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="配置jsp属性">配置jsp属性</h3><p>JSP属性定义使用元素配置，主要包括如下4个方面。</p>
<ul>
<li>是否允许使用表达式语言：使用元素确定，默认值为false，即允许使用表达式语言。</li>
<li>是否允许使用JSP脚本：使用元素确定，默认值为false，即允许使用JSP脚本。</li>
<li>声明JSP页面的编码：使用元素确定，配置该元素后，可以代替每个页面里page指令contentType属性的charset部分。</li>
<li>使用隐式包含：使用和元素确定，可以代替在每个页面里使用include编译指令来包含其他页面。</li>
</ul>
<p>此处隐式包含的作用与JSP提供的静态包含的作用相似。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-app</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line"><span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/javaee   http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span> <span class="attribute">version</span>=<span class="value">"3.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/noscript/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">el-ignored</span>&gt;</span>true<span class="tag">&lt;/<span class="title">el-ignored</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">page-encoding</span>&gt;</span>GBK<span class="tag">&lt;/<span class="title">page-encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">scripting-invalid</span>&gt;</span>true<span class="tag">&lt;/<span class="title">scripting-invalid</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">include-prelude</span>&gt;</span>/inc/top.jspf<span class="tag">&lt;/<span class="title">include-prelude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">include-coda</span>&gt;</span>/inc/bottom.jspf<span class="tag">&lt;/<span class="title">include-coda</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">jsp-property-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">el-ignored</span>&gt;</span>false<span class="tag">&lt;/<span class="title">el-ignored</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">page-encoding</span>&gt;</span>GBK<span class="tag">&lt;/<span class="title">page-encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">scripting-invalid</span>&gt;</span>false<span class="tag">&lt;/<span class="title">scripting-invalid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">jsp-property-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/inc/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">el-ignored</span>&gt;</span>false<span class="tag">&lt;/<span class="title">el-ignored</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">page-encoding</span>&gt;</span>GBK<span class="tag">&lt;/<span class="title">page-encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">scripting-invalid</span>&gt;</span>true<span class="tag">&lt;/<span class="title">scripting-invalid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">jsp-property-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">jsp-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="表达式语言">表达式语言</h3><p>表达式语言（Expression Language）是一种简化的数据访问方式。使用表达式语言可以方便地访问JSP的隐含对象和JavaBeans组件，在JSP 2规范中，建议尽量使用表达式语言使JSP文件的格式一致，避免使用Java脚本。</p>
<p>表达式语言的语法格式是： <code>${expression}</code><br>如果想输出<code>$</code>符号，则在<code>$</code>前加转义字符<code>\</code></p>
<ol>
<li><p>表达式语言支持的算术运算符和逻辑运算符</p>
<p> 所有java语言里的算术运算符都支持，甚至java不支持的运算符也支持。<br> div(除)、mod(取余)、lt(小于)、gt(大于)、ge(大于等于)、le(小于等于)、eq(等于)、ne(不等于)<br> 表达式语言不仅可在数字与数字之间比较，还可在字符与字符之间比较，字符串的比较是根据其对应UNICODE值来比较大小的。<br> 表达式语言把所有数值都当成浮点数处理，所以3/0的实质是3.0/0.0，得到结果应该是Infinity。</p>
</li>
<li><p>表达式语言的内置对象</p>
<p> 表达式语言包含如下11个内置对象。</p>
<ul>
<li>pageContext：代表该页面的pageContext对象，与JSP的pageContext内置对象相同。</li>
<li>pageScope：用于获取page范围的属性值。</li>
<li>requestScope：用于获取request范围的属性值。</li>
<li>sessionScope：用于获取session范围的属性值。</li>
<li>applicationScope：用于获取application范围的属性值。</li>
<li>param：用于获取请求的参数值。</li>
<li>paramValues：用于获取请求的参数值，与param的区别在于，该对象用于获取属性值为数组的属性值。</li>
<li>header：用于获取请求头的属性值。</li>
<li>headerValues：用于获取请求头的属性值，与header的区别在于，该对象用于获取属性值为数组的属性值。</li>
<li>initParam：用于获取请求Web应用的初始化参数。</li>
<li>cookie：用于获取指定的Cookie值。<br>两种方法取得请求参数值：<br><code>${param.name}</code>、 <code>${param[&quot;name&quot;]</code></li>
</ul>
</li>
<li><p>表达式语言的自定义函数</p>
<p> 表达式语言除了可以使用基本的运算符外，还可以使用自定义函数。通过自定义函数，能够大大加强表达式语言的功能。自定义函数的开发步骤非常类似于标签的开发步骤，定义方式也几乎一样。区别在于自定义标签直接在页面上生成输出，而自定义函数则需要在表达式语言中使用。</p>
<p> 函数功能大大扩充了EL的功能，EL本身只是一种数据访问语言，因此它不支持调用方法。如果需要在EL中进行更复杂的处理，就可以通过函数来完成。函数的本质是：提供一种语法允许在EL中调用某个类的静态方法。</p>
<p> 使用标签库定义函数：定义函数的方法与定义标签的方法大致相似。在<code>&lt;taglib.../&gt;</code>元素下增加<code>&lt;tag.../&gt;</code>元素用于定义自定义标签；增加<code>&lt;function.../&gt;</code>元素则用于定义自定义函数。每个<code>&lt;function.../&gt;</code>元素只要三个子元素即可。</p>
<ul>
<li>name：指定自定义函数的函数名。</li>
<li>function-class：指定自定义函数的处理类。</li>
<li><p>function-signature：指定自定义函数对应的方法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">taglib</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee"</span></span><br><span class="line"><span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee web-jsptaglibrary_2_0.xsd"</span> <span class="attribute">version</span>=<span class="value">"2.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tlib-version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="title">tlib-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">short-name</span>&gt;</span>crazyit<span class="tag">&lt;/<span class="title">short-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义该标签库的URI --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">uri</span>&gt;</span>http://www.crazyit.org/tags<span class="tag">&lt;/<span class="title">uri</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义第一个函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">function</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义函数名:reverse --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>reverse<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义函数的处理类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">function-class</span>&gt;</span>lee.Functions<span class="tag">&lt;/<span class="title">function-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义函数的实现方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">function-signature</span>&gt;</span>java.lang.String reverse(java.lang.String)<span class="tag">&lt;/<span class="title">function-signature</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">function</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义第二个函数: countChar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">function</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义函数名:countChar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>countChar<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义函数的处理类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">function-class</span>&gt;</span>lee.Functions<span class="tag">&lt;/<span class="title">function-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义函数的实现方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">function-signature</span>&gt;</span>int countChar(java.lang.String)<span class="tag">&lt;/<span class="title">function-signature</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">function</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的粗体字代码定义了两个函数，不难发现其实定义函数比定义自定义标签更简单，因为自定义函数只需配置三个子元素即可，变化更少。</p>
<p>useFunctions.jsp：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">%@</span> <span class="attribute">page</span> <span class="attribute">contentType</span>=<span class="value">"text/html; charset=GBK"</span> <span class="attribute">language</span>=<span class="value">"java"</span> <span class="attribute">errorPage</span>=<span class="value">""</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%@</span> <span class="attribute">taglib</span> <span class="attribute">prefix</span>=<span class="value">"crazyit"</span> <span class="attribute">uri</span>=<span class="value">"http://www.crazyit.org/tags"</span><span class="value">%</span>&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">title</span>&gt;</span>new document<span class="tag">&lt;/<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>表达式语言 - 自定义函数<span class="tag">&lt;/<span class="title">h2</span>&gt;</span><span class="tag">&lt;<span class="title">hr</span>/&gt;</span></span><br><span class="line">请输入一个字符串：</span><br><span class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"useFunctions.jsp"</span> <span class="attribute">method</span>=<span class="value">"post"</span>&gt;</span></span><br><span class="line">字符串 = <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"$</span></span></span><span class="expression">&#123;<span class="variable">param</span>['<span class="variable">name</span>']&#125;</span><span class="xml"><span class="tag"><span class="value">"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span>  <span class="attribute">value</span>=<span class="value">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">border</span>=<span class="value">"1"</span> <span class="attribute">bgcolor</span>=<span class="value">"aaaadd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">b</span>&gt;</span>表达式语言<span class="tag">&lt;/<span class="title">b</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">b</span>&gt;</span>计算结果<span class="tag">&lt;/<span class="title">b</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>\$</span><span class="expression">&#123;<span class="variable">param</span>[<span class="string">"name"</span>]&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>$</span><span class="expression">&#123;<span class="variable">param</span>[<span class="string">"name"</span>]&#125;</span><span class="xml">&amp;nbsp;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  使用reverse函数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>\$</span><span class="expression">&#123;<span class="variable">crazyit</span>:<span class="variable">reverse</span>(<span class="variable">param</span>[<span class="string">"name"</span>])&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>$</span><span class="expression">&#123;<span class="variable">crazyit</span>:<span class="variable">reverse</span>(<span class="variable">param</span>[<span class="string">"name"</span>])&#125;</span><span class="xml">&amp;nbsp;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>\$</span><span class="expression">&#123;<span class="variable">crazyit</span>:<span class="variable">reverse</span>(<span class="variable">crazyit</span>:<span class="variable">reverse</span>(<span class="variable">param</span>[<span class="string">"name"</span>]))&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>$</span><span class="expression">&#123;<span class="variable">crazyit</span>:<span class="variable">reverse</span>(<span class="variable">crazyit</span>:<span class="variable">reverse</span>(<span class="variable">param</span>[<span class="string">"name"</span>]))&#125;</span><span class="xml">&amp;nbsp;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用countChar函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>\$</span><span class="expression">&#123;<span class="variable">crazyit</span>:<span class="variable">countChar</span>(<span class="variable">param</span>[<span class="string">"name"</span>])&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>$</span><span class="expression">&#123;<span class="variable">crazyit</span>:<span class="variable">countChar</span>(<span class="variable">param</span>[<span class="string">"name"</span>])&#125;</span><span class="xml">&amp;nbsp;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span> <span class="tag">&lt;/<span class="title">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>如上面程序中粗体字代码所示，导入标签库定义文件后（实质上也是函数库定义文件），就可以在表达式语言中使用函数定义库文件里定义的各函数了。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Tag_File_支持">Tag File 支持</h3><p>建立Tag文件，在JSP所支持Tag File规范下，Tag File代理了标签处理类，它的格式类似于JSP文件。可以这样理解：如同JSP可以代替Servlet作为表现层一样，Tag File则可以代替标签处理类。</p>
<p>Tag File具有以下5个编译指令。</p>
<ul>
<li>taglib：作用与JSP文件中的taglib指令效果相同，用于导入其他标签库。</li>
<li>include：作用与JSP文件中的include指令效果相同，用于导入其他JSP或静态页面。</li>
<li>tag：作用类似于JSP文件中的page指令，有pageEncoding、body-content等属性，用于设置页面编码等属性。</li>
<li>attribute：用于设置自定义标签的属性，类似于自定义标签处理类中的标签属性。</li>
<li>variable：用于设置自定义标签的变量，这些变量将传给JSP页面使用。</li>
</ul>
<p>下面是迭代器标签的Tag File，这个Tag File的语法与JSP语法非常相似。</p>
<p>iterator.tag<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="vbscript">&lt;%@ tag pageEncoding=<span class="string">"GBK"</span> import=<span class="string">"java.util.List"</span>%&gt;</span><span class="xml"></span><br><span class="line"><span class="comment">&lt;!-- 定义了4个标签属性 --&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%@ attribute name=<span class="string">"bgColor"</span> %&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%@ attribute name=<span class="string">"cellColor"</span> %&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%@ attribute name=<span class="string">"title"</span> %&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%@ attribute name=<span class="string">"bean"</span> %&gt;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">border</span>=<span class="value">"1"</span> <span class="attribute">bgcolor</span>=<span class="value">"$&#123;bgColor&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span> <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">b</span>&gt;</span>$&#123;title&#125;<span class="tag">&lt;/<span class="title">b</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span> <span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 取出request范围的a集合 --&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%</span><br><span class="line">List&lt;<span class="built_in">String</span>&gt; list = (List&lt;<span class="built_in">String</span>&gt;) <span class="built_in">request</span>.getAttribute(<span class="string">"a"</span>);</span><br><span class="line">//遍历输出list集合的元素</span><br><span class="line"><span class="keyword">for</span> (Object ele : list)&#123;</span><br><span class="line">%&gt;</span><span class="xml"> </span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span> <span class="tag">&lt;<span class="title">td</span> <span class="attribute">bgcolor</span>=<span class="value">"$&#123;cellColor&#125;"</span>&gt;</span></span><span class="vbscript">&lt;%=ele%&gt;</span><span class="xml"> <span class="tag">&lt;/<span class="title">td</span>&gt;</span> <span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%&#125;%&gt;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>将该文件存在Web应用的某个路径下，这个路径相当于标签库的URI名。如将其放在/WEB-INF/tags下</p>
<p>在页面中使用自定义标签时，需要先导入标签库，再使用标签。使用Tag File标签与普通自定义标签的用法完全相同，只是在导入标签库时存在一些差异。由于此时的标签库没有URI，只有标签库路径。因此导入标签时，使用如下语法格式：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">%</span>@ taglib prefix=<span class="string">"tagPrefix"</span> tagdir=<span class="string">"path"</span> <span class="preprocessor">%</span>&gt;</span><br></pre></td></tr></table></figure>
<p>其中，prefix与之前的taglib指令的prefix属性完全相同，用于确定标签前缀；而tagdir标签库路径下存放很多Tag File，每个Tag File对应一个标签。</p>
<p>useTagFile.jsp</p>
<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="vbscript">&lt;%@ page contentType=<span class="string">"text/html; charset=GBK"</span> language=<span class="string">"java"</span> errorPage=<span class="string">""</span> %&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%@ page import=<span class="string">"java.util.*"</span> %&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%@ taglib prefix=<span class="string">"tags"</span> tagdir=<span class="string">"/WEB-INF/tags"</span> %&gt;</span><span class="xml"></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">title</span>&gt;</span>迭代器tag file<span class="tag">&lt;/<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>迭代器tag file<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%</span><br><span class="line">//创建集合对象，用于测试Tag File所定义的标签</span><br><span class="line">List&lt;<span class="built_in">String</span>&gt; a = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">a.add(<span class="string">"hello"</span>);</span><br><span class="line">a.add(<span class="string">"world"</span>);</span><br><span class="line">a.add(<span class="string">"java"</span>);</span><br><span class="line">//将集合对象放入页面范围</span><br><span class="line"><span class="built_in">request</span>.setAttribute(<span class="string">"a"</span> , a);%&gt;</span><span class="xml"></span><br><span class="line">//使用自定义标签</span><br><span class="line"><span class="tag">&lt;<span class="title">tags:iterator</span> <span class="attribute">bgColor</span>=<span class="value">"#99dd99"</span> <span class="attribute">cellColor</span>=<span class="value">"#9999cc"</span> <span class="attribute">title</span>=<span class="value">"迭代器标签"</span> <span class="attribute">bean</span>=<span class="value">"a"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span> <span class="tag">&lt;/<span class="title">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tags:<span class="keyword">iterator</span> bgColor=<span class="string">"#99dd99"</span> cellColor=<span class="string">"#9999cc"</span> title=<span class="string">"迭代器标签"</span> bean=<span class="string">"a"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>tags表明该标签使用/WEB-INF/tags路径下的Tag File来处理标签；<strong>而iterator是标签名，即使用WEB-INF/tags路径下的iterator.tag文件负责处理该标签</strong>。</p>
<p>Tag File是自定义标签的简化。事实上，就如同JSP文件会编译成Servlet一样，Tag File也会编译成标签处理类，自定义标签的后台依然由标签处理类完成，而这个过程由容器完成。打开Tomcat的work\Catalina\localhost\jsp2\org\apache\jsp\tag\web路径，即可看到iterator_tag.java、iterator_tag.class两个文件，这两个文件就是Tag File所对应的标签处理类。</p>
<p>通过查看iterator_tag.java文件的内容不难发现，Tag File中只有如下几个内置对象。</p>
<ul>
<li>request：与JSP脚本中的request对象对应。</li>
<li>response：与JSP脚本中的response对象对应。</li>
<li>session：与JSP脚本中的session对象对应。</li>
<li>application：与JSP脚本中的application对象对应。</li>
<li>config：与JSP脚本中的config对象对应。</li>
<li>out：与JSP脚本中的out对象对应。</li>
</ul>
<h2 id="Servlet_3-0新特性">Servlet 3.0新特性</h2><h3 id="Servlet_3-0的Annotation">Servlet 3.0的Annotation</h3><p>Servlet 3.0规范在javax.servlet.annotation包下提供了如下Annotation。</p>
<ul>
<li>@WebServlet：用于修饰一个Servlet类，用于部署Servlet类。</li>
<li>@WebInitParam：用于与@WebServlet或@WebFilter一起使用，为Servlet、Filter配置参数。</li>
<li>@WebListener：用于修饰Listener类，用于部署Listener类。</li>
<li>@WebFilter：用于修饰Filter类，用于部署Filter类。</li>
<li>@MultipartConfig：用于修饰Servlet，指定该Servlet将会负责处理multipart/form-data类型的请求（主要用于文件上传）。</li>
<li>@ServletSecurity：这是一个与JAAS有关的Annotation，修饰Servlet指定该Servlet的安全与授权控制。</li>
<li>@HttpConstraint：用于与@ServletSecurity一起使用，用于指定该Servlet的安全与授权控制。</li>
<li>@HttpMethodConstraint：用于与@ServletSecurity一起使用，用于指定该Servlet的安全与授权控制。</li>
</ul>
<h3 id="Servlet_3-0的Web模块支持">Servlet 3.0的Web模块支持</h3><p>Servlet 3.0规范不再要求所有Web组件（如Servlet、Listener、Filter等）都部署在web.xml文件中，而是允许采用”Web模块”来部署、管理它们。</p>
<p>一个Web模块通常对应于一个JAR包，这个JAR包有如下文件结构：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;webModule&gt;</span>.jar--这是Web模块的JAR包，可以改变</span><br><span class="line">|<span class="string">－META-INF</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">－web-fragment.xml</span><br><span class="line"></span>|<span class="string">－Web模块所用的类文件、资源文件等。</span></span><br></pre></td></tr></table></figure>
<p>从上面的文件结构可以看出，Web模块与普通JAR的最大区别在于需要在META-INF目录下添加一个web-fragment.xml文件，这个文件也被称为Web模块部署描述符。</p>
<p>web-fragment.xml文件与web.xml文件的作用、文档结构都基本相似，因为它们都用于部署、管理各种Web组件。只是web-fragment.xml用于部署、管理Web模块而已，但web-fragment.xml文件可以多指定如下两个元素。</p>
<p><code>&lt;name.../&gt;</code>：用于指定该Web模块的名称。<br><code>&lt;ordering.../&gt;</code>：用于指定加载该Web模块的相对顺序。</p>
<p>web-fragment.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-fragment</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line"><span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd"</span> <span class="attribute">version</span>=<span class="value">"3.0"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定该Web模块的唯一标识 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">name</span>&gt;</span>crazyit<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>lee.CrazyitListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">ordering</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于配置该Web模块必须位于哪些模块之前加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">before</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于指定位于其他所有模块之前加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">others</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">before</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ordering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-fragment</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另一个web-fragment.xml:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-fragment</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line"><span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd"</span> <span class="attribute">version</span>=<span class="value">"3.0"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定该Web模块的唯一标识 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">name</span>&gt;</span>leegang<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置Listener --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>lee.LeegangListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">ordering</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于配置该Web模块必须位于哪些模块之后加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">after</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此处可用多个name元素列出该模块必须位于这些模块之后加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">name</span>&gt;</span>crazyit<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">after</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ordering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-fragment</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>先加载crazyit模块，再加载leegang模块。</p>
<p>Web应用除了可按web-fragment.xml文件中指定的加载顺序来加载Web模块之外，还可以通过web.xml文件指定各Web模块加载的绝对顺序。在web.xml文件中指定的加载顺序将会覆盖Web模块中web-fragment.xml文件所指定的加载顺序。</p>
<h3 id="Servlet_3-0提供的异步处理">Servlet 3.0提供的异步处理</h3><p>在以前的Servlet规范中，如果Servlet作为控制器调用了一个耗时的业务方法，那么Servlet必须等到业务方法完全返回之后才会生成响应，这将使得Servlet对业务方法的调用变成一种阻塞式的调用，因此效率比较低。</p>
<p>Servlet 3.0规范引入了异步处理来解决这个问题，异步处理允许Servlet重新发起一条新线程去调用耗时的业务方法，这样就可避免等待。</p>
<p>Servlet 3.0的异步处理是通过AsyncContext类来处理的，Servlet可通过ServletRequest的如下两个方法开启异步调用、创建AsyncContext对象：</p>
<ul>
<li>AsyncContext startAsync()</li>
<li>AsyncContext startAsync(ServletRequest, ServletResponse)</li>
</ul>
<p>重复调用上面的方法将得到同一个AsyncContext对象。AsyncContext对象代表异步处理的上下文，它提供了一些工具方法，可完成设置异步调用的超时时长，dispatch用于请求、启动后台线程、获取request、response对象等功能。</p>
<p>AsyncServlet.java:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@WebServlet</span>(urlPatterns=<span class="string">"/async"</span>,asyncSupported=<span class="literal">true</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AsyncServlet</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HttpServlet</span>  &#123;</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line">public void doGet(<span class="type">HttpServletRequest</span> request, <span class="type">HttpServletResponse</span> response)</span><br><span class="line"><span class="keyword">throws</span> <span class="type">IOException</span>,<span class="type">ServletException</span> &#123;</span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=GBK"</span>);</span><br><span class="line">    <span class="type">PrintWriter</span> out = response.getWriter();</span><br><span class="line">    out.println(<span class="string">"&lt;title&gt;异步调用示例&lt;/title&gt;"</span>);</span><br><span class="line">    out.println(<span class="string">"进入Servlet的时间："</span> + <span class="keyword">new</span> java.util.<span class="type">Date</span>() + <span class="string">".&lt;br/&gt;"</span>);</span><br><span class="line">    out.flush();</span><br><span class="line">    <span class="comment">//创建AsyncContext，开始异步调用</span></span><br><span class="line">    <span class="type">AsyncContext</span> actx = request.startAsync();</span><br><span class="line">    <span class="comment">//设置异步调用的超时时长</span></span><br><span class="line">    actx.setTimeout(<span class="number">30</span>*<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//启动异步调用的线程</span></span><br><span class="line">    actx.start(<span class="keyword">new</span> <span class="type">Executor</span>(actx));</span><br><span class="line">    out.println(<span class="string">"结束Servlet的时间："</span> + <span class="keyword">new</span> java.util.<span class="type">Date</span>() + <span class="string">".&lt;br/&gt;"</span>);</span><br><span class="line">    out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是线程执行体的代码。</p>
<p>Executor.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AsyncContext actx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Executor</span><span class="params">(AsyncContext actx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actx = actx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待5秒钟，以模拟业务方法的执行</span></span><br><span class="line">            Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            ServletRequest request = actx.getRequest();</span><br><span class="line">            List&lt;String&gt; books = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            books.add(<span class="string">"疯狂Java讲义"</span>);</span><br><span class="line">            books.add(<span class="string">"经典Java EE企业应用实战"</span>);</span><br><span class="line">            books.add(<span class="string">"疯狂XML讲义"</span>);</span><br><span class="line">            request.setAttribute(<span class="string">"books"</span> , books);</span><br><span class="line">            actx.dispatch(<span class="string">"/async.jsp"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该线程执行体内让线程暂停5秒来模拟调用耗时的业务方法，最后调用AsyncContext的dispatch方法把请求dispatch到指定JSP页面。</p>
<p>被异步请求dispatch的目标页面需要指定session=”false”，表明该页面不会重新创建session。</p>
<p>async.jsp:</p>
<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="vbscript">&lt;%@ page contentType=<span class="string">"text/html; charset=GBK"</span> language=<span class="string">"java"</span> session=<span class="string">"false"</span>%&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span> <span class="tag">&lt;<span class="title">c:forEach</span> <span class="attribute">items</span>=<span class="value">"$&#123;books&#125;"</span> <span class="attribute">var</span>=<span class="value">"book"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">li</span>&gt;</span>$&#123;book&#125;<span class="tag">&lt;/<span class="title">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">c:forEach</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%out.println(<span class="string">"业务调用结束的时间："</span> + <span class="keyword">new</span> java.util.<span class="built_in">Date</span>());</span><br><span class="line">//完成异步调用</span><br><span class="line"><span class="built_in">request</span>.getAsyncContext().complete();</span><br><span class="line">%&gt;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
<p>为Servlet开启异步调用有两种方式：</p>
<ul>
<li>为@WebServlet指定asyncSupported=true。</li>
<li>在web.xml文件的<servlet...>元素中增加<async-supported...>子元素。</async-supported...></servlet...></li>
</ul>
<p>当Servlet启用异步调用的线程之后，该线程的执行过程对开发者是透明的。但在有些情况下，开发者需要了解该异步线程的执行细节，并针对特定的执行结果进行针对性处理，这可借助于Servlet 3.0提供的异步监听器来实现。</p>
<p>异步监听器需要实现AsyncListener接口，实现该接口的监听器类需要实现如下4个方法。</p>
<ul>
<li>onStartAsync(AsyncEvent event)：当异步调用开始时触发该方法。</li>
<li>onComplete(AsyncEvent event)：当异步调用完成时触发该方法。</li>
<li>onError(AsyncEvent event)：当异步调用出错时触发该方法。</li>
<li>onTimeout(AsyncEvent event)：当异步调用超时时触发该方法。</li>
</ul>
<p>提供了异步监听器之后，还需要通过AsyncContext来注册监听器，调用该对象的addListener()方法即可注册监听器。例如在上面的Servlet中增加如下代码即可注册监听器：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AsyncContext actx = request.startAsync<span class="params">()</span>;</span><br><span class="line"><span class="comment">//为该异步调用注册监听器</span></span><br><span class="line">actx.addListener<span class="params">(new MyAsyncListener<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>虽然上面的MyAsyncListener监听器类可以监听异步调用开始、异步调用完成两个事件，但从实际运行的结果来看，它并不能监听到异步调用开始事件，这可能是因为注册该监听器时异步调用已经开始了的缘故。</p>
<p>在Filter中进行异步调用与在Servlet中进行异步调用的效果完全相似</p>
<h3 id="改进的Servlet_API">改进的Servlet API</h3><p>Servlet 3.0还有一个改变是改进了部分API，这种改进很好地简化了Java Web开发。其中两个较大的改进是：</p>
<p>HttpServletRequest增加了对文件上传的支持。</p>
<p>ServletContext允许通过编程的方式动态注册Servlet、Filter。</p>
<p>HttpServletRequest提供了如下两个方法来处理文件上传。</p>
<p>Part getPart(String name)：根据名称来获取文件上传域。</p>
<p>Collection<part> getParts()：获取所有的文件上传域。</part></p>
<p>上面两个方法的返回值都涉及一个API：Part，每个Part对象对应于一个文件上传域，该对象提供了大量方法来访问上传文件的文件类型、大小、输入流等，并提供了一个write(String file)方法将上传文件写入服务器磁盘。</p>
<p>为了向服务器上传文件，需要在表单里使用<code>&lt;input type=&quot;file&quot; .../&gt;</code>文件域，这个文件域会在HTML页面上产生一个单行文本框和一个”浏览”按钮，浏览者可通过该按钮选择需要上传的文件。除此之外，上传文件一定要为表单域设置enctype属性。</p>
<p>表单的enctype属性指定的是表单数据的编码方式，该属性有如下三个值。</p>
<ul>
<li>application/x-www-form-urlencoded：这是默认的编码方式，它只处理表单域里的value属性值，采用这种编码方式的表单会将表单域的值处理成URL编码方式。</li>
<li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数里。</li>
<li>text/plain：这种编码方式当表单的action属性为mailto:URL的形式时比较方便，这种方式主要适用于直接通过表单发送邮件的方式。</li>
</ul>
<p>如果将enctype设置为application/x-www-form-urlencoded，或不设置enctype属性，提交表单时只会发送文件域的文本框里的字符串，也就是浏览者所选择文件的绝对路径，对服务器获取该文件在客户端上的绝对路径没有任何作用，因为服务器不可能访问客户机的文件系统。</p>
<p>UploadServlet.java:</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet<span class="params">(name=<span class="string">"upload"</span> , urlPatterns=&#123;<span class="string">"/upload"</span>&#125;)</span></span><br><span class="line">@MultipartConfig</span><br><span class="line">public class UploadServlet extends HttpServlet &#123;</span><br><span class="line">    public void service<span class="params">(HttpServletRequest request , HttpServletResponse response)</span> throws IOException , ServletException &#123; </span><br><span class="line">        response.setContentType<span class="params">(<span class="string">"text/html;charset=GBK"</span>)</span>;</span><br><span class="line">        PrintWriter out = response.getWriter<span class="params">()</span>;</span><br><span class="line">        <span class="comment">//获取普通请求参数</span></span><br><span class="line">        String fileName = request.getParameter<span class="params">(<span class="string">"name"</span>)</span>;</span><br><span class="line">        <span class="comment">//获取文件上传域</span></span><br><span class="line">        Part part = request.getPart<span class="params">(<span class="string">"file"</span>)</span>;</span><br><span class="line">        <span class="comment">//获取上传文件的类型</span></span><br><span class="line">        out.println<span class="params">(<span class="string">"上传文件的类型为："</span> + part.getContentType<span class="params">()</span> + <span class="string">"&lt;br/&gt;"</span>)</span>;</span><br><span class="line">        <span class="comment">//获取上传文件的大小</span></span><br><span class="line">        out.println<span class="params">(<span class="string">"上传文件的的大小为："</span> + part.getSize<span class="params">()</span>  + <span class="string">"&lt;br/&gt;"</span>)</span>;</span><br><span class="line">        <span class="comment">//获取该文件上传域的Header Name</span></span><br><span class="line">        Collection&lt;String&gt; headerNames = part.getHeaderNames<span class="params">()</span>;</span><br><span class="line">        <span class="comment">//遍历文件上传域的Header Name、Value</span></span><br><span class="line">        <span class="keyword">for</span> <span class="params">(String headerName : headerNames)</span> &#123;</span><br><span class="line">            out.println<span class="params">(headerName + <span class="string">"---&gt;"</span> + part.getHeader<span class="params">(headerName)</span> + <span class="string">"&lt;br/&gt;"</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将上传的文件写入服务器</span></span><br><span class="line">        part.write<span class="params">(getServletContext<span class="params">()</span>.getRealPath<span class="params">(<span class="string">"/uploadFiles"</span>)</span> + <span class="string">"/"</span> + fileName )</span>;</span><br><span class="line">        <span class="comment">//①</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面Servlet使用了@MultipartConfig修饰，处理文件上传的Servlet应该使用该Annotation修饰。接下来该Servlet中HttpServletRequest就可通过getPart(String name)方法来获取文件上传域—就像获取普通请求参数一样。</p>
<p>与Servlet 3.0所有Annotation相似的是，Servlet 3.0为@提供了相似的配置元素，我们同样可以通过在<servlet...>元素中添加<multipart-config...>子元素来达到相同的效果。</multipart-config...></servlet...></p>
<p>上面Servlet上传时保存的文件名直接使用了name请求参数，实际项目中一般不会这么做，因为可能多个用户会填写相同的name参数，这样将导致后面用户上传的文件覆盖前面用户上传的图片。实际项目中可借助于java.util.UUID工具类生成文件名。</p>
<p>ServletContext则提供了如下方法来动态地注册Servet、Filter，并允许动态设置Web应用的初始化参数。</p>
<ul>
<li>多个重载的addServlet：动态地注册Servlet。</li>
<li>多个重载的addFilter：动态地注册Filter。</li>
<li>多个重载的addListener：动态地注册Listener。</li>
</ul>
<p>setInitParameter(String name, String value)：为Web应用设置初始化参数。</p>
]]></content>
    <summary type="html">
    <![CDATA[JSP/Servlet及相关技术笔记]]>
    
    </summary>
    
      <category term="JSP" scheme="http://howiefh.github.io/tags/JSP/"/>
    
      <category term="Servlet" scheme="http://howiefh.github.io/tags/Servlet/"/>
    
      <category term="JavaEE" scheme="http://howiefh.github.io/categories/JavaEE/"/>
    
      <category term="JSP" scheme="http://howiefh.github.io/categories/JavaEE/JSP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring笔记二]]></title>
    <link href="http://howiefh.github.io/2015/03/06/spring-note-2/"/>
    <id>http://howiefh.github.io/2015/03/06/spring-note-2/</id>
    <published>2015-03-06T08:09:20.000Z</published>
    <updated>2015-03-13T02:19:56.000Z</updated>
    <content type="html"><![CDATA[<h2 id="两种后处理器">两种后处理器</h2><p>Spring框架提供了很好的扩展性，除了可以与各种第三方框架良好整合外，其IoC容器也允许开发者进行扩展，这种扩展甚至无须实现BeanFactory或ApplicationContext接口，而是允许通过两个后处理器对IOC容器进行扩展。Spring提供了两种常用的后处理器：</p>
<ol>
<li>Bean后处理器：这种后处理器会对容器中的Bean进行后处理，对Bean功能进行额外加强。</li>
<li>容器后处理器：这种后处理器对IoC容器进行后处理，用于增强容器功能。</li>
</ol>
<a id="more"></a>
<h3 id="Bean后处理器">Bean后处理器</h3><p>Bean后处理器是一种特殊的Bean，这种特殊Bean并不对外提供服务，它甚至可以无须id属性，它主要负责对容器中的其他Bean执行后处理，例如为容器中的目标Bean生成代理等。</p>
<p>Bean后处理器会在Bean实例创建成功之后，对Bean实例进行进一步的增强处理。</p>
<p>Bean后处理器必须实现 BeanPostProcessor 接口，它包含两个方法：</p>
<ol>
<li>Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException：第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean实例的名字。</li>
<li>Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException：第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean实例的名字。</li>
</ol>
<p>实现该接口的Bean后处理器必须实现这两个方法，这两个方法会对容器中的Bean进行后处理，会在目标Bean初始化之前、初始化之后分别被回调，这两个方法用于对容器中的Bean实例进行增强处理。</p>
<p>Axe.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖Bean:SteelAxe实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;  </span><br><span class="line">    public void useAxe();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span>,<span class="title">InitializingBean</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="keyword">private</span> String name;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring执行依赖关系注入,setAxe..."</span>);  </span><br><span class="line">        <span class="keyword">this</span>.axe = axe;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring执行依赖关系注入,setName..."</span>);  </span><br><span class="line">        <span class="keyword">this</span>.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring实例化主调Bean:Chinese实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(name+axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"正在执行初始化方法afterPropertiesSet..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"正在执行初始化方法init..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FirstBeanPostProcessor.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span>  </span><br><span class="line">            <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Bean后处理器在初始化之前对"</span>+beanName+<span class="string">"进行增强处理..."</span>);  </span><br><span class="line">        <span class="keyword">return</span> bean;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span>  </span><br><span class="line">            <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Bean后处理器在初始化之后对"</span>+beanName+<span class="string">"进行增强处理..."</span>);  </span><br><span class="line">        <span class="keyword">if</span>(bean <span class="keyword">instanceof</span> Chinese)&#123;  </span><br><span class="line">            Chinese c=(Chinese)bean;  </span><br><span class="line">            c.setName(<span class="string">"中国人"</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> bean;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span> init-<span class="keyword">method</span>=<span class="string">"init"</span>&gt;  </span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;  </span><br><span class="line">   &lt;property name=<span class="string">"name"</span> value=<span class="string">"依赖注入的值"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">   </span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"beanPostProcessor"</span> class=<span class="string">"com.bean.FirstBeanPostProcessor"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        p.useAxe();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器中一旦注册了Bean后处理器，Bean后处理器就会自动启动，在容器中每个Bean创建时自动工作。从上面程序的运行结果可以看出，Bean后处理器两个方法的回调时机如下所示：</p>
<p><img src="http://fh-1.qiniudn.com/Bean后处理器两个方法的毁掉时机.png" alt="Bean后处理器两个方法的毁掉时机"></p>
<p>采用ApplicationContext作为Spring容器时，无须手动注册BeanPostProcessor。但是如果采用BeanFactory作为Spring容器时，就必须手动注册BeanPostProcess，如下：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ClassPathResource resource=new ClassPathResource(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        XmlBeanFactory factory=new XmlBeanFactory(resource);  </span><br><span class="line">        BeanPostProcessor bpp=(FirstBeanPostProcessor) factory.getBean(<span class="string">"beanPostProcessor"</span>);  </span><br><span class="line">        factory.addBeanPostProcessor(bpp);  //注册BeanPostProcessor实例  </span><br><span class="line">        System.out.println(<span class="string">"程序已经实例化BeanFactory..."</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) factory.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(<span class="string">"程序中已经完成了chinese bean的实例化..."</span>);  </span><br><span class="line">        p.useAxe();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是Spring提供的两个常用的后处理器：</p>
<ol>
<li>BeanNameAutoProxyCreator：根据Bean实例的name属性，创建Bean实例的代理。</li>
<li>DefaultAdvisorAutoProxyCreator：根据提供的advisor，对容器中所有的Bean实例创建代理。<br>上面提供的两个Bean后处理器，都用于根据容器中配置的拦截器，创建代理Bean，代理Bean就是对目标Bean进行增强、在目标Bean的基础上进行修改得到新的Bean。</li>
</ol>
<h3 id="容器后处理器">容器后处理器</h3><p>Spring还提供了一种容器后处理器。Bean后处理器负责处理容器中的所有Bean实例，而容器后处理器则负责处理容器本身。</p>
<p>容器后处理器必须实现 BeanFactoryPostProcessor 接口，该接口中有一个方法：</p>
<p>void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException</p>
<p>实现该方法的方法体就是对Spring容器进行的处理，这种处理可以对Spring容器进行自定义扩展，当然也可以对Spring容器不进行任何处理。</p>
<p>FirstBeanFactoryPostProcessor.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span>  </span><br><span class="line">            <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"程序对Spring所做的BeanFactory的初始化没有改变..."</span>);  </span><br><span class="line">        System.out.println(<span class="string">"Spring容器是:"</span>+beanFactory);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span>&gt;  </span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">   </span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"beanFactoryPostProcessor"</span> class=<span class="string">"com.bean.FirstBeanFactoryPostProcessor"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        p.useAxe();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序会自动搜索容器中实现了BeanFactoryPostProcessor接口的类，并将它注册成容器后处理器。</p>
<p>Spring已经提供了如下几个常用的容器后处理器：</p>
<ol>
<li>PropertyPlaceholderConfigurer：属性占位符配置器。</li>
<li>PropertyOverrideConfigurer：重写占位符配置器。</li>
<li>CustomAutowireConfigurer：自定义自动装配的配置器。</li>
<li>CustomScopeConfigurer：自定义作用域的配置器。</li>
</ol>
<p>从上面的介绍可以看出，容器后处理器通常用于对Spring容器进行处理，并且总是在容器实例化任何其他的Bean之前，读取配置文件的元数据，并有可能修改这些元数据。</p>
<p>如果有需要，程序可以配置多个容器后处理器，多个容器后处理器可设置order属性来控制容器后处理器的执行次序。</p>
<h3 id="属性占位符配置器">属性占位符配置器</h3><p>Spring提供了PropertyPlaceholderConfigurer，它是一个容器后处理器，负责读取Properties属性文件里的属性值，并将这些属性值设置成Spring配置文件的元数据。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans  </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--如果采用基于XML Schema的配置文件则可以简化下面配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"locations"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">value</span>&gt;</span>dbconn.properties<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 如果有多个属性文件，依次在下面列出来 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attribute">destroy-method</span>=<span class="value">"close"</span> &gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClass"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.driverClassName&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jdbcUrl"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>dbconn.properties:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClassName=com<span class="class">.mysql</span><span class="class">.jdbc</span><span class="class">.Driver</span></span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/javaee</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure></p>
<p>通过这种方法，可从主XML配置文件中分离出部分配置信息。如果仅需要修改数据库连接属性，则无须修改主XML配置文件。</p>
<p>简化的配置属性占位符<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">context</span>:<span class="keyword">property</span>-placeholder location=<span class="string">"classpath:dbconn.properties"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="重写占位符配置器">重写占位符配置器</h3><p>Spring提供了PropertyOverrideConfigurer，负责读取Properties属性文件里的属性值，并将这些属性值直接覆盖Spring配置文件的元数据。即允许XML配置文件中有默认的配置信息。可以认为Spring配置文件是XML配置文件和属性文件的总和。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans  </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!--如果采用基于XML Schema的配置文件则可以简化下面配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.springframework.beans.factory.config.PropertyOverrideConfigurer"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"locations"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">value</span>&gt;</span>dbconn.properties<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 如果有多个属性文件，依次在下面列出来 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attribute">destroy-method</span>=<span class="value">"close"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>dbconn.properties:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClassName=com<span class="class">.mysql</span><span class="class">.jdbc</span><span class="class">.Driver</span></span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/javaee</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure></p>
<p>通过这种方法，可从主XML配置文件中分离出部分配置信息。如果仅需要修改数据库连接属性，则无须修改主XML配置文件。</p>
<p>简化的配置属性占位符<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">context</span>:<span class="keyword">property</span>-override location=<span class="string">"classpath:dbconn.properties"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Spring的“零配置”支持">Spring的“零配置”支持</h2><p>Spring提供了如下几个Annotation来标注Spring Bean。</p>
<table>
<thead>
<tr>
<th>Annotation名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Component</td>
<td>标注一个普通的Spring Bean类。</td>
</tr>
<tr>
<td>@Controller</td>
<td>标注一个控制器组件类。</td>
</tr>
<tr>
<td>@Service</td>
<td>标注一个业务逻辑组件类。</td>
</tr>
<tr>
<td>@Repository</td>
<td>标注一个DAO组件类。</td>
</tr>
</tbody>
</table>
<p>如果我们需要定义一个普通的Spring Bean，则直接使用@Component标注即可。但如果用@Repository、@Service或@Controller来标注这些Bean类，这些Bean类将被作为特殊的JavaEE组件对待，也许能更好地被工具处理，或与切面进行关联。</p>
<p>在Spring的未来版本中，@Controller、@Service和@Repository也许还能携带更多语义，因此如果需要在JavaEE应用中使用这些标注时，尽量考虑使用@Controller、@Service和@Repository来代替通用的@Component标注。</p>
<p>指定了某些类可作为Spring Bean类使用后，最后还需要让Spring搜索指定路径，此时需要在Spring配置文件中导入context Scheme，并指定一个简单的搜索路径。</p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>StoneAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoneAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"石斧砍柴真慢"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.axe = axe;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">        <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line">        <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">        <span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span>  </span><br><span class="line">        <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans   </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span><br><span class="line">                http://www.springframework.org/schema/context   </span><br><span class="line">                http://www.springframework.org/schema/context/spring-context-2.5.xsd  </span><br><span class="line">                http://www.springframework.org/schema/tx   </span><br><span class="line">                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"com.bean"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </span><br><span class="line">        ApplicationContext ctx=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        System.<span class="keyword">out</span>.println(Arrays.toString(ctx.getBeanDefinitionNames()));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行Test.java，控制台输出：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ steelAxe, stoneAxe, chinese, </span><br><span class="line">org<span class="class">.springframework</span><span class="class">.context</span><span class="class">.annotation</span><span class="class">.internalCommonAnnotationProcessor</span>, </span><br><span class="line">org<span class="class">.springframework</span><span class="class">.context</span><span class="class">.annotation</span><span class="class">.internalAutowiredAnnotationProcessor</span>,</span><br><span class="line">org<span class="class">.springframework</span><span class="class">.context</span><span class="class">.annotation</span><span class="class">.internalRequiredAnnotationProcessor</span> ]</span><br></pre></td></tr></table></figure></p>
<p>从上面程序的运行结果来看，Spring容器中三个Bean实例的名称分别为chinese、steelAxe和stoneAxe，之所以叫这些名称，是因为在这种基于Annotation的方式下，Spring采用约定的方式来为这些Bean实例指定名称，这些Bean实例的名称默认是Bean类的首字母小写，其他部分不变。</p>
<p>当然，Spring也允许在使用@Component标注时指定Bean实例的名称：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>(<span class="string">"axe"</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span>&#123;</span>  </span><br><span class="line">   <span class="comment">//codes here  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在默认情况下，Spring会自动搜索所有以@Component、@Controller、@Service和@Repository标注的Java类，并将它们当成Spring Bean来处理。</p>
<p>除此之外，我们还可通过为<code>&lt;component-scan.../&gt;</code>元素添加<code>&lt;include-filter.../&gt;</code>或<code>&lt;exclude-filter.../&gt;</code>子元素来指定Spring Bean类，只要位于指定路径下的Java类满足这种规则，即使这些java类没有使用任何Annotation标注，Spring一样会将它们当成Bean类来处理。</p>
<p><code>&lt;include-filter.../&gt;</code>元素用于指定满足该规则的Java类会被当成Bean类处理。<code>&lt;exclude-filter.../&gt;</code>元素用于指定满足该规则的Java类不会被当成Bean类处理。使用这两个元素时都要求指定如下两个属性：</p>
<ol>
<li>type：指定过滤器类型。</li>
<li>expression：指定过滤器所需要的表达式。<br>Spring内建支持如下4种过滤器：</li>
<li>annotation：Annotation过滤器，该过滤器需要指定一个Annotation名，如lee.AnnotationTest</li>
<li>assignable：类名过滤器，该过滤器直接指定一个Java类。</li>
<li>regex：正则表达式过滤器，该过滤器指定一个正则表达式，匹配该正则表达式的Java类将满足该过滤规则，如<code>org\.example\.Default.*</code>。</li>
<li>aspectj：AspectJ过滤器，如<code>org.example..*Service+</code>。</li>
</ol>
<p>例如下面的配置文件指定所有以Chinese结尾的类，以Axe结尾的类都将被当成Spring Bean处理。<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="literal">context</span>:component-scan base-<span class="keyword">package</span>=<span class="string">"org.crazyit.app.service"</span>&gt;  </span><br><span class="line">  &lt;<span class="literal">context</span>:<span class="literal">include</span>-filter <span class="built_in">type</span>=<span class="string">"regex"</span> expression=<span class="string">".*Chinese"</span>/&gt;  </span><br><span class="line">  &lt;<span class="literal">context</span>:<span class="literal">include</span>-filter <span class="built_in">type</span>=<span class="string">"regex"</span> expression=<span class="string">".*Axe"</span>/&gt;  </span><br><span class="line">&lt;/<span class="literal">context</span>:component-scan&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="指定Bean的作用域">指定Bean的作用域</h3><p>当使用XML配置方式来配置Bean实例时，可以通过scope来指定Bean实例的作用域，没有指定scope属性的Bean实例的作用域默认是singleton。</p>
<p>当我们采用零配置方式来管理Bean实例时，可以使用@Scope Annotation，只要在该Annotation中提供作用域的名称即可。例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Scope</span>(<span class="string">"prototype"</span>)  </span><br><span class="line"><span class="variable">@Component</span>(<span class="string">"axe"</span>)  </span><br><span class="line">public class SteelAxe implements Axe&#123;  </span><br><span class="line">   <span class="comment">//codes here  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用@Resource配置依赖">使用@Resource配置依赖</h3><p>@Resource位于java.annotation包下，是来自JavaEE规范的一个Annotation，Spring直接借鉴了该Annotation，通过使用该Annotation为目标Bean指定协作者Bean。</p>
<p>@Resource有一个name属性，默认情况下，Spring将这个值解释为需要被注入的Bean实例的名字。换句话说，使用@Resource与<code>&lt;property.../&gt;</code>元素的ref属性有相同的效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="annotation">@Resource</span>(name=<span class="string">"stoneAxe"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.axe = axe;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的@Resource Annotation指定将stoneAxe注入该setAxe( )方法，也就是将容器中的stoneAxe Bean作为setAxe方法的参数传入。</p>
<p>@Resource不仅可以修饰setter方法，也可以直接修饰Field，使用@Resource时还可以省略name属性。使用@Resource修饰Field时连setter方法都可以不要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Resource</span>(name=<span class="string">"stoneAxe"</span>)  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>当使用@Resource修饰setter方法时，如果省略name属性，例如@Resource标注setName( )方法，则Spring默认注入容器中名为name的组件。</li>
<li>当使用@Resource修饰Field时，如果省略name属性，例如@Resource标注name Field，则Spring默认会注入容器中名为name的组件。</li>
</ol>
<h3 id="使用@PostConstruct和@PreDestroy定制生命周期行为">使用@PostConstruct和@PreDestroy定制生命周期行为</h3><p>@PostConstruct和@PreDestroy同样位于java.annotation包下，也是来自JavaEE规范的两个Annotation，Spring直接借鉴了它们，用于定制Spring容器中Bean的生命周期行为。</p>
<p>@PostConstruct和@PreDestroy大致相当于<code>&lt;bean.../&gt;</code>元素的 init-method 属性和 destroy-method 属性指定的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Resource</span>(name=<span class="string">"steelAxe"</span>)  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@PostConstruct</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"正在执行初始化的init方法..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@PreDestroy</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"正在执行销毁之前的close方法..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spring3-0新增的@DependsOn和@Lazy">Spring3.0新增的@DependsOn和@Lazy</h3><p>@DependsOn用于强制初始化其他Bean。可以修饰Bean类或方法，使用该Annotation时可以指定一个字符串数组作为参数，每个数组元素对应于一个强制初始化的Bean。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@DependsOn</span>(&#123;<span class="string">"steelAxe"</span>,<span class="string">"abc"</span>&#125;)  </span><br><span class="line"><span class="variable">@Component</span>  </span><br><span class="line">public class Chinese implements Person&#123;  </span><br><span class="line">   <span class="comment">//codes here  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Lazy用于指定该Bean是否取消预初始化。主要用于修饰Spring Bean类，用于指定该Bean的预初始化行为，使用该Annotation时可以指定一个boolean型的value属性，该属性决定是否要预初始化该Bean。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Lazy</span>(true)  </span><br><span class="line"><span class="variable">@Component</span>  </span><br><span class="line">public class Chinese implements Person&#123;  </span><br><span class="line">   <span class="comment">//codes here  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="自动装配和精确装配">自动装配和精确装配</h3><p>spring提供了@Autowired Annotation来指定自动装配，使用@Autowired可以标注setter方法、普通方法、Field、函数形参和构造器等。</p>
<p>例如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="annotation">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Axe <span class="title">getAxe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码使用@Autowired 指定setAxe()方法进行自动装配，spring将会自动搜索容器中类型为Axe的Bean实例，并将该Bean实例作为setAxe()方法的参数传入，此时spring默认的装配策略为byType。同样的@Autowired可以修饰普通的方法，Field和构造器等，且其默认的装配策略均为byType类型的装配。</p>
<p>为了实现精确的自动装配，spring提供了@Qualifier Annotation，通过使用@Qualifier，允许根据Bean的标识来指定自动装配，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Autowired</span></span><br><span class="line">    <span class="annotation">@Qualifier</span>(<span class="string">"steelAxe"</span>)</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Axe <span class="title">getAxe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="资源访问">资源访问</h2><p>Resource接口的主要方法有:</p>
<ul>
<li>InputStream getInputStream() throws IOException:返回资源对应的输入流.</li>
<li>boolean exists():资源是否存在.</li>
<li>boolean isOpen():资源是否打开.</li>
<li>URL getURL() throws IOException:如果底层资源可以表示成URL,该方法返回对应的URL对象.</li>
<li>File getFile() throws IOException:如果底层资源对应一个文件,该方法返回对应的File对象.</li>
<li>String getDescription():返回资源的描述信息，用于资源处理出错时输出该信息，通常是全限定文件名或实际URL.</li>
<li>String getFilename():返回资源文件名，通常是路径中的最后一部分，比如”file.txt”.</li>
</ul>
<h3 id="Resource实现类">Resource实现类</h3><p>Spring在设计上使用了策略模式，针对不同的资源访问，提供了不同的实现类，常用的实现类有：</p>
<ul>
<li>UrlResource：封装了java.net.URL,用户能够访问任何可以通过URL表示的资源,如文件的系统资源,HTTP资源和FTP资源等.</li>
<li>ClassPathResource：访问类加载路径里的资源的实现类.</li>
<li>FileSystemResource：访问文件系统资源的实现类</li>
<li>ServletContextResource：访问相对于ServletContext路径里的资源的实现类</li>
<li>InputStreamResource：访问输入流资源的实现类</li>
<li><p>ByteArrayResource：访问字节数组资源的实现类</p>
</li>
<li><p>访问网络资源</p>
</li>
</ul>
<p>URL资源通常应该提供标准的协议前缀。file:用于访问文件系统；http:用于通过HTTP协议访问资源；ftp:用于通过FTP协议访问资源等。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class UrlResourceTest &#123;</span><br><span class="line">    public static void main<span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Resource对象，指定从文件系统里读取资源</span></span><br><span class="line">        <span class="comment">//1.只需要将此出替换即可使用其他策略</span></span><br><span class="line">        Resource res = new UrlResource<span class="params">(<span class="string">"file:book.xml"</span>)</span>;</span><br><span class="line">        <span class="comment">//获取该资源的简单信息</span></span><br><span class="line">        System.out.println<span class="params">(res.getFilename<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(res.getDescription<span class="params">()</span>)</span>;</span><br><span class="line">        <span class="comment">//创建Dom4j的解析器</span></span><br><span class="line">        SAXReader reader = new SAXReader<span class="params">()</span>;</span><br><span class="line">        Document doc = reader.read<span class="params">(res.getFile<span class="params">()</span>)</span>;</span><br><span class="line">        <span class="comment">//获取根元素</span></span><br><span class="line">        Element el = doc.getRootElement<span class="params">()</span>;</span><br><span class="line">        List list = el.elements<span class="params">()</span>;</span><br><span class="line">        <span class="comment">//遍历根元素的全部子元素</span></span><br><span class="line">        <span class="keyword">for</span> <span class="params">(Iterator it = list.iterator<span class="params">()</span>;it.hasNext<span class="params">()</span>;)</span> &#123;</span><br><span class="line">            Element book = <span class="params">(Element)</span>it.next<span class="params">()</span>;</span><br><span class="line">            List ll = book.elements<span class="params">()</span>;</span><br><span class="line">            <span class="keyword">for</span><span class="params">(Iterator it2 = ll.iterator<span class="params">()</span>;it2.hasNext<span class="params">()</span>;)</span> &#123;</span><br><span class="line">                Element eee = <span class="params">(Element)</span>it2.next<span class="params">()</span>;</span><br><span class="line">                System.out.println<span class="params">(eee.getText<span class="params">()</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>加载类加载路径下的资源</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource <span class="keyword">res</span> = <span class="keyword">new</span> ClassPathResource(<span class="string">"book.xml"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>访问文件系统资源</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource <span class="keyword">res</span> = <span class="keyword">new</span> FileSystemResource(<span class="string">"book.xml"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>访问应用相关资源</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource <span class="keyword">res</span> = <span class="keyword">new</span> ServletContextResource(<span class="string">"book.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>用于访问Web Context下相对路径下的资源。默认情况下，JSP不能直接访问WEB-INF路径下的任何资源，所以应用中的JSP页面需要使用ServletContextResource来访问资源。</p>
<ul>
<li>访问字节数组资源</li>
</ul>
<p>Spring 提供了InputStreamResource来访问二进制输入流资源，InputStreamResource是针对输入流的Resource实现，只有当没有合适的Resource实现时，才考虑使用该InputStreamResource。通常情况下，优先考虑使用ByteArrayResource或者基于文件的Resource实现。</p>
<p>InputStreamResource是一个总是被打开的Resource，所以isOpen方法总是返回true。因此需要多次读取某个流，就不要使用InputStreamResource，创建InputStreamResource实例时应提供一个InputStreamResource参数。</p>
<p>在某些情况下，如读取数据库得到的Blob对象，可以通过Blob的getBinaryStream方法获取二进制输入流。</p>
<p>ByteArrayResource在Socket，线程之间的信息交换方面是很有用的。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">file</span> = <span class="string">"&lt;?xml version='1.0' encoding='UTF-8'"</span></span><br><span class="line">            + <span class="string">"&lt;计算机书籍列表&gt;&lt;书&gt;&lt;书名&gt;疯狂JAVA讲义"</span></span><br><span class="line">            + <span class="string">"&lt;/书名&gt;&lt;作者&gt;李刚&lt;/作者&gt;&lt;/书&gt;&lt;书&gt;&lt;书名&gt;"</span></span><br><span class="line">            + <span class="string">"轻量级java ee企业应用实战&lt;/书名&gt;&lt;作者&gt;李刚"</span></span><br><span class="line">            + <span class="string">"&lt;/作者&gt;&lt;/书&gt;&lt;/计算机书籍列表&gt;"</span></span><br><span class="line"><span class="keyword">byte</span>[] fileBytes = <span class="keyword">file</span>.getBytes();</span><br><span class="line">Resource res = <span class="keyword">new</span> ByteArrayResource(fileBytes);</span><br></pre></td></tr></table></figure>
<h3 id="ResourceLoader接口和ResourceLoaderAware接口">ResourceLoader接口和ResourceLoaderAware接口</h3><p>ResourceLoader 接口由能返回(或者载入)Resource 实例的对象来实现。</p>
<p>所有的ApplicationContext都实现了 ResourceLoader 接口， 因此它们可以用来获取Resource 实例。</p>
<p>当你调用特定ApplicationContext的 getResource() 方法， 而且资源路径并没有特定的前缀时，你将获得与该ApplicationContext相应的 Resource 类型。例如：假定下面的代码片断是基于ClassPathXmlApplicationContext 实例上执行的：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="keyword">template</span> = ctx.getResource(<span class="string">"some/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure>
<p>这将返回ClassPathResource；如果是基于FileSystemXmlApplicationContext 实例上执行的，那你将获得FileSystemResource。而对于 WebApplicationContext 你将获得ServletContextResource，依此类推。</p>
<p>另一方面，无论什么类型的ApplicationContext，你可以通过使用特定的前缀 classpath: 强制使用ClassPathResource。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="keyword">template</span> = ctx.getResource(<span class="string">"classpath:some/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure>
<p>同样的，你可以用任何标准的 java.net.URL 前缀，强制使用 UrlResource ：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="keyword">template</span> = ctx.getResource(<span class="string">"file:/some/resource/path/myTemplate.txt"</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="keyword">template</span> = ctx.getResource(<span class="string">"http://myhost.com/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure></p>
<p>下面的表格概述了 String 到 Resource 的转换规则：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>classpath:</td>
<td>classpath:com/myapp/config.xml</td>
<td>从classpath中加载。</td>
</tr>
<tr>
<td>file:</td>
<td>file:/data/config.xml</td>
<td>作为 URL 从文件系统中加载。</td>
</tr>
<tr>
<td>http:</td>
<td><a href="http://myserver/logo.png" target="_blank" rel="external">http://myserver/logo.png</a></td>
<td>作为 URL 加载。</td>
</tr>
<tr>
<td>(none)</td>
<td>/data/config.xml</td>
<td>根据 ApplicationContext 进行判断。</td>
</tr>
</tbody>
</table>
<p>ResourceLoaderAware是特殊的标记接口，它希望拥有一个ResourceLoader 引用的对象。<br>当实现了 ResourceLoaderAware接口的类部署到ApplicationContext(比如受Spring管理的bean)中时，它会被ApplicationContext识别为 ResourceLoaderAware。 接着ApplicationContext会调用setResourceLoader(ResourceLoader)方法，并把自身作为参数传入该方法(记住，所有Spring里的ApplicationContext都实现了ResourceLoader接口)。</p>
<p>既然 ApplicationContext 就是ResourceLoader，那么该bean就可以实现 ApplicationContextAware接口并直接使用所提供的ApplicationContext来载入资源，但是通常更适合使用特定的满足所有需要的 ResourceLoader实现。 这样一来，代码只需要依赖于可以看作辅助接口的资源载入接口，而不用依赖于整个Spring ApplicationContext 接口。</p>
<p>TestBean.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    ResourceLoader rd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceloader)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rd = resourceloader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SpringTest.java:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpringTest</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        TestBean tb = (TestBean)ctx.getBean(<span class="string">"test"</span>);</span><br><span class="line">        ResourceLoader rl = tb.getResourceLoader();</span><br><span class="line">        System.<span class="keyword">out</span>.println(rl == ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用Resource作为属性">使用Resource作为属性</h3><p>前面都是通过编码的方式获取资源的，资源所在的物理位置就耦合到代码中了，如果资源位置变化，则必须改写程序。因此，可以通过依赖注入资源</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestBean</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResource</span>(<span class="params">Resource res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.res = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bean.xml:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="property">id</span>=<span class="string">"testBean"</span> <span class="type">class</span>=<span class="string">"com.bean.TestBean"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"res"</span> value=<span class="string">"classpath:book.xml"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果不采用任何前缀，则Spring将采用与该ApplicationContext相同的资源访问策略来访问资源。</p>
<h3 id="在ApplicationContext中使用资源">在ApplicationContext中使用资源</h3><p>ApplicationContext确定资源访问策略通常有两个方法：</p>
<ul>
<li>ApplicationContext实现类指定访问策略</li>
<li>前缀指定访问策略</li>
</ul>
<h4 id="ApplicationContext实现类指定访问策略">ApplicationContext实现类指定访问策略</h4><p>ClassPathXmlApplicationContext：返回ClassPathResource<br>FileSystemXmlApplicationContext： 获得FileSystemResource<br>XmlWebApplicationContext： 获得ServletContextResource</p>
<h4 id="前缀指定访问策略">前缀指定访问策略</h4><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new FileSystemXmlApplicationContext<span class="params">(<span class="string">"classpath:bean.xml"</span>)</span>;</span><br><span class="line">Resource r = ctx.getResource<span class="params">(<span class="string">"book.xml"</span>)</span>;</span><br><span class="line">System.out.println<span class="params">(r.getDescription<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>通过classpath:前缀指定资源访问策略仅仅对当次访问有效，程序后面进行资源访问时，还是会根据ApplicationContext的实现类来选择对应的资源访问策略。建议尽量显示指定资源，而不是通过前缀。</p>
<h4 id="classpath*:前缀的用法">classpath*:前缀的用法</h4><p>classpath<em>:前缀提供了装载多个XML配置文件的能力，当使用classpath</em>:前缀来指定XML配置文件时，系统搜索类加载路径，找出所有与文件名匹配的文件，分辨装载文件中的配置定义，最后合并成一个ApplicationContext。classpath<em>:前缀仅对ApplicationContext有效，用于加载配置文件。其他情况，使用classpath</em>:前缀加载多个资源是不行的。</p>
<p>还有一种可以一次加载多个配置文件的方式：指定配置文件时使用通配符。</p>
<p>这两种方式也可以混合使用</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"classpath*:bean*.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>这将会加载类加载路径下所有以bean开头的配置文件。</p>
<h4 id="file:前缀的用法">file:前缀的用法</h4><p>FileSystemApplicationContext 会简单地让所有绑定的 FileSystemResource 实例把绝对路径都当成相对路径，而不管它们是否以反斜杠开头。也就是说，下面的含义是相同的：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"conf/context.xml"</span>);</span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"/conf/context.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的两行代码是没有区别的。</p>
<p>实际上如果的确需要使用绝对路径，那你最好就不要使用 FileSystemResource 或 FileSystemXmlApplicationContext来确定绝对路径。我们可以通过使用 file: URL前缀来强制使用UrlResource。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"file:/conf/context.xml"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Spring的AOP">Spring的AOP</h2><h3 id="使用AspectJ实现AOP">使用AspectJ实现AOP</h3><p>AOP 专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。</p>
<p>AspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳了它的一些思想。由于Spring3.0的AOP与AspectJ进行了很好的集成，因此掌握AspectJ是学习Spring AOP的基础。</p>
<p>AspectJ是Java语言的一个AOP实现，其主要包括两个部分：第一个部分定义了如何表达、定义AOP编程中的语法规范，通过这套语法规范，我们可以方便地用AOP来解决Java语言中存在的交叉关注点问题；第二个部分是工具部分，包括编译器、调试工具等。</p>
<p>AspectJ是最早、功能比较强大的AOP实现之一，对整套AOP机制都有较好的实现，很多其他语言的AOP实现，也借鉴或采纳了AspectJ中的很多设计。而在Java领域，AspectJ中的很多语法结构基本上已经成为AOP领域的标准。</p>
<p>从Spring2.0开始，Spring AOP已经引入了对AspectJ的支持，并且允许直接使用AspectJ进行AOP编程，而Spring自身的AOP API也努力与AspectJ保持一致。因此学习Spring AOP就必然需要从AspectJ开始，因为它是Java领域最流行的AOP解决方案。即使不用Spring框架，我们甚至也可以直接使用AspectJ进行AOP编程。</p>
<p>下载、安装AspectJ和配置环境变量：<br>登陆点击打开链接站点<a href="http://www.eclipse.org/aspectj/downloads.php#stable_release" target="_blank" rel="external">AspectJ</a>，下载AspectJ的一个稳定版本。下载完成后得到一个aspectj-[version].jar文件。我这里将它放在D盘的lib文件夹下的aspectj文件夹下。启动命令行窗口：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">java</span> <span class="tag">-jar</span> <span class="tag">aspectj-</span><span class="attr_selector">[version]</span><span class="class">.jar</span></span><br></pre></td></tr></table></figure>
<p>安装好了以后记得配置环境变量：将 E:\Java\AOP\aspectj\bin添加到path环境变量中，将 E:\Java\AOP\aspectj\lib\aspectjrt.jar添加到CLASSPATH，注意这还不够，前面得有点号和分号。</p>
<h4 id="AspectJ使用入门">AspectJ使用入门</h4><p>我们在D盘下写一个Hello.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hello</span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;  </span><br><span class="line">        Hello h=<span class="keyword">new</span> Hello();  </span><br><span class="line">        h.sayHello();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Hello AspectJ !"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac -d . Hello<span class="class">.java</span></span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure></p>
<p>假设现在客户需要在执行sayHello()方法之前启动事务，方法结束之后关闭事务，在传统的编程模式下，我们必须手动修改sayHello()方法。但是如果采用面向切面编程的思想，则可以无须修改sayHello( )方法，也可以达到同样的效果。这里我们使用AspectJ框架帮我们做到这一点。我们在D盘下写一个TransactionAspect.java：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="aspect"><span class="keyword">aspect</span> <span class="title">TransactionAspect</span></span>&#123;  </span><br><span class="line">    <span class="comment">//指定执行Hello.sayHello()方法时执行下面的代码块  </span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">around</span>():<span class="keyword">call</span>(<span class="keyword">void</span> Hello.sayHello())&#123;  </span><br><span class="line">        System.out.println(<span class="string">"开启事务"</span>);  </span><br><span class="line">        <span class="keyword">proceed</span>();<span class="comment">//回调原来的sayHello()方法  </span></span><br><span class="line">        System.out.println(<span class="string">"结束事务"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的java文件不是使用class、interface或enum，而是使用 aspect，aspect是AspectJ才能识别的关键字。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ajc -d . Hello<span class="class">.java</span> TransactionAspect<span class="class">.java</span></span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure></p>
<p>我们可以把 ajc 命令理解成javac命令，它们都用于编译Java程序，区别是ajc命令可以识别AspectJ的语法，从这个意义上看，我们可以将ajc当成一个增强版的javac命令。</p>
<p>运行Hello类没有任何改变，但是程序的输出已经让我们足够惊喜了，对，就是我们想要的结果！</p>
<p>有了AOP，我们完全可以不对Hello.java类进行任何修改，同时又可以满足客户的需求。上面的程序只是在控制台打印输出语句模拟事务的开启和关闭，在实际工作中可以用实际的操作代码来代替打印语句，这就可以满足客户的要求了。<br>如果客户再次提出新需求，需要在sayHello( )方法后增加记录日志的功能，那也很简单，我们再写一个 LogAspect.java :</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="aspect"><span class="keyword">aspect</span> <span class="title">LogAspect</span></span>&#123;  </span><br><span class="line">    <span class="keyword">pointcut</span> <span class="title">logPointcut</span>()  </span><br><span class="line">        :<span class="keyword">execution</span>(<span class="keyword">void</span> Hello.sayHello());  </span><br><span class="line">    <span class="keyword">after</span>():logPointcut()&#123;  </span><br><span class="line">        System.out.println(<span class="string">"记录日志功能..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ajc</span> -d . <span class="regexp">*.java</span></span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure>
<p>实际上，AspectJ允许同时为多个方法添加新功能，只要我们定义Pointcut时指定匹配更多的方法即可。如如下片段：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointcut xxxPointcut()  </span><br><span class="line">   :execution(void H*.<span class="keyword">say</span>*());</span><br></pre></td></tr></table></figure>
<p>上面程序中的xxxPointcut将可以匹配所有以H开头的类中、所有以say开头的方法，但该方法返回的必须是void。如果想匹配任意的返回值类型：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointcut xxxPointcut  </span><br><span class="line">   :execution(* H*.<span class="keyword">say</span>*());</span><br></pre></td></tr></table></figure>
<p>修改：</p>
<p>Hello.java :</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hello</span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;  </span><br><span class="line">        Hello h=<span class="keyword">new</span> Hello();  </span><br><span class="line">        h.sayHello();  </span><br><span class="line">        h.sayGoodbye();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Hello AspectJ !"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayGoodbye</span>(<span class="params"></span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Goodbye Java !"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LogAspect.java :</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="aspect"><span class="keyword">aspect</span> <span class="title">LogAspect</span></span>&#123;  </span><br><span class="line">    <span class="keyword">pointcut</span> <span class="title">logPointcut</span>()  </span><br><span class="line">        :<span class="keyword">execution</span>(<span class="keyword">void</span> Hello.say*());  </span><br><span class="line">    <span class="keyword">after</span>():logPointcut()&#123;  </span><br><span class="line">        System.out.println(<span class="string">"记录日志功能..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransactionAspect.java :</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="aspect"><span class="keyword">aspect</span> <span class="title">TransactionAspect</span></span>&#123;  </span><br><span class="line">    <span class="comment">//指定执行Hello.sayHello()方法时执行下面的代码块  </span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">around</span>():<span class="keyword">call</span>(<span class="keyword">void</span> Hello.say*())&#123;  </span><br><span class="line">        System.out.println(<span class="string">"开启事务"</span>);  </span><br><span class="line">        <span class="keyword">proceed</span>();<span class="comment">//回调原来的sayHello()方法  </span></span><br><span class="line">        System.out.println(<span class="string">"结束事务"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AOP_的基本概念">AOP 的基本概念</h3><p>如果安装了Java的反编译工具，可以反编译上篇文章中的Hello.class文件，我们将会发现该Hello.class文件不是由Hello.java文件编译得到的，该Hello.class里新增了很多内容。这表明AspectJ在编译时已增强了Hello.class类的功能，因此 AspectJ 通常被称为编译时增强的AOP框架。</p>
<p>与AspectJ相对的还有另外一种AOP框架，它们不需要在编译时对目标类进行增强，而是运行时生成目标类的代理类，该代理类要么与目标类实现相同的接口，要么是目标类的子类。总之，代理类都对目标类进行了增强处理，前者是JDK动态代理的处理策略，后者是CGLIB代理的处理策略。</p>
<p>Spring AOP以创建动态代理的方式来生成代理类，底层既可使用JDK动态代理，也可采用CGLIB代理。</p>
<p>一般来说，编译时增强的AOP框架在性能上更有优势—因为运行时动态增强的AOP框架需要每次运行时都进行动态增强。</p>
<p>AOP从程序运行角度考虑程序的流程，提取业务处理过程的切面。AOP面向的是程序运行中各个步骤，希望以更好的方式来组合业务处理的各个步骤。</p>
<p>AOP框架并不与特定的代码耦合，AOP框架能处理程序执行中特定切入点（Pointcut），而不与某个具体类耦合。AOP框架具有如下两个特征：</p>
<ol>
<li>各步骤之间的良好隔离性。</li>
<li>源代码无关性。</li>
</ol>
<p>下面是关于面向切面编程的一些术语：</p>
<ol>
<li>切面（Aspect）：业务流程运行的某个特定步骤，也就是应用运行过程的关注点，关注点可能横切多个对象，所以常常也称为横切关注点。</li>
<li>连接点（Joinpoint）：程序执行过程中明确的点，如方法的调用或者异常的抛出。Spring AOP中，连接点总是方法的调用。</li>
<li>增强处理（Advice）：AOP框架在特定的切入点执行的增强处理。处理有around，before，after等类型。</li>
<li>切入点（Pointcut）：可以插入增强处理的连接点。简而言之，当某个连接点满足指定要求时，该连接点将被添加增强处理，该连接点也就变成了切入点。例如如下代码：<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointcut xxxPointcut()  </span><br><span class="line">   :execution(void H*.<span class="keyword">say</span>*())</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>每个方法被调用都只是连接点，但如果该方法属于H开头的类，且方法名义say开头，那么该方法的调用执行将变成切入点。如何使用表达式来定义切入点是AOP的核心，Spring默认使用AspectJ切入点语法：</p>
<ol>
<li>引入：将方法或字段添加到被处理的类中。Spring允许引入新的接口到任何被处理的对象。例如你可以使用一个引入，使任何对象实现isModified接口，以此来简化缓存。</li>
<li>目标对象：被AOP框架进行增强处理的对象，也被称为被增强的对象。如果AOP框架是通过运行时代理来实现的，那么这个对象将是一个被代理的对象。</li>
<li>AOP代理：AOP框架创建的对象，简单地说，代理就是对目标对象的加强。Spring中的AOP代理可以是JDK动态代理，也可以是CGLIB代理。前者为实现接口的目标对象的代理，后者为不实现接口的目标对象的代理。</li>
<li>织入（Weaving）：将增强处理添加到目标对象中，并创建一个被增强的对象（AOP代理）的过程就是织入。织入有两种实现方式：编译时增强（例如AspectJ）和运行时增强（例如CGLIB）。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li>
</ol>
<p>由前面的介绍知道：AOP代理其实是由AOP框架动态生成的一个对象，该对象可作为目标对象使用。AOP代理包含了目标对象的全部方法，但AOP代理中的方法与目标对象的方法存在差异：AOP方法在特定切入点添加了增强处理，并且回调了目标对象的方法。<br>AOP代理所包含的方法与目标对象的方法示意图如下：</p>
<p><img src="http://fh-1.qiniudn.com/AOP代理的方法和目标对象代理的方法.jpg" alt="AOP代理的方法和目标对象代理的方法"></p>
<h3 id="Spring_的AOP支持">Spring 的AOP支持</h3><p>Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其他Bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了。</p>
<p>Spring也可以使用CGLIB代理，在需要代理类而不是代理接口的时候，Spring会自动切换为使用CGLIB代理。但Spring推荐使用面向接口编程，因此业务对象通常都会实现一个或多个接口，此时默认将使用JDK动态代理，但也可强制使用CGLIB。</p>
<p>Spring AOP使用纯Java实现，它不需要专门的编译过程。Spring AOP不需要控制类装载器层次，因此它可以在所有JavaWeb容器或应用服务器中运行良好。</p>
<p>Spring目前仅支持将方法调用作为连接点，如果需要把对field的访问和更新也作为增强处理的连接点，则可以考虑使用AspectJ。</p>
<p>Spring实现AOP的方法跟其他的框架不同，Spring并不是要提供最完整的AOP实现，Spring侧重于AOP实现和Spring IOC容器之间的整合，用于帮助解决在企业级开发中的常见问题。</p>
<p>因此Spring的AOP通常和Spring IOC容器一起使用，Spring AOP从来没有打算通过提供一种全面的AOP解决方案来与AspectJ竞争。Spring AOP采用基于代理的AOP实现方案，而AspectJ则采用编译时增强的解决方案。</p>
<p>一旦我们掌握了上面AOP的相关概念，就不难发现进行AOP编程其实是很简单的事情。纵观AOP编程，其中需要程序员参与的只有三个部分：</p>
<ol>
<li>定义普通业务组件。</li>
<li>定义切入点，一个切入点可能横切多个业务组件。</li>
<li>定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作。</li>
</ol>
<p>上面三个部分的第一个部分是最平常不过的事情，那么进行AOP编程的关键就是定义切入点和定义增强处理。一旦定义了合适的切入点和增强处理，AOP框架将会自动生成AOP代理，而AOP代理的方法大致有如下公式：</p>
<p>代理对象的方法 = 增强处理 + 被代理对象的方法</p>
<p>我们使用AspectJ方式来定义切入点和增强处理，在这种方式下，Spring有两种选择来定义切入点和增强处理。</p>
<ol>
<li>基于 Annotation 的零配置方式：使用@Aspect、@Pointcut等Annotation来标注切入点和增强处理。</li>
<li>基于XML配置文件的管理方式：使用Spring配置文件来定义切入点和增强处理。</li>
</ol>
<h3 id="基于Annotation的“零配置”方式">基于Annotation的“零配置”方式</h3><p>AspectJ 允许使用Annotation定义切面、切入点和增强处理，而 Spring框架则可识别并根据这些Annotation来生成AOP代理。Spring只是使用了和AspectJ一样的注解，并没有使用AspectJ的编译器和织入器，底层依然使用的是 Spring AOP，依然是在运行时动态生成AOP代理，并不依赖于AspectJ的编译器或者织入器。</p>
<p>为了启用Spring对@AspectJ切面配置的支持，并保证Spring容器中的目标Bean被一个或多个切面自动增强，必须在配置文件中加如下代码：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;aop:aspectj-autoproxy/&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不打算使用Spring的XML Schema配置方式，则应该在Spring配置文件中增加如下片段来启用@AspectJ支持</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="keyword">class</span>=<span class="string">"org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>为了在Spring应用中启动@AspectJ支持，还需要添加 aspectjrt.jar 和aspectjweaver.jar到工程lib目录下。</p>
<h4 id="定义切面Bean">定义切面Bean</h4><p>使用@Aspect标注一个Java类，该Java类将会作为切面Bean</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> &#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发时无须担心使用@Aspect 定义的切面类被增强处理，当Spring容器检测到某个Bean类使用了@Aspect标注之后，Spring容器不会对该Bean类进行增强。</p>
<h4 id="定义Before增强处理">定义Before增强处理</h4><p>Person.java:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;  </span><br><span class="line">    public String sayHello(String name);  </span><br><span class="line">    public void eat(String food);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"我正在吃:"</span>+food);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">"Hello,Spring AOP"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BeforeAdviceTest.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeAdviceTest</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Before</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authority</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"模拟执行权限检查"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">        <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line">        <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">        <span class="attribute">xmlns:aop</span>=<span class="value">"http://www.springframework.org/schema/aop"</span>  </span><br><span class="line">        <span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span>  </span><br><span class="line">        <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans   </span><br><span class="line">                http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span><br><span class="line">                http://www.springframework.org/schema/context   </span><br><span class="line">                http://www.springframework.org/schema/context/spring-context-3.0.xsd  </span><br><span class="line">                http://www.springframework.org/schema/aop  </span><br><span class="line">                http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"com.bean"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">context:include-filter</span> <span class="attribute">type</span>=<span class="value">"annotation"</span>   </span><br><span class="line">                 <span class="attribute">expression</span>=<span class="value">"org.aspectj.lang.annotation.Aspect"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">context:component-scan</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:aspectj-autoproxy</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));  </span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="定义AfterReturning增强处理">定义AfterReturning增强处理</h4><p>AfterReturning 增强处理将在目标方法正常完成后被织入。<br>使用@AfterReturning可指定如下两个属性：</p>
<ol>
<li>pointcut / value : 两者都用于指定该切入点对应的切入表达式</li>
<li>returning : 指定一个返回值形参名，增强处理定义的方法可通过该行参名来访问目标方法的返回值。</li>
</ol>
<p>AfterReturningAdviceTest.java :</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Aspect  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AfterReturningAdviceTest</span> &#123;  </span><br><span class="line">    @AfterReturning(returning=<span class="string">"rvt"</span>,pointcut=<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span>(<span class="params">Object rvt</span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"获取目标方法返回值："</span>+rvt);  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"模拟记录日志的功能..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));  </span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="定义AfterThrowing增强处理">定义AfterThrowing增强处理</h4><p>@AfterThrowing 主要用于处理程序中未处理的异常。<br>使用@AfterThrowing 时可指定如下两个属性：</p>
<ol>
<li>pointcut / value : 用于指定该切入点对应的切入表达式。</li>
<li>throwing : 指定一个返回值形参名，增强处理定义的方法可通过该形参名来访问目标方法中所抛出的异常对象。</li>
</ol>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">5</span>/<span class="number">0</span>;  </span><br><span class="line">        System.out.println(<span class="string">"divide执行完成！"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">"sayHello方法开始被执行..."</span>);  </span><br><span class="line">            <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"目标类的异常处理"</span>+e.getMessage());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">" Hello,Spring AOP"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AfterThrowingAdviceTest.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Aspect  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AfterThrowingAdviceTest</span> &#123;  </span><br><span class="line">    @AfterThrowing(throwing=<span class="string">"ex"</span>,pointcut=<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span>(<span class="params">Throwable ex</span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"目标方法中抛出的异常:"</span>+ex);  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"模拟抛出异常后的增强处理..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));  </span><br><span class="line">        p.divide();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面程序中的sayHello方法和divide两个方法都会抛出异常，但sayHello方法中的异常将由该方法显式捕捉，所以Spring AOP不会处理该异常；而divide方法将抛出ArithmeticException异常，且该异常没有被任何程序所处理，故Spring AOP会对该异常进行处理。</p>
<p>catch捕捉 意味着完全处理该异常，如果catch块中没有重新抛出新异常，则该方法可以正常结束；而 AfterThrowing 虽然处理了该异常，但他不能完全处理该异常，该异常依然会传播到上一级调用者，本例中传播到JVM，导致程序终止。</p>
<p>如果上面的doRecoveryActions方法定义了ex形参的类型是NullPointerException，则该切入点只匹配抛出NullPointerException异常的情况。</p>
<h4 id="After增强处理">After增强处理</h4><p>@After与@AfterReturning有点相似，但是也有区别：</p>
<ol>
<li>AfterReturning 增强处理只在目标方法成功完成后才会被织入。</li>
<li>After 增强处理不管目标方法如何结束，包括成功完成和遇到异常终止两种情况，它都会被织入。<br>因为不论一个方法是如何结束的，After增强处理都会被织入，因此After增强处理必须准备处理正常返回和异常返回两种情况，这种增强处理通常用于释放资源。</li>
</ol>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">5</span>/<span class="number">0</span>;  </span><br><span class="line">        System.out.println(<span class="string">"divide执行完成！"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">try</span> &#123;  </span><br><span class="line">            System.out.println(<span class="string">"sayHello方法开始被执行..."</span>);  </span><br><span class="line">            <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);  </span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;  </span><br><span class="line">            System.out.println(<span class="string">"目标类的异常处理"</span>+e.getMessage());  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">" Hello,Spring AOP"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AfterAdviceTest.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterAdviceTest</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@After</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">realease</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"模拟方法结束后的释放资源..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));  </span><br><span class="line">        p.divide();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然divide方法因为ArithemeticException异常结束，但After增强处理依然被正常织入。由此After的作用有点类似finally块。</p>
<h4 id="Around增强处理">Around增强处理</h4><p>@Around 增强处理是功能比较强大的增强处理，它近似等于Before 和 AfterReturning的总和。@Around既可在执行目标方法之前织入增强动作，也可在执行目标方法之后织入增强动作。@Around甚至可以决定目标方法在什么时候执行，如何执行，更甚者可以完全阻止目标方法的执行。</p>
<p>@Around可以改变执行目标方法的参数值，也可以改变执行目标方法之后的返回值。</p>
<p>@Around功能虽然强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturning就能解决的问题，就没有必要使用Around了。如果需要目标方法执行之前和之后共享某种状态数据，则应该考虑使用Around。尤其是需要使用增强处理阻止目标的执行，或需要改变目标方法的返回值时，则只能使用Around增强处理了。</p>
<p>当定义一个Around增强处理方法时，该方法的第一个形参必须是 ProceedingJoinPoint 类型，在增强处理方法体内，调用ProceedingJoinPoint的proceed方法才会执行目标方法—这就是@Around增强处理可以完全控制目标方法执行时机、如何执行的关键；如果程序没有调用ProceedingJoinPoint的proceed方法，则目标方法不会执行。</p>
<p>调用ProceedingJoinPoint的proceed方法时，还可以传入一个Object[]对象，该数组中的值将被传入目标方法作为实参。如果传入的Object[]数组长度与目标方法所需要的参数个数不相等，或者Object[]数组元素与目标方法所需参数的类型不匹配，程序就会出现异常。</p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">5</span>/<span class="number">0</span>;  </span><br><span class="line">        System.out.println(<span class="string">"divide执行完成！"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"sayHello方法被调用..."</span>);  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">" Hello,Spring AOP"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"我正在吃:"</span>+food);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AroundAdviceTest.java :<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundAdviceTest</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Around</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">processTx</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable</span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"执行目标方法之前，模拟开始事务..."</span>);  </span><br><span class="line">        Object rvt=jp.<span class="keyword">proceed</span>(<span class="keyword">new</span> String[]&#123;<span class="string">"被改变的参数"</span>&#125;);  </span><br><span class="line">        System.out.println(<span class="string">"执行目标方法之后，模拟结束事务..."</span>);  </span><br><span class="line">        <span class="keyword">return</span> rvt+<span class="string">"新增的内容"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));  </span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);  </span><br><span class="line">        p.divide();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果proceed方法参数数组的维度大于需要增强处理的方法，程序会抛出异常。</p>
<h4 id="访问目标方法">访问目标方法</h4><p>最简单的做法就是定义增强处理方法时将第一个参数定义为JoinPoint 类型，当该增强处理方法被调用时，该JoinPoint参数就代表了织入增强处理的连接点。JoinPoint里包含了如下几个常用的方法：</p>
<ul>
<li>Object[ ] getArgs( )    返回执行目标方法时的参数</li>
<li>Signature getSignature( )    返回被增强的方法的相关信息</li>
<li>Object getTarget( )    返回被织入增强处理的目标对象</li>
<li>Object getThis( )    返回AOP框架为目标对象生成的代理对象</li>
</ul>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"sayHello方法被调用..."</span>);  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">" Hello,Spring AOP"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"我正在吃:"</span>+food);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FourAdviceTest.java :<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Aspect  </span><br><span class="line">public class FourAdviceTest &#123;  </span><br><span class="line">    @Around<span class="params">(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span>  </span><br><span class="line">    public Object processTx<span class="params">(ProceedingJoinPoint jp)</span> throws Throwable&#123;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Around增强:执行目标方法之前，模拟开始事务..."</span>)</span>;</span><br><span class="line">        Object[] args=jp.getArgs<span class="params">()</span>;  </span><br><span class="line">        <span class="keyword">if</span><span class="params">(args!=null &amp;&amp; args.length&gt;<span class="number">0</span> &amp;&amp; args[<span class="number">0</span>].getClass<span class="params">()</span>==String.class)</span>&#123;</span><br><span class="line">            args[<span class="number">0</span>]=<span class="string">"被改变的参数"</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        Object rvt=jp.proceed<span class="params">(args)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Around增强:执行目标方法之后，模拟结束事务..."</span>)</span>;</span><br><span class="line">        return rvt+<span class="string">" 新增的内容"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    @Before<span class="params">(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span>  </span><br><span class="line">    public void authority<span class="params">(JoinPoint jp)</span>&#123;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Before增强:模拟执行权限检查..."</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Before增强:被织入增强处理的目标方法为："</span>+ jp.getSignature<span class="params">()</span>.getName<span class="params">()</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Before增强：目标方法的参数为："</span>+Arrays.toString<span class="params">(jp.getArgs<span class="params">()</span>)</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Before增强:被织入增强处理的目标对象为："</span>+jp.getTarget<span class="params">()</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    @AfterReturning<span class="params">(returning=<span class="string">"rvt"</span>,pointcut=<span class="string">"execution(* com.bean.*.*(..))"</span>)</span>  </span><br><span class="line">    public void <span class="built_in">log</span><span class="params">(JoinPoint jp,Object rvt)</span>&#123;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强：获取目标方法返回值："</span>+rvt)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强：模拟记录日志功能..."</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强：被织入增强处理的目标方法为:"</span>+ jp.getSignature<span class="params">()</span>.getName<span class="params">()</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强：目标方法的参数为："</span>+ Arrays.toString<span class="params">(jp.getArgs<span class="params">()</span>)</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强:被织入增强处理的目标对象为："</span>+ jp.getTarget<span class="params">()</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">      </span><br><span class="line">    @After<span class="params">(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span>  </span><br><span class="line">    public void release<span class="params">(JoinPoint jp)</span>&#123;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"After增强：模拟方法结束后的释放资源..."</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"After增强：被织入增强处理的目标方法为："</span>+ jp.getSignature<span class="params">()</span>.getName<span class="params">()</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"After增强：目标方法的参数为："</span>+ Arrays.toString<span class="params">(jp.getArgs<span class="params">()</span>)</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"After增强: 被织入增强处理的目标对象为："</span>+ jp.getTarget<span class="params">()</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));  </span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Before、Around、AfterReturning、After增强处理的优先级从低到高的顺序：Before、Around、AfterReturning、After</p>
<h4 id="织入增强处理的顺序">织入增强处理的顺序</h4><p>Spring AOP 采用和 AspectJ 一样的优先顺序来织入增强处理：在进入连接点时，高优先级的增强处理将先被织入；在退出连接点时，高优先级的增强处理会后被织入。</p>
<p>当不同的切面里的两个增强处理需要在同一个连接点被织入时，Spring AOP将以随机的顺序来织入这两个增强处理。如果应用需要指定不同切面类里增强处理的优先级，Spring提供了如下两种解决方案：</p>
<ol>
<li>让切面类实现org.springframework.core.Ordered接口，实现该接口只需实现一个int getOrder()方法，该方法返回值越小，则优先级越高。</li>
<li>直接使用@Order注解来修饰一个切面类，使用 @Order 时可指定一个int型的value属性，该属性值越小，则优先级越高。</li>
</ol>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"我正在吃:"</span>+food);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AspectFirst.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span>  </span><br><span class="line"><span class="annotation">@Order</span>(<span class="number">5</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectFirst</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Before</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspectFirstStart</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"@Before增强处理：我是AspectFirst切面，我的优先级为5"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@After</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspectFirstEnd</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"@After增强处理：我是AspectFirst切面，我的优先级为5"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AspectSecond.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span>  </span><br><span class="line"><span class="annotation">@Order</span>(<span class="number">1</span>)  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectSecond</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Before</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspectSecondStart</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"@Before增强处理：我是AspectSecond切面，我的优先级为1"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@After</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspectSecondEnd</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"@After增强处理：我是AspectSecond切面，我的优先级为1"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同一个切面类里的两个相同类型的增强处理在同一个连接点被织入时，Spring AOP将以随机顺序来织入这两个增强处理，没有办法指定它们的织入顺序。如果确实需要保证它们以固有的顺序被织入，则可考虑将多个增强处理压缩成一个，或者将不同增强处理重构到不同切面类中，通过在切面类级别上进行排序。</p>
<h4 id="定义切入点">定义切入点</h4><p>我们在前面的文章中，在一个切面类中定义了4个增强处理，定义4个增强处理时分别指定了相同的切入点表达式，这种做法显然不太符合软件设计的原则：我们居然将那个切入点表达式重复了4次，如果有一天需要修改这个切入点表达式，那就要修改4个地方。如果重复了更多次呢？岁，我们就得修改更多次。</p>
<p>为了解决这个问题，AspectJ和Spring都允许定义切入点。所谓 定义切入点，其实质就是为一个切入点表达式起一个名称，从而允许在多个增强处理中重用该名称。</p>
<p>Spring AOP 只支持以Spring Bean的方法执行组作为连接点，所以可以把 切入点 看成所有能和切入表达式匹配的Bean方法。</p>
<p>切入点定义包括两个部分：</p>
<ol>
<li>一个切入点表达式：用于指定该切入点和哪些方法进行匹配。</li>
<li>一个包含名字和任意参数的方法签名：作为该切入点的名称。</li>
</ol>
<p>在@AspectJ风格的AOP中，切入点签名 采用一个普通的方法定义(方法体通常为空)，且方法的返回值必须为void；切入点表达式需要使用@Pointcut注解来标注。</p>
<p>下面的代码片段定义了一个切入点，anyOldTransfer，这个切入点将匹配任何名为transfer的方法的执行：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用@Pointcut注解时指定切入点表达式  </span></span><br><span class="line"><span class="annotation">@Pointcut</span>(<span class="string">"execution(* transfer(..))"</span>)  </span><br><span class="line"><span class="comment">//使用一个返回值为void，方法体为空的方法来命名切入点  </span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">anyOldTransfer</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>切入点表达式，也就是组成@Pointcut注解的值，是正规的AspectJ5切入点表达式。如果想要更多了解AspectJ的切入点语法，参见AspectJ编程指南。</p>
<p>一旦采用上面的代码片段定义了名为anyOldTransfer的切入点之后，程序就可以多次重复使用该切入点了，甚至可以在其他切面类、其他包的切面类里使用该切入点，至于是否可以在其他切面类、其他包的切面类里访问该切入点，则取决于该方法签名前的访问控制符—例如，本示例中anyOldTransfer方法使用的是private修饰符，则意味着仅能在当前切面类中使用该切入点。</p>
<p>如果需要使用本切面类中的切入点，则可在使用@Pointcut时，指定value属性值为已有的切入点，如下所示：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@AfterReturning</span>(pointcut=<span class="string">"myPointcut()"</span>,returning=<span class="string">"retVal"</span>)  </span><br><span class="line">public <span class="keyword">void</span> writeLog(<span class="built_in">String</span> msg,<span class="built_in">Object</span> retVal)&#123;  </span><br><span class="line">   ...  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，指定切入点时非常像调用Java方法的语法———只是该方法代表一个切入点，其实质是为该增强处理定义一个切入点表达式。</p>
<p>如果需要使用其他切面类中的切入点，则其他切面类中的切入点不能使用private修饰。如下程序的切面类中仅定义了一个切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemArchitecture</span></span>&#123;  </span><br><span class="line">   <span class="annotation">@Pointcut</span>(<span class="string">"execution(* org.crazyit.app.service.impl.Chin*.say*(..))"</span>)  </span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPointcut</span><span class="params">()</span></span>&#123;  </span><br><span class="line">   &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的切面类中将直接使用上面定义的myPointcut切入点：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Aspect  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAspect</span> &#123;  </span><br><span class="line">    @AfterReturning(pointcut=<span class="string">"SystemArchitecture.myPointcut()&amp;&amp; args(msg)"</span>,returning=<span class="string">"retVal"</span>)  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span>(<span class="params">String msg,Object retVal</span>)</span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(msg);  </span><br><span class="line">        System.<span class="keyword">out</span>.println(retVal);  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"模拟记录日志..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="切入点指示符">切入点指示符</h4><p>前面定义切点表达式时使用了大量的execution表达式，其中execution就是一个切入点指示符。Spring AOP仅支持部分AspectJ的切入点指示符，但Spring AOP还额外支持一个bean切入点指示符。不仅如此，因为Spring AOP只支持使用方法调用作为连接点，所以Spring AOP的切入点指示符仅匹配方法执行的连接点。</p>
<p>完整的AspectJ切入点语言支持大量切入点指示符，但是Spring并不支持它们。它们是：call，get，preinitialization，staticinitialization，initialization，handler，adviceexecution，withincode，cflow，cflowbelow，if，@this和@withincode。一旦在Spring AOP中使用这些切点指示符，就会抛出IllegalArgumentException。</p>
<p>Spring AOP支持的切入点指示符有如下几个：</p>
<ul>
<li><p>execution：用于匹配执行方法的连接点，这是Spring AOP中国最主要的切入点指示符。该切入点的用法也相对复杂，execution表达式的格式如下：</p>
<p>  execution(modifier-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)</p>
<p>  上面的格式中，execution是不变的，用于作为execution表达式的开头，整个表达式中几个参数的详细解释如下：</p>
<ul>
<li>modifier-pattern：指定方法的修饰符，支持通配符，该部分可以省略</li>
<li>ret-type-pattern：指定返回值类型，支持通配符，可以使用“*”来通配所有的返回值类型</li>
<li>declaring-type-pattern：指定方法所属的类，支持通配符，该部分可以省略</li>
<li>name-pattern：指定匹配的方法名，支持通配符，可以使用“*”来通配所有的方法名</li>
<li>param-pattern：指定方法的形参列表，支持两个通配符，“<em>”和“..”，其中“</em>”代表一个任意类型的参数，而“..”代表0个或多个任意类型的参数。</li>
<li>throw-pattern：指定方法声明抛出的异常，支持通配符，该部分可以省略</li>
</ul>
</li>
</ul>
<p>如下是几个execution表达式：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">execution</span><span class="params">(public * * (..)</span></span>)<span class="comment">//匹配所有public方法</span></span><br><span class="line"><span class="function"><span class="title">execution</span><span class="params">(* set*(..)</span></span>)<span class="comment">//匹配以set开始的方法</span></span><br><span class="line"><span class="function"><span class="title">execution</span><span class="params">(* com.abc.service.AdviceManager.* (..)</span></span>)<span class="comment">//匹配AdviceManager中任意方法</span></span><br><span class="line"><span class="function"><span class="title">execution</span><span class="params">(* com.abc.service.*.* (..)</span></span>)<span class="comment">//匹配com.abc.servcie包中任意类的任意方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>within：限定匹配特定类型的连接点，当使用Spring AOP的时候，只能匹配方法执行的连接点。下面是几个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">within</span><span class="params">(com.abc.service.*)</span></span><span class="comment">//匹配com.abc.service包中的任意连接点</span></span><br><span class="line"><span class="function"><span class="title">within</span><span class="params">(com.abc.service..*)</span></span><span class="comment">//匹配com.abc.service包或子包中任意的连接点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>this：用于指定AOP代理必须是指定类型的实例，用于匹配该对象的所有连接点。当使用Spring AOP的时候，只能匹配方法执行的连接点。下面是个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">this</span><span class="params">(com.abc.service.AdviceManager)</span></span><span class="comment">//匹配实现了AdviceManager接口的代理对象的所有连接点，在Spring中只是方法执行的连接点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>target：用于限定目标对象必须是指定类型的实例，用于匹配该对象的所有连接点。当使用Spring AOP的时候，只能匹配方法执行的连接点。下面是个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">target</span><span class="params">(com.abc.servcie.AdviceManager)</span></span><span class="comment">//匹配实现了AdviceManager接口的目标对象的所有连接点，在Spring中只是方法执行的连接点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>args：用于对连接点的参数类型进行限制，要求参数的类型时指定类型的实例。同样，当使用Spring AOP的时候，只能匹配方法执行的连接点。下面是个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">args</span><span class="params">(java.io.Serializable)</span></span><span class="comment">//匹配只接受一个参数，且参数类型是Serializable的所有连接点，在Spring中只是方法执行的连接点</span></span><br></pre></td></tr></table></figure>
<p>  注意，这个例子与使用execution(<em> </em>(java.io.Serializable))定义的切点不同，args版本只匹配运行时动态传入参数值是Serializable类型的情形，而execution版本则匹配方法签名只包含一个Serializable类型的形参的方法。</p>
<p>  另外，Spring AOP还提供了一个名为bean的切入点提示符，它是Spring AOP额外支持的，并不是AspectJ所支持的切入点指示符。这个指示符对Spring框架来说非常有用：它将指定为Spring中的哪个Bean织入增强处理。当然，Spring AOP中只能使用方法执行作为连接点。</p>
</li>
<li><p>bean：用于指定只匹配该Bean实例内的连接点，实际上只能使用方法执行作为连接点。定义bean表达式时需要传入Bean的id或name，支持使用”*”通配符。下面是几个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">bean</span><span class="params">(adviceManager)</span></span><span class="comment">//匹配adviceManager实例内方法执行的连接点</span></span><br><span class="line"><span class="function"><span class="title">bean</span><span class="params">(*Manager)</span></span><span class="comment">//匹配以Manager结尾的实例内方法执行的连接点</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="使用组合切点表达式">使用组合切点表达式</h4><p>Spring支持使用如下三个逻辑运算符来组合切入点表达式：</p>
<ul>
<li>&amp;&amp;：要求连接点同时匹配两个切点表达式</li>
<li>||：要求连接点匹配至少一个切入点表达式</li>
<li>!：要求连接点不匹配指定的切入点表达式</li>
</ul>
<p>其实在之前介绍args的时候，已经用到了“&amp;&amp;”运算符：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">pointcut</span><span class="params">(<span class="string">"execution(* com.abc.service.*.*(..) &amp;&amp; args(name))"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>上面的pointcut由两个表达式组成，而且使用&amp;&amp;来组合这两个表达式，因此连接点需要同时满足这两个表达式才能被织入增强处理。</p>
<h3 id="基于XML配置文件的管理方式">基于XML配置文件的管理方式</h3><p>在Spring的配置文件中，所有的切面、切点和增强处理都必须定义在<code>&lt;aop:config../&gt;</code>元素内部。<code>&lt;beans../&gt;</code>元素可以包含多个<code>&lt;aop:config../&gt;</code>元素，一个<code>&lt;aop:config../&gt;</code>可以包含pointcut、advisor和aspect元素，且这三个元素需要按照此顺序来定义。</p>
<p>注意：当我们使用<code>&lt;aop:config../&gt;</code>方式进行配置时，可能与Spring的自动代理方式相互冲突，因此，建议要么全部使用<code>&lt;aop:config../&gt;</code>配置方式，要么全部使用自动代理方式，不要把两者混合使用。</p>
<h4 id="配置切面">配置切面</h4><p>配置<code>&lt;aop:config../&gt;</code>元素时，实质是将已有的Spring Bean转换成切面Bean，所以需要先定义一个普通的Spring Bean。因为切面Bean可以当成一个普通的Spring Bean来配置，所以我们完全可以为该切面Bean配置依赖注入。当切面Bean的定义完成后，通过<code>&lt;aop:congig../&gt;</code>元素中使用ref属性来引用该Bean，就可以将该Bean转换成切面Bean了。配置<code>&lt;aop:config../&gt;</code>元素时可以指定如下三个属性：</p>
<ul>
<li>id：该切面Bean的标识名</li>
<li>ref：指定将要被转换成切面Bean的的普通Bean的id</li>
<li>order：指定该切面Bean的优先级，值越小，优先级越高</li>
</ul>
<p>如下配置片段定义了一个切面：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义普通的Bean实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"afterAdviceBean"</span> <span class="attribute">class</span>=<span class="value">"com.bean.AfterAdviceBean"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将容器中的afterAdviceBean转换成切面Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:aspect</span> <span class="attribute">id</span>=<span class="value">"afterAdviceAspect"</span> <span class="attribute">ref</span>=<span class="value">"afterAdviceBean"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="title">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的配置中，将一个AfterAdviceBean类型普通的Bean对象afterAdviceBean转换成了切面Bean对象afterAdviceAspect。</p>
<h4 id="配置增强处理">配置增强处理</h4><p>与使用@AspectJ完全一样，使用XML一样可以配置Before、After、AfterReturning、AfterThrowing和Around 5种增强处理，而且完全支持和@Aspect完全一样的语义。使用XML配置增强处理分别依赖于如下几个元素：</p>
<ul>
<li><code>&lt;aop:before../&gt;</code>：配置Before增强处理</li>
<li><code>&lt;aop:after../&gt;</code>：配置After增强处理</li>
<li><code>&lt;aop:after-returning../&gt;</code>：配置AfterReturning增强处理</li>
<li><code>&lt;aop:after-throwing../&gt;</code>：配置AfterThrowing增强处理</li>
<li><code>&lt;aop:around../&gt;</code>：配置Around增强处理</li>
</ul>
<p>这些元素都不支持使用子元素，但通常可以指定如下属性：</p>
<ul>
<li>pointcut：指定一个切入点表达式，Spring将在匹配该表达式的连接点织入增强处理</li>
<li>pointcut-ref：指定一个已经存在的切入点名称，通常pointcut和pointcut-ref只需使用其中之一</li>
<li>method：指定一个方法名，指定切面Bean的该方法作为增强处理</li>
<li>throwing：只对<code>&lt;aop:after-throwing../&gt;</code>元素有效，用于指定一个形参名，AfterThrowing增强处理方法，可通过该形参访问目标方法所抛出的异常</li>
<li>returning：只对<code>&lt;aop:after-returning../&gt;</code>元素有效，用于指定一个形参名，AfterThrowing增强处理方法，可通过该形参访问目标方法的返回值</li>
</ul>
<p>定义切点时，XML配置方式和@AspectJ注解方式支持完全相同的切点指示符，一样可以支持execution、within、args、this、target和bean等切点提示符。另外，XML配置文件方式也和@AspectJ方式一样支持组合切入点表达式，但XML配置方式不再使用简单的&amp;&amp;、|| 和 ! 作为组合运算符（因为直接在XML文件中需要使用实体引用来表示他们），而是使用如下三个组合运算符：and（相当于&amp;&amp;）、or（相当于||）和not（相当于！）。 下面是一个使用<code>&lt;aop:congig../&gt;</code>的例子，这是把前面的例子中关于切面切点和增强处理的注解去掉后，使用XML配置文件来重新实现这些切面切点的功能：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"adviceTest"</span> <span class="attribute">class</span>=<span class="value">"com.bean.AdviceTest"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意这里可以使用order属性为Aspect指定优先级 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:aspect</span> <span class="attribute">id</span>=<span class="value">"firstAspect"</span> <span class="attribute">ref</span>=<span class="value">"adviceTest"</span> <span class="attribute">order</span>=<span class="value">"2"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @Before切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:before</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span> </span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"permissionCheck"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @After切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:after</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span> </span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"releaseResource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @AfterReturning切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:after-returning</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span> </span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"log"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @AfterThrowing切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:after-throwing</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span> </span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"handleException"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @Around切点（多个切点提示符使用and、or或者not连接） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:around</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..)) and args(name,time,..)"</span> </span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"process"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的定义中，特意为firstAspec指定了order=2，表明firstAspect的优先级为2，如果这个XML文件中还有order=1的Aspect，那么这个Aspect将被Spring AOP优先织入。其执行结果，和前面几篇文章中介绍的相同，这里不再给出。</p>
<h4 id="配置切点">配置切点</h4><p>在Spring中通过<code>&lt;aop:pointcut../&gt;</code>元素来定义切点。当把<code>&lt;aop:pointcut../&gt;</code>元素作为<code>&lt;aop:config../&gt;</code>的子元素时，表明该切点可以被多个切面共享；当把<code>&lt;aop:pointcut../&gt;</code>元素作为<code>&lt;aop:aspect../&gt;</code>的子元素时，表明该切点只能在这个切面内使用。配置<code>&lt;aop:pointcut../&gt;</code>时，通常需要配置如下两个属性：</p>
<ul>
<li>id：指定该切点的标识名</li>
<li>expression：指定该切点关联的切点表达式</li>
</ul>
<p>如下的配置定义了一个简单的切点：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:pointcut <span class="variable">id=</span><span class="string">"point1"</span> <span class="variable">expression=</span><span class="string">"execution(* com.bean.service.*.*(..))"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>另外，如果程序中已经使用注解的方式定义了切点，在<code>&lt;aop:pointcut../&gt;</code>元素中指定切入点表达式时还有另一种用法，看例子：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:pointcut <span class="variable">id=</span><span class="string">"point2"</span> <span class="variable">expression=</span><span class="string">"com.bean.AdviceTest.myPointcut()"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>下面的程序中定义了一个AfterThrowing增强处理，包含该增强处理的切面类如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AfterThrowingAdviceTest</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个普通方法作为增强处理方法，这个方法名将在XML配置文件中指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryAction</span>(<span class="params">Throwable th</span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"目标方法抛出异常："</span> + th);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"模拟数据库事务恢复"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与前面的切面类完全类似，该Java类就是一个普通的Java类。下面的配置文件将负责配置该Bean实例，并将该Bean转换成切面Bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"afterThrowingAdviceTest"</span> </span><br><span class="line">    <span class="attribute">class</span>=<span class="value">"com.abc.advice.AfterThrowingAdviceTest"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个切点将可以被多个&lt;aop:aspect../&gt;使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:pointcut</span> <span class="attribute">id</span>=<span class="value">"myPointcut"</span> </span><br><span class="line">        <span class="attribute">expression</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个aspect由上面的Bean afterThrowingAdviceTest转化而来 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:aspect</span> <span class="attribute">id</span>=<span class="value">"aspect1"</span> <span class="attribute">ref</span>=<span class="value">"afterThrowingAdviceTest"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义一个AfterThrowing增强处理，指定切入点以切面Bean中</span><br><span class="line">            的doRecoverryAction作为增强处理方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:after-throwing</span> <span class="attribute">pointcut-ref</span>=<span class="value">"myPointcut"</span> </span><br><span class="line">            <span class="attribute">method</span>=<span class="value">"doRecoveryAction"</span> <span class="attribute">throwing</span>=<span class="value">"th"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的<code>&lt;aop:pointcut../&gt;</code>元素定义了一个全局的切点myPointcut，这样其他切面Bean就可以多次复用这个切点了。<code>&lt;aop:after-throwing../&gt;</code>元素中，使用pointcut-ref属性指定了一个已经存在的切点。</p>
<h2 id="Spring_的事务">Spring 的事务</h2><h3 id="Spring支持的事务策略">Spring支持的事务策略</h3><p>JavaEE应用的传统事务有两种策略：全局事务和局部事务。</p>
<ul>
<li>全局事务由应用服务器管理，需要底层服务器的JTA支持。</li>
<li>局部事务和底层所采用的持久化技术有关，当采用JDBC持久化技术时，需要使用Connection对象来操作事务；而采用Hibernate持久化技术时，需要使用Session对象来操作事务。</li>
</ul>
<p>当采用传统的事务编程策略时，程序代码必然和具体的事务操作代码耦合，这样造成的后果是：当应用需要在不同的事务策略之间切换时，开发者必须手动修改程序代码。当使用Spring事务策略后，就可以改变这种状况。</p>
<p>Spring事务策略是通过PlatformTransactionManager接口实现的，该接口是Spring事务策略的核心。该接口的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;  </span><br><span class="line">   <span class="comment">//平台无关的获得事务的方法  </span></span><br><span class="line">   <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">   <span class="comment">//平台无关的事务提交方法  </span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">   <span class="comment">//平台无关的事务回滚方法  </span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PlatformTransactionManager是一个与任何事务策略分离的接口，随着底层不同事务策略的切换，应用必须采用不同的实现类。PlatformTransactionManager接口没有与任何事务资源捆绑在一起，它可以适应于任何的事务策略，结合Spring的IoC容器，可以向PlatformTransactionManager注入相关的平台特性。</p>
<p>PlatformTransactionManager接口有许多不同的实现类，应用程序面向于平台无关的接口编程，当底层采用不同的持久层技术时，系统只需使用不同的 PlatformTransactionManager 实现类即可。而这种切换通常由Spring容器负责管理，应用程序既无须与具体的事务API耦合，也无须与特定实现类耦合，从而将应用和持久化技术、事务API彻底分离开来。</p>
<p>TransactionStatus对象表示一个事务。getTransaction(TransactionDefinition definition)返回的TransactionStatus对象，可能是一个新的事务，也可能是一个已经存在的事务对象；否则，系统将新建一个事务对象后返回。</p>
<p>TransactionDefinition接口定义了一个事务规则，该接口必须指定如下几个属性：</p>
<ul>
<li>事务隔离    当前事务和其他事务的隔离程度。例如这个事务能否看到其他事务未提交的数据等。</li>
<li>事务传播    通常，在事务中执行的代码都会在当前事务中运行。但是如果一个事务上下文已经存在，有几个选项可指定该事务性方法的执行行为。例如，大多数情况下，简单地在现有的事务上下文中运行；或者挂起现有事务，创建一个新的事务。Spring提供EJB CMT中所有的事务传播选项。</li>
<li>事务超时    事务在超时前能运行多久，也就是事务的最长持续时间。如果事务一直没有被提交或回滚，将在超出该时间后，系统自动回滚事务。</li>
<li>只读状态    只读事务不修改任何数据。在某些情况下，例如使用Hibernate时，只读事务是非常有用的优化。TransactionStatus代表事务本身，它提供了简单的控制事务执行和查询事务状态的方法，这些方法在所有的事务API中都是相同的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span> </span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;  </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SavepointManager</span> </span>&#123;  </span><br><span class="line">    <span class="function">Object <span class="title">createSavepoint</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollbackToSavepoint</span><span class="params">(Object savepoint)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseSavepoint</span><span class="params">(Object savepoint)</span> <span class="keyword">throws</span> TransactionException</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring具体的事务管理由PlatformTransactionManager的不同实现类来完成。在Spring容器中配置PlatformTransactionManager Bean时，必须针对不同环境提供不同的实现类。<br>譬如针对 JDBC数据源 的局部事务策略的配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line">        <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line">        <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span>  </span><br><span class="line">        <span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span>  </span><br><span class="line">        <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans   </span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  </span><br><span class="line">                http://www.springframework.org/schema/context   </span><br><span class="line">                http://www.springframework.org/schema/context/spring-context-2.5.xsd  </span><br><span class="line">                http://www.springframework.org/schema/tx   </span><br><span class="line">                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义数据源Bean，使用C3P0数据源实现 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClass"</span> <span class="attribute">value</span>=<span class="value">"oracle.jdbc.driver.OracleDriver"</span>/&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jdbcUrl"</span> <span class="attribute">value</span>=<span class="value">"jdbc:oracle:thin:@localhost:1521:orcl"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"scott"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"tiger"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxPoolSize"</span> <span class="attribute">value</span>=<span class="value">"40"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"minPoolSize"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"initialPoolSize"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxIdleTime"</span> <span class="attribute">value</span>=<span class="value">"20"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 配置JDBC数据源的局部事务管理器，使用DataSourceTransactionManager类 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 该类实现PlatformTransactionManager接口，是针对采用数据源连接的特定实现 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span>   </span><br><span class="line">          <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>针对 Hibernate 的局部事务策略的配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义Hibernate的SessionFactory --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionFactory"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"mappingResources"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">list</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>xxx/Xxx.hbm.xml<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="title">list</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernateProperties"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">props</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLInnoDBDialect<span class="tag">&lt;/<span class="title">prop</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="title">prop</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;/<span class="title">props</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 配置Hibernate的局部事务管理器，使用HibernateTransactionManager类 --&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 该类实现PlatformTransactionManager接口，是针对采用Hibernate的特定实现 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span>   </span><br><span class="line">        <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionFactory"</span> <span class="attribute">ref</span>=<span class="value">"sessionFactory"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">```      </span><br><span class="line"></span><br><span class="line">从上面的配置文件可以看出，当采用Spring事务管理策略时，应用程序无须与具体的事务策略耦合。Spring提供了两种事务管理方式：</span><br><span class="line">1. 编程式事务管理：即使利用Spring编程式事务时，程序也可直接获取容器中的transactionManager Bean，该Bean总是PlatformTransactionManager的实例，所以可以通过该接口提供的3个方法来开始、提交事务和回滚事务。</span><br><span class="line">2. 声明式事务管理：无须在Java程序中书写任何的事务操作代码，而是通过在XML文件中为业务组件配置事务代理，AOP为事务代理所织入的增强处理也由Spring提供：在目标方法执行之前，织入开始事务；在目标方法执行之后，织入结束事务。</span><br><span class="line"></span><br><span class="line">不论采用何种持久化策略，Spring都提供了一致的事务抽象，因此，应用开发者能在任何环境下，使用一致的编程模型。无须更改代码，应用就可在不同的事务管理策略中切换。</span><br><span class="line"></span><br><span class="line">### 使用TransactionProxyFactoryBean创建事务代理</span><br><span class="line"></span><br><span class="line">Spring同时支持编程式事务策略和声明式事务策略，在实际开发中，几乎都采用声明式事务策略。使用声明式事务策略的优势 十分明显：</span><br><span class="line"></span><br><span class="line">1. 声明式事务能大大降低开发者的代码书写量，而且声明式事务几乎不影响应用的代码。因此，无论底层事务策略如何变化，应用程序都无须任何改变。</span><br><span class="line">2. 应用程序代码无须任何事务处理代码，可以更关注于业务逻辑的实现。</span><br><span class="line">3. Spring可对任何POJO的方法提供事务管理，而且Spring的声明式事务管理无须容器的支持，可在任何环境下使用。</span><br><span class="line">4. EJB的CMT无法提供声明式回滚规则；而通过配置文件，Spring可指定事务在遇到特定异常时自动回滚。Spring不仅可在代码中使用setRollbackOnly回滚事务，也可在配置文件中配置回滚规则。</span><br><span class="line">5. 由于Spring采用AOP方式管理事务，因此可以在事务回滚动作中插入用户自己的动作，而不仅仅是执行系统默认的回滚。</span><br><span class="line"></span><br><span class="line">在Spring1.x中，声明式事务使用 TransactionProxyFactoryBean 来配置事务代理Bean。每个TransactionProxyFactoryBean为一个目标Bean生成一个事务代理Bean，事务代理的方法改写了目标Bean的方法，就是在目标Bean的方法执行之前加入开始事务，在目标Bean的方法正常结束之后提交事务，如果遇到特定异常则回滚事务。</span><br><span class="line"></span><br><span class="line">TransactionProxyFactoryBean创建事务代理时，需要了解当前事务所处的环境，该环境属性通过PlatformTransactionManager实例传入，而相关事务规则则在该Bean定义中给出。</span><br><span class="line"></span><br><span class="line">NewsDao.java :</span><br></pre></td></tr></table></figure></p>
<p>public interface NewsDao {<br>    public void insert(Integer id,String title,String content);<br>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NewsDaoImpl<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class NewsDaoImpl implements NewsDao{<br>    private DataSource ds;<br>    public void setDs(DataSource ds) {<br>        this.ds = ds;<br>    }<br>    @Override<br>    public void insert(Integer id, String title, String content) {<br>        JdbcTemplate jt=new JdbcTemplate(ds);<br>        jt.update(“insert into news values(?,?,?)”,new Object[]{id,title,content});<br>        jt.update(“insert into news values(?,?,?)”,new Object[]{id,title,content});<br>    }<br>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bean<span class="class">.xml</span> :</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;  </p>
<p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemalocation="http://www.springframework.org/schema/beans   
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  
                http://www.springframework.org/schema/context   
                http://www.springframework.org/schema/context/spring-context-2.5.xsd  
                http://www.springframework.org/schema/tx   
                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"><br>    <!-- 定义数据源Bean --><br>    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"><br>        <property name="driverClass" value="oracle.jdbc.driver.OracleDriver"><br>        <property name="jdbcUrl" value="jdbc:oracle:thin:@localhost:1521:orcl"><br>        <property name="user" value="scott"><br>        <property name="password" value="tiger"><br>        <property name="maxPoolSize" value="40"><br>        <property name="minPoolSize" value="1"><br>        <property name="initialPoolSize" value="1"><br>        <property name="maxIdleTime" value="20"><br>    </property></property></property></property></property></property></property></property></bean><br>    <!-- 配置一个业务逻辑Bean --><br>    <bean id="newsDao" class="com.bean.NewsDaoImpl"><br>        <property name="ds" ref="dataSource"><br>    </property></bean><br>    <!-- 配置JDBC数据源的局部事务管理器 --><br>    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"><br>        <property name="dataSource" ref="dataSource"><br>    </property></bean><br>    <!-- 为业务逻辑Bean配置事务代理 --><br>    <bean id="newsDaoTrans" class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean"><br>          <property name="transactionManager" ref="transactionManager"><br>          <property name="target" ref="newsDao"><br>          <property name="transactionAttributes"><br>            <props><br>                <prop key="*">PROPAGATION_REQUIRED</prop><br>            </props><br>          </property><br>    </property></property></bean><br></beans><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class Test {<br>    public static void main(String[] args) {<br>        ApplicationContext ctx=new ClassPathXmlApplicationContext(“bean.xml”);<br>        NewsDao dao=(NewsDao) ctx.getBean(“newsDaoTrans”);<br>        dao.insert(1,”夺冠”,”绿衫军夺冠”);<br>    }<br>}<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以知道，插入数据失败。上面程序中违反主键约束，该行代码将引发异常。</span><br><span class="line"></span><br><span class="line">如果在没有事务控制的环境下，前一条代码将会向数据表中插入一条记录，第二条插入失败。但是现在一条记录都没有插入，这说明事务起作用了，这两条语句是一个整体，因为第二条插入失败，导致第一条插入的数据也被回滚。</span><br><span class="line"></span><br><span class="line">配置事务代理 时需要传入一个事务管理器，一个目标Bean，并指定该事物代理的事务属性，事务属性由transactionAttributes属性指定。上面事务属性只有一条事务传播规则，该规则指定对于所有方法都使用PROPAGATION_REQUIRED的传播规则。Spring支持的事务传播规则如下：</span><br><span class="line"></span><br><span class="line"><span class="bullet">* </span>PROPAGATION_MANDATORY	要求调用该方法的线程必须处于事务环境中，否则抛出异常。</span><br><span class="line"><span class="bullet">* </span>PROPAGATION<span class="emphasis">_NESTED	如果执行该方法的线程已经处于事务环境下，依然启动新的事务，方法在嵌套的事务里执行。如果执行该方法的线程并未处于事务中，也启动新的事务，然后执行该方法，次时与PROPAGATION_</span>REQUIRED相同。</span><br><span class="line"><span class="bullet">* </span>PROPAGATION_NEVER	不允许调用该方法的线程处于事务环境下，如果调用该方法的线程处于事务环境下，则抛出异常。</span><br><span class="line"><span class="bullet">* </span>PROPAGATION<span class="emphasis">_NOT_</span>SUPPORTED	如果调用该方法的线程处在事务中，则先暂停当前事务，然后执行该方法。</span><br><span class="line"><span class="bullet">* </span>PROPAGATION_REQUIRED	要求在事务环境中执行该方法，如果当前执行线程已经处于事务中，则直接调用；如果当前执行线程不处于事务中，则启动新的事务后执行该方法。</span><br><span class="line"><span class="bullet">* </span>PROPAGATION<span class="emphasis">_REQUIRES_</span>NEW	该方法要求在新的事务环境中执行，如果当前执行线程已经处于事务中，则先暂停当前事务，启动新事务后执行该方法；如果当前调用线程不处于事务中，则启动新的事务后执行方法。</span><br><span class="line"><span class="bullet">* </span>PROPAGATION_SUPPORTS	如果当前执行线程处于事务中，则使用当前事务，否则不使用事务。</span><br><span class="line"></span><br><span class="line"><span class="header">### Spring2.x的事务配置策略</span></span><br><span class="line"></span><br><span class="line">Spring1.x 的声明式事务使用TransactionProxyFactoryBean配置策略简单易懂，但是配置起来极为繁琐：每个目标Bean都需要额外配置一个TransactionProxyFactoryBean代理，这种方式将导致配置文件急剧增加。</span><br><span class="line"></span><br><span class="line">Spring 2.x 的XML Schema方式提供了更简洁的事务配置策略，Spring2.x提供了tx命名空间来配置事务管理，tx命名空间下提供了<span class="code">`&lt;tx:advice.../&gt;`</span> 元素来配置事务增强处理，一旦使用该元素配置了事务增强处理，就可直接使用<span class="code">`&lt;aop:advisor.../&gt;`</span> 元素启用自动代理了。</span><br><span class="line"></span><br><span class="line">bean.xml :</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;  </p>
<p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemalocation="http://www.springframework.org/schema/beans   
        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  
                http://www.springframework.org/schema/context   
                http://www.springframework.org/schema/context/spring-context-2.5.xsd  
                http://www.springframework.org/schema/tx   
                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd  
                http://www.springframework.org/schema/aop   
                http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"><br>    <!-- 定义数据源Bean --><br>    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"><br>        <property name="driverClass" value="oracle.jdbc.driver.OracleDriver"><br>        <property name="jdbcUrl" value="jdbc:oracle:thin:@localhost:1521:orcl"><br>        <property name="user" value="scott"><br>        <property name="password" value="tiger"><br>        <property name="maxPoolSize" value="40"><br>        <property name="minPoolSize" value="1"><br>        <property name="initialPoolSize" value="1"><br>        <property name="maxIdleTime" value="20"><br>    </property></property></property></property></property></property></property></property></bean><br>    <!-- 配置一个业务逻辑Bean --><br>    <bean id="newsDao" class="com.bean.NewsDaoImpl"><br>        <property name="ds" ref="dataSource"><br>    </property></bean><br>    <!-- 配置JDBC数据源的局部事务管理器 --><br>    <bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"><br>        <property name="dataSource" ref="dataSource"><br>    </property></bean><br>    <!-- 配置事务增强处理Bean，指定事务管理器 --><br>    <tx:advice id="txAdvice" transaction-manager="transactionManager"><br>        <tx:attributes><br>            <!-- 所有以'get'开头的方法是只读的 --><br>            <tx:method name="get*" read-only="true"><br>            <!-- 其他方法使用默认的事务处理 --><br>            <tx:method name="*"><br>        </tx:method></tx:method></tx:attributes><br>    </tx:advice><br>    <!-- AOP配置的元素 --><br>    <aop:config><br>        <aop:pointcut id="myPointcut" expression="execution(* com.bean.*.*(..))"><br>        <aop:advisor advice-ref="txAdvice" pointcut-ref="myPointcut"><br>    </aop:advisor></aop:pointcut></aop:config><br></beans><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Test<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class Test {<br>    public static void main(String[] args) {<br>        ApplicationContext ctx=new ClassPathXmlApplicationContext(“bean.xml”);<br>        NewsDao dao=(NewsDao) ctx.getBean(“newsDao”);<br>        dao.insert(1,”夺冠”,”绿衫军夺冠”);<br>    }<br>}<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可见，事务已经自动启动了。两条记录是一个事务，第二条记录插入失败，导致第一条记录也被回滚。</span><br><span class="line"></span><br><span class="line">配置 `&lt;tx:advice.../&gt;` 元素时只需指定一个transaction-manager属性，该属性的默认值是“transactionManager”。除了transaction-manager属性之外，还需要配置一个attributes子元素，该子元素里又可包含多个<span class="keyword">method</span>子元素，每个`&lt;<span class="keyword">method</span>.../&gt;`子元素为一批方法指定所需的事务语义，包括事务传播属性、事务隔离属性、事务超时属性、只读事务、对指定异常回滚，对指定异常不回滚等。</span><br><span class="line"></span><br><span class="line">配置<span class="keyword">method</span>子元素时可以指定如下几个属性：</span><br><span class="line"></span><br><span class="line">* name	必选属性，与该事务语义关联的方法名。该属性支持使用通配符，例如get*，handle*等。</span><br><span class="line">* propagation	指定事务传播行为，该属性值可为<span class="type">Propagation</span>枚举类的任一枚举值，默认为<span class="type">Propagation_REQUIRED</span>。</span><br><span class="line">* isolation	指定事务隔离级别。该属性值可为<span class="type">Isolation</span>枚举类的任一枚举值，默认为<span class="type">Isolation_DEFAULT</span>。</span><br><span class="line">* timeout	指定事务超时的时间(以秒为单位)。指定-<span class="number">1</span>意味着不超时，默认值为-<span class="number">1</span>。</span><br><span class="line">* read-only	指定事务是否只读。默认为<span class="literal">false</span>。</span><br><span class="line">* rollback-<span class="keyword">for</span>	指定触发事务回滚的异常类，可指定多个异常类，以英文逗号隔开。</span><br><span class="line">* no-rollback-<span class="keyword">for</span>	指定不触发事务回滚的异常类，可指定多个异常类，以英文逗号隔开。</span><br><span class="line"></span><br><span class="line"><span class="comment">### 使用@Transactional</span></span><br><span class="line"></span><br><span class="line"><span class="type">Spring</span> 还允许将事务配置放在<span class="type">Java</span>类中定义，这需要借助于@<span class="type">Transactional</span>注解，该注解既可用于修饰<span class="type">Spring</span> <span class="type">Bean</span>类，也可用于修饰<span class="type">Bean</span>类中的某个方法。</span><br><span class="line"></span><br><span class="line">使用@<span class="type">Transactional</span>修饰<span class="type">Bean</span>类，表明这些事务设置对整个<span class="type">Bean</span>类起作用；</span><br><span class="line">使用@<span class="type">Transactional</span>修饰<span class="type">Bean</span>类中的某个方法，表明这些事务设置只对该方法有效。</span><br><span class="line">使用@<span class="type">Transactional</span> 时可指定如下属性：</span><br><span class="line">* isolation	用于指定事务的隔离级别，默认为底层事务的隔离级别。</span><br><span class="line">* noRollbackFor	指定遇到指定异常时强制不回滚事务。</span><br><span class="line">* noRollbackForClassName	指定遇到指定多个异常时强制不回滚事务，该属性值可以指定多个异常类名。</span><br><span class="line">* propagation	指定事务传播属性。</span><br><span class="line">* readOnly	指定事务是否只读。</span><br><span class="line">* rollbackFor	指定遇到特定异常时强制回滚事务。</span><br><span class="line">* rollbackForClassName	指定遇到指定多个异常时强制回滚事务，该属性值可以指定多个异常类名。</span><br><span class="line">* timeout	指定事务的超时时长。 例如：</span><br></pre></td></tr></table></figure></p>
<p>public class NewsDaoImpl implements NewsDao{<br>    private DataSource ds;<br>    public void setDs(DataSource ds) {<br>        this.ds = ds;<br>    }<br>    @Transactional(propagation=Propagation.REQUIRED)//这里<br>public void insert(Integer id, String title, String content) {<br>        JdbcTemplate jt=new JdbcTemplate(ds);<br>        jt.update(“insert into news values(?,?,?)”,new Object[]{id,title,content});<br>        jt.update(“insert into news values(?,?,?)”,new Object[]{id,title,content});<br>    }<br>}<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">仅仅使用这个<span class="keyword">Annotation</span>修饰还不够，还需要让Spring根据<span class="keyword">Annotation</span>来配置事务代理，所以还需要在Spring配置文件中增加如下配置片段：</span><br></pre></td></tr></table></figure></p>
<p><bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"><br>        <property name="dataSource" ref="dataSource"><br>    </property></bean>  </p>
<p><tx:annotation-driven transaction-manager="transactionManager"><br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## Spring整合Struts2</span><br><span class="line"></span><br><span class="line">### 启动Spring容器</span><br><span class="line"></span><br><span class="line">实际开发中，项目多数会选择使用Spring整合Struts2框架。对于使用Spring框架的Web应用，我们不能手动创建Spring容器，而是通过配置文件，声明式地创建Spring容器。为了让Spring容器随着Web应用的启动而自动地创建起来，可以借助于ServletContextListener监听器完成，该监听器可以在Web应用启动时回调自定义方法从而创建Spring容器。</span><br><span class="line"></span><br><span class="line">Spring提供了一个ContextLoaderListener，该监听器类实现了ServletContextListener接口，可以作为监听器使用。那么该监听器类的回调方法根据什么东西创建Spring容器呢？答案当然是Spring的配置文件。如果有多个配置文件需要载入，考虑使用<span class="escape">`&lt;</span>context-param.../&gt;<span class="escape">`元</span>素来确定配置文件。ContextLoaderListener加载时，会查找名为contextConfigLocation的初始化参数，因此配置<span class="escape">`&lt;</span>context-param.../&gt;<span class="escape">`时</span>应指定参数名为contextConfigLocation。参数值为Spring的多个配置文件，文件之间以逗号隔开。</span><br><span class="line"></span><br><span class="line">Spring根据指定配置文件创建WebApplicationContext对象，并将其保存在Web应用的ServletContext中。如果要获得Spring容器对象，可以通过如下代码：</span><br></pre></td></tr></table></figure></tx:annotation-driven></p>
<p>WebApplicationContext ctx=  WebApplicationContextUtils.getWebApplicationContext(servletContext);<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">web<span class="class">.xml</span> :</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;  </p>
<p><web-app version="2.4" xmlns="http://java.sun.com/xml/ns/j2ee" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://java.sun.com/xml/ns/j2ee   
    http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"><br>  <context-param><br>    <param-name>contextConfigLocation</param-name><br>    <param-value>classpath:beans.xml</param-value><br>  </context-param><br>  <listener><br>    <listener-class>org.springframework.web.context.ContextLoaderListener</listener-class><br>  </listener><br>  <filter><br>    <filter-name>struts2</filter-name><br>    <filter-class>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter</filter-class><br>  </filter><br>  <filter-mapping><br>    <filter-name>struts2</filter-name><br>    <url-pattern>/*</url-pattern><br>  </filter-mapping><br></web-app><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">index<span class="class">.jsp</span> :</span><br></pre></td></tr></table></figure></p>
<p><body><br><a href="test">点击我</a><br></body><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok<span class="class">.jsp</span> :</span><br></pre></td></tr></table></figure></p>
<p><body><br>操作成功，已获得Spring容器实例,控制台已经输出了容器对象…<br></body><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struts<span class="class">.xml</span> :</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;<br>&lt;!DOCTYPE struts PUBLIC<br>    “-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN”<br>    “<a href="http://struts.apache.org/dtds/struts-2.1.7.dtd&quot;&gt;" target="_blank" rel="external">http://struts.apache.org/dtds/struts-2.1.7.dtd&quot;&gt;</a>  </p>
<p><struts><br>    <package name="demo" extends="struts-default"><br>        <action name="test" class="com.action.TestAction"><br>            <result>/ok.jsp</result><br>        </action><br>    </package><br></struts><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">TestAction<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class TestAction extends ActionSupport {<br>    @Override<br>    public String execute() throws Exception {<br>        ServletContext servletContext=ServletActionContext.getServletContext();<br>        WebApplicationContext ctx=<br>            WebApplicationContextUtils.getWebApplicationContext(servletContext);<br>        System.out.println(ctx);<br>        return “success”;<br>    }<br>}<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果将Spring的配置文件放在WEB-INF目录下：</span><br><span class="line"></span><br><span class="line">则修改web.xml的&lt;<span class="built_in">param</span>-<span class="built_in">value</span>&gt;的值为：</span><br></pre></td></tr></table></figure></p>
<p><context-param><br>  <param-name>contextConfigLocation</param-name><br>  <param-value>/WEB-INF/beans.xml</param-value><br></context-param><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="header">### MVC框架与Spring整合的思考</span></span><br><span class="line"></span><br><span class="line">对于一个基于B/S架构的JavaEE应用而言，用户请求总是向MVC框架的控制器请求，而当控制器拦截到用户请求后，必须调用业务逻辑组件来处理用户请求。此时有一个问题：控制器应该如何获得业务逻辑组件？</span><br><span class="line"></span><br><span class="line">最容易想到的策略是，直接通过 new 关键字创建业务逻辑组件，然后调用业务逻辑组件的方法，根据业务逻辑方法的返回值确定结果。</span><br><span class="line"></span><br><span class="line">在实际开发中，很少采用上面的策略，因为这是一种非常差的策略。原因有三：</span><br><span class="line"><span class="bullet">1. </span>控制器直接创建业务逻辑组件，导致控制器和业务逻辑组件的耦合降低到代码层次，不利于高层次解耦。</span><br><span class="line"><span class="bullet">2. </span>控制器不应该负责业务逻辑组件的创建，控制器只是业务逻辑组件的使用者，无须关心业务逻辑组件的实现。</span><br><span class="line"><span class="bullet">3. </span>每次创建新的业务逻辑组件导致性能下降。</span><br><span class="line"></span><br><span class="line">对于轻量级的JavaEE应用，工厂模式 则是更实际的策略。因为在轻量级JavaEE应用中，业务逻辑组件不是EJB，通常就是一个POJO，业务逻辑组件的生成通常应由工厂负责，而且工厂可以保证该组件的实例只有一个，这样就可以避免重复实例化造成的系统开销。</span><br><span class="line"></span><br><span class="line">采用工厂模式，将控制器和业务逻辑组件的实现分离，从而提供更好的解耦。在采用工厂模式的访问策略中，所有的业务逻辑组件的创建由工厂负责，业务逻辑组件的运行也由工厂负责。控制器只需定位工厂实例即可。</span><br><span class="line"></span><br><span class="line">如果系统采用 Spring框架，则Spring成为最大的工厂。Spring负责业务逻辑组件的创建和生成，并可管理业务逻辑组件的生命周期。可以如此理解：Spring是个性能非常优秀的工厂，可以生产出所有的实例，从业务逻辑组件，到持久层组件，甚至控制器组件。</span><br><span class="line"></span><br><span class="line">现在的问题是：控制器如何访问到Spring容器中的业务逻辑组件呢？有两种策略：</span><br><span class="line"><span class="bullet">1. </span>Spring容器负责管理控制器Action，并利用依赖注入为控制器注入业务逻辑组件。</span><br><span class="line"><span class="bullet">2. </span>利用Spring的自动装配，Action将会自动从Spring容器中获取所需的业务逻辑组件。</span><br><span class="line"></span><br><span class="line"><span class="header">### 让Spring容器管理控制器</span></span><br><span class="line"></span><br><span class="line">web.xml如前所示。 </span><br><span class="line">index.jsp :</span><br></pre></td></tr></table></figure></p>
<p><body>  </body></p>
<p><form action="add" method="post"><br>部门名称:<input type="text" name="dname"><br><br>部门地址:<input type="text" name="loc"><br>  </form></p>
<p><input type="submit" value="提交"><br><br><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ok<span class="class">.jsp</span> :</span><br></pre></td></tr></table></figure></p>
<p><body><br>部门信息添加成功…<br></body><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Dept<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class Dept {<br>    private String dname;<br>    private String loc;<br>    //setter .. getter<br>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeptDAO<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public interface DeptDAO {<br>    public void save(Dept dept);<br>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DeptDAOImpl<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class DeptDAOImpl implements DeptDAO {<br>    @Override<br>    public void save(Dept dept) {<br>        System.out.println(“将Dept对象保存进数据库”);<br>    }<br>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AddDeptAction<span class="class">.java</span> :</span><br></pre></td></tr></table></figure></p>
<p>public class AddDeptAction extends ActionSupport {<br>    private String dname;<br>    private String loc;<br>    private DeptDAO deptDao;<br>    public String execute(){<br>        Dept dept=new Dept();<br>        dept.setDname(dname);<br>        dept.setLoc(loc);<br>        deptDao.save(dept);<br>        return “success”;<br>    }<br>    //setter … getter<br>}<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">struts<span class="class">.xml</span> :</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8” ?&gt;<br>&lt;!DOCTYPE struts PUBLIC<br>    “-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN”<br>    “<a href="http://struts.apache.org/dtds/struts-2.1.7.dtd&quot;&gt;" target="_blank" rel="external">http://struts.apache.org/dtds/struts-2.1.7.dtd&quot;&gt;</a>  </p>
<p><struts><br>    <package name="demo" extends="struts-default"><br>        <action name="add" class="addDeptAction"><br>            <result>/ok.jsp</result><br>        </action><br>    </package><br></struts><br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beans<span class="class">.xml</span> :</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”UTF-8”?&gt;  </p>
<p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemalocation="http://www.springframework.org/schema/beans   
                http://www.springframework.org/schema/beans/spring-beans-2.5.xsd  
                http://www.springframework.org/schema/context   
                http://www.springframework.org/schema/context/spring-context-2.5.xsd  
                http://www.springframework.org/schema/tx  
                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd  
                http://www.springframework.org/schema/aop  
                http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"><br>    <bean id="addDeptAction" class="com.action.AddDeptAction" scope="prototype"><br>        <property name="deptDao" ref="dao"><br>    </property></bean><br>    <bean id="dao" class="com.dao.DeptDAOImpl"><br></bean></beans><br><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="preprocessor">## Spring整合Hibernate</span></span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### Spring提供的DAO支持</span></span><br><span class="line"></span><br><span class="line">DAO模式 是一种标准的Java EE设计模式，DAO模式的核心思想是：所有的数据库访问，都通过DAO组件完成，DAO组件封装了数据库的增删改等原子操作。业务逻辑组件依赖于DAO组件提供的数据库原子操作，完成系统业务逻辑的实现。</span><br><span class="line"></span><br><span class="line">DAO组件是整个Java EE应用的持久层访问的重要组件，每个JavaEE应用的底层实现都难以离开DAO组件的支持。Spring对实现DAO组件提供了许多工具类，系统的DAO组件可通过继承这些工具类完成，从而可以更加简便地实现DAO组件。</span><br><span class="line"></span><br><span class="line">Spring提供了一系列的抽象类，这些抽象类将被作为应用中DAO实现类的父类。通过继承这些抽象类，Spring简化了DAO的开发步骤，能以一致的方式使用数据库访问技术。不管底层采用JDBC还是Hibernate，应用中都可采用一致的编程模型。</span><br><span class="line"></span><br><span class="line">除外之外，Spring通过了一致的异常抽象，将原有的checked异常转换包装成Runtime异常，因而，编码时无须捕获各种技术中特定的异常。Spring DAO体系中的异常，都继承DataAccessException，而DataAccessException异常是Runtime的，无须显式捕捉。通过DataAccessException的子类包装原始异常信息，从而保证应用程序依然可以捕捉到原始异常信息。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 管理Hibernate的SessionFactory</span></span><br><span class="line"></span><br><span class="line">在实际开发中，我们直接以配置文件来管理SessionFactory实例。</span><br></pre></td></tr></table></figure></p>
<!-- 定义Hibernate的SessionFactory -->  
<p><bean id="sessionFactory" class="org.springframework.orm.hibernate3.LocalSessionFactoryBean"><br>    <property name="dataSource" ref="dataSource"><br>    <property name="mappingResources"><br>        <list><br>            <value>xxx/Xxx.hbm.xml</value><br>        </list><br>    </property><br>    <property name="hibernateProperties"><br>        <props><br>            <prop key="hibernate.dialect">org.hibernate.dialect.MySQLInnoDBDialect</prop><br>            <prop key="hibernate.hbm2ddl.auto">update</prop><br>        </props><br>    </property><br></property></bean><br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">### 使用HibernateTemplate</span></span><br><span class="line"></span><br><span class="line"><span class="type">HibernateTemplate</span>文档中的一句话：</span><br><span class="line"></span><br><span class="line"><span class="type">NOTE</span>: <span class="type">As</span> <span class="keyword">of</span> <span class="type">Hibernate</span> <span class="number">3</span>.<span class="number">0</span>.<span class="number">1</span>, transactional <span class="type">Hibernate</span> access code can also be coded <span class="keyword">in</span> plain <span class="type">Hibernate</span> style. <span class="type">Hence</span>, <span class="keyword">for</span> newly started projects,consider adopting the standard <span class="type">Hibernate3</span> style <span class="keyword">of</span> coding data access objects instead, based on <span class="type">SessionFactory</span>.getCurrentSession().(<span class="type">Spring</span>'s <span class="type">LocalSessionFactoryBean</span> automatically supports <span class="type">Spring</span> transaction management <span class="keyword">for</span> the <span class="type">Hibernate3</span> getCurrentSession() <span class="keyword">method</span>.)作者说：在新开始的工程，可以考虑用标准的<span class="type">Hibernate3</span>的编码方式作为<span class="type">HibernateTemplate</span>的替代。因为<span class="type">Hibernate3</span>提供的<span class="type">SessionFactory</span>.getCurrentSession()已经取代了以往那种每次操作都open一个新<span class="type">Session</span>的方式，同时<span class="type">Spring</span>的<span class="type">LocalSessionFactoryBean</span>自动支持<span class="type">Hibernate3</span>的getCurrentSession()的事务管理。也就是说，如果不用<span class="type">HibernateTemplate</span>这咱<span class="type">Spring</span>的专有<span class="type">API</span>，而只用<span class="type">Hibernate3</span>,我们一样可以受用<span class="type">Spring</span>的事务管理。</span><br></pre></td></tr></table></figure></p>
<p>puclic class PersonDaoImpl implements PersonDao {<br>    private HibernateTemplate ht = null;<br>    @Resource(name=”sessionFactory”)<br>    private SessionFactory sessionFactory;</p>
<pre><code>private HibernateTemplate getHibernateTemplate(){
    if(ht==null){
        ht = new HibernateTemplate(sessionFactory);
    }
    return ht;
}
public <span class="keyword">Person</span> get(Integer id){
    return getHibernateTemplate().get(<span class="keyword">Person</span>.class,id);
}
//....
</code></pre><p>}<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">常用方法</span><br><span class="line">delete(Object entity)：删除指定持久化实例</span><br><span class="line">deleteAll(Collection entities)：删除集合内全部持久化类实例</span><br><span class="line">find(String queryString)：根据HQL查询字符串来返回实例集合  //from <span class="keyword">Person</span>,返回<span class="keyword">Person</span>的全部实例 ；select p.name,p.password from <span class="keyword">Person</span> 则返回Object对象， select后要new select new <span class="keyword">Person</span>（p.name,p.password）from Pserson p</span><br><span class="line">findByNamedQuery(String queryName)：根据命名查询返回实例集合</span><br><span class="line">get(Class entityClass, Serializable id)：根据主键加载特定持久化类的实例</span><br><span class="line">save(Object entity)：保存新的实例</span><br><span class="line">saveOrUpdate(Object entity)：根据实例状态，选择保存或者更新</span><br><span class="line">update(Object entity)：更新实例的状态，要求entity是持久状态</span><br><span class="line">setMaxResults(int maxResults)：设置分页的大小</span><br><span class="line"></span><br><span class="line">### 使用HibernateCallback</span><br><span class="line"></span><br><span class="line">弥补HibernateTemplate灵活性不足。HibernateTemplate还提供一种更加灵活的方式来操作数据库，通过这种方式可以完全使用Hibernate的操作方式。这种灵活方式主要是通过如下两个方法完成的：</span><br></pre></td></tr></table></figure></p>
<p>Object execute(HibernateCallback action)<br>List executeFind(HibernateCallback action)<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">HibernateCallback是个接口，该接口包含一个方法<span class="function"><span class="title">doInHibernate</span><span class="params">(org.hibernate.Session session)</span></span>，该方法只有一个参数Session。 </span><br><span class="line"></span><br><span class="line">在doInHibernate方法内可访问Session，该Session对象是绑定到该线程的Session实例。在该方法内的持久层操作，与不使用Spring时的持久化操作完全相同。这保证了对于复杂的持久化层访问，依然可以使用Hibernate的访问方式。</span><br></pre></td></tr></table></figure></p>
<p>/<em>*<br>使用hql进行分页查询<br>@param hql 需要查询的hql语句<br>@param offset 第一条记录索引<br>@param pageSize 当前需要显示的记录数<br>@return 当前页的所有记录   </em>/<br>public List findByPage(final String hql, final int offset, final int pageSize){<br>        //通过一个HibernateCallback对象来执行查询<br>        List list = getHibernateTemplate().executeFind(<br>                new HibernateCallback(){//实现HibernateCallback接口必须实现的方法<br>                    public Object doInHibernate(Session session)throws HibernateException, SQLException{//执行Hibernate分页查询<br>                        List result = session.createQuery(hql)<br>                        .setFirstResult(offset)<br>                        .setMaxResults(pageSize)<br>                        .list();<br>                        return result;<br>                        }<br>                    });<br>        return list;<br>}<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">注意：Spring提供的XxxTemplate和XxxCallBack互为补充，XxxTemplate对通用操作进行封装，而XxxCallBack解决了封装后灵活性不足的缺陷。</span><br><span class="line"></span><br><span class="line"><span class="preprocessor">### 实现DAO组件</span></span><br><span class="line"></span><br><span class="line">为了实现DAO组件，Spring提供了大量的XxxDaoSupport类，这些DAO支持类对于实现DAO组件有很大的帮助，因为这些DAO支持类完成了大量基础性工作。 </span><br><span class="line"></span><br><span class="line">Spring为Hibernate的DAO提供工具类：HibernateDaoSupport。该类主要提供如下两个方法来简化DAO的实现： </span><br><span class="line"></span><br><span class="line">* <span class="keyword">public</span> <span class="keyword">final</span> HibernateTemplate getHibernateTemplate() </span><br><span class="line">* <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> setSessionFactory(SessionFactory sessionFactory) </span><br><span class="line"></span><br><span class="line">在继承HibernateDaoSupport的DAO实现里，程序无须理会Hibernate的Session管理，Spring会根据实际的操作，采用“每次事务打开一次session”的策略，自动提高数据库访问的性能。</span><br></pre></td></tr></table></figure></p>
<p>public class MyHibernateDaoSupport extends HibernateDaoSupport implements IMyHibernateDaoSupport {  </p>
<pre><code><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDao</span><span class="params">()</span></span>{  
    List <span class="built_in">list</span> = getHibernateTemplate().find(<span class="string">"from NewsInf"</span>);  
    System.out.println(<span class="string">"list.size()="</span>+<span class="built_in">list</span>.size());  
}  
</code></pre><p>}<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p><bean id="myHibernateDaoSupport" class="com.dao.impl.MyHibernateDaoSupport"><br>        <property name="hibernateTemplate" ref="hibernateTemplate"></property><br></bean><br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">### 使用IoC容器组装各种组件</span><br><span class="line"></span><br><span class="line">至此为止，J2</span>EE应用所需要的各种组件都已经出现了，从M<span class="title">VC层的控制器组件，到业务逻辑组件，以及持久层的DAO组件，已经全部成功实现。应用程序代码并未将这些组件耦合在一起，代码中都是面向接口编程，因此必须利用Spring的IoC容器将他们组合在一起。</span><br><span class="line"></span><br><span class="line">从用户角度来看，用户发出HTTP请求，当MVC框架的控制器组件拦截到用户请求时，将调用系统的业务逻辑组件，而业务逻辑组件则调用系统的DAO组件，而DAO组件则依赖于SessionFactory和DataSource等底层组件实现数据库访问。</span><br><span class="line"></span><br><span class="line">从系统实现角度来看，IoC容器先创建SessionFactory和DataSource等底层组件，然后将这些底层组件注入给DAO组件，提供一个完整的DAO组件，并将此DAO组件注入给业务逻辑组件，从而提供一个完整的业务逻辑组件，而业务逻辑组件又被注入给控制器组件，控制器组件负责拦截用户请求，并将处理结果呈现给用户——这一系列的衔接都由Spring的IoC容器提供实现。</span><br><span class="line"></span><br><span class="line">下面给出关于如何在容器中配置J2</span>EE组件的大致模板，其模板代码如下：</span><br></pre></td></tr></table></figure></p>
<p>&lt;?xml version=”1.0” encoding=”GBK”?&gt;<br><!-- beans是Spring配置文件的根元素，并且指定了Schema信息 --></p>
<p><beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemalocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"><br>    <!-- 定义数据源Bean，使用C3P0数据源实现 --><br>    <bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource" destroy-method="close"><br>        <!-- 指定连接数据库的驱动 --><br>        <property name="driverClass" value="com.mysql.jdbc.Driver"><br>        <!-- 指定连接数据库的URL --><br>        <property name="jdbcUrl" value="jdbc:mysql://localhost/j2ee"><br>        <!-- 指定连接数据库的用户名 --><br>        <property name="user" value="root"><br>        <!-- 指定连接数据库的密码 --><br>        <property name="password" value="32147"><br>        <!-- 指定连接数据库连接池的最大连接数 --><br>        <property name="maxPoolSize" value="40"><br>        <!-- 指定连接数据库连接池的最小连接数 --><br>        <property name="minPoolSize" value="1"><br>        <!-- 指定连接数据库连接池的初始化连接数 --><br>        <property name="initialPoolSize" value="1"><br>        <!-- 指定连接数据库连接池的连接最大空闲时间 --><br> <property name="maxIdleTime" value="20"><br>    </property></property></property></property></property></property></property></property></bean><br>    <!-- 定义Hibernate的SessionFactory Bean --><br>    <bean id="sessionFactory" class="org.springframework.orm.hibernate3. 
    LocalSessionFactoryBean"><br>        <!-- 依赖注入数据源，注入的正是上文中定义的dataSource --><br>        <property name="dataSource" ref="dataSource"><br>        <!-- mappingResources属性用来列出全部映射文件 --><br>        <property name="mappingResources"><br>            <list><br>                <!-- 以下用来列出所有的PO映射文件 --><br>                <value>lee/Person.hbm.xml</value><br>                <!-- 此处还可列出更多的PO映射文件 --><br>            </list><br>        </property><br>          <!-- 定义Hibernate的SessionFactory属性 --><br>        <property name="hibernateProperties"><br>             <props><br>                <!-- 指定Hibernate的连接方言 --><br>                <prop key="hibernate.dialect">org.hibernate.dialect.<br>                MySQLDialect</prop><br>                <!-- 指定启动应用时，是否根据Hibernate映射文件创建数据表 --><br>                  <prop key="hibernate.hbm2ddl.auto">update</prop><br>             </props><br>        </property><br>    </property></bean><br>    <!-- 配置Person持久化类的DAO Bean --><br>    <bean id="personDao" class="lee.PersonDaoImpl"><br>        <!-- 采用依赖注入来传入SessionFactory的引用 --><br>        <property name="sessionFactory" ref="sessionFactory"><br>    </property></bean><br>    <!-- 下面能以相同的方式配置更多的持久化Bean --><br>    …<br>    <bean id="myService" class="lee.MyServiceImp"><br>        <!-- 注入业务逻辑组件所必需的DAO组件 --><br>        <property name="peronDdao" ref=" personDao "><br>        <!-- 此处可采用依赖注入更多的DAO组件 --><br>        …<br>    </property></bean><br>    <!-- 配置控制器Bean，设置起作用域为Request --><br>    <bean name="/login" class="lee.LoginAction" scope="request"><br>        <!-- 依赖注入控制器所必需的业务逻辑组件 --><br>        <property name="myService" ref=" myService "><br>    </property></bean><br></beans><br>```<br>在上面的配置文件中，同时配置了控制器Bean、业务逻辑组件Bean、DAO组件Bean以及一些基础资源Bean。各组件的组织被解耦到配置文件中，而不是在代码层次的低级耦合。<br>当客户端的HTTP请求向/login.do发送请求时，将被容器中的lee.LoginAction拦截，LoginAction调用myService Bean，myService Bean则调用personDao等系列DAO组件，整个流程将系统中的各组件有机地组织在一起。</p>
<p>注意：在实际应用中，很少会将DAO组件、业务逻辑组件以及控制组件都配置在同一个文件中。而是在不同配置文件中，配置相同一组J2EE应用组件。</p>
<h3 id="使用声明式事务">使用声明式事务</h3><ul>
<li>针对不同的事务策略配置对应的事务管理器   <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"txManager"</span> class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"dataSource"</span> <span class="keyword">ref</span>=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li>使用<code>&lt;tx:advice&gt;</code>元素配置事务增强处理Bean，配置事务增强处理Bean时使用多个<code>&lt;method../&gt;</code>子元素为不同方法指定相应的事务语义</li>
<li>在<code>&lt;aop:config../&gt;</code>子元素中使用<code>&lt;aop:advisor../&gt;</code>元素配置自动事务代理  <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=<span class="string">"txAdvice"</span> transaction-manager=<span class="string">"txManager"</span>&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"get*"</span> read-only=<span class="string">"true"</span> propagation=<span class="string">"NOT_SUPPORTED"</span>/&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"save*"</span>/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut</span><br><span class="line">            expression=<span class="string">"execution(* org.flyne.service.impl.*.*(..))"</span></span><br><span class="line">            id=<span class="string">"perform"</span>/&gt;</span><br><span class="line">    &lt;aop:advisor advice-<span class="keyword">ref</span>=<span class="string">"txAdvice"</span> pointcut-<span class="keyword">ref</span>=<span class="string">"perform"</span>/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[Spring]]>
    
    </summary>
    
      <category term="Spring" scheme="http://howiefh.github.io/tags/Spring/"/>
    
      <category term="JavaEE" scheme="http://howiefh.github.io/categories/JavaEE/"/>
    
      <category term="Spring" scheme="http://howiefh.github.io/categories/JavaEE/Spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring笔记一]]></title>
    <link href="http://howiefh.github.io/2015/03/06/spring-note-1/"/>
    <id>http://howiefh.github.io/2015/03/06/spring-note-1/</id>
    <published>2015-03-06T08:09:20.000Z</published>
    <updated>2015-07-05T14:35:32.000Z</updated>
    <content type="html"><![CDATA[<p>使用Spring框架，必须使用Spring Core Container，主要由<code>org.springframework.core</code>、<code>org.springframework.beans</code>和<code>org.springframework.context</code>、<code>org.springframework.expression</code>四个包及其子包组成，主要提供Spring IoC容器支持。</p>
<a id="more"></a>
<p><img src="http://fh-1.qiniudn.com/spring3-modules.png" alt="Spring组成结构" title="Spring组成结构"></p>
<h2 id="Spring核心机制：依赖注入">Spring核心机制：依赖注入</h2><p>Java应用（从applets的小范围到全套n层服务端企业应用）是一种典型的依赖型应用，它就是由一些互相适当地协作的对象构成的。因此，我们说这些对象间存在依赖关系。加入A组件调用了B组件的方法，我们就可以称A组件依赖于B组件。我们通过使用依赖注入，Java EE应用中的各种组件不需要以硬编码方式耦合在一起，甚至无需使用工厂模式。当某个Java 实例需要其他Java 实例时，系统自动提供所需要的实例，无需程序显示获取，这种自动提供java实例我们谓之为依赖注入，也可以称之为控制反转（Inversion of Control IoC）。</p>
<p>依赖注入通常有如下两种：</p>
<ol>
<li>设置注入：IoC容器使用属性的setter方法来注入被依赖的实例。</li>
<li>构造注入：IoC容器使用构造器来注入被依赖的实例。</li>
</ol>
<h3 id="设值注入">设值注入</h3><p>设值注入是指IoC容器使用属性的setter方法来注入被依赖的实例。这种注入方式比较简单、直观。<br>下面是Person接口，该接口定义了一个Person规范。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;  </span><br><span class="line">    //定义使用斧子的方法  </span><br><span class="line">    public void useAxe();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Axe接口：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;  </span><br><span class="line">    <span class="comment">//Axe接口里面有个砍的方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person的实现类。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Chinese implements <span class="keyword">Person</span> &#123;  </span><br><span class="line">    private Axe axe;  </span><br><span class="line">    private String name;  </span><br><span class="line"></span><br><span class="line">    // 设值注入所需的setter方法  </span><br><span class="line">    public void setAxe(Axe axe) &#123;  </span><br><span class="line">        this.axe = axe;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;  </span><br><span class="line">        this.name = name;  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    // 实现<span class="keyword">Person</span>接口的userAxe方法  </span><br><span class="line">    public void useAxe() &#123;  </span><br><span class="line">        // 调用axe的chop方法，表明<span class="keyword">Person</span>对象依赖于Axe对象  </span><br><span class="line">        System.out.println(<span class="string">"我是"</span>+name+<span class="string">"用"</span>+axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码实现了Person接口的userAxe()方法，实现该方法时调用了axe的的chop()方法，这就是典型的依赖关系。</p>
<p>在这里Spring容器的作用就是已松耦合的方式来管理这种调用关系。在上面的Chinese类中，Chinese类并不知道它要调用的axe实例在哪里，也不知道axe实例是如何实现的，它只是需要调用一个axe实例，这个Axe实例将由Spring容器负责注入。<br>Axe的实现类：StoneAxe类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoneAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"石斧砍柴好慢啊!!!"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直到这里，程序依然不知道Chinese类和Axe实例耦合，Spring也不知道！实际上，Spring需要使用XML配置文件来指定实例之间的依赖关系。<br>Spring采用了XML文件作为配置文件。<br>对于本应用的XML配置文件如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans  </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 配置Chinese实例，其实现类是Chinese --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.Chinese"</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 将StoneAxe注入给axe属性 --&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"axe"</span> <span class="attribute">ref</span>=<span class="value">"stoneAxe"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"孙悟空"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 配置stoneAxe实例 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"stoneAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.StoneAxe"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在配置文件中，Spring配置Bean实例通常会指定两个属性：</p>
<ul>
<li>id：指定该Bean的唯一标识，程序会通过id属性值来访问该Bean实例。</li>
<li>class：指定该Bean的实现类，此处不可再用接口，必须是实现类，Spring容器会使用XML解析器读取该属性值，并利用反射来创建该实现类的实例。</li>
</ul>
<p>从上面可以看出Bean于Bean之间的依赖关系放在配置文件里组织，而不是写在代码里。通过配置文件的指定，Spring能够精确地为每个Bean注入属性。因此，配置文件里的<code>&lt;bean…/&gt;</code>元素的class属性值不能是接口，而必须是真正的实现类。</p>
<p>Spring会自动接管每个<code>&lt;bean…/&gt;</code>定义里的<code>&lt;property …/&gt;</code>元素定义，Spring会在调用无参数的构造器、创建默认的Bean实例后，调用相应的setter方法为程序注入属性值。<code>&lt;property…/&gt;</code>定义的属性值将不再有该Bean来主动设置、管理，而是接受Spring的注入。</p>
<p>每个Bean的id属性是该Bean的唯一标识，程序通过id属性访问Bean，Bean与Bean的依赖关系也是通过id属性关联。<br>测试程序：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BeanTest &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        //创建Spring容器  </span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        //获取Chinese实例  </span><br><span class="line">        <span class="keyword">Person</span> <span class="keyword">person</span> = ctx.getBean(<span class="string">"chinese"</span>,<span class="keyword">Person</span>.class);  </span><br><span class="line">        <span class="keyword">person</span>.useAxe();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bean与Bean之间的依赖关系有Spring管理，Spring采用setter方法为目标Be阿玛尼注入所依赖的Bean，这种方式被称之为设值注入。</p>
<p>从上面的实例我们可以看出，依赖注入以配置文件管理Bean实例之间的耦合，让Bean实例之间的耦合从代码层次分离出来。</p>
<p>Spring IoC容器有如下3个基本要点：</p>
<ol>
<li>应用程序的各个组件面向接口编程。面向接口编程可以将各个组件的耦合提升到接口层次，从而有利于项目后期的扩展。</li>
<li>应用程序的各组件不再由程序主动产生，而是由Spring容器来负责产生，并初始化。</li>
<li>Spring采用配置文件、或者Annotation来管理Bean的实现类、依赖关系，Spring容器则根据配置文件，利用反射机制来创建时间，并为之注入依赖关系。</li>
</ol>
<h3 id="构造注入">构造注入</h3><p>构造注入就是利用构造器来设置依赖关系的方式。<br>Japanese类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="comment">//默认构造器  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">()</span></span>&#123;  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//构造注入所需的带参数构造器  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">(Axe axe)</span></span>&#123;  </span><br><span class="line">    <span class="keyword">this</span>.axe = axe;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的Chinese类并没有setter方法，仅仅只是提供了一个带Axe属性的构造器，Spring将通过该构造器为Chinese注入所依赖的Bean实例。</p>
<p>构造注入的配置文件需要做一些修改。为了使用构造注入，使用<code>&lt;constructor-arg…/&gt;</code>元素来指定构造器的参数。如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans  </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 配置Chinese实例 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.Chinese"</span>&gt;</span>  </span><br><span class="line">        <span class="comment">&lt;!-- 使用构造注入，为Japanese实例注入SteelAxe实例--&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"stoneAxe"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 配置stoneAxe实例 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"stoneAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.StoneAxe"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的配置文件使用<code>&lt;contructor-arg…/&gt;</code>元素指定了一个构造器参数，该参数类型是Axe，这指定Spring调用Chinese类里带一个Axe参数的构造器来创建chinese实例，因为使用了有参数的构造器创建实例，所以当Bean实例被创建完成后，该Bean的依赖关系也就已经设置完成。</p>
<h3 id="两种注入方式的对比">两种注入方式的对比</h3><p>Spring支持两种依赖注入方式，这两种依赖注入方式并没有好坏之分，只是适合的场景有所不同。<br>设值注入有如下优点：</p>
<ol>
<li>与传统的JavaBean的写法更相似，程序开发人员更加容易理解，接受。通过setter方法设定依赖关系显得更加直观、自然。</li>
<li>对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因此导致性能下降。而设值注入，则可以避免这些问题。</li>
<li>尤其是在某些属性可选的情况下，多参数的构造器更加笨重。<br>但是构造器也有如下优势：</li>
<li>构造注入可以再构造器中决定依赖关系的注入顺序，优先依赖的优先注入。</li>
<li>对于依赖关系无须变化的Bean，构造注入更有用处。因为没有setter方法，所有的依赖关系全部在构造器中设定，因此，无须担心后续的代码对依赖关系产生破坏。</li>
<li>依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更加符合高内聚的原则。</li>
</ol>
<p>通过上面的对比。所以建议用以设值注入为主，构造注入为辅的注入策略。对于依赖关系无须变化的注入，尽量采用构造注入；而其他的依赖关系，则考虑设值注入。</p>
<p>Spring有两个核心接口：BeanFactory和ApplicationContext，其中ApplicationContext是BeanFactory的子接口。他们都可代表Spring容器，Spring容器是生成Bean实例的工厂，并且管理容器中的Bean。Bean是Spring管理的基本单位，在基于Spring的Java EE应用中，所有的组件都被当成Bean处理，包括数据源、Hibernate的SessionFactory、事务管理器等。</p>
<p>而且应用中的所有组件，都处于Spring的管理下，都被Spring以Bean的方式管理，Spring负责创建Bean实例，并管理他们的生命周期。Bean在Spring容器中运行，无须感受Spring容器的存在，一样可以接受Spring的依赖注入，包括Bean属性的注入，协作者的注入、依赖关系的注入等。</p>
<p>Spring容器负责创建Bean实例，所以需要知道每个Bean的实现类，Java程序面向接口编程，无须关心Bean实例的实现类；但是Spring容器必须能够精确知道每个Bean实例的实现类，因此Spring配置文件必须精确配置Bean实例的实现类。</p>
<h2 id="Spring容器">Spring容器</h2><p>Spring容器最基本的接口就是BeanFactor。BeanFactory负责配置、创建、管理Bean，他有一个子接口：ApplicationContext，因此也称之为Spring上下文。Spring容器负责管理Bean与Bean之间的依赖关系。</p>
<p>BeanFactory接口包含以下几个基本方法：</p>
<ul>
<li><code>Boolean containBean(String name)</code>:判断Spring容器是否包含id为name的Bean实例。</li>
<li><code>&lt;T&gt; getBean(Class&lt;T&gt; requiredTypr)</code>:获取Spring容器中属于requiredType类型的唯一的Bean实例。</li>
<li><code>Object getBean(String name)</code>：返回Sprin容器中id为name的Bean实例。</li>
<li><code>&lt;T&gt; T getBean(String name,Class requiredType)</code>：返回容器中id为name,并且类型为requiredType的Bean</li>
<li><code>Class &lt;?&gt; getType(String name)</code>：返回容器中指定Bean实例的类型。</li>
</ul>
<p>在使用BeanFactory接口时，我们一般都是使用这个实现类：org.springframework.beans.factory.xml.XmlBeanFactory。然而ApplicationContext作为BeanFactory的子接口，使用它作为Spring容器会更加方便。它的实现类有：FileSystemXmlApplicationContext、ClassPathXmlApplicationContext、AnnotationConfigApplicationContext。</p>
<p>创建Spring容器实例时，必须提供Spring容器管理的Bean的详细配置信息。Spring的配置信息通常采用xml配置文件来设置，因此，创建BeanFactory实例时，应该提供XML配置文件作为参数。</p>
<p>XML配置文件通常使用Resource对象传入。Resource接口是Spring提供的资源访问接口，通过使用该接口，Spring能够以简单、透明的方式访问磁盘、类路径以及网络上的资源。</p>
<p>对于Java EE应用而言，可在启动Web应用时自动加载ApplicationContext实例，接受Spring管理的Bean无须知道ApplicationContext的存在。一般使用如下方式实例化BeanFactory</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索当前文件路径下的bean.xml文件创建Resource对象  </span></span><br><span class="line">InputStreamSource isr = <span class="keyword">new</span> FileSystemResource(<span class="string">"bean.xml"</span>);  </span><br><span class="line"><span class="comment">//以Resource对象作为参数创建BeanFactory实例  </span></span><br><span class="line">XmlBeanFactory <span class="literal">factory</span> = <span class="keyword">new</span> XmlBeanFactory((Resource) isr);</span><br></pre></td></tr></table></figure>
<p>//搜索当前文件路径下的bean.xml文件创建Resource对象  </p>
<p>或<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource res = <span class="keyword">new</span> ClassPathResource(<span class="string">"bean.xml"</span>);  </span><br><span class="line"><span class="comment">//以Resource对象作为参数创建BeanFactory实例  </span></span><br><span class="line">XmlBeanFactory <span class="literal">factory</span> = <span class="keyword">new</span> XmlBeanFactory(res);</span><br></pre></td></tr></table></figure></p>
<p>但是如果应用里面有多个属性配置文件，则应该采用BeanFactory的子接口ApplicationContext来创建BeanFactory的实例。ApplicationContext通常使用如下两个实现类：</p>
<ul>
<li>FileSystemXmlApplicationContext：以基于文件系统的XML配置文件创建ApplicationContext实例。</li>
<li>ClassPathXmlApplicationContext：以类加载路径下的XML配置文件创建的ApplicationContext实例。<br>如果需要同时加载多个XML配置文件，采用如下方式：</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索CLASSPATH路径，以classpath路径下的bean.xml、service.xml文件创建applicationContext  </span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> <span class="built_in">String</span>[]&#123;<span class="string">"bean.xml"</span>,<span class="string">"service.xml"</span>&#125;);  </span><br><span class="line"></span><br><span class="line"><span class="comment">//以指定路径下的bean.xml、service.xml文件创建applicationContext  </span></span><br><span class="line">ApplicationContext ctx1 = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="keyword">new</span> <span class="built_in">String</span>[]&#123;<span class="string">"bean.xml"</span>,<span class="string">"service.xml"</span>&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="使用ApplicationContext">使用ApplicationContext</h3><p>ApplicationContext允许以声明式方式操作容器，无须手动创建它。在Web应用启动时自动创建ApplicationContext。当然，也可以采用编程方式创建ApplicationContext。</p>
<p>除了提供BeanFactory所支持的全部功能外，ApplicationContext还有如下功能：</p>
<ol>
<li>ApplicationContext继承MessageSource接口，因此提供国际化支持。</li>
<li>资源访问。</li>
<li>事件机制。</li>
<li>载入多个配置文件。</li>
<li>以声明式的方式启动，并创建Spring容器。</li>
</ol>
<p>当系统创建ApplicationContext容器时，默认会预初始化所有的singleton Bean。也就是说，当ApplicationContext容器初始化完成后，容器中所有singleton Bean也实例化完成，这就意味着：系统前期创建ApplicationContext时将有较大的系统开销，但一旦ApplicationContext初始化完成，程序后面获取singleton Bean实例时将拥有较好的性能。</p>
<h3 id="ApplicationContext的国际化支持">ApplicationContext的国际化支持</h3><p>ApplicationContext接口继承MessageSource接口，因此具备国际化功能。MessageSource接口中定义了三个方法用于国际化功能。</p>
<ul>
<li><code>String getMessage(Stringcode,Object[] args,Locale loc);</code></li>
<li><code>StringgetMessage(String code,Object[] args,String default,Locale loc);</code></li>
<li><code>StringgetMessage(MessageSourceResolvable resolvable,Local loc);</code></li>
</ul>
<p>ApplicationContext正是通过这三个方法来实现国际化的。当程序创建ApplicationContext容器时，Spring会自动查找在配置文件中名为messageSource的bean实例，一旦找到这个Bean实例，上述三个方法的调用被委托给该MessageSource Bean。如果没有该Bean，ApplicationContext会查找其父定义中的messagesource Bean，如果找到，它会作为messageSource Bean使用。但是如果无法找到messageSource，系统将会创建一个空的staticMessageSource Bean，该Bean的能接受上述三个方法的调用。</p>
<p>在Spring中配置messagesourceBean时通常使用ResourceBundleMessageSource.如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans  </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"messsageSource"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"basenames"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">list</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>messagevalue&gt;  </span><br><span class="line">    <span class="comment">&lt;!--如果有多个资源文件，全部列在此处--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">list</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>message.properties:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">hello=<span class="value">欢迎你:&#123;<span class="number">0</span>&#125;</span></span></span><br><span class="line"><span class="setting">now=<span class="value">现在时间是:&#123;<span class="number">0</span>&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>配置文件中包含非西欧文字需要使用native2ascii工具<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">native2ascii</span> <span class="tag">message</span><span class="class">.properties</span> <span class="tag">message_zh_CN</span><span class="class">.properties</span></span><br></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line"><span class="built_in">String</span>[] a =&#123;<span class="string">"howie"</span>&#125;;</span><br><span class="line"><span class="built_in">String</span> hello = ctx.getMessage(<span class="string">"hello"</span>,a, Locale.getDefault());</span><br><span class="line"><span class="built_in">Object</span>[] b = &#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line"><span class="built_in">String</span> now = ctx.getMessage(<span class="string">"now"</span>,b,Locale.getDefault());</span><br></pre></td></tr></table></figure></p>
<h3 id="ApplicationContext的事件机制">ApplicationContext的事件机制</h3><p>ApplicationContext的事件机制是观察者设计模式的实现，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext的事件处理。</p>
<p>Spring的事件框架有如下两个重要成员：</p>
<ol>
<li>ApplicationEvent：容器事件，必须由ApplicationContext发布。</li>
<li>ApplicationListener：监听器，可由容器中的任何监听器Bean担任。</li>
</ol>
<p>Spring的事件机制需要事件源、事件和事件监听器组成。只是此处的事件是ApplicationContext，且事件必须由java程序显示触发。下图简单示范了ApplicationContext的事件流程。</p>
<p>下面实例展示了Spring容器的事件机制。</p>
<ol>
<li><p>定义一个ApplicationEvent类，其对象就是Spring容器事件。</p>
 <figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class EmailEvent extends ApplicationEvent &#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> address;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> <span class="built_in">text</span>;  </span><br><span class="line">    <span class="comment">// 定义一个带参的构造函数  </span></span><br><span class="line">    <span class="keyword">public</span> EmailEvent(<span class="keyword">Object</span> source) &#123;  </span><br><span class="line">        <span class="keyword">super</span>(source);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">public</span> EmailEvent(<span class="keyword">Object</span> source, <span class="keyword">String</span> address, <span class="keyword">String</span> <span class="built_in">text</span>) &#123;  </span><br><span class="line">        <span class="keyword">super</span>(source);  </span><br><span class="line">        <span class="keyword">this</span>.address = address;  </span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">text</span> = <span class="built_in">text</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//address、text的setter和getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 容器事件的监听器类必须实现ApplicationListener接口，它的实现方法如下：<br> onAPplicationEvent(ApplicationEventevent):每当容器内发生任何事件时，此方法都会被触发。</p>
</li>
<li><p>编写该容器的监听器类。</p>
 <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EmailNotifier</span> <span class="title">implements</span> <span class="title">ApplicationListener</span>&#123;  </span><br><span class="line">    <span class="comment">//该方法会在容器发生事件时触发  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span>(<span class="params">ApplicationEvent <span class="keyword">event</span></span>) </span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">event</span> instanceof EmailEvent)&#123;  </span><br><span class="line">            <span class="comment">//只处理EmailEvent，发送email通知  </span></span><br><span class="line">            EmailEvent emailEvent = (EmailEvent) <span class="keyword">event</span>;  </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"需要发送邮件的接收地址为:"</span>+emailEvent.getAddress());  </span><br><span class="line">                </span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"需要发送邮件的邮件正文是:"</span>+emailEvent.getText());  </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//容器内置事件不作任何处理  </span></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"容器本身的事件:"</span>+<span class="keyword">event</span>);  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将监听器类配置在容器中。</p>
<p> 在为Spring容器注册监听器时，我们只需在Spring配置文件中配置一个实现了ApplicationListener的Bean即可，Spring容器会把这个Bean当做容器事件的监听器。 </p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans  </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 配置监听器 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.app.listener.EmailNotifier"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过上面的3个步骤就可以实现Spring容器的事件了。当系统创建Spring容器，加载Spring容器时会自动触发容器事件，容器事件监听器可以监听到这些事件。同时我们也可以调用ApplicationContext的pulishEvent()方法来主动触发容器事件。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpringTest</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="comment">//创建一个ApplicationEvent对象  </span></span><br><span class="line">        EmailEvent emailEvent = <span class="keyword">new</span> EmailEvent(<span class="string">"hello"</span>,<span class="string">"spring_test@163.com"</span>,<span class="string">"this is a test"</span>);  </span><br><span class="line">        <span class="comment">//主动触发容器事件  </span></span><br><span class="line">        ctx.publishEvent(emailEvent);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果Bean想发布事件，则Bean必须获得其容器的引用。如果程序中没有直接获取容器的引用，则应该让Bean实现ApplicationContextAware或BeanFactoryAware接口，从而获得容器的引用。</p>
<p>除了我们可以自己实现Spring容器的事件外，Spring也提供了几个内置事件：</p>
<ol>
<li>ContextRefreshedEvent：ApplicationContext容器初始化或者刷新时触发该事件。</li>
<li>ContextStartedEvent：当使用ConfigurableApplicationContext接口的start()方法启动ApplicationContext容器时触发该事件。</li>
<li>ContextClosedEvent：当使用ConfigurableApplicationContext接口的close()方法关闭ApplicationContext容器时触发该事件。</li>
<li>ContextStopedEvent: 当使用ConfigurableApplicationContext接口的stop()方法停止ApplicationContext容器时触发该事件。</li>
</ol>
<h3 id="让Bean获取Spring容器">让Bean获取Spring容器</h3><p>在Spring中我们可以使用Spring容器中getBean()方法来获取Spring容器中的Bean实例。在这样的访问模式下，程序中总是持有Spring容器的引用。但是在实际的应用中，Spring容器通常是采用声明式方式配置产生：即开发者只要在web.xml文件中配置一个Listener，该Listener将会负责初始化Spring容器。在这种情况下，容器中Bean处于容器管理下，无须主动访问容器，只需要接受容器的注入管理即可。同时Bean实例的依赖关系通常也是由容器动态注入，无须Bean实例主动请求。</p>
<p>在这种情况下，Sprig容器中Bean通常不会需要访问容器中其他的Bean—采用依赖注入，让Spring把被依赖的Bean注入到依赖的Bean中即可。</p>
<p>实现BeanFactoryAware接口的Bean，拥有访问的BeanFactory容器的能力，实现BeanFactoryAware接口的Bean实例将会拥有对容器的访问能力。BeanFactoryAware接口仅有如下一个方法：</p>
<p>SetBeanFactory(BeanFactory beanFactory)：该方法有一个参数beanFactory，该参数指向创建它的BeanFactory。</p>
<p>该方法将由Spring调动，当Spring调用该方法时会将Spring容器作为参数传入该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span>&#123;  </span><br><span class="line">    <span class="comment">//将BeanFactory容器以成员变量保存  </span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ctx;  </span><br><span class="line">    <span class="comment">/** </span><br><span class="line">    * 实现ApplicationContextAware接口实现的方法 </span><br><span class="line">    */</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext cyx)</span>  <span class="keyword">throws</span> BeansException </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//获取ApplicationContext的测试方法  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationContext <span class="title">getContext</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> ctx;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的Chinese类实现了ApplicationContext接口，并实现了该接口提供的setApplicationContextAware()方法，这就使得该Bean实例可以直接访问到创建她的Spring容器。<br>将该Bean部署在Spring容器中。<br>测试类：<br>该程序先通过实例化的方法来获取ApplicationContext，然后通过chinese Bean来获得BeanFactory，并将两者进行比较。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChineseTest</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        Chinese c = ctx.getBean(<span class="string">"chinese"</span>,Chinese.class);  </span><br><span class="line">        System.<span class="keyword">out</span>.println(c.getContext());  </span><br><span class="line">        System.<span class="keyword">out</span>.println(c.getContext()==ctx);  </span><br><span class="line"></span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//结果如下：</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>上面的代码虽然实现了ApplicationContextAware接口让Bean拥有了访问容器的能力，但是污染了代码，导致代码与Spring接口耦合在一起。所以，如果不是特别需要，一般不建议直接访问容器。</p>
<h2 id="Spring容器中的Bean">Spring容器中的Bean</h2><p>从前面我们知道Spring其实就是一个大型的工厂，而Spring容器中的Bean就是该工厂的产品.对于Spring容器能够生产那些产品，则取决于配置文件中配置。</p>
<p>对于我们而言，我们使用Spring框架所做的就是两件事：开发Bean、配置Bean。对于Spring框架来说，它要做的就是根据配置文件来创建Bean实例，并调用Bean实例的方法完成“依赖注入”。</p>
<h3 id="Bean的基本定义">Bean的基本定义</h3><p>beans元素可以有以下属性，bean元素可以有没有default-前缀的属性，beans属性是全局的。</p>
<ul>
<li>default-lazy-init ：延迟初始化</li>
<li>default-merge：merge行为</li>
<li>default-autowire：自动装配行为</li>
<li>default-autowire-candidates：自动装配候选bean</li>
<li>default-init-method：初始化方法</li>
<li>default-destroy-method：回收方法</li>
</ul>
<p><code>&lt;beans…/&gt;</code>元素是Spring配置文件的根元素，<code>&lt;bean…/&gt;</code>元素师<code>&lt;beans../&gt;</code>元素的子元素，<code>&lt;beans…/&gt;</code>元素可以包含多个<code>&lt;bean…/&gt;</code>子元素，每个<code>&lt;bean…/&gt;</code>元素可以定义一个Bean实例，每一个Bean对应Spring容器里的一个Java实例定义Bean时通常需要指定两个属性。</p>
<ul>
<li>id：确定该Bean的唯一标识符，容器对Bean管理、访问、以及该Bean的依赖关系，都通过该属性完成。Bean的id属性在Spring容器中是唯一的。    </li>
<li>class：指定该Bean的具体实现类。注意这里不能是接口。通常情况下，Spring会直接使用new关键字创建该Bean的实例，因此，这里必须提供Bean实现类的类名。</li>
</ul>
<p>下面是定义一个Bean的简单配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义第一个Bean实例：bean1 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bean1"</span> <span class="attribute">class</span>=<span class="value">"com.Bean1"</span> /&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 定义第二个Bean实例：bean2 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bean2"</span> <span class="attribute">class</span>=<span class="value">"com.Bean2"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当我们在配置文件中通过<code>&lt;bean id=”xxx” class=”x.xxxClass”/&gt;</code>方法配置一个Bean时，这样就需要该Bean实现类中必须有一个无参构造器。故Spring底层相当于调用了如下代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx = new x.<span class="function"><span class="title">xxxClass</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果在配置文件中通过构造注入来创建Bean：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bean1"</span> <span class="attribute">class</span>=<span class="value">"com.Bean1"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"chenssy"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"35-354"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>则Spring相当于调用如下代码：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Bean </span><span class="keyword">bean </span>= new com.Test(<span class="string">"chenssy"</span>,<span class="string">"35-354"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>除了可以为<code>&lt;bean…/&gt;</code>元素指定一个id属性外，还可以为<code>&lt;bean…/&gt;</code>元素指定name属性，用于为Bean实例指定别名。如果需要为Bean实例指定多个别名，可以在name属性中使用逗号、冒号或者空格来分隔多个别名，后面通过任一别名即可访问该Bean实例。但是在一些特殊的情况下，程序无法在定义Bean时就指定所有的别名，而是在其他地方为一个已经存在的Bean实例指定别名，则可以使用<code>&lt;alias…/&gt;</code>元素来完成，该元素有如下两个属性：</p>
<ul>
<li>name：该属性指定一个Bean实例的标识名，表示将会为该Bean指定别名。</li>
<li>alias：指定一个别名.<br>如：</li>
</ul>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">alias</span> <span class="title">name</span>=”bean1” <span class="keyword">alias</span>=”name1”/&gt;  </span><br><span class="line">&lt;<span class="keyword">alias</span> <span class="title">name</span>=”bean2” <span class="keyword">alias</span>=”name2”/&gt;</span><br></pre></td></tr></table></figure>
<p>在默认情况下，当Spring创建ApplicationContext容器时，Spring会自动预初始化容器中所有的singleton实例，如果我们想让Spring容器预初始化某个singleton Bean，则可以为该<code>&lt;bean…/&gt;</code>元素增加lazy-init属性，该属性用于指定该Bean实例的预初始化，如果设置为true，则Spring不会预初始化该Bean实例。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=”<span class="keyword">person</span>” class=”com.<span class="keyword">Person</span>” lazy-init=”true”/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="容器中Bean的作用域">容器中Bean的作用域</h3><p>当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持5种作用域：</p>
<ul>
<li>singleton：单例模式。在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例。</li>
<li>prototype：原型模式。每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例。</li>
<li>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新的实例，即每次HTTP请求都会产生不同的Bean实例。当然只有在WEB应用中使用Spring时，该作用域才真正有效。</li>
<li>session：对于每次HTTPSession，使用session定义的Bean都将产生一个新的实例时，即每次HTTP Session都将产生不同的Bean实例。同HTTP一样，只有在WEB应用才会有效。</li>
<li>global session：每个全局的HTTPSession对应一个Bean实例。仅在portlet Context的时候才有效。</li>
</ul>
<p>比较常用的singleton和prototype。如果一个Bean实例被设置为singleton，那么每次请求该Bean时都会获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为。如果一个Bean实例被设置为prototype，那么每次请求该id的Bean，Spring都会创建一个新的Bean实例返回给程序，在这种情况下，Spring容器仅仅使用new关键字创建Bean实例，一旦创建成功，容器将不会再跟踪实例，也不会维护Bean实例的状态。Spring默认使用singleton作用域。prototype作用域Bean的创建、销毁代价会比较大。除非必要，否则尽量避免将Bean的作用域设置为prototype。</p>
<p>设置Bean的作用域是通过scope属性来指定。可以接受Singleton、prototype、request、session、global session 5个值。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置一个singleton Bean实例：默认 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bean1"</span> <span class="attribute">class</span>=<span class="value">"com.Bean1"</span> /&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 配置一个prototype Bean实例 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bean2"</span> <span class="attribute">class</span>=<span class="value">"com.Bean2"</span> <span class="attribute">scope</span>=<span class="value">"prototype"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>测试代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpringTest</span> &#123;  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="comment">//判断两次请求singleton作用域的Bean实例是否相等  </span></span><br><span class="line">        System.<span class="keyword">out</span>.println(ctx.getBean(<span class="string">"bean1"</span>)==ctx.getBean(<span class="string">"bean1"</span>));  </span><br><span class="line">        <span class="comment">//判断两次请求prototype作用域的Bean实例是否相等  </span></span><br><span class="line">        System.<span class="keyword">out</span>.println(ctx.getBean(<span class="string">"bean2"</span>)==ctx.getBean(<span class="string">"bean2"</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//程序运行结果如下</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>
<p>request和session作用域只在web应用中才会有效，并且必须在Web应用中增加额外配置才会生效。为了能够让request和session两个作用域生效，必须将HTTP请求对象绑定到位该请求提供的服务线程上，这使得具有request和session作用的Bean实例能够在后面的调用链中被访问到。</p>
<p>因此我们可以采用两种配置方式：采用Listener配置或者采用Filter配置，在web.xml中。<br>Listener配置：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;  </span><br><span class="line">&lt;listener-class&gt;  </span><br><span class="line">org<span class="class">.springframework</span><span class="class">.web</span><span class="class">.context</span><span class="class">.request</span><span class="class">.RequestContextListener</span>  </span><br><span class="line">&lt;/listener-class&gt;  </span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure></p>
<p>Filter配置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="attribute">filter</span>&gt;  </span><br><span class="line">&lt;<span class="attribute">filter</span>-name&gt;requestContextFilter&lt;/<span class="attribute">filter</span>-name&gt;  </span><br><span class="line">&lt;<span class="attribute">filter</span>-class&gt;org<span class="class">.springframework</span><span class="class">.web</span><span class="class">.filter</span><span class="class">.RequestContextFilter</span>&lt;/<span class="attribute">filter</span>-class&gt;  </span><br><span class="line">&lt;/<span class="attribute">filter</span>&gt;  </span><br><span class="line">&lt;<span class="attribute">filter</span>-mapping&gt;  </span><br><span class="line">&lt;<span class="attribute">filter</span>-name&gt;requestContextFilter&lt;/<span class="attribute">filter</span>-name&gt;  </span><br><span class="line">&lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;  </span><br><span class="line">&lt;/filter-mapping&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>一旦在web.xml中增加上面两种配置中的一种，程序就可以在Spring配置文件中使用request或者session作用域了。如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定使用request作用域 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"p"</span> <span class="attribute">class</span>=<span class="value">"com.app.Person"</span> <span class="attribute">scope</span>=<span class="value">"request"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的配置文件配置了一个实现类Person的Bean，指定它的作用域为request。这样Spring容器会为每次的HttP请求生成一个Person的实例，当该请求响应结束时，该实例也会被注销。</p>
<h3 id="配置依赖">配置依赖</h3><p>在一般情况下，我是不应该在配置文件中管理普通属性的引用，通常只是用配置文件管理容器中的Bean实例的依赖关系。</p>
<p>Spring在实例化容器时，会校验BeanFactory中每一个Bean的配置。这些校验包括：</p>
<ul>
<li>Bean引用的依赖Bean是否指向一个合法的Bean。</li>
<li>Bean的普通属性值是否获得一个有效值。</li>
</ul>
<p>对于singleton作用域的Bean，如果没有强行取消其预初始化的行为，系统会在创建Spring容器时预初始化所用singleton Bean，与此同时，该Bean所依赖的Bean也被一起实例化。</p>
<p>BeanFactory与ApplicationContext实例化容器中的Bean的时机也是不同的：BeanFactory等到程序需要Bean实例时才创建Bean，而ApplicationContext是在创建ApplicationContext实例时，会预初始化容器中的全部Bean。</p>
<p>ApplicationContext实例化过程比BeanFactory实例化过程的时间和内存开销大，但是一旦创建成功，应用后面的响应速度会非常快，同时可以检验出配置错误，故一般都是推荐使用ApplicationContext作为Spring容器。</p>
<p>其实我们可以指定lazy-int=”true”来强制取消singleton作用域的Bean的预初始。这样该Bean就不会随着ApplicationContext启动而预实例化了。</p>
<p>Spring可以为任何java对象注入任何类型的属性，只要改java对象为该属性提供了对应的setter方法即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"person"</span> <span class="attribute">class</span>=<span class="value">"lee.Person"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- Property配置需要依赖注入的属性 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"chenming"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span> <span class="attribute">value</span>=<span class="value">"22"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring会为<code>&lt;bean…/&gt;</code>元素创建一个java对象，一个这样的java对象对应一个Bean实例，对于如上代码，Spring会采用如下形式来创建Java实例。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取lee.<span class="keyword">Person</span>类的Class对象  </span><br><span class="line">Class  personClass = Class.forName(<span class="string">"lee.Person"</span>);  </span><br><span class="line">//创建lee.<span class="keyword">Person</span>类的默认实例  </span><br><span class="line">Object personBean = personBean.newInStance();</span><br></pre></td></tr></table></figure>
<p>创建该实例后，Spring就会遍历该<code>&lt;bean../&gt;</code>元素的所有<code>&lt;property…/&gt;</code>子元素。<code>&lt;bean…/&gt;</code>元素每包含一个<code>&lt;property…/&gt;</code>子元素，Spring就会为该Bean实例调用一次setter方法。类似于下面程序：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取name属性的setter方法  </span><br><span class="line">String setName = <span class="string">"set"</span>+<span class="string">"Name"</span>;  </span><br><span class="line">//获取lee.<span class="keyword">Person</span>类里面的Set()Name方法  </span><br><span class="line">java.lang.reflect.Method setMethod = personClass.getMethod(setName, aVal.getClass());  </span><br><span class="line">//调用Bean实例的SetName()方法  </span><br><span class="line">setMethod.invoke(personBean, aVal);</span><br></pre></td></tr></table></figure>
<p>对于使用<code>&lt;constructor-arg…/&gt;</code>元素来指定构造器注入，Spring不会采用默认的构造器来创建Bean实例，而是使用特定的构造器来创建该Bean实例。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"person"</span> <span class="variable">class=</span><span class="string">"lee.Person"</span>&gt;  </span><br><span class="line">&lt;constructor-arg <span class="variable">index=</span><span class="string">"0"</span> <span class="variable">value=</span><span class="string">"aVal"</span> /&gt;  </span><br><span class="line">&lt;constructor-arg <span class="variable">index=</span><span class="string">"1"</span> <span class="variable">value=</span><span class="string">"bVal"</span> /&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>针对上面的代码，Spring会采用类似如下的代码来创建Bean实例：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取lee.<span class="keyword">Person</span>类的class对象  </span><br><span class="line">Class  personClass = Class.forName(<span class="string">"lee.Person"</span>);  </span><br><span class="line">//获取第一个参数是aVal类型，第二个参数是bVal类型的构造器  </span><br><span class="line">Constructor personCtr = personClass.getConstructor(aVal.getClass(),bVal.getClass());  </span><br><span class="line">//以指定构造器创建Bean实例  </span><br><span class="line">Object bean = personCtr.newInstance(aVal,bVal);</span><br></pre></td></tr></table></figure></p>
<p>上面的程序只是一个实例，实际上Spring还需要根据<code>&lt;property…/&gt;</code>元素、<code>&lt;contructor-arg../&gt;</code>元素所使用value属性，ref属性等来判断需要注入的到底是什么数据类型，并要对这些值进行合适的类型转换，所以Spring的实际处理过程会更加复杂。</p>
<p>Java实例的属性值可以有很多种数据类型、基本类型值、字符串类型、java实例甚至其他的Bean实例、java集合、数组等。所以Spring允许通过如下几个元素为Bean实例的属性指定值：</p>
<ul>
<li>value</li>
<li>ref</li>
<li>bean</li>
<li>list、set、map、props</li>
</ul>
<h3 id="设置普通属性值">设置普通属性值</h3><p>value属性用于指定字符串类型、基本类型的属性值。Spring使用XML解析器来解析出这些数据，然后利用java.beans.PropertyEdior完成类型转换：从java.lang.String类型转换为所需的参数值类型。如果目标类型是基本数据类型，通常都是可以正确转换。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTest</span> </span>&#123;  </span><br><span class="line"><span class="comment">//定义一个String型属性  </span></span><br><span class="line"><span class="keyword">private</span> String name;  </span><br><span class="line"><span class="comment">//定义一个int型属性  </span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;  </span><br><span class="line"><span class="comment">// name 、age的getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面实例只是演示了注入普通属性值。在Spring配置文件中使用value属性来为这两个属性指定属性值。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="property">id</span>=<span class="string">"text"</span> <span class="type">class</span>=<span class="string">"com.spring.service.impl.ValueTest"</span>&gt;  </span><br><span class="line">&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"age"</span> value=<span class="string">"1"</span> /&gt;  </span><br><span class="line">&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"name"</span> value=<span class="string">"chenssy"</span> /&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="配置合作者">配置合作者</h3><p>如果我们需要为Bean设置属性值是另一个Bean实例时，这个时候需要使用ref属性。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.spring.service.impl.SteelAce"</span>&gt;&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.spring.service.impl.Chinese"</span> &gt;  </span><br><span class="line">&lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span> /&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>早期Spring版本使用ref元素，ref元素可以指定如下两个属性。<br>bean:引用不在同一份XML配置文件中的其他Bean实例的id属性值。<br>local：引用同一份XML配置文件中的其他Bean实例的id属性值。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.spring.service.impl.SteelAce"</span>&gt;&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.spring.service.impl.Chinese"</span> &gt;  </span><br><span class="line">&lt;property name=<span class="string">"axe"</span>&gt;  </span><br><span class="line">&lt;<span class="keyword">ref</span> local=<span class="string">"steelAxe"</span>/&gt;  </span><br><span class="line">&lt;/property&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用自动装配注入合作者bean">使用自动装配注入合作者bean</h3><p>Spring支持自动装配Bean与Bean之间的依赖关系，也就是说我们无需显示的指定依赖Bean。由BeanFactory检查XML配置文件内容，根据某种规则，为主调Bean注入依赖关系。</p>
<p>Spring的自动装配机制可以通过<code>&lt;bean.../&gt;</code>元素的default-autowire属性指定，也可以通过<code>&lt;bean.../&gt;</code>元素的autowire属性指定。</p>
<p>自动装配可以减少配置文件的工作量，但是它降低了依赖关系的透明性和清晰性，所以一般来说在较大部署环境中不推荐使用，显示配置合作者能够得到更加清晰的依赖关系。Spring提供了如下几种规则来实现自动装配。</p>
<ul>
<li>no:不适用自动装配。Bean依赖必须通过ref元素定义。</li>
<li>byName：根据属性名自动装配。BeanFactory查找容器中的全部Bean，找出其中id属性与属性同名的Bean来完成注入。如果没有找到匹配的Bean实例，则Spring不会进行任何注入。</li>
<li>byType：根据属性类型自动装配。BeanFactory查找容器中的全部Bean，如果正好有一个与依赖属性类型相同的Bean，就自动注入这个属性；但是如果有多个这样的Bean，就会抛出一个异常。如果没有匹配的Bean，则什么都不会发生，属性就不会被设置。如果需要无法自动装配时抛出异常，则设置dependency-check=”objects”。</li>
<li>constructor:与不Type类似，区别是用于构造注入的参数。</li>
<li>autodetect:BeanFactory根据Bean内部结构，决定使用constructor或者byType。如果找到一个默认的构造函数，则使用byType。</li>
</ul>
<h4 id="byName规则">byName规则</h4><p>byName规则是指通过名字注入依赖关系，假如Bean A的实现类里面包含setB()方法，而Spring的配置文件恰好包含一个id为b的Bean，则Spring容器就会将b实例注入Bean A中。如果容器中没有名字匹配的Bean，Spring则不会做任何事情。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"chinese"</span> <span class="variable">class=</span><span class="string">"com.spring.service.impl.Chinese"</span> <span class="variable">autowire=</span><span class="string">"byName"</span> /&gt;  </span><br><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"gundog"</span> <span class="variable">class=</span><span class="string">"com.spring.service.impl.Gundog"</span>&gt;  </span><br><span class="line">&lt;property <span class="variable">name=</span><span class="string">"name"</span> <span class="variable">value=</span><span class="string">"wangwang"</span> /&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>上面的配置文件指定了byName规则。则com.app.service.impl.Chinese类中提供如下的依赖注入方法：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span> </span><br><span class="line"><span class="keyword">*</span> 依赖关系必须的setter方法，因为需要通过名字自动装配 </span><br><span class="line"><span class="keyword">*</span> 所以setter方法必须提供set+Bean名，Bean名的首字母大写 </span><br><span class="line"><span class="keyword">*</span> <span class="comment">@param dog 设置的dog值 </span></span><br><span class="line"><span class="keyword">*</span>/  </span><br><span class="line">public void setGundog(Dog dog)&#123;  </span><br><span class="line">    this.dog = dog;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="byType规则">byType规则</h4><p>byType规则是根据类型匹配注入依赖关系。假如A实例有setB(B b)方法，而Spring配置文件中恰好有一个类型B的Bean实例，容器为A注入类型匹配的Bean实例。如果容器中存在多个B的实例，则会抛出异常，如果没有B实例，则不会发生任何事情。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"chinese"</span> <span class="variable">class=</span><span class="string">"com.spring.service.impl.Chinese"</span> <span class="variable">autowire=</span><span class="string">"byType"</span> /&gt;  </span><br><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"gundog"</span> <span class="variable">class=</span><span class="string">"com.spring.service.impl.Gundog"</span>&gt;  </span><br><span class="line">&lt;property <span class="variable">name=</span><span class="string">"name"</span> <span class="variable">value=</span><span class="string">"wangwang"</span> /&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>针对上面的配置文件Chinese类有如下方法。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span>  </span><br><span class="line"><span class="keyword">*</span> 依赖关系必须的setter方法  </span><br><span class="line"><span class="keyword">*</span> 因为使用按类型自动装配，setter方法的参数类型与容器的Bean的类型相同  </span><br><span class="line"><span class="keyword">*</span> 程序中的Gundog实现了Dog接口  </span><br><span class="line"><span class="keyword">*</span> <span class="comment">@param dog传入的dog对象  </span></span><br><span class="line"><span class="keyword">*</span>/  </span><br><span class="line">public void setDog(Dog dog)&#123;  </span><br><span class="line">    this.dog = dog;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当一个Bean即使用自动装配依赖，又使用ref显示依赖时，则显示指定的依赖就会覆盖自动装配。</p>
<p>在默认的情况下，Spring会自动搜索容器中的全部Bean，并对这些Bean进行判断，判断他们是否满足自动装配的条件，如果满足就会将该Bean注入目标Bean实例中。如果我们不想让Spring搜索容器中的全部Bean，也就是说，我们需要Spring来判断哪些Bean需要搜索，哪些Bean不需要搜索，这个时候就需要用到autowire-candidate属性。通过为<code>&lt;bean.../&gt;</code>元素设置autowire-candidate=”false”，即可将该Bean限制在自动装配范围之外，容器在查找自动装配对象时将不考虑该Bean。</p>
<h3 id="注入嵌套Bean">注入嵌套Bean</h3><p>如果某个Bean所依赖的Bean不想被Spring容器直接访问，则可以使用嵌套Bean。<code>&lt;bean.../&gt;</code>元素用来定义嵌套Bean，嵌套Bean只对嵌套它的外部Bean有效，Spring容器无法直接访问嵌套Bean，因此在定义嵌套Bean时是无需指定id属性的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.Chinese"</span> <span class="attribute">autowire</span>=<span class="value">"byName"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"axe"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!--   </span><br><span class="line">属性值为嵌套Bean，嵌套Bean不能由Spring容器直接访问，  </span><br><span class="line">所以嵌套Bean是不需要id属性  </span><br><span class="line">--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.SteelAce"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>采用上面的配置可以保证嵌套Bean不能被容器访问，因此不用担心其他程序修改嵌套bean。但是嵌套Bean限制了Bean的访问，提高了程序的内聚性。</p>
<h3 id="list、set、map、props">list、set、map、props</h3><p><code>&lt;list.../&gt;</code>、<code>&lt;set.../&gt;</code>、<code>&lt;map.../&gt;</code>和<code>&lt;props.../&gt;</code>元素分别用来设置类型list、set、map和Properties的集合属性值。<br>先看下面java类：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Chinese implements Person&#123;  </span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是一系列的集合属性  </span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">List</span><span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span> schools;  </span><br><span class="line"><span class="keyword">private</span> <span class="built_in">Map</span> scores;  </span><br><span class="line"><span class="keyword">private</span> <span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, Axe<span class="subst">&gt;</span> phaseAxes;  </span><br><span class="line"><span class="keyword">private</span> Properties health;  </span><br><span class="line"><span class="keyword">private</span> <span class="built_in">Set</span> axe;  </span><br><span class="line"><span class="keyword">private</span> <span class="built_in">String</span><span class="preprocessor">[</span><span class="preprocessor">]</span><span class="markup"> books;  </span><br><span class="line">//setter 和getter方法</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的java代码中有数组、list、set、，map、Properties。下面是针对上面的配置文件。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans  </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 定义一个普通的Axe Bean --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"steelAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.SteelAxe"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"stoneAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.StoneAxe"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义Chinese Bean --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.Chinese"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"schools"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">list</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>小学<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>中学<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>大学<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">list</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"scores"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">map</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"语文"</span> <span class="attribute">value</span>=<span class="value">"88"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"数学"</span> <span class="attribute">value</span>=<span class="value">"87"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"外语"</span> <span class="attribute">value</span>=<span class="value">"88"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">map</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"phaseAxes"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">map</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"原始社会"</span> <span class="attribute">value-ref</span>=<span class="value">"stoneAxe"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"农业社会"</span> <span class="attribute">value-ref</span>=<span class="value">"steelAxe"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">map</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"health"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">props</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"血压"</span>&gt;</span>正常<span class="tag">&lt;/<span class="title">prop</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"身高"</span>&gt;</span>175<span class="tag">&lt;/<span class="title">prop</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">props</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"axe"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">set</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>普通字符串<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.SteelAxe"</span>&gt;</span><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">local</span>=<span class="value">"stoneAxe"</span>/&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">set</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"books"</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">list</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>java 编程思想<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>思考致富<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>将才<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">list</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从上面的配置文件中可以看出，Spring对list属性和数组属性的处理是一样的。</p>
<p>当我们使用<code>&lt;list.../&gt;</code>、<code>&lt;set.../&gt;</code>、<code>&lt;map.../&gt;</code>等元素配置集合属性时，我们还需要手动配置集合元素。由于集合元素又可以是基本类型值、引用容器中的其他Bean、嵌套Bean和集合属性等。所以这些元素又可以接受如下子元素：</p>
<ul>
<li>value:指定集合元素是基本数据类型或者字符类型值。</li>
<li>ref:指定集合元素师容器中另一个Bean实例。</li>
<li>bean:指定集合元素是一个嵌套Bean。</li>
<li>list、set、map、props:指定集合元素值又是集合。</li>
</ul>
<p><code>&lt;props.../&gt;</code>元素用于配置Properties类型的属性，Properties类型是一种特殊的类型，其key和value都只能是字符串。</p>
<p>使用<code>&lt;map.../&gt;</code>元素配置Map属性时比较复杂，因为Map集合的每个元素由key、value两个部分组成，所以配置文件中每个<code>&lt;entry.../&gt;</code>配置一个Map元素，其中entry支持如下4个属性：</p>
<ul>
<li>key：Map的key是基本类型或字符串。</li>
<li>key-ref：Map的key是容器中另一个Bean实例。</li>
<li>value：Map的value是基本类型或字符串。</li>
<li>value-ref：Map的value是容器中另一个Bean实例。</li>
</ul>
<h3 id="组合属性名称">组合属性名称</h3><p>当在配置文件中为Bean属性指定值时，还可以使用组合属性名的方式。例如我们使用如foo.bar.name的属性名，这表明为Bean实例的foo属性的bar属性的name属性指定值。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="keyword">Person</span> &#123;  </span><br><span class="line">    private String name;  </span><br><span class="line">    //getter .. setter</span><br><span class="line">&#125;  </span><br><span class="line">public class ExampleBean &#123;  </span><br><span class="line">    private <span class="keyword">Person</span> <span class="keyword">person</span>=new <span class="keyword">Person</span>();  </span><br><span class="line">    public <span class="keyword">Person</span> getPerson() &#123;  </span><br><span class="line">        return <span class="keyword">person</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bean.xml核心配置：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="property">id</span>=<span class="string">"exampleBean"</span> <span class="type">class</span>=<span class="string">"com.bean.ExampleBean"</span>&gt;  </span><br><span class="line">        &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"person.name"</span> value=<span class="string">"孙悟空"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>除了最后一个属性外，其他属性不能为null，否则引发异常</p>
<p>上面配置片段相当Spring执行：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exampleBean.getPerson<span class="params">()</span>.setName<span class="params">(<span class="string">"孙悟空"</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spring的Bean和JavaBean">Spring的Bean和JavaBean</h3><p>Spring容器对Bean没有特殊要求，甚至不要求该Bean像标准的JavaBean那样必须为每个属性提供对应的getter和setter方法。Spring中的Bean是Java实例、Java组件；而传统的Java应用中的JavaBean通常作为DTO(数据传输对象)，用来封装值对象，在各层之间传递数据。</p>
<p>虽然Spring对Bean没有特殊要求，但还是建议Spring中的Bean应该尽量满足如下几个原则：</p>
<ul>
<li>尽量为每个Bean实现类提供无参数的构造器。</li>
<li>接受构造注入的Bean，应该提供对应的构造函数。</li>
<li>接受设值注入的Bean，应该提供对应的setter方法，并不强制要求提供对应的getter方法。</li>
</ul>
<p>传统的JavaBean和Spring中的Bean存在如下区别：</p>
<ul>
<li>用处不同：传统的JavaBean更多作为值对象传递参数；Spring中的Bean用处几乎无所不包，任何应用组件都被称为Bean。</li>
<li>写法不同：传统的JavaBean作为值对象，要求每个属性都提供getter和setter方法；但Spring的Bean只需为接受设值注入的属性提供setter方法。</li>
<li>生命周期不同：传统的JavaBean作为值对象传递，不接受任何容器管理其生命周期；但Spring中的Bean由Spring管理其生命周期行为。</li>
</ul>
<h2 id="Spring_3-0提供的Java配置管理">Spring 3.0提供的Java配置管理</h2><p>Spring允许开发者使用Java类进行配置管理。</p>
<p>假如有如下Person实现类：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Chinese implements <span class="keyword">Person</span> &#123;</span><br><span class="line">       private Axe axe;</span><br><span class="line">       private String name;</span><br><span class="line">       //设值注入所需的setter方法</span><br><span class="line">       public void setAxe(Axe axe) &#123;</span><br><span class="line">           this.axe = axe;</span><br><span class="line">       &#125;</span><br><span class="line">       //设值注入所需的setter方法</span><br><span class="line">       public void setName(String name) &#123;</span><br><span class="line">           this.name = name;</span><br><span class="line">       &#125;</span><br><span class="line">       //实现<span class="keyword">Person</span>接口的useAxe方法</span><br><span class="line">       public void useAxe() &#123;</span><br><span class="line">           //调用axe的chop()方法，</span><br><span class="line">           //表明<span class="keyword">Person</span>对象依赖于axe对象</span><br><span class="line">           System.out.println(<span class="string">"我是："</span> + name + axe.chop());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面Chinese类需要注入两个属性：name和Axe，本示例当然也为Axe提供了两个实现类：StoneAxe和SteelAxe。如果我们采用XML配置，相应的配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring配置文件的根元素，使用spring-beans-3.0.xsd语义约束 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置chinese实例，其实现类是Chinese --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"org.crazyit.app.service.impl.Chinese"</span>&gt;</span></span><br><span class="line">                       <span class="comment">&lt;!-- 将stoneAxe注入给axe属性 --&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"axe"</span> <span class="attribute">ref</span>=<span class="value">"stoneAxe"</span>/&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"孙悟空"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置stoneAxe实例，其实现类是StoneAxe --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"stoneAxe"</span> <span class="attribute">class</span>=<span class="value">"org.crazyit.app.service.impl.StoneAxe"</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置steelAxe实例，其实现类是SteelAxe --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"steelAxe"</span> <span class="attribute">class</span>=<span class="value">"org.crazyit.app.service.impl.SteelAxe"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果开发者不喜欢使用XML配置文件，Spring 3.0允许开发者使用Java类进行配置。<br>上面XML配置文件可以替换为如下Java配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">       <span class="comment">//定义需要依赖注入的属性值</span></span><br><span class="line">       <span class="annotation">@Value</span>(<span class="string">"孙悟空"</span>) String personName;</span><br><span class="line">       <span class="comment">//配置一个Bean：chinese</span></span><br><span class="line">       <span class="annotation">@Bean</span>(name=<span class="string">"chinese"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Chinese p = <span class="keyword">new</span> Chinese();</span><br><span class="line">           p.setAxe(stoneAxe());</span><br><span class="line">           p.setName(personName);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//配置Bean：stoneAxe</span></span><br><span class="line">       <span class="annotation">@Bean</span>(name=<span class="string">"stoneAxe"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Axe <span class="title">stoneAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> StoneAxe();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//配置Bean：steelAxe</span></span><br><span class="line">       <span class="annotation">@Bean</span>(name=<span class="string">"steelAxe"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Axe <span class="title">steelAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SteelAxe();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面配置文件中使用了Java配置类的3个常用Annotation：</p>
<ul>
<li>@Configuration：用于修饰一个Java配置类。</li>
<li>@Bean：用于修饰一个方法，将该方法的返回值定义成容器中的一个Bean。</li>
<li>@Value：用于修饰一个Field，用于为配置一个值。</li>
</ul>
<p>一旦使用了Java配置类来管理Spring容器中Bean、及其依赖关系，此时需要使用如下方式来创建Spring容器：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Spring容器</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span></span><br><span class="line">       AnnotationConfigApplicationContext(AppConfig.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面AnnotationConfigApplicationContext类会根据Java配置类来创建Spring容器。不仅如此，该类还提供了一个register(Class)方法用于添加Java配置类。</p>
<p>获得Spring容器之后，接下来利用Spring容器获取Bean实例、调用Bean方法就没有任何特别之处了。</p>
<p>使用Java配置类时，还有如下常用的Annotation：</p>
<ul>
<li>@Import：修饰一个Java配置类，用于向当前Java配置类中导入其他Java配置类。</li>
<li>@Scope：用于修饰一个方法，指定该方法对应的Bean的生命域。</li>
<li>@Lazy：用于修饰一个方法，指定该方法对应的Bean的是否需要延迟初始化。</li>
<li>@DependOn：用于修饰一个方法，指定在初始化该方法对应的Bean之前初始化指定Bean。</li>
</ul>
<ol>
<li><p>如果以XML配置为主，就需要让XML配置能加载Java类配置。这并不难，只要在XML配置中增加如下代码即可：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span></span><br><span class="line">    <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">    http://www.springframework.org/schema/context</span><br><span class="line">    http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">!—加载Java配置类</span> <span class="attribute">--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.crazyit.app.config.AppConfig”/&gt;</span><br><span class="line">&lt;/beans&gt;</span></span></span><br></pre></td></tr></table></figure>
<p> 由于应用以XML配置为主，因此应用创建Spring容器时，还是以这份XML文件为参数来创建ApplicationContext对象。那么Spring会先加载这份XML配置文件，再根据这份XML配置文件的指示，去加载指定的Java配置类。</p>
</li>
<li><p>如果以Java类配置为主，就需要让Java配置类能加载XML配置。这就需要借助于@ImportResource Annotation，这个Annotation可修饰Java配置类，用于导入指定的XML配置文件。也就是在Java配置类上增加如下Annotation即可：</p>
 <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="comment">//导入XML配置</span></span><br><span class="line"><span class="variable">@ImportResource</span>(<span class="string">"classpath:/bean.xml"</span>)</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 由于应用以Java类配置为主，因此应用创建Spring容器时，应以Java配置类为参数，创建AnnotationConfigApplicationContext对象来作为Spring容器。那么Spring会先加载这个Java配置类，再根据这个Java配置类的指示，去加载指定的XML配置文件。</p>
</li>
</ol>
<h2 id="Bean实例的创建方式及依赖配置">Bean实例的创建方式及依赖配置</h2><p>创建Bean通常有如下方法：调用构造器，调用静态工厂方法，调用实例工厂方法。</p>
<h3 id="使用构造器创建Bean实例">使用构造器创建Bean实例</h3><p>使用构造器来创建Bean实例是最常见的情况，如果采用设置注入的方式，要求该类提供无参数构造器。class属性是必需的（除非采用继承）</p>
<p>BeanFactory将使用无参数构造器来创建Bean实例，该实例是个默认实例，Spring对Bean实例的所有属性执行默认初始化，即所有基本类型的值初始化为0或false，所有引用类型的值初始化为null。</p>
<p>接下来，BeanFactory会根据配置文件决定依赖关系，先实例化被依赖的Bean实例，然后为Bean注入依赖关系。最后将一个完整的Bean实例返回给程序，该Bean实例的所有属性，已经由Spring容器完成了初始化。</p>
<p>Axe.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;  </span><br><span class="line">    public void useAxe();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖Bean:SteelAxe实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chinese</span> <span class="title">implements</span> <span class="title">Person</span>&#123;  </span><br><span class="line">    @<span class="function">Override  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span>(<span class="params">Axe axe</span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Spring执行依赖关系注入"</span>);  </span><br><span class="line">        <span class="keyword">this</span>.axe = axe;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Spring实例化主调Bean:Chinese实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置 :<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span>&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">    </span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> <span class="keyword">person</span>=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        <span class="keyword">person</span>.useAxe();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">//控制台输出：</span><br><span class="line">Spring实例化主调Bean:Chinese实例...</span><br><span class="line">Spring实例化依赖Bean:SteelAxe实例...</span><br><span class="line">Spring执行依赖关系注入</span><br><span class="line">钢斧砍柴真快</span><br></pre></td></tr></table></figure></p>
<p>执行结果清楚地反映了执行过程：</p>
<ol>
<li>程序创建ApplicationContext实例。</li>
<li>调用Chinese类的默认构造器创建默认实例。</li>
<li>根据配置文件注入依赖关系：先实例化依赖Bean，然后将依赖Bean注入。</li>
<li>返回一个完整的Chinese实例。</li>
</ol>
<h3 id="使用静态工厂方法创建Bean">使用静态工厂方法创建Bean</h3><p>Being.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Being</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeing</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Dog.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Being</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String msg;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.msg = msg;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(msg+<span class="string">",狗爱啃骨头"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Cat.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Being</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String msg;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.msg = msg;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeing</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(msg+<span class="string">",猫爱吃老鼠"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BeingFactory.java :</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BeingFactory</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Being <span class="title">getBeing</span>(<span class="params">String arg</span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(arg.equalsIgnoreCase(<span class="string">"dog"</span>))&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Dog();  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Cat();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bean.xml核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dog"</span> class=<span class="string">"com.bean.BeingFactory"</span> factory-<span class="keyword">method</span>=<span class="string">"getBeing"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"dog"</span>/&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"msg"</span> value=<span class="string">"我是狗"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">    </span><br><span class="line">&lt;bean id=<span class="string">"cat"</span> class=<span class="string">"com.bean.BeingFactory"</span> factory-<span class="keyword">method</span>=<span class="string">"getBeing"</span>&gt;  </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"cat"</span>/&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"msg"</span> value=<span class="string">"我是猫"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>从上面的核心配置可以看出，cat和dog两个Bean配置的class属性和factory-method属性完全相同，这是因为这两个实例都是由同一个工厂类的同一个静态方法生产得到的。配置这两个Bean实例指定了工厂的静态方法的实参值不同，配置静态方法的实参值使用<code>&lt;constructor-arg.../&gt;</code>元素。<br>Test.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </span><br><span class="line">        ApplicationContext ctx=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        Being b1=(Being) ctx.getBean(<span class="string">"dog"</span>);  </span><br><span class="line">        b1.testBeing();  </span><br><span class="line">        Being b2=(Being) ctx.getBean(<span class="string">"cat"</span>);  </span><br><span class="line">        b2.testBeing();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时class属性并不是Bean实例的实现类，而是静态工厂类。除此之外，还需要使用factory-method属性来指定工厂的静态方法名。</p>
<h3 id="调用实例工厂方法创建Bean">调用实例工厂方法创建Bean</h3><p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;  </span><br><span class="line">    public String sayHello(String name);  </span><br><span class="line">    public String sayGoodBye(String name);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayGoodBye</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">",再见！"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">",你好"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>American.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">American</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayGoodBye</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">",Good Bye !"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">",Hello !"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PersonFactory.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersonFactory</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span>(<span class="params">String ethnic</span>)</span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(ethnic.equalsIgnoreCase(<span class="string">"chin"</span>))&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Chinese();  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  </span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> American();  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置 :<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"personFactory"</span> class=<span class="string">"com.bean.PersonFactory"</span>/&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"chinese"</span> factory-bean=<span class="string">"personFactory"</span> factory-<span class="keyword">method</span>=<span class="string">"getPerson"</span>&gt; </span><br><span class="line">    &lt;constructor-arg value=<span class="string">"chin"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">   </span><br><span class="line">&lt;bean id=<span class="string">"american"</span> factory-bean=<span class="string">"personFactory"</span> factory-<span class="keyword">method</span>=<span class="string">"getPerson"</span>&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">"ame"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p1=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        System.out.println(p1.sayGoodBye(<span class="string">"tom"</span>)+p1.sayHello(<span class="string">"tom"</span>));  </span><br><span class="line">        <span class="keyword">Person</span> p2=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"american"</span>);  </span><br><span class="line">        System.out.println(p2.sayGoodBye(<span class="string">"tom"</span>)+p2.sayHello(<span class="string">"tom"</span>));  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实例工厂方法与静态工厂方法的区别。</p>
<p>调用实例工厂方法创建Bean，必须将实例工厂配置成Bean实例。而静态工厂方法创建Bean，则无需配置工厂Bean。<br>调用实例工厂方法创建Bean，必须使用factory-bean属性确定工厂Bean。而静态工厂方法创建Bean，则使用class元素确定静态工厂类。</p>
<h2 id="深入理解容器中的Bean">深入理解容器中的Bean</h2><h3 id="使用抽象Bean">使用抽象Bean</h3><p>抽象Bean，都是指定abstract属性为true的Bean，抽象Bean不能被实例化，Spring容器不会创建抽象Bean的实例。抽象Bean的价值在于被继承，抽象Bean通常作为父Bean被继承。<br>当某个Bean将作为其他Bean的模板使用时，该Bean通常不需要实例化，而ApplicationContext默认预初始化所有的singleton Bean。为了阻止Bean模板被预初始化，可以指定abstract=“true”将该模板Bean设置为抽象Bean，Spring容器会忽略所有的抽象Bean定义，预初始化时不初始化抽象Bean。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chineseTemplate"</span> class=<span class="string">"com.bean.Chinese"</span> abstract=<span class="string">"true"</span>&gt;  </span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>这样配置以后，当程序采用ApplicationContext作为Spring容器时，程序实例化ApplicationContext容器时会默认实例化所有的singleton Bean，但不会初始化abstract  Bean。<br>抽象Bean是一个模板，容器会忽略抽象Bean的定义，不会实例化抽象Bean。抽象Bean因为无须实例化，因此可以没有class属性。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chineseTemplate"</span> abstract=<span class="string">"true"</span>&gt;  </span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>抽象Bean不能实例化，因此既不能通过getBean显式地获得抽象Bean实例，也不能将抽象Bean注入成其他Bean的依赖属性。无论何时，只要企图实例化抽象Bean，都将导致错误。</p>
<h3 id="使用子Bean">使用子Bean</h3><p>现象：有一批Bean配置的大量配置信息完全相同，只有少量配置不同。那么我们是否有办法来简化配置呢？Spring提供了 Bean继承来应对这个问题。Spring可以先为这批Bean配置一个Bean模板，将这批Bean中相同的配置信息配置成Bean模板，因为Spring容器无须创建Bean模板的实例，所以通常将这个Bean模板配成抽象Bean。</p>
<p>将大部分相同信息配置成Bean模板后，将实际的Bean实例配置成Bean模板的子Bean即可。子Bean定义可以从父Bean继承实现类、构造器参数、属性值等配置信息，除此之外，子Bean配置可以增加新的配置信息，并可指定新的配置信息覆盖父Bean的定义。</p>
<p>子Bean无法从父Bean继承如下属性：depends-on、autowire、singleton、scope、lazy-init，这些属性将总是从子Bean定义中获得，或采取默认值。</p>
<p>通过为一个<code>&lt;bean.../&gt;</code>元素指定 parent属性 即可指定该Bean是一个子Bean，parent属性指定该Bean所继承的父Bean的id。</p>
<p>Axe.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖bean:SteelAxe实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>StoneAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoneAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"石斧砍柴真慢"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StoneAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖bean:StoneAxe实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;  </span><br><span class="line">    public void useAxe();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chinese</span> <span class="title">implements</span> <span class="title">Person</span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span>(<span class="params">Axe axe</span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Spring执行依赖关系注入..."</span>);  </span><br><span class="line">        <span class="keyword">this</span>.axe = axe;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Spring实例化主调bean:Chinese实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    @<span class="function">Override  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"steelAxe"</span> <span class="variable">class=</span><span class="string">"com.bean.SteelAxe"</span>/&gt;  </span><br><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"stoneAxe"</span> <span class="variable">class=</span><span class="string">"com.bean.StoneAxe"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"chineseTemplate"</span> <span class="variable">class=</span><span class="string">"com.bean.Chinese"</span> <span class="variable">abstract=</span><span class="string">"true"</span>&gt;  </span><br><span class="line">   &lt;property <span class="variable">name=</span><span class="string">"axe"</span> <span class="variable">ref=</span><span class="string">"steelAxe"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"chinese"</span> <span class="variable">parent=</span><span class="string">"chineseTemplate"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        p.useAxe();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">//控制台输出：</span><br><span class="line">Spring实例化依赖bean：SteelAxe实例...</span><br><span class="line">Spring实例化依赖bean：StoneAxe实例...</span><br><span class="line">Spring实例化主调bean：Chinese实例...</span><br><span class="line">Spring执行依赖关系注入...</span><br><span class="line">钢斧砍柴真快</span><br></pre></td></tr></table></figure></p>
<p>子Bean从父Bean继承了实现类，依赖关系等配置信息。实际上，子Bean也可以覆盖父Bean的配置信息：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"stoneAxe"</span> class=<span class="string">"com.bean.StoneAxe"</span>/&gt;  </span><br><span class="line">  </span><br><span class="line">&lt;bean id=<span class="string">"chineseTemplate"</span> class=<span class="string">"com.bean.Chinese"</span> abstract=<span class="string">"true"</span>&gt;  </span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"chinese"</span> parent=<span class="string">"chineseTemplate"</span>&gt;  </span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"stoneAxe"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>控制台输出：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Spring</span>实例化依赖bean：<span class="variable">SteelAxe</span>实例...</span><br><span class="line"><span class="variable">Spring</span>实例化依赖bean：<span class="variable">StoneAxe</span>实例...</span><br><span class="line"><span class="variable">Spring</span>实例化主调bean：<span class="variable">Chinese</span>实例...</span><br><span class="line"><span class="variable">Spring</span>执行依赖关系注入...</span><br><span class="line">石斧砍柴真慢</span><br></pre></td></tr></table></figure></p>
<h3 id="Bean继承与Java继承的区别">Bean继承与Java继承的区别</h3><p>Spring中的Bean继承与Java中的继承截然不同。前者是实例与实例之间的参数的延续，后者则是一般到特殊的细化；前者是对象与对象之间的关系，后者是类与类之间的关系。Spring中的Bean继承与Java中的继承有如下区别：</p>
<ol>
<li>Spring中子Bean和父Bean可以是不同类型，但Java中的继承则可保证子类是一种特殊的父类。</li>
<li>Spring中的Bean继承是实例之间的关系，因此主要表现为参数值的延续；而Java中的继承是类之间的关系，主要表现为方法、属性的延续。</li>
<li>Spring中子Bean不可作为父Bean使用，不具备多态性；Java中的子类实例完全可以当成父类实例使用。</li>
</ol>
<h3 id="容器中的_工厂Bean">容器中的 工厂Bean</h3><p>此处的工厂Bean，与前面介绍的实例工厂方法创建Bean，或者静态工厂方法创建Bean的工厂有所区别：前面那些工厂是标准的工厂模式，Spring只是负责调用工厂方法来创建Bean实例；此处的工厂Bean是Spring的一种特殊Bean，这种工厂Bean必须实现FactoryBean接口。</p>
<p>FactoryBean接口是工厂Bean的标准接口，实现该接口的Bean通常只能作为工厂Bean使用，当我们将工厂Bean部署在容器中，并通过getBean( )方法来获取工厂Bean时，容器不会返回FactoryBean实例，而是返回FactoryBean的产品。</p>
<p>FactoryBean接口提供如下三个方法：</p>
<ul>
<li>Object getObject( )    实现该方法负责返回该工厂Bean生成的Java实例。</li>
<li>Class getObjectType( )    实现该方法返回该工厂Bean生成的Java实例的实现类。</li>
<li>boolean isSingleton( )    实现该方法表示该工厂Bean生成的Java实例是否为单例模式。 实现FactoryBean接口的Bean无法作为正常Bean使用，配置FactoryBean与配置普通Bean没有区别，但当客户端对该Bean id请求时，容器返回该FactoryBean的产品，而不是返回该FactoryBean本身。</li>
</ul>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;  </span><br><span class="line">    public String sayHello(String name);  </span><br><span class="line">    public String sayGoodBye(String name);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayGoodBye</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"再见,"</span>+name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"你好,"</span>+name;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PersonFactory.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Person p;  </span><br><span class="line">    <span class="comment">//返回工厂Bean所生产的产品  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getObject</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;  </span><br><span class="line">            p=<span class="keyword">new</span> Chinese();  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="keyword">return</span> p;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//获取工厂Bean所生产的产品的类型  </span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;  </span><br><span class="line">        <span class="keyword">return</span> Chinese.class;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//返回该工厂Bean所生产的产品是否为单例  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="property">id</span>=<span class="string">"chinese"</span> <span class="type">class</span>=<span class="string">"com.bean.PersonFactory"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        //直接请求FactoryBean时，系统将返回该FactoryBean的产品  </span><br><span class="line">        <span class="keyword">Person</span> p1=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);//1  </span><br><span class="line">        System.out.println(p1.sayHello(<span class="string">"汤姆"</span>));  </span><br><span class="line">        System.out.println(p1.sayGoodBye(<span class="string">"汤姆"</span>));  </span><br><span class="line">        //再次获取该FactoryBean的产品  </span><br><span class="line">        <span class="keyword">Person</span> p2=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);//2  </span><br><span class="line">        System.out.println(p1==p2);  </span><br><span class="line">        System.out.println(ctx.getBean(<span class="string">"&amp;chinese"</span>));//3  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">///控制台输出：</span><br><span class="line">你好，汤姆</span><br><span class="line">再见，汤姆</span><br><span class="line">true</span><br><span class="line">com.bean.PersonFactory@5e5a50</span><br></pre></td></tr></table></figure></p>
<p>上面的PersonFactory是一个标准的工厂Bean，该PersonFactory的getObject( )方法保证每次产生的Person对象是单例的，故该工厂类的isSingleton( )方法返回true。</p>
<p>Test.java中1和2直接请求容器中的FactoryBean，Spring将不会返回该FactoryBean实例，而是返回该FactoryBean的产品；程序3在Bean id前增加&amp;符号，这将会让Spring返回FactoryBean本身。</p>
<p>因为FactoryBean以单例方式管理产品Bean，因此两次请求的产品，是同一个共享实例。</p>
<p>当程序需要获取FactoryBean本身时，并不直接请求Bean id，而是在Bean id前增加&amp;符号。</p>
<p>对于初学者而言，可能无法体会到工厂Bean的作用。实际上，FactoryBean是Spring中非常有用的一个接口，Spring内置提供了很多实用的工厂Bean，例如TransactionProxyFactoryBean等，这个工厂Bean专门用于为目标Bean创建事务代理。</p>
<p>Spring提供的工厂Bean，大多以FactoryBean后缀结尾，Spring提供的工厂Bean，大多用于生产一批具有某种特征的Bean实例，工厂Bean是Spring的一个重要工具类。</p>
<h3 id="获得Bean部署时的id">获得Bean部署时的id</h3><p>在某些极端情况下，程序开发Bean类时需要获得在容器中部署该Bean时指定的id属性，此时可借助于Spring提供的 BeanNameAware 接口，通过该接口允许Bean类获取部署该Bean时指定的id属性。</p>
<p>BeanNameAware接口提供的一个方法：setBeanName(String name)，该方法的name参数就是Bean的id，实现该方法的Bean类就可通过该方法来获得部署该Bean的id了。</p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span></span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> String beanName;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">this</span>.beanName=name;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBeanId</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Chinese实现类，部署该Bean时指定的id为："</span>+beanName);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml 核心配置：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="property">id</span>=<span class="string">"chinese"</span> <span class="type">class</span>=<span class="string">"com.bean.Chinese"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;  </span><br><span class="line">        ApplicationContext ctx=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        Chinese c=(Chinese) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        c.getBeanId();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span>控制台输出：</span></span><br><span class="line">Chinese实现类，部署该Bean时指定的id为:chinese</span><br></pre></td></tr></table></figure></p>
<p>Spring容器何时回调Bean实例的setBeanName(String name)方法呢？Spring容器会在Bean初始化完成后回调该方法—这里的初始化指的是Bean的初始化行为：包括回调实现InitializingBean接口所实现的afterPropertiesSet方法，回调Bean配置中init-method属性指定的方法。当Spring容器完成了Bean的初始化动作之后，接下来将会回调实现BeanNameAware接口里的setBeanName(String name)方法。</p>
<h3 id="强制初始化Bean">强制初始化Bean</h3><p>Spring默认有个规则：总是先初始化主调Bean，然后再初始化依赖Bean。</p>
<p>大多数情况下，Bean之间的依赖关系非常直接，Spring容器在返回Bean实例之前，完成Bean依赖关系的注入。假如Bean A依赖于Bean B，程序请求Bean A时，Spring容器会自动先初始化Bean B，再将Bean B注入Bean A，最后将具备完整依赖的Bean A返回给程序。</p>
<p>在极端的情况下，Bean之间的依赖不够直接。比如某个类的初始化块中使用其他Bean，Spring总是先初始化主调Bean，执行初始化块时还没有实例化主调Bean，被依赖的Bean还没实例化，此时将引发异常。</p>
<p>为了让指定Bean在目标Bean之前初始化，可以使用 depends-on 属性，该属性可以在初始化主调Bean之前，强制初始化一个或多个Bean。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"beanOne"</span> class=<span class="string">"ExampleBean"</span> depends-on=<span class="string">"manager"</span>&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"manager"</span> <span class="keyword">ref</span>=<span class="string">"manager"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"manager"</span> class=<span class="string">"ManagerBean"</span>/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="容器中Bean的生命周期">容器中Bean的生命周期</h2><p>对于singleton作用域的Bean，Spring容器知道Bean何时实例化结束、何时销毁，Spring可以管理实例化结束之后和销毁之前的行为。管理Bean的生命周期行为主要有如下两个时机：</p>
<ol>
<li>注入依赖关系之后。</li>
<li>即将销毁Bean之前。</li>
</ol>
<h3 id="依赖关系注入之后的行为">依赖关系注入之后的行为</h3><p>依赖关系注入之后的行为：<br>Spring提供两种方式在Bean全部属性设置成功后执行特定行为：</p>
<ol>
<li>使用 init-method 属性<br> 使用init-method属性指定某个方法应在Bean全部依赖关系设置结束后自动执行，使用这种方法不需将代码与Spring的接口耦合在一起，代码污染小。</li>
<li>实现 InitializingBean 接口<br> 该接口提供一个方法，void afterPropertiesSet( )throws Exception。Spring容器会在为该Bean注入依赖关系之后，接下来会调用该Bean所实现的afetrPropertiesSet( )方法。</li>
</ol>
<p>Axe.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;  </span><br><span class="line">    public void useAxe();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖bean:SteelAxe实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span>,<span class="title">InitializingBean</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring实例化主调Bean:Chinese实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring执行依赖关系注入..."</span>);  </span><br><span class="line">        <span class="keyword">this</span>.axe = axe;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"正在执行初始化方法init..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"正在执行初始化方法afterPropertiesSet..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml 核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span> init-<span class="keyword">method</span>=<span class="string">"init"</span>&gt;  </span><br><span class="line">    &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>&gt;&lt;/property&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">    </span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        p.useAxe();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从运行结果可以看出：依赖注入完成之后，程序先调用afterPropertiesSet方法，再调用init-method属性所指定的方法进行初始化。</p>
<h3 id="Bean_销毁之前的行为">Bean 销毁之前的行为</h3><p>与定制初始化行为相似，Spring也提供两种方法定制Bean实例销毁之前的行为：</p>
<ol>
<li>使用destroy-method属性：<br> destroy-method属性指定某个方法在Bean销毁之前被自动执行。使用这种方式，不需要将代码与Spring的接口耦合，代码污染小。</li>
<li>实现DisposableBean接口：<br> 该接口提供了一个方法，void destroy( ) throws Exception，该方法就是Bean实例被销毁之前应该执行的方法。</li>
</ol>
<p>Axe.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;  </span><br><span class="line">    public void useAxe();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖Bean:SteelAxe实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span>,<span class="title">DisposableBean</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> Axe axe;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring实例化主调Bean:Chinese实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring执行依赖关系注入..."</span>);  </span><br><span class="line">        <span class="keyword">this</span>.axe = axe;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(axe.chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"正在执行销毁之前的方法close..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"正在执行销毁之前的方法destroy..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span> destroy-<span class="keyword">method</span>=<span class="string">"close"</span>&gt;  </span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>&gt;&lt;/property&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">   </span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        AbstractApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        p.useAxe();  </span><br><span class="line">        ctx.registerShutdownHook();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>singleton 作用域的Bean通常会随容器的关闭而销毁，但问题是：ApplicationContext容器在什么时候关闭呢？在基于web的ApplicationContext实现中，系统已经提供了相应的代码保证关闭web应用时恰当地关闭Spring容器。</p>
<p>如果处于一个非web应用的环境下，为了让Spring容器优雅地关闭，并调用singleton Bean上的相应析构回调方法，则需要在JVM虚拟机里注册一个关闭钩子，这样就可保证Spring容器被恰当关闭，且自动执行singleton Bean实例的析构回调方法。</p>
<p>为了注册关闭钩子，只需要调用在AbstractApplicationContext中提供的registerShutdownHook( )方法即可。</p>
<p>从程序的输出可以看出：Spring容器注入之后，关闭之前，程序先调用destroy方法进行回收资源，再调用close方法进行回收资源。</p>
<p>如果某个Bean类实现了DisposableBean接口，在Bean被销毁之前，Spring容器会自动调用该Bean实例的destroy方法，其结果与采用destroy-method属性指定生命周期方法几乎一样。但实现DisposableBean接口污染了代码，是侵入式设计，因此不推荐使用。</p>
<p>除此之外，如果容器中很多Bean都需要指定特定的生命周期行为，则可以利用 <code>&lt;beans.../&gt;</code> 元素的 default-init-method属性和 default-destroy-method 属性，这两个属性的作用类似于 <code>&lt;bean.../&gt;</code>元素的 init-method 属性和destroy-method 属性，区别是default-init-method和default-destroy-method是针对容器中所有Bean生效。</p>
<h3 id="协调作用域不同步的Bean">协调作用域不同步的Bean</h3><p>当两个singleton作用域Bean存在依赖关系时，或prototype作用域Bean依赖singleton作用域Bean时，不会有任何问题。</p>
<p>但当singleton作用域Bean依赖prototype作用域Bean时，singleton作用域Bean只有一次初始化的机会，它的依赖关系也只在初始化阶段被设置，它所依赖的prototype作用域Bean则需要每次都得到一个全新的Bean实例，这将会导致singleton作用域的Bean的依赖得不到即时更新。</p>
<p>由于singleton Bean具有单例行为，当客户端多次请求singleton Bean时，Spring返回给客户端的将是同一个singleton Bean实例，这不存在任何问题。问题是：如果客户端多次请求singleton Bean、并调用singleton Bean去调用prototype Bean的方法时，始终都是调用同一个prototype Bean实例，这就违背了设置prototype Bean的初衷：本来希望它具有prototype行为，但实际上它却表现出singleton行为。</p>
<p>这就是问题的所在：当singleton作用域的Bean依赖于prototype作用域的Bean时，会产生不同步的现象。</p>
<p>解决该问题有如下两种思路：</p>
<ol>
<li>部分放弃依赖注入：singleton作用域Bean每次需要prototype作用域Bean时，主动向容器请求新的Bean实例，即可保证每次注入的prototype Bean实例都是最新的实例。</li>
<li>利用方法注入。<br>第一种方式显然不是一个好的做法，代码主动请求新的Bean实例，必然导致代码与Spring API耦合，造成代码严重污染。<br>通常情况下，我们采用第二种做法，使用方法注入。方法注入通常使用lookup方法注入，利用lookup方法注入可以让Spring容器重写容器中Bean的抽象或具体方法，返回查找容器中其他Bean的结果，被查找的Bean通常是一个non-singleton Bean。Spring通过使用CGLIB库修改客户端的二进制码，从而实现上述的要求。</li>
</ol>
<p>Axe.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;  </span><br><span class="line">    <span class="annotation">@Override</span>  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖Bean:SteelAxe实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;  </span><br><span class="line">    public void useAxe();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Chinese</span> <span class="title">implements</span> <span class="title">Person</span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Spring实例化主调Bean:Chinese实例..."</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="comment">//singleton Bean里增加一个抽象方法  </span></span><br><span class="line">    <span class="comment">//方法的返回值类型是被依赖的Bean  </span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Axe <span class="title">getAxe</span>(<span class="params"></span>)</span>;  </span><br><span class="line">    @<span class="function">Override  </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span>(<span class="params"></span>) </span>&#123;  </span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"正在使用"</span>+getAxe()+<span class="string">"砍柴!"</span>);  </span><br><span class="line">        System.<span class="keyword">out</span>.println(getAxe().chop());  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span>&gt;  </span><br><span class="line">   &lt;lookup-<span class="keyword">method</span> name=<span class="string">"getAxe"</span> bean=<span class="string">"steelAxe"</span>/&gt;  </span><br><span class="line">&lt;/bean&gt;  </span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span> scope=<span class="string">"prototype"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;  </span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;  </span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);  </span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);  </span><br><span class="line">        p.useAxe();  </span><br><span class="line">        p.useAxe();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在singleton Bean里新增一个抽象方法，该方法的返回值类型是被依赖的Bean，该方法是一个抽象方法，其实现由Spring完成。问题是：Spring怎么知道如何实现该方法呢？为了让Spring知道如何实现该方法，我们需要在配置文件中使用<code>&lt;lookup-method.../&gt;</code>元素来配置这个方法。<br>使用<code>&lt;lookup-method.../&gt;</code>元素需要指定如下两个属性：</p>
<ol>
<li>name：指定需要让Spring实现的方法。</li>
<li>bean：指定Spring实现该方法后的返回值。</li>
</ol>
<p>程序的执行结果表明：使用lookup方法注入后，系统每次调用getAxe( )方法都将生成一个新的SteelAxe实例，这就可以保证当singleton作用域的Bean需要全新的Bean实例时，直接调用getAxe()方法即可，从而可以避免一直使用最早注入的Bean实例。</p>
<h2 id="深入理解依赖关系配置">深入理解依赖关系配置</h2><p>组件与组件之间的耦合，采用依赖注入管理，但是普通的javabean属性值，应直接在代码里设置。</p>
<p>在spring配置文件中使用xml元素进行配置,实际上是让spring执行相应的java代码<br>例如:  </p>
<ol>
<li>使用<bean>元素,就是让spring执行无参数构造函数  </bean></li>
<li>使用<property> 就是让spring执行setter方法  </property></li>
</ol>
<p>但是java程序还有可能还有其他语句,调用getting,调用普通方法,访问类或者对象的file,spring也为这种语句提供利配置的语法  </p>
<ol>
<li>调用getter方法:使用 PropertyPathFactoryBean  </li>
<li>访问类或对象的Field值,使用FieldRetrievingFactoryBean  </li>
<li>调用普通方法:使用MethodInvokingFactoryBean<br>由此可见,spring可以然我们不写java代码就可以实现java编程,只要使用合适XML 语法进行配置,spring就可通过反射执行任意的底层java代码.  </li>
</ol>
<h3 id="注入其他Bean的属性值">注入其他Bean的属性值</h3><p>属性值的注入，是通过PropertyPathFactoryBean完成的，PropertyPathFactoryBean用来获取目标bean的属性，获得的值可以注入到其他bean,也可以定义成新的bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"person"</span> <span class="attribute">class</span>=<span class="value">"com.bean.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span> <span class="attribute">value</span>=<span class="value">"30"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"son"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.bean.Son"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span> <span class="attribute">value</span>=<span class="value">"11"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--如下将会将person的属性son的属性age传入son1实例的age属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"son1"</span> <span class="attribute">class</span>=<span class="value">"com.bean.Son"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以下是访问bean属性的简单方式,这样可以将person这个bean的age属性赋值给son1这个bean的age属性--&gt;</span>           </span><br><span class="line">        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"person.son.age"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 以下将会获得结果son,它将是person bean的son的数值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"son2"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetBeanName"</span> <span class="attribute">value</span>=<span class="value">"person"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"propertyPath"</span> <span class="attribute">value</span>=<span class="value">"son"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 以下将会获得结果16,它将是person bean的son的age属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"theAge1"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetBeanName"</span> <span class="attribute">value</span>=<span class="value">"person"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"propertyPath"</span> <span class="attribute">value</span>=<span class="value">"son.age"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 以下会获得结果为30 ,它将是获得该bean的内部bean的age属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"theAge2"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetObject"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.bean.Person"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span> <span class="attribute">value</span>=<span class="value">"30"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"propertyPath"</span> <span class="attribute">value</span>=<span class="value">"age"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main<span class="params">(String[] args)</span> throws Exception &#123;</span><br><span class="line">        String path=new Test<span class="params">()</span>.getClass<span class="params">()</span>.getResource<span class="params">(<span class="string">"/"</span>)</span>.getPath<span class="params">()</span>;</span><br><span class="line">        String realpath=path.substring<span class="params">(<span class="number">1</span>, path.length<span class="params">()</span>)</span>;</span><br><span class="line">        ApplicationContext context=new FileSystemXmlApplicationContext<span class="params">(realpath+<span class="string">"/superIOCparam.xml"</span>)</span>;</span><br><span class="line">        Son son1=<span class="params">(Son)</span>context.getBean<span class="params">(<span class="string">"son1"</span>)</span>;</span><br><span class="line">        Son son2=<span class="params">(Son)</span>context.getBean<span class="params">(<span class="string">"son2"</span>)</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println<span class="params">(<span class="string">"person age is:"</span>+son1.getAge<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"person age is:"</span>+son2.getAge<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(context.getBean<span class="params">(<span class="string">"theAge1"</span>)</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(context.getBean<span class="params">(<span class="string">"theAge2"</span>)</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>可以将Bean实例的属性值注入另一个Bean，此时bean的id是指定属性表达式，不是唯一标识。</li>
<li>可以将Bean实例的属性值直接定义成Bean实例，此时的id就是它的唯一标识。且必须指定两个属性：targetBeanName用于指定目标Bean，确定获取哪个Bean的属性值，或targetObject用于指定嵌套Bean实例；propertyPath，用于指定属性，确定获取目标Bean的哪个属性值，此处的属性可直接使用复合属性的形式。</li>
</ol>
<h3 id="注入其他Bean的Field值">注入其他Bean的Field值</h3><p>FieldRetrievingFactoryBean获得目标Bean的Field值后，得到的值可注入给其他Bean，也可直接定义成新的Bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将指定的类的静态Field设置成bean的属性值 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"son"</span> <span class="attribute">class</span>=<span class="value">"com.bean.Son"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- id指定了哪个Field的值 将会被设置给id="son"的bean --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span>   </span><br><span class="line">            <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 将其他bean的Field定义成一个bean --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"theAge1"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!-- targetClass 设置Field所在的类,targetObject,当目标对象时使用(代替targetClass) --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetClass"</span> <span class="attribute">value</span>=<span class="value">"java.sql.Connection"</span> /&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- targetField指定目标类的目标Field --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetField"</span> <span class="attribute">value</span>=<span class="value">"TRANSACTION_SERIALIZABLE"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 将静态Field定义成一个bean的简单写法 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"theAge2"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"staticField"</span> <span class="attribute">value</span>=<span class="value">"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main<span class="params">(String[] args)</span> throws Exception &#123;</span><br><span class="line">        String path=new Test<span class="params">()</span>.getClass<span class="params">()</span>.getResource<span class="params">(<span class="string">"/"</span>)</span>.getPath<span class="params">()</span>;</span><br><span class="line">        String realpath=path.substring<span class="params">(<span class="number">1</span>, path.length<span class="params">()</span>)</span>;</span><br><span class="line">        ApplicationContext context=new FileSystemXmlApplicationContext<span class="params">(realpath+<span class="string">"/superIOCparam.xml"</span>)</span>;</span><br><span class="line">        Son son=<span class="params">(Son)</span>context.getBean<span class="params">(<span class="string">"son"</span>,Son.class)</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println<span class="params">(<span class="string">"son age is:"</span>+son.getAge<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(context.getBean<span class="params">(<span class="string">"theAge1"</span>)</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(context.getBean<span class="params">(<span class="string">"theAge2"</span>)</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用FieldRetrievingFactoryBean获取Field值时，必须指定两个属性值</p>
<ul>
<li>targetClass或targetObject：分别用于指定Field值所在的目标类或目标对象，如果需要获得Field是静态Field，则使用targetClass指定目标类，否则使用targetObject指定目标对象。</li>
<li>targetField：用于指定目标Field的Field名。如果是静态Field可以通过staticField直接指定域。</li>
</ul>
<h3 id="注入其他Bean的方法返回值">注入其他Bean的方法返回值</h3><p>通过MethodInvokingFactoryBean工厂Bean，可获得指定方法的返回值并将其注入到指定Bean实例的指定属性，也可以直接定义成Bean实例。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 提供方法的bean --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"valueGenerator"</span> <span class="attribute">class</span>=<span class="value">"com.util.valueGenerator"</span> /&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 将一个bean的方法 返回值 注入 新bean的 age属性 --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"son1"</span> <span class="attribute">class</span>=<span class="value">"com.bean.Son"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetObject"</span> <span class="attribute">ref</span>=<span class="value">"valueGenerator"</span> /&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetMethod"</span> <span class="attribute">value</span>=<span class="value">"getValue"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 上面 是调用非静态类对象的getValue()这种无参方法 --&gt;</span>  </span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 调用静态类的静态方法,静态方法的返回值直接 定义成bean --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sysProps"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetClass"</span> <span class="attribute">value</span>=<span class="value">"java.lang.System"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetMethod"</span> <span class="attribute">value</span>=<span class="value">"getProperties"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line"><span class="comment">&lt;!-- 调用无参 静态类的静态方法 创建bean name="staticMethod",value=静态类.静态方法--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"myBean"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"staticMethod"</span> <span class="attribute">value</span>=<span class="value">"xxx.MyStaticClass.myStaticMethod"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line"><span class="comment">&lt;!-- 有参数的方法调用,返回值 配置成一个bean --&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"javaVersion"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 目标bean,确定调用哪个bean的方法 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetObject"</span> <span class="attribute">ref</span>=<span class="value">"sysProps"</span> /&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 确定目标方法,确定调用bean的哪个方法 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetMethod"</span> <span class="attribute">value</span>=<span class="value">"getProperty"</span> /&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 确定调用目标方法的参数 相当于调用getProperty方法,传递参数"java.version" --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"arguments"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">list</span>&gt;</span>  </span><br><span class="line">        <span class="tag">&lt;<span class="title">value</span>&gt;</span>java.version<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">list</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ValueGenrator类<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValueGenerator</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStaticValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main<span class="params">(String[] args)</span> throws Exception &#123;</span><br><span class="line">        String path=new Test<span class="params">()</span>.getClass<span class="params">()</span>.getResource<span class="params">(<span class="string">"/"</span>)</span>.getPath<span class="params">()</span>;</span><br><span class="line">        String realpath=path.substring<span class="params">(<span class="number">1</span>, path.length<span class="params">()</span>)</span>;</span><br><span class="line">        ApplicationContext context=new FileSystemXmlApplicationContext<span class="params">(realpath+<span class="string">"/superIOCparam.xml"</span>)</span>;</span><br><span class="line">        Son son1=<span class="params">(Son)</span>context.getBean<span class="params">(<span class="string">"son1"</span>,Son.class)</span>;</span><br><span class="line">        Son son2=<span class="params">(Son)</span>context.getBean<span class="params">(<span class="string">"son2"</span>,Son.class)</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println<span class="params">(<span class="string">"son age is:"</span>+son1.getAge<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"son age is:"</span>+son2.getAge<span class="params">()</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>targetClass或targetObject：分别用于指定目标类或目标对象。</li>
<li>targetMethod：用于指定目标方法的方法名。如果是静态方法可以通过staticMethod直接指定方法。</li>
</ul>
<h2 id="基于xml_schema_的简化配置方式">基于xml schema 的简化配置方式</h2><h3 id="使用p名称空间配置属性">使用p名称空间配置属性</h3><p>使用p命名空间可以简化原来property 的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line"><span class="attribute">xmlns:p</span>=<span class="value">"http://www.springframework.org/schema/p"</span>  </span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans  </span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 配置Chinese实例 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.Chinese"</span> <span class="attribute">p:age</span>=<span class="value">"29"</span> <span class="attribute">p:age-ref</span>=<span class="value">"stoneAxe"</span>/&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 配置stoneAxe实例 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"stoneAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.StoneAxe"</span> /&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先，需要导入p名字空间，通过在axe后添加”-ref”指定该值不是一个具体的值，而是对另外一个Bean的引用。</p>
<h3 id="使用util_Schema">使用util Schema</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>  </span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span>  </span><br><span class="line"><span class="attribute">xmlns:p</span>=<span class="value">"http://www.springframework.org/schema/p"</span>  </span><br><span class="line"><span class="attribute">xmlns:util</span>=<span class="value">"http://www.springframework.org/schema/util"</span>  </span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans  </span><br><span class="line">http://www.springframework.org/schema/util</span><br><span class="line">http://www.springframework.org/schema/util/spring-util-3.0.xsd</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 配置Chinese实例 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.Chinese"</span></span><br><span class="line">    <span class="attribute">p:age-ref</span>=<span class="value">"chin.age"</span></span><br><span class="line">    <span class="attribute">p:age-ref</span>=<span class="value">"stoneAxe"</span></span><br><span class="line">    <span class="attribute">p:schools-ref</span>=<span class="value">"chin.schools"</span></span><br><span class="line">    <span class="attribute">p:axes-ref</span>=<span class="value">"chin.axes"</span></span><br><span class="line">    <span class="attribute">p:scores-ref</span>=<span class="value">"chin.scores"</span> /&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- 配置stoneAxe实例 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"stoneAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.StoneAxe"</span> /&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"steelAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.SteelAxe"</span> /&gt;</span>  </span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将指定类的静态Field暴露出来 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">util:constant</span> <span class="attribute">id</span>=<span class="value">"chin.age"</span> <span class="attribute">static-field</span>=<span class="value">"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span>/&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 将指定bean的属性 暴露出来 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">util:property-path</span> <span class="attribute">id</span>=<span class="value">"test"</span> <span class="attribute">path</span>=<span class="value">"chinese.age"</span>/&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 加载指定资源文件 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">util:properties</span> <span class="attribute">id</span>=<span class="value">"confTest"</span> <span class="attribute">location</span>=<span class="value">"classpath:message_zh_CN.properties"</span>/&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 定义一个list --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">util:list</span> <span class="attribute">id</span>=<span class="value">"chin.schools"</span> <span class="attribute">list-class</span>=<span class="value">"java.util.LinkedList"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>小学<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>中学<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>大学<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">util:list</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 定义一个set对象 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">util:set</span> <span class="attribute">id</span>=<span class="value">"chin.axes"</span> <span class="attribute">set-class</span>=<span class="value">"java.util.HashSet"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>字符串斧子<span class="tag">&lt;/<span class="title">value</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.SteelAxe"</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">local</span>=<span class="value">"stoneAxe"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">util:set</span>&gt;</span>  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!-- 定一个 map对象 --&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">util:map</span> <span class="attribute">id</span>=<span class="value">"chin.scores"</span> <span class="attribute">map-class</span>=<span class="value">"java.util.TreeMap"</span> <span class="attribute">key-type</span>=<span class="value">"java.lang.String"</span> <span class="attribute">value-type</span>=<span class="value">"java.lang.Double"</span>&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"数学"</span> <span class="attribute">value</span>=<span class="value">"89"</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"英语"</span> <span class="attribute">value</span>=<span class="value">"89"</span>/&gt;</span>  </span><br><span class="line">            <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"语文"</span> <span class="attribute">value</span>=<span class="value">"89"</span>/&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">util:map</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>util Schema元素</p>
<ul>
<li>constant：该标签用于将指定类的静态Field暴露成一个Bean实例。使用该标签时可制定如下两个属性。<ul>
<li>id：该属性指定将静态Field定义成名为id的Bean实例</li>
<li>static-field：该属性指定将哪个类、哪个静态Field暴露出来。</li>
</ul>
</li>
<li>property-path：该标签用于将指定Bean实例的指定属性暴露成一个Bean实例，使用该标签时可指定如下两个属性  <ul>
<li>id：该属性指定将属性定义成名为id的Bean实例</li>
<li>path：该属性指定将哪个Bean实例、哪个属性（支持复合属性）暴露出来。</li>
</ul>
</li>
<li>list 该标签用于定义一个List Bean，支持使用value、ref、bean等标签来定义List集合元素，使用该标签支持如下三个属性，  <ul>
<li>id：该属性指定定义一个名为id的List实例</li>
<li>list-class：该属性指定Spring使用哪个List实现类来创建Bean实例</li>
<li>scope：指定该List实例的作用域</li>
</ul>
</li>
<li>set：该标签用于定义一个Set Bean，支持使用value、ref、bean等标签来定义Set集合元素，使用该标签支持如下三个属性。<ul>
<li>id：该属性指定定义一个名为id的Set Bean实例</li>
<li>set-class：该属性指定Set Bean使用哪个Set实现类来创建Bean实例</li>
<li>scope：指定该Set Bean实例的作用域</li>
</ul>
</li>
<li>map 该标签用于定义一个Map Bean，支持使用entry来定义Map的key-value对．使用该标签支持如下三个属性<ul>
<li>id：该属性指定定义一个名为id的Map Bean实例</li>
<li>map-class：该属性指定Spring使用哪个Map实现类来创建Bean实例</li>
<li>scope：指定该Map Bean实例的作用域</li>
</ul>
</li>
<li>properties：该标签用于加载一份资源文件并根据加载的资源文件创建个Properties Bean实例，使用该标签可指定如下几个属性<ul>
<li>id：该属性指定定义一个名为id的Properties Bean实例</li>
<li>location：指定资源文件的位置。</li>
<li>scope：指定该Properties Bean实例的作用域</li>
</ul>
</li>
</ul>
<h2 id="Spring3-0提供的表达式语言(SpEl)">Spring3.0提供的表达式语言(SpEl)</h2><p>Spring的表达式语言与Java注解结合，以便开发人员可以撰写和指向他们的配置，而不需要单独的XML文件写入，使得Spring开发者在不需要XML的情况下对应用进行配置。</p>
<h3 id="使用Expression接口进行表达式求值">使用Expression接口进行表达式求值</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">public class SpELTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">       @Test  </span><br><span class="line">    public void test2<span class="params">()</span> &#123;  </span><br><span class="line">        ExpressionParser parser=new SpelExpressionParser<span class="params">()</span>;  </span><br><span class="line">        Expression <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"'Hello World'"</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Hello World的结果"</span>+exp.getValue<span class="params">()</span>)</span>;  </span><br><span class="line">          </span><br><span class="line">        <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"'Hello World'.concat('!')"</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"concat后的结果"</span>+exp.getValue<span class="params">()</span>)</span>;  </span><br><span class="line">          </span><br><span class="line">        <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"'Hello World'.bytes"</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"调用getBytes方法后的结果"</span>+exp.getValue<span class="params">()</span>)</span>;  </span><br><span class="line">          </span><br><span class="line">        <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"'Hello World'.bytes.length"</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"方法返回值后的属性的结果"</span>+exp.getValue<span class="params">()</span>)</span>;  </span><br><span class="line">          </span><br><span class="line">        <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"new String('Hello World').toUpperCase()"</span>)</span>;  </span><br><span class="line">        <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"age"</span>)</span>;  </span><br><span class="line">        Chinese c=act.getBean<span class="params">(<span class="string">"chinese"</span>,Chinese.class)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"以Chinese为root,age的表达式的值是:"</span>+exp.getValue<span class="params">(c, Integer.class)</span>)</span>;  </span><br><span class="line">        <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"age==15"</span>)</span>;  </span><br><span class="line">        StandardEvaluationContext ctx=new StandardEvaluationContext<span class="params">()</span>;  </span><br><span class="line">        ctx.setRootObject<span class="params">(c)</span>;  </span><br><span class="line">        System.out.println<span class="params">(exp.getValue<span class="params">(ctx, Boolean.class)</span>)</span>;  </span><br><span class="line">          </span><br><span class="line">        List&lt;Boolean&gt; list=new ArrayList&lt;Boolean&gt;<span class="params">()</span>;  </span><br><span class="line">        list.add<span class="params">(<span class="literal">true</span>)</span>;  </span><br><span class="line">        EvaluationContext ctx2=new StandardEvaluationContext<span class="params">()</span>;  </span><br><span class="line">        ctx2.setVariable<span class="params">(<span class="string">"list"</span>,list)</span>;  </span><br><span class="line">          </span><br><span class="line">        parser.parseExpression<span class="params">(<span class="string">"#list[0]"</span>)</span>.setValue<span class="params">(ctx2, <span class="string">"false"</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"List集合中的第一个元素:"</span>+list.get<span class="params">(<span class="number">0</span>)</span>)</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建解析器：SpEL使用ExpressionParser接口表示解析器，提供SpelExpressionParser默认实现；</li>
<li>解析表达式：使用ExpressionParser的parseExpression来解析相应的表达式为Expression对象。</li>
<li>构造上下文：准备比如变量定义等等表达式需要的上下文数据。</li>
<li>求值：通过Expression接口的getValue方法根据上下文获得表达式值。</li>
</ol>
<p>接下来让我们看下SpEL的主要接口吧：</p>
<ol>
<li>ExpressionParser接口：表示解析器，默认实现是org.springframework.expression.spel.standard包中的SpelExpressionParser类，使用parseExpression方法将字符串表达式转换为Expression对象，对于ParserContext接口用于定义字符串表达式是不是模板，及模板开始与结束字符</li>
<li>EvaluationContext接口：表示上下文环境，默认实现是org.springframework.expression.spel.support包中的StandardEvaluationContext类，使用setRootObject方法来设置根对象，使用setVariable方法来注册自定义变量，使用registerFunction来注册自定义函数等等。</li>
<li>Expression接口：表示表达式对象，默认实现是org.springframework.expression.spel.standard包中的SpelExpression，提供getValue方法用于获取表达式值，提供setValue方法用于设置对象值。</li>
</ol>
<h3 id="Bean定义中的表达式语言支持">Bean定义中的表达式语言支持</h3><p>xml配置文件和Annotation中使用SpEL时，都需要在表达式外面增加#{}包围。</p>
<h3 id="SpEL语法详述">SpEL语法详述</h3><h4 id="基本表达式">基本表达式</h4><ul>
<li>字面量表达式</li>
<li>算术运算表达式</li>
<li>比较运算表达式</li>
<li>逻辑运算表达式</li>
<li>字符串连接与截取表达式</li>
<li>三目运算及Elivis运算表达式</li>
<li>正则表达式</li>
</ul>
<p>字面量表达式<br>字符串、数字类型（int、long、float、double）、布尔类型、null。<br>字符串 ‘Hello World!’、”Hello World!”<br>数值类型 1、-1L、1.1、1.1E+2、0xa、0xaL<br>布尔类型 true、false<br>null null</p>
<p>算术运算表达式<br>加(+)、减(-)、乘(<code>*</code>)、除(/或DIV)、求余（%或MOD）、幂（^）。<br>加减乘除 <code>1+2-3*4/2</code>、<code>1+2-3*4DIV2</code><br>求余 <code>4%3</code>、<code>4MOD 3</code><br>幂运算 <code>2^3</code></p>
<p>比较运算表达式</p>
<p>不等于 !=或ne 1!= 1或 1ne 1<br>等于 ==或eq 1== 1或 1eq 1<br>大于等于 &gt;=或ge 1&gt;= 1或 1ge 1<br>小于等于 &lt;=或le 1&lt;= 1或 1le 1<br>大于 &gt;或gt 1&gt; 1或 1gt 1<br>小于 &lt;或lt 1&lt; 1或 1lt 1<br>区间 between 1 between {1, 2}</p>
<p>逻辑运算表达式<br>与 AND true AND true<br>或 OR true OR true<br>非 NOT NOT true</p>
<p>字符串连接及截取表达式<br>连接 + ‘Hello’ + ‘World !’<br>截取一个字符 string[index] ‘Hello World’[0]</p>
<p>三目运算及Elivis运算表达式<br>三目运算符 表达式1?表达式2:表达式3 2&gt;1?true:false<br>Elivis运算 表达式1?:表达式2 null? :false或true?:false</p>
<p>正则表达式<br>正则表达式 matches ‘123’ matches ‘\d{3}’</p>
<h4 id="类相关表达式">类相关表达式</h4><ul>
<li>类类型表达式</li>
<li>类实例化表达式</li>
<li>instanceof表达式</li>
<li>变量定义及引用</li>
<li>自定义函数</li>
<li>赋值表达式</li>
<li>对象属性存取及安全导航表达式<ul>
<li>访问root对象属性</li>
<li>安全访问</li>
<li>给root对象属性赋值</li>
</ul>
</li>
<li>对象方法调用</li>
<li>Bean引用</li>
</ul>
<p>类类型表达式</p>
<p>使用”T(Type)”来表示java.lang.Class实例，”Type”必须是类全限定名（java.lang包除外）。使用类类型表达式还可以进行访问类静态方法及类静态字段。</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>java.lang包类访问</td>
<td>T(String)</td>
</tr>
<tr>
<td>其他包的类访问</td>
<td>T(foo.bar.spel.SpELTest)</td>
</tr>
<tr>
<td>类静态字段访问</td>
<td>T(Integer).MAX_VALUE</td>
</tr>
<tr>
<td>类静态方法调用</td>
<td>T(Integer).parseInt(‘1’)</td>
</tr>
</tbody>
</table>
<p>类实例化表达式</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>java.lang包类的实例化</td>
<td>new String(‘hello’)</td>
</tr>
<tr>
<td>其他包的类实例化</td>
<td>new java.util.Date()</td>
</tr>
</tbody>
</table>
<p>instanceof</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java内使用同义</td>
<td>‘hello’ instanceof T(String)</td>
</tr>
</tbody>
</table>
<p>变量定义与引用</p>
<p>变量定义通过EvaluationContext接口的setVariable(variableName, value)方法定义；在表达式中使用“#variableName”引用；除了引用自定义变量，SpEL还允许引用根对象及当前上下文对象，使用 “#root”引用根对象，使用“#this”引用当前上下文对象。“#this”引用当前上下文对象，此处“#this”即根对象。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">publicvoid testVariableExpression<span class="params">()</span> &#123; </span><br><span class="line">   ExpressionParser parser =new SpelExpressionParser<span class="params">()</span>; </span><br><span class="line">   EvaluationContext context =new StandardEvaluationContext<span class="params">()</span>; </span><br><span class="line">   context.setVariable<span class="params">(<span class="string">"variable"</span>,<span class="string">"hello"</span>)</span>; </span><br><span class="line">   context.setVariable<span class="params">(<span class="string">"variable"</span>,<span class="string">"world"</span>)</span>;</span><br><span class="line">   </span><br><span class="line">   String result1 = parser.parseExpression<span class="params">(<span class="string">"#variable"</span>)</span>.getValue<span class="params">(context, String.class)</span>; </span><br><span class="line">   Assert.assertEquals<span class="params">(<span class="string">"world"</span>, result1)</span>; </span><br><span class="line">  </span><br><span class="line">   context =new StandardEvaluationContext<span class="params">(<span class="string">"hello"</span>)</span>; </span><br><span class="line">   String result2 = parser.parseExpression<span class="params">(<span class="string">"#root"</span>)</span>.getValue<span class="params">(context, String.class)</span>; </span><br><span class="line">   Assert.assertEquals<span class="params">(<span class="string">"hello"</span>, result2)</span>;</span><br><span class="line">   </span><br><span class="line">   String result3 = parser.parseExpression<span class="params">(<span class="string">"#this"</span>)</span>.getValue<span class="params">(context, String.class)</span>; </span><br><span class="line">   Assert.assertEquals<span class="params">(<span class="string">"hello"</span>, result3)</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义函数</p>
<p>目前只支持类静态方法注册为自定义函数；SpEL使用StandardEvaluationContext的registerFunction方法进行注册自定义函数，其实完全可以使用setVariable代替，两者其实本质是一样的。<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Test</span></span><br><span class="line">publicvoid testFunctionExpression<span class="literal">()</span>throws <span class="type">SecurityException</span>, <span class="type">NoSuchMethodException</span> &#123;</span><br><span class="line">    <span class="type">ExpressionParser</span> <span class="keyword">parser</span> = <span class="keyword">new</span> <span class="type">SpelExpressionParser</span><span class="literal">()</span>;</span><br><span class="line">    <span class="type">StandardEvaluationContext</span> context = <span class="keyword">new</span> <span class="type">StandardEvaluationContext</span><span class="literal">()</span>;</span><br><span class="line">    <span class="type">Method</span> parseInt = <span class="type">Integer</span>.<span class="keyword">class</span>.getDeclaredMethod(<span class="string">"parseInt"</span>, <span class="type">String</span>.<span class="keyword">class</span>);</span><br><span class="line">    context.registerFunction(<span class="string">"parseInt"</span>, parseInt);</span><br><span class="line">    context.setVariable(<span class="string">"parseInt2"</span>, parseInt);</span><br><span class="line">    <span class="type">String</span> expression1 = <span class="string">"#parseInt('3') == #parseInt2('3')"</span>;</span><br><span class="line">    boolean result1 = <span class="keyword">parser</span>.parseExpression(expression1).getValue(context,boolean.<span class="keyword">class</span>);</span><br><span class="line">    <span class="type">Assert</span>.assertEquals(<span class="literal">true</span>, result1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>赋值表达式</p>
<p>SpEL即允许给自定义变量赋值，也允许给跟对象赋值，直接使用“#variableName=value”即可赋值：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">publicvoid testAssignExpression<span class="params">()</span> &#123;</span><br><span class="line">    ExpressionParser parser = new SpelExpressionParser<span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 1.给root对象赋值</span></span><br><span class="line">    EvaluationContext context = new StandardEvaluationContext<span class="params">(<span class="string">"aaaa"</span>)</span>;</span><br><span class="line">    String result1 = parser.parseExpression<span class="params">(<span class="string">"#root='aaaaa'"</span>)</span>.getValue<span class="params">(context, String.class)</span>;</span><br><span class="line">    Assert.assertEquals<span class="params">(<span class="string">"aaaaa"</span>, result1)</span>;</span><br><span class="line">    String result2 = parser.parseExpression<span class="params">(<span class="string">"#this='aaaa'"</span>)</span>.getValue<span class="params">(context, String.class)</span>;</span><br><span class="line">    Assert.assertEquals<span class="params">(<span class="string">"aaaa"</span>, result2)</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 2.给自定义变量赋值</span></span><br><span class="line">    context.setVariable<span class="params">(<span class="string">"#variable"</span>,<span class="string">"variable"</span>)</span>;</span><br><span class="line">    String result3 = parser.parseExpression<span class="params">(<span class="string">"#variable=#root"</span>)</span>.getValue<span class="params">(context, String.class)</span>;</span><br><span class="line">    Assert.assertEquals<span class="params">(<span class="string">"aaaa"</span>, result3)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对象属性存取及安全导航表达式</p>
<p>对象属性获取非常简单，即使用如“a.property.property”这种点缀式获取，SpEL对于属性名首字母是不区分大小写的。</p>
<p>给对象属性赋值可以采用赋值表达式或Expression接口的setValue方法赋值，而且也可以采用点缀方式赋值。</p>
<p>SpEL还引入了Groovy语言中的安全导航运算符“(对象|属性)?.属性”，用来避免当“?.”前边的表达式为null时抛出空指针异常，而是返回null。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser =new SpelExpressionParser<span class="params">()</span>;</span><br><span class="line"><span class="comment">// ===============访问root对象属性 ===============</span></span><br><span class="line">Date date =new Date<span class="params">()</span>;</span><br><span class="line">StandardEvaluationContext context =new StandardEvaluationContext<span class="params">(date)</span>;</span><br><span class="line">int result1 = parser.parseExpression<span class="params">(<span class="string">"Year"</span>)</span>.getValue<span class="params">(context,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(date.getYear<span class="params">()</span>, result1)</span>;</span><br><span class="line">int result2 = parser.parseExpression<span class="params">(<span class="string">"year"</span>)</span>.getValue<span class="params">(context,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(date.getYear<span class="params">()</span>, result2)</span>;</span><br><span class="line"><span class="comment">// ===============安全访问 ===============</span></span><br><span class="line">context.setRootObject<span class="params">(null)</span>; </span><br><span class="line">Object result3 = parser.parseExpression<span class="params">(<span class="string">"#root?.year"</span>)</span>.getValue<span class="params">(context, Object.class)</span>; </span><br><span class="line">Assert.assertEquals<span class="params">(null, result3)</span>;</span><br><span class="line"><span class="comment">// ===============给root对象属性赋值 ===============</span></span><br><span class="line">context.setRootObject<span class="params">(date)</span>;</span><br><span class="line">int result4 = parser.parseExpression<span class="params">(<span class="string">"Year = 4"</span>)</span>.getValue<span class="params">(context,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">4</span>, result4)</span>;</span><br><span class="line">parser.parseExpression<span class="params">(<span class="string">"Year"</span>)</span>.setValue<span class="params">(context, <span class="number">5</span>)</span>;</span><br><span class="line">int result5 = parser.parseExpression<span class="params">(<span class="string">"Year"</span>)</span>.getValue<span class="params">(context,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">5</span>, result5)</span>;</span><br></pre></td></tr></table></figure></p>
<p>对象方法调用</p>
<p>对象方法调用更简单，跟Java语法一样；如“’helo’.substring(2,4)”将返回“lo”。对于根对象可以直接调用方法。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser <span class="subst">=</span><span class="literal">new</span> SpelExpressionParser();</span><br><span class="line"><span class="comment">// ===============直接调用对象方法 ===============</span></span><br><span class="line"><span class="built_in">String</span> result1 <span class="subst">=</span> parser<span class="built_in">.</span>parseExpression(<span class="string">"'hello'.substring(3)"</span>)<span class="built_in">.</span>getValue(<span class="built_in">String</span><span class="built_in">.</span>class);</span><br><span class="line">Assert<span class="built_in">.</span>assertEquals(<span class="string">"lo"</span>, result1);</span><br><span class="line"><span class="comment">// ===============调用上下文root对象方法 ===============</span></span><br><span class="line"><span class="built_in">Date</span> <span class="built_in">date</span> <span class="subst">=</span><span class="literal">new</span> <span class="built_in">Date</span>();</span><br><span class="line">StandardEvaluationContext context <span class="subst">=</span><span class="literal">new</span> StandardEvaluationContext(<span class="built_in">date</span>); </span><br><span class="line">int result2 <span class="subst">=</span> parser<span class="built_in">.</span>parseExpression(<span class="string">"getYear()"</span>)<span class="built_in">.</span>getValue(context,int<span class="built_in">.</span>class); </span><br><span class="line">Assert<span class="built_in">.</span>assertEquals(<span class="built_in">date</span><span class="built_in">.</span>getYear(), result2);</span><br></pre></td></tr></table></figure>
<p>Bean引用</p>
<p>SpEL支持使用“@”符号来引用Bean，在引用Bean时需要使用BeanResolver接口实现来查找Bean，Spring提供BeanFactoryResolver实现。</p>
<p>在示例中首先初始化了一个IoC容器，ClassPathXmlApplicationContext 实现默认会把“System.getProperties()”注册为“systemProperties”Bean，因此使用 “@systemProperties”来引用该Bean。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Test</span> </span><br><span class="line">publicvoid testBeanExpression<span class="literal">()</span> &#123; </span><br><span class="line">   <span class="type">ClassPathXmlApplicationContext</span> ctx =<span class="keyword">new</span> <span class="type">ClassPathXmlApplicationContext</span><span class="literal">()</span>; </span><br><span class="line">    ctx.refresh<span class="literal">()</span>; </span><br><span class="line">   <span class="type">ExpressionParser</span> <span class="keyword">parser</span> =<span class="keyword">new</span> <span class="type">SpelExpressionParser</span><span class="literal">()</span>; </span><br><span class="line">   <span class="type">StandardEvaluationContext</span> context =<span class="keyword">new</span> <span class="type">StandardEvaluationContext</span><span class="literal">()</span>; </span><br><span class="line">   context.setBeanResolver(<span class="keyword">new</span> <span class="type">BeanFactoryResolver</span>(ctx)); </span><br><span class="line">   <span class="type">Properties</span> result1 = <span class="keyword">parser</span>.parseExpression(<span class="string">"@systemProperties"</span>).getValue(context, <span class="type">Properties</span>.<span class="keyword">class</span>); </span><br><span class="line">    <span class="type">Assert</span>.assertEquals(<span class="type">System</span>.getProperties<span class="literal">()</span>, result1); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="集合相关表达式">集合相关表达式</h4><ul>
<li>内联List</li>
<li>内联Array</li>
<li>Collection，Map元素访问</li>
<li>Collection、Map、Array元素修改</li>
<li>集合投影</li>
<li>集合选择</li>
</ul>
<p>内联List</p>
<p>从Spring3.0.4开始支持内联List，使用{表达式，……}定义内联List。如“{1,2,3}”将返回一个整型的ArrayList，而“{}”将返回空的List，对于字面量表达式列表，SpEL会使用java.util.Collections.unmodifiableList方法将列表设置为不可修改。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将返回不可修改的空List </span></span><br><span class="line"><span class="built_in">List</span>&lt;Integer&gt; result2 = parser.parseExpression(<span class="string">"&#123;&#125;"</span>).getValue(<span class="built_in">List</span>.<span class="keyword">class</span>);</span><br><span class="line"><span class="comment">//对于列表中只要有一个不是字面量表达式，将只返回原始List，不会进行不可修改处理</span></span><br><span class="line"><span class="built_in">String</span> expression3 = <span class="string">"&#123; &#123;1 + 2,2 + 4&#125;, &#123;3, 4 + 4&#125; &#125;"</span>;</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; result3 = parser.parseExpression(expression3).getValue(<span class="built_in">List</span>.<span class="keyword">class</span>);</span><br><span class="line">result3.<span class="literal">get</span>(<span class="number">0</span>).<span class="literal">set</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result3.size());</span><br></pre></td></tr></table></figure>
<p>内联Array</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//声明一维数组并初始化值 </span><br><span class="line">int[] result2 = parser.parseExpression("new int[]&#123;1,2&#125;").getValue(int[].class);</span><br><span class="line">Assert.assertEquals(result2[0], 1);</span><br><span class="line">//定义多维数组但不初始化（定义多维数组不能初始化）</span><br><span class="line">int[<span class="link_label"></span>][<span class="link_reference"></span>][<span class="link_label"></span>] result3 = parser.parseExpression("new int[<span class="link_label">2</span>][<span class="link_reference">2</span>][<span class="link_label">2</span>]").getValue(int[<span class="link_label"></span>][<span class="link_reference"></span>][<span class="link_label"></span>].class);</span><br></pre></td></tr></table></figure>
<p>集合，字典元素访问</p>
<p>SpEL目前支持所有集合类型和字典类型的元素访问，使用“集合[索引]”访问集合元素，使用“map[key]”访问字典元素。<br>集合元素访问是通过Iterator遍历来定位元素位置的。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpEL内联List访问</span></span><br><span class="line">int result1 = parser.parseExpression<span class="params">(<span class="string">"&#123;1,2,3&#125;[0]"</span>)</span>.getValue<span class="params">(int.class)</span>;</span><br><span class="line"><span class="comment">//即list.get(0)</span></span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">1</span>, result1)</span>;</span><br><span class="line"><span class="comment">// SpEL目前支持所有集合类型的访问</span></span><br><span class="line">Collection&lt;Integer&gt; collection =new HashSet&lt;Integer&gt;<span class="params">()</span>;</span><br><span class="line">collection.add<span class="params">(<span class="number">1</span>)</span>;</span><br><span class="line">collection.add<span class="params">(<span class="number">2</span>)</span>;</span><br><span class="line">EvaluationContext context2 =new StandardEvaluationContext<span class="params">()</span>;</span><br><span class="line">context2.setVariable<span class="params">(<span class="string">"collection"</span>, collection)</span>;</span><br><span class="line">int result2 = parser.parseExpression<span class="params">(<span class="string">"#collection[1]"</span>)</span>.getValue<span class="params">(context2,int.class)</span>;</span><br><span class="line"><span class="comment">//对于任何集合类型通过Iterator来定位元素</span></span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">2</span>, result2)</span>;</span><br><span class="line"><span class="comment">// SpEL对Map字典元素访问的支持</span></span><br><span class="line">Map&lt;String, Integer&gt; map =new HashMap&lt;String, Integer&gt;<span class="params">()</span>;</span><br><span class="line">map.put<span class="params">(<span class="string">"a"</span>, <span class="number">1</span>)</span>;</span><br><span class="line">EvaluationContext context3 =new StandardEvaluationContext<span class="params">()</span>;</span><br><span class="line">context3.setVariable<span class="params">(<span class="string">"map"</span>, map)</span>;</span><br><span class="line">int result3 = parser.parseExpression<span class="params">(<span class="string">"#map['a']"</span>)</span>.getValue<span class="params">(context3,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">1</span>, result3)</span>;</span><br></pre></td></tr></table></figure></p>
<p>列表，字典，数组元素修改</p>
<p>可以使用赋值表达式或Expression接口的setValue方法修改。对数组修改直接对“#array[index]”赋值即可修改元素值，同理适用于集合和字典类型。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ===============修改数组元素值 ===============</span></span><br><span class="line">int[] array =newint[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">EvaluationContext context1 =new StandardEvaluationContext<span class="params">()</span>;</span><br><span class="line">context1.setVariable<span class="params">(<span class="string">"array"</span>, array)</span>;</span><br><span class="line">int result1 = parser.parseExpression<span class="params">(<span class="string">"#array[1] = 3"</span>)</span>.getValue<span class="params">(context1,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">3</span>, result1)</span>;</span><br><span class="line"><span class="comment">// ===============修改集合值 ===============</span></span><br><span class="line">Collection&lt;Integer&gt; collection =new ArrayList&lt;Integer&gt;<span class="params">()</span>;</span><br><span class="line">collection.add<span class="params">(<span class="number">1</span>)</span>;</span><br><span class="line">collection.add<span class="params">(<span class="number">2</span>)</span>;</span><br><span class="line">EvaluationContext context2 =new StandardEvaluationContext<span class="params">()</span>;</span><br><span class="line">context2.setVariable<span class="params">(<span class="string">"collection"</span>, collection)</span>;</span><br><span class="line">int result2 = parser.parseExpression<span class="params">(<span class="string">"#collection[1] = 3"</span>)</span>.getValue<span class="params">(context2,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">3</span>, result2)</span>;</span><br><span class="line">parser.parseExpression<span class="params">(<span class="string">"#collection[1]"</span>)</span>.setValue<span class="params">(context2, <span class="number">4</span>)</span>;</span><br><span class="line">result2 = parser.parseExpression<span class="params">(<span class="string">"#collection[1]"</span>)</span>.getValue<span class="params">(context2,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">4</span>, result2)</span>;</span><br><span class="line"><span class="comment">// ===============修改map元素值 ===============</span></span><br><span class="line">Map&lt;String, Integer&gt; map =new HashMap&lt;String, Integer&gt;<span class="params">()</span>;</span><br><span class="line">map.put<span class="params">(<span class="string">"a"</span>, <span class="number">1</span>)</span>;</span><br><span class="line">EvaluationContext context3 =new StandardEvaluationContext<span class="params">()</span>;</span><br><span class="line">context3.setVariable<span class="params">(<span class="string">"map"</span>, map)</span>;</span><br><span class="line">int result3 = parser.parseExpression<span class="params">(<span class="string">"#map['a'] = 2"</span>)</span>.getValue<span class="params">(context3,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">2</span>, result3)</span>;</span><br></pre></td></tr></table></figure></p>
<p>集合投影</p>
<p>在SQL中投影指从表中选择出列，而在SpEL指根据集合中的元素中通过选择来构造另一个集合，该集合和原集合具有相同数量的元素；SpEL使用“（list|map）.![投影表达式]”来进行投影运算：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Collection<span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;</span> collection <span class="subst">=</span><span class="literal">new</span> ArrayList<span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;</span>();</span><br><span class="line">collection<span class="built_in">.</span>add(<span class="number">4</span>);</span><br><span class="line">collection<span class="built_in">.</span>add(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// =============== 测试集合或数组 ===============</span></span><br><span class="line">EvaluationContext context1 <span class="subst">=</span><span class="literal">new</span> StandardEvaluationContext();</span><br><span class="line">context1<span class="built_in">.</span>setVariable(<span class="string">"collection"</span>, collection);</span><br><span class="line">Collection<span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;</span> result1 <span class="subst">=</span> parser<span class="built_in">.</span>parseExpression(<span class="string">"#collection.![#this+1]"</span>)<span class="built_in">.</span>getValue(context1, Collection<span class="built_in">.</span>class);</span><br><span class="line">Assert<span class="built_in">.</span>assertEquals(<span class="number">2</span>, result1<span class="built_in">.</span>size());</span><br><span class="line">Assert<span class="built_in">.</span>assertEquals(<span class="literal">new</span> <span class="built_in">Integer</span>(<span class="number">5</span>), result1<span class="built_in">.</span>iterator()<span class="built_in">.</span>next());</span><br><span class="line">对于集合或数组使用如上表达式进行投影运算，其中投影表达式中“<span class="variable">#this</span>”代表每个集合或数组元素，可以使用比如“<span class="variable">#this.property</span>”来获取集合元素的属性，其中“<span class="variable">#this</span>”可以省略。</span><br><span class="line"><span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span> <span class="built_in">map</span> <span class="subst">=</span><span class="literal">new</span> HashMap<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span>();</span><br><span class="line"><span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"b"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// ===============测试Map =============== </span></span><br><span class="line">EvaluationContext context2 <span class="subst">=</span><span class="literal">new</span> StandardEvaluationContext(); </span><br><span class="line">context2<span class="built_in">.</span>setVariable(<span class="string">"map"</span>, <span class="built_in">map</span>); </span><br><span class="line"><span class="built_in">List</span><span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;</span> result2 <span class="subst">=</span> </span><br><span class="line">parser<span class="built_in">.</span>parseExpression(<span class="string">"#map.![value+1]"</span>)<span class="built_in">.</span>getValue(context2, <span class="built_in">List</span><span class="built_in">.</span>class); </span><br><span class="line">Assert<span class="built_in">.</span>assertEquals(<span class="number">2</span>, result2<span class="built_in">.</span>size());</span><br></pre></td></tr></table></figure></p>
<p>SpEL投影运算还支持Map投影，但Map投影最终只能得到List结果，如上所示，对于投影表达式中的“#this”将是Map.Entry，所以可以使用“value”来获取值，使用“key”来获取键。</p>
<p>集合选择</p>
<p>在SQL中指使用select进行选择行数据，而在SpEL指根据原集合通过条件表达式选择出满足条件的元素并构造为新的集合，SpEL使用“(list|map).?[选择表达式]”，其中选择表达式结果必须是boolean类型，如果true则选择的元素将添加到新集合中，false将不添加到新集合中。<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;<span class="typename">Integer</span>&gt; collection =<span class="keyword">new</span> ArrayList&lt;<span class="typename">Integer</span>&gt;();</span><br><span class="line">collection.add(<span class="number">4</span>);</span><br><span class="line">collection.add(<span class="number">5</span>);</span><br><span class="line">// ===============集合或数组测试 ==============</span><br><span class="line">EvaluationContext context1 =<span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">context1.setVariable(<span class="string">"collection"</span>, collection);</span><br><span class="line">Collection&lt;<span class="typename">Integer</span>&gt; result1 = parser.parseExpression(<span class="string">"#collection.?[#this&gt;4]"</span>).getValue(context1, Collection.class);</span><br><span class="line"><span class="keyword">Assert</span>.assertEquals(<span class="number">1</span>, result1.size());</span><br><span class="line"><span class="keyword">Assert</span>.assertEquals(<span class="keyword">new</span> <span class="typename">Integer</span>(<span class="number">5</span>), result1.iterator().<span class="keyword">next</span>());</span><br><span class="line"><span class="keyword">Map</span>&lt;<span class="typename">String</span>, <span class="typename">Integer</span>&gt; <span class="keyword">map</span> =<span class="keyword">new</span> HashMap&lt;<span class="typename">String</span>, <span class="typename">Integer</span>&gt;();</span><br><span class="line"><span class="keyword">map</span>.put(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">map</span>.put(<span class="string">"b"</span>, <span class="number">2</span>);</span><br><span class="line">// =============== <span class="keyword">Map</span>测试 ==============</span><br><span class="line">EvaluationContext context2 =<span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">context2.setVariable(<span class="string">"map"</span>, <span class="keyword">map</span>);</span><br><span class="line"><span class="keyword">Map</span>&lt;<span class="typename">String</span>, <span class="typename">Integer</span>&gt; result2 = parser.parseExpression(<span class="string">"#map.?[#this.key != 'a']"</span>).getValue(context2, <span class="keyword">Map</span>.class);</span><br><span class="line"><span class="keyword">Assert</span>.assertEquals(<span class="number">1</span>, result2.size());</span><br><span class="line"> </span><br><span class="line">List&lt;<span class="typename">Integer</span>&gt; result3 = parser.parseExpression(<span class="string">"#map.?[key != 'a'].![value+1]"</span>).getValue(context2, List.class);</span><br><span class="line"><span class="keyword">Assert</span>.assertEquals(<span class="keyword">new</span> <span class="typename">Integer</span>(<span class="number">3</span>), result3.iterator().<span class="keyword">next</span>());</span><br></pre></td></tr></table></figure></p>
<p>对于Map选择，如“#map.?[#this.key != ‘a’]”将选择键值不等于”a”的，其中选择表达式中“#this”是Map.Entry类型，而最终结果还是Map，这点和投影不同；集合选择和投影可以一起使用，如“#map.?[key != ‘a’].![value+1]”将首先选择键值不等于”a”的，然后在选出的Map中再进行“value+1”的投影。</p>
<h4 id="表达式模板">表达式模板</h4><p>模板表达式就是由字面量与一个或多个表达式块组成。每个表达式块由“前缀+表达式+后缀”形式组成，如“${1+2}”即表达式块。在前边我们已经介绍了使用ParserContext接口实现来定义表达式是否是模板及前缀和后缀定义。在此就不多介绍了，如“Error ${井v0} ${井v1}”(把<code>井</code>换位<code>#</code>)表达式表示由字面量“Error ”、模板表达式“#v0”、模板表达式“#v1”组成，其中v0和v1表示自定义变量，需要在上下文定义。</p>
]]></content>
    <summary type="html">
    <![CDATA[Spring]]>
    
    </summary>
    
      <category term="Spring" scheme="http://howiefh.github.io/tags/Spring/"/>
    
      <category term="JavaEE" scheme="http://howiefh.github.io/categories/JavaEE/"/>
    
      <category term="Spring" scheme="http://howiefh.github.io/categories/JavaEE/Spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hibernate笔记]]></title>
    <link href="http://howiefh.github.io/2015/03/05/hibernate-note/"/>
    <id>http://howiefh.github.io/2015/03/05/hibernate-note/</id>
    <published>2015-03-05T14:49:08.000Z</published>
    <updated>2015-03-13T02:19:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="对象/关系数据库映射(ORM)">对象/关系数据库映射(ORM)</h2><p>ORM全称是Object/Relation Mapping，对象/关系数据库映射。ORM可理解成一种规范，它概述了这类框架的基本特征：完成面向对象的编程语言到关系数据库的映射。</p>
<a id="more"></a>
<h3 id="ORM基本映射方式">ORM基本映射方式</h3><ul>
<li>数据表映射类：持久化类被映射到一个数据表。</li>
<li>数据表的行映射对象：持久化类会生成很多实例，每个实例就对应数据表中的一行记录。</li>
<li>数据表的列映射对象的属性。</li>
</ul>
<h3 id="流行的ORM框架">流行的ORM框架</h3><ul>
<li>JPA:JPA只是一种ORM规范，并不是ORM产品。提供接口，而不是实现。所以如果面向JPA编程，那么程序即可在各种ORM框架之间自由切换。</li>
<li>Hibernate</li>
<li>iBATIS</li>
<li>TopLink</li>
</ul>
<h2 id="Hibernate入门">Hibernate入门</h2><h3 id="Hibernate下载和安装">Hibernate下载和安装</h3><p>从 <a href="http://hibernate.org" target="_blank" rel="external">http://hibernate.org</a> 进行下载。<br>将hibernate[version].jar和lib路径下的required、bytecode、jpa子目录下所有JAR包添加到应用的类加载路径中。Hibernate底层依然基于JDBC，所以JDBC对应的驱动也要添加到类加载路径中。</p>
<h3 id="Hibernate的数据库操作">Hibernate的数据库操作</h3><p>ORM框架中非常重要的媒介：PO(Persistent Object，持久化对象)。持久化对象的作用是完成持久化操作，简单说，通过该对象可对数据执行增删改查操作—以面向对象的方式操作数据库。</p>
<p>Hibernate使用POJO(普通、传统Java对象)作为PO</p>
<p>News.java</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class News&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Integer</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> title;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> content;</span><br><span class="line">    <span class="comment">//setter 和 getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>News.hbm.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class="line">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span><br><span class="line">"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">hibernate-mapping</span> <span class="attribute">package</span>=<span class="value">"pojo"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每个class元素对应一个持久化对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"News"</span> <span class="attribute">table</span>=<span class="value">"news_table"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id元素定义持久化类的标识属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"id"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定主键生成策略 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"identity"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"title"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"content"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Hibernate配置文件hibernate.cfg.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class="line">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span><br><span class="line">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">session-factory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库所用的驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的url，hibernate连接的数据库名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connection.url"</span>&gt;</span>jdbc:mysql://192.168.0.121/dbname<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的用户名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connection.password"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接池最大连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.c3p0.max_size"</span>&gt;</span>20<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接池最小连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.c3p0.min_size"</span>&gt;</span>1<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接池里最大缓存多少个Statement对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.c3p0.max_statements"</span>&gt;</span>100<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.c3p0.idle_test_period"</span>&gt;</span>3000<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.c3p0.acquire_increment"</span>&gt;</span>2<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.c3p0.validate"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定数据库方言 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQLInnoDBDialect<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 根据需要自动创建数据表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 映射文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">mapping</span> <span class="attribute">class</span>=<span class="value">"pojo.News"</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">ssion-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Hibernate并不推荐DriverManager来连接数据库，而是推荐使用数据源来管理数据库连接，这样能保证更好的性能。Hibernate推荐使用C2P0数据源。</p>
<p>数据源是一种提高数据库连接性能的常规手段，数据源会负责维持一个数据库连接池，当程序创建数据源实例时，系统会一次性地创建多个数据库连接，并把这些数据库连接保存在连接池中，当程序需要进行数据库访问时，无须重新获得数据库连接，而是从连接池中取出一个空闲的数据库连接。当程序使用数据库连接访问数据结束后，无须关闭数据库连接，而是将数据库连接归还给连接池即可，通过这种方式可以避免频繁地获取数据库连接、关闭数据库连接所导致的性能下降。</p>
<p>完成消息的插入操作</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化Configuration, configure方法加载hibernate.cfg.xml文件</span></span><br><span class="line">Configuration conf = new Configuration<span class="params">()</span>.configure<span class="params">()</span>;</span><br><span class="line"><span class="comment">//以Configuration创建SessionFactory</span></span><br><span class="line">SessionFactory sf = conf.buildSessionFactory<span class="params">()</span>;</span><br><span class="line"><span class="comment">//创建Session</span></span><br><span class="line">Session sess = sf.openSession<span class="params">()</span>;</span><br><span class="line"><span class="comment">//开始事务</span></span><br><span class="line">Transaction tx = sess.beginTransaction<span class="params">()</span>;</span><br><span class="line"><span class="comment">//创建消息实例</span></span><br><span class="line">News n = new News<span class="params">()</span>;</span><br><span class="line">n.setTitle<span class="params">(<span class="string">""</span>)</span>;</span><br><span class="line">n.setContent<span class="params">(<span class="string">""</span>)</span>;</span><br><span class="line"><span class="comment">//保存消息</span></span><br><span class="line">sess.save<span class="params">(n)</span>;</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">tx.commit<span class="params">()</span>;</span><br><span class="line"><span class="comment">//关闭session</span></span><br><span class="line">sess.close<span class="params">()</span>;</span><br><span class="line">sf.close<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>PO只有在Session的管理下才可完成数据库访问。为了使用Hibernate进行持久化操作，通常有如下操作步骤。</p>
<ul>
<li>开发持久化类，由POJO加映射文件组成</li>
<li>获取Configuration</li>
<li>获取SessionFactory</li>
<li>获取Session，打开事务 </li>
<li>用面向对象的方式操作数据库</li>
<li>关闭事务，关闭Session</li>
</ul>
<p>随PO与Session的关联关系，PO有如下三种状态    </p>
<ul>
<li>瞬态：PO从未与Session关联</li>
<li>持久化：PO实例与Session关联起来，且该实例对应到数据库记录。</li>
<li>脱管：PO实例曾经与Session关联，但因为Session关闭等原因，PO实例脱离Session的管理。</li>
</ul>
<p><img src="http://fh-1.qiniudn.com/PO_lifecycle.jpg" alt="持久化对象的生命周期"></p>
<p>对PO的操作必须在Session管理下才能同步到数据库。Session由SessionFactory工厂产生，SessionFactory是数据库编译后的内存镜像，通常一个应用对应一个SessionFactory对象。SessionFactory对象由Configuration对象产生，Configuration对象负责加载Hibernate配置文件。</p>
<h3 id="在Eclipse中使用Hibernate">在Eclipse中使用Hibernate</h3><p>Hibernate官方提供HibernateTools插件。</p>
<p>hibernate.cfg.xml文件通常在src目录下。</p>
<p>如果希望显示sql语句，自动建表可以在配置文件hibernate.cfg.xml中添加hibernate.show_sql、hibernate.format_sql和hibernate.hbm2ddl.auto</p>
<h2 id="Hibernate体系结构">Hibernate体系结构</h2><p><img src="http://fh-1.qiniudn.com/hibernate_simple_struct.gif" alt="Hibernate简要体系结构"><br><img src="http://fh-1.qiniudn.com/hibernate_struct.gif" alt="Hibernate全面解决方案体系结构"></p>
<ul>
<li>SessionFactory：这是Hibernate的关键对象，它是单个数据库映射关系经过编译后的内存镜像，它也是线程安全的。它是生成Session的工厂，本身要应用到ConnectionProvider，该对象可以在进程和集群的级别上，为那些事务之间可以重用的数据提供可选的二级缓存。</li>
<li>Session：它是应用程序和持久存储层之间交互操作的一个单线程对象。它也是Hibernate持久化操作的关键对象，所有的持久化对象必须在Session的管理下才能够进行持久化操作。此对象的生存周期很短，其隐藏了JDBC连接，也是Transaction 的工厂。Session对象有一个一级缓存，现实执行Flush之前，所有的持久化操作的数据都在缓存中Session对象处。</li>
<li>持久化对象：系统创建的POJO实例一旦与特定Session关联，并对应数据表的指定记录，那该对象就处于持久化状态，这一系列的对象都被称为持久化对象。程序中对持久化对象的修改，都将自动转换为持久层的修改。持久化对象完全可以是普通的Java Beans/POJO，唯一的特殊性是它们正与Session关联着。</li>
<li>瞬态对象和脱管对象：系统进行new关键字进行创建的Java 实例，没有Session 相关联，此时处于瞬态。瞬态实例可能是在被应用程序实例化后，尚未进行持久化的对象。如果一个曾经持久化过的实例，但因为Session的关闭而转换为脱管状态。</li>
<li>事务(Transaction)：代表一次原子操作，它具有数据库事务的概念。但它通过抽象，将应用程序从底层的具体的JDBC、JTA和CORBA事务中隔离开。在某些情况下，一个Session 之内可能包含多个Transaction对象。虽然事务操作是可选的，但是所有的持久化操作都应该在事务管理下进行，即使是只读操作。</li>
<li>连接提供者(ConnectionProvider)：它是生成JDBC的连接的工厂，同时具备连接池的作用。他通过抽象将底层的DataSource和DriverManager隔离开。这个对象无需应用程序直接访问，仅在应用程序需要扩展时使用。</li>
<li>事务工厂(TransactionFactory)：他是生成Transaction对象实例的工厂。该对象也无需应用程序的直接访问。</li>
</ul>
<h2 id="深入Hibernate的配置文件">深入Hibernate的配置文件</h2><ol>
<li><p>使用hibernate.properties作为配置文件</p>
<p> 需要通过addResource方法添加映射文件<code>new Configuration().addResource(&quot;News.hbm.xml&quot;)</code>。也可以通过addClass()方法添加持久化类<code>new Configuration().addClass(lee.Nuews.class)</code>此时映射文件应该放在类文件相同的包路径下。Hibernate自己会去搜索。</p>
</li>
<li><p>使用hibernate.cfg.xml作为配置文件</p>
<p> hibernate.cfg.xml文件中已经添加了Hibernate映射文件。<code>new Configuration().configure()</code></p>
</li>
<li><p>不用配置文件创建Configuration实例</p>
<p> 使用下面三个方法</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Configuration <span class="function"><span class="title">addResource</span><span class="params">(String resourceName)</span></span></span><br><span class="line">Configuration <span class="function"><span class="title">setProperties</span><span class="params">(Properties properties)</span></span></span><br><span class="line">Configuration <span class="function"><span class="title">setProperty</span><span class="params">(String propertyName, String value)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="JDBC连接属性">JDBC连接属性</h3><p>所有Hibernate属性的名字和语义都在org.hibernate.cfg.Environment中定义。</p>
<ul>
<li>hibernate.connection.driver_class：指定连接数据库所用的驱动。</li>
<li>hibernate.connection.url：指定连接数据库的url，hibernate连接的数据库名。</li>
<li>hibernate.connection.username：该属性是可选的。</li>
<li>hibernate.connection.passowrd：该属性是可选的。</li>
<li>hibernate.connection.pool_size：设置Hibernate数据库连接池的最大并发连接数。</li>
<li>hibernate.dialect：设置连接数据库所使用的方言。</li>
</ul>
<p>Hibernate自带的连接池仅有测试价值，实际项目中使用C3P0或Proxool连接池。</p>
<h3 id="数据库方言">数据库方言</h3><table>
<thead>
<tr>
<th>关系型数据库</th>
<th>方言</th>
</tr>
</thead>
<tbody>
<tr>
<td>DB2</td>
<td>org.hibernate.dialect.DB2Dialect</td>
</tr>
<tr>
<td>DB2 AS/400</td>
<td>org.hibernate.dialect.DB2400Dialect</td>
</tr>
<tr>
<td>DB2 OS390</td>
<td>org.hibernate.dialect.DB2390Dialect</td>
</tr>
<tr>
<td>PostgreSQL</td>
<td>org.hibernate.dialect.PostgreSQLDialect</td>
</tr>
<tr>
<td>MySQL</td>
<td>org.hibernate.dialect.MySQLDialect</td>
</tr>
<tr>
<td>MySQL with InnoDB</td>
<td>org.hibernate.dialect.MySQLInnoDBDialect</td>
</tr>
<tr>
<td>MySQL with MyISAM</td>
<td>org.hibernate.dialect.MySQLMyISAMDialect</td>
</tr>
<tr>
<td>Oracle (any version)</td>
<td>org.hibernate.dialect.OracleDialect</td>
</tr>
<tr>
<td>Oracle 9i</td>
<td>org.hibernate.dialect.Oracle9iDialect</td>
</tr>
<tr>
<td>Oracle 10g</td>
<td>org.hibernate.dialect.Oracle10gDialect</td>
</tr>
<tr>
<td>Sybase</td>
<td>org.hibernate.dialect.SybaseDialect</td>
</tr>
<tr>
<td>Sybase Anywhere</td>
<td>org.hibernate.dialect.SybaseAnywhereDialect</td>
</tr>
<tr>
<td>Microsoft SQL Server</td>
<td>org.hibernate.dialect.SQLServerDialect</td>
</tr>
<tr>
<td>SAP DB</td>
<td>org.hibernate.dialect.SAPDBDialect</td>
</tr>
<tr>
<td>Informix</td>
<td>org.hibernate.dialect.InformixDialect</td>
</tr>
<tr>
<td>HypersonicSQL</td>
<td>org.hibernate.dialect.HSQLDialect</td>
</tr>
<tr>
<td>Ingres</td>
<td>org.hibernate.dialect.IngresDialect</td>
</tr>
<tr>
<td>Progress</td>
<td>org.hibernate.dialect.ProgressDialect</td>
</tr>
<tr>
<td>Mckoi SQL</td>
<td>org.hibernate.dialect.MckoiDialect</td>
</tr>
<tr>
<td>Interbase</td>
<td>org.hibernate.dialect.InterbaseDialect</td>
</tr>
<tr>
<td>Pointbase</td>
<td>org.hibernate.dialect.PointbaseDialect</td>
</tr>
<tr>
<td>FrontBase</td>
<td>org.hibernate.dialect.FrontbaseDialect</td>
</tr>
<tr>
<td>Firebird</td>
<td>org.hibernate.dialect.FirebirdDialect</td>
</tr>
</tbody>
</table>
<h3 id="JNDI数据源的连接属性">JNDI数据源的连接属性</h3><p>JNDI: Java Naming Directory Interface,Java命名目录接口。</p>
<ul>
<li>hibernate.connection.datasource：指定数据源JNDI名字。</li>
<li>hibernate.jndi.url：指定JNDI提供者的URL，该属性是可选的。如果JNDI与HIbernate持久化访问的代码处在同一个应用中。则无须指定该属性。</li>
<li>hibernate.jndi.class：指定JND InitialContextFactory的实现类，该属性也是可选的。如果JNDI与HIbernate持久化访问的代码处在同一个应用中。则无须指定该属性。</li>
<li>hibernate.connection.username：该属性是可选的。</li>
<li>hibernate.connection.passowrd：该属性是可选的。</li>
</ul>
<p>虽然设置数据库方言并不是必需的，但对于优化持久层访问很有必要。</p>
<h3 id="Hibernate事务属性">Hibernate事务属性</h3><ul>
<li>hibernate.transaction.factory_class:指定Hibernate所用的事务工厂的类型，该属性值必须是TransactionFactory的直接或间接子类。</li>
<li>jta.UserTransaction：该属性值是一个JNDI名，Hibernate将使用JTATransactionFactory从应用服务器获取JTA UserTransaction。</li>
<li>hibernate.transaction.manager_lookup_class：该属性值应为一个TransactionManagerLookup类名，当使用JVM级别的缓存时，或在JTA环境中使用hilo生成器策略时，需要该类。</li>
<li>hibernate.transaction.flush_before_completion：指定Session是否在事务完成后自动将数据刷新到底层受苦。该属性值只能为true或false。现在更好的方法是使用Context相关的Session管理。</li>
<li>hibernate.transaction.auto_close_session：指定是否在事务结束后自动关闭Session。该属性只能是true或false。现在更好的方法是使用Context相关的Session管理。</li>
</ul>
<h3 id="二级缓存相关属性">二级缓存相关属性</h3><ul>
<li>hibernate.cache.provider_class：该属性用于设置二级缓存CacheProvider的类名</li>
<li>hibernate.cache.user_minimal_puts：</li>
<li>hibernate.cache.use_second_level_cache：</li>
<li>hibernate.cache.query_cache_factory：</li>
<li>hibernate.cache.region_prefix：</li>
<li>hibernate.cache.use_structured_entries：</li>
</ul>
<h3 id="外连接抓取属性">外连接抓取属性</h3><p>将hibernate.max_fetch_depth设为0，将在全局范围内禁止外连接抓取，设为1或更高值能启用N-1或1-1的外连接抓取。除此之外，还应该在映射文件中通过fetch=”join”来指定这种外连接抓取。</p>
<h3 id="其他常用的配置属性">其他常用的配置属性</h3><ul>
<li>hibernate.show_sql：是否在控制台打印Hibernate生成的sql语句。</li>
<li>hibernate.format_sql：是否将SQL语句格式化。</li>
<li>hibernate.use_sql_comments：是否在Hibernate生成的SQL语句中添加有助于调试的注释。前三个取值只能是true或false</li>
<li>hibernate.jdbc.fetch_size：指定JDBC抓取数量的大小，它可接受一个整数值，其实质是调用Statement.setFetchSize()方法</li>
<li>hibernate.jdbc.batch_size：指定Hibernate使用JDBC2的批量更新的大小，它接受一个整数值，建议取5到30之间的值。</li>
<li>hibernate.connection.autocommit：设置是否自动提交。通常不建议打开自动提交。</li>
<li>hibernate.hbm2ddl.auto：设置当创建SessionFactory时，是否根据映射文件自动建立数据库表。如果使用create-drop值，显示关闭SessionFactory时，将Drop刚建的数据表。该属性可以为update、create和create-drop三个值。</li>
</ul>
<h2 id="深入理解持久化对象">深入理解持久化对象</h2><h3 id="持久化类的要求">持久化类的要求</h3><ul>
<li>提供一个无参数的构造器</li>
<li>提供一个标识属性，标识属性通常映射数据库表的主键字段。可以是任何名字，可以使用基本类型及其包装类，java.lang.String，java.util.Date。如果是联合主键，甚至可以用一个用户自定义的类，也可以不指定任何标识属性，而在配置文件中将多个普通类型映射成一个联合主键，但通常不推荐这么做。主键建议使用包装类型而不是基本类型。</li>
<li>没有标识可能导致Hibernate很多功能没法使用。Hibernate建议使用可以为空的类型来作为标识属性的类型，因此应该尽量避免使用基本数据类型。</li>
<li>为持久化类的每个属性提供setter和getter方法。Hibernate默认采用属性方式访问持久化类的属性。setX、getX、isX是被认可的。</li>
<li>使用非final的类。同时应避免在非final类中声明public final的方法。如果有这种方法，必须通过设置lazy=”false”来明确地禁用代理。</li>
<li>重写equals()和hashCode()方法。需要放入Set中（当进行关联映射时，推荐这么做），通常是使用判断标志值的方法。遗憾的是，对采用自动生成标识的对象不能使用这种方法。Hibernate仅为那些持久化对象指定标识值，一个新创建的实例将不会有任何标识值，通过保存一个对象将会给它赋标识值。如果equals()和hashCode()是基于标识值的，则其hashCode返回值会发生改变，这将违反Set规则。当我们想要重用脱管实例时，该实例所属的持久化类也应该重写equals()和hashCode()</li>
</ul>
<h3 id="持久化对象的状态">持久化对象的状态</h3><ul>
<li>瞬态：对象由new操作符创建，且尚未与Hibernate Session 关联的对象。不会被持久化到数据库中，也不会被赋予持久化标识。使用Hibernate Session可以将其变为持久化状态。</li>
<li>持久化：实例对应到数据库记录，并拥有一个持久化标识。持久化对象可以是刚刚保存的也可以是刚加载的，必须与指定的Hibernate Session关联。Hibernate会检测到处于持久化状态对象的改动，在当前操作执行完成时将对象数据写会数据库，不需要手动update。</li>
<li>脱管：某个实例曾经处于持久化状态，但随着与之关联的Session关闭，该对象处于脱管状态。</li>
</ul>
<p><img src="http://fh-1.qiniudn.com/PO_lifecycle.jpg" alt="持久化对象的状态演化图"></p>
<h3 id="改变持久化对象状态的方法">改变持久化对象状态的方法</h3><p>save()和persist()方法</p>
<ol>
<li>如果News的标识属性是generated，也就是说指定了主键生成器，那么Hibernate将会在执行save方法时自动生成标识属性值，并将该标识属性值分配给该News对象。</li>
<li>如果News的标识属性是assigned类型的，或者是联合主键，那么该标识属性值应当在调用save之前手动赋给News对象。</li>
</ol>
<p>Hibernate之所以提供与save( )功能几乎完全类似的persist( )方法，一方面是为了照顾JPA的用法习惯。另一方面save和persist还有一个区别：使用save( )方法保存持久化对象时，该方法返回该持久化对象的标识属性值即对应记录的主键值；但persist( )方法保存持久化对象时，没有任何返回值。因为save方法需要立即返回持久化对象的标识属性值，所以程序执行save( )方法时会立即将持久化对象对应的数据插入数据库。而persist方法则保证当它在一个事物外部被调用时，并不立即转换成insert语句，这个功能是很有用的，尤其当我们封装一个长会话流程的时候，persist就显得尤为重要了。</p>
<p>load( )与get( )：<br>也可以通过load( )来加载一个持久化实例，这种加载就是根据持久化类的标识属性值加载持久化实例———其实质就是根据主键从数据表中加载一条新记录。News n=session.load(News.class,new Integer(pk))；pk就是需要加载的持久化实例的标识属性。<br>如果没有匹配的数据库记录，load( )方法可能抛出HibernateException异常；如果我们在类映射文件中指定了延迟加载，则load( )方法会返回一个未初始化的代理对象，这个代理对象并没有装载数据记录，直到程序调用该代理对象的某方法时，Hibernate才会去访问数据库。<br>如果希望在某对象中创建一个指向另一个对象的关联，又不想在从数据库中装载该对象的同时装载相关联的所有对象，这种延迟加载的方式就非常有用了。<br>与load( )方法类似的是get( )方法，get( )方法也用于根据主键装载持久化实例，但get( )方法会立刻访问数据库，如果没有对应的记录，get( )方法返回null，而不是返回一个代理对象。<br>一旦加载了该持久化实例后，该实体就处于持久化状态，在代码中对持久化实例所做的修改，例如：n.setTitle(“新标题”);这种修改将被保存到数据库，对标题的修改被映射成修改数据表的特定行的特定列。<br>程序对持久化实例所做的修改会在Session flush之前被自动保存到数据库，无需程序调用其他方法(不需要调用update方法)来将修改持久化。也就是说，修改对象最简单的方法就是在Session处于打开状态时load它，然后直接修改即可。<br>对于一个曾经持久化过的、但现在已脱离Session管理的持久化对象，我们把它称为处于脱管状态。当我们修改脱管对象的状态后，程序应该使用新的Session来保存这些修改。Hibernate提供了update( )、merge( )和updateOrSave( )等方法来保存这些修改。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">News</span> <span class="keyword">n</span>=firstSession.load(<span class="keyword">News</span>.<span class="keyword">class</span>,new Integer(pk));  </span><br><span class="line">firstSession.<span class="keyword">close</span>();  </span><br><span class="line"><span class="keyword">n</span>.setTitle(<span class="string">"新标题"</span>);  </span><br><span class="line">Session secondSession=HibernateSessionFactory.getSession();  </span><br><span class="line">secondSession.<span class="keyword">update</span>(<span class="keyword">n</span>);</span><br></pre></td></tr></table></figure></p>
<p>当我们用另一个Session来保存这种修改后，该脱管对象再次回到Session的管理之下，也就再次回到持久化状态。<br>当需要使用update( )来保存程序对持久化对象所做的修改时，如果不清楚该对象是否曾经持久化过，那么程序可以选择使用updateOrSave( )方法，该方法自动判断该对象是否曾经持久化，如果曾经持久化过，就使用update方法，否则将使用save操作。<br>merge( )方法也可将程序对脱管对象所做的修改保存到数据库，但merge方法与update方法最大的区别就是：merge( )方法不会持久化给定对象。举例来说，当我们执行session.update(a)代码后，a对象将会变成持久化状态；而执行session.merge(a)代码后，a对象依然不是持久化状态，a对象依然不会被关联到Session上。<br>当程序使用merge()方法来保存程序对脱管对象所做的修改时，如果Session中存在相同持久化标识的持久化对象，merge()方法里提供对象的状态将覆盖原有持久化实例的状态。如果Session中没有相应的持久化实例，则尝试从数据库中加载，或创建新的持久化实例，最后返回持久化实例。<br>merge()方法作用只是将当前对象的状态信息保存到数据库，并不会将该对象转换为持久化状态。<br>当我们使用load()和get()方法来加载持久化对象时，还可以指定一个”锁模式”参数。</p>
<p>save():保存持久化对象，在数据库中新增加一条数据<br>saveOrUpdate()保存或者是更新，该方法根据id标签的unsaved-value属性值决定执行新增加一条记录或者是更新。<br>get()根据标识符属性获得一个持久化对象，如果未找到，则返回null<br>load()该方法根据标识符属性加在一个持久化对象，如果未找到，则抛出异常<br>update() 该方法对托管状态的对象重新完成持久化，更新数据库中的数据<br>delete()删除数据库中的一条记录，不过需要先使用get() or  load() 获取持久化对象<br>close()关闭当前的session对象，并且清空该对象中的数据<br>evict()用于清除session缓存中的某一个对象<br>clear()清除Session中的所有缓存对象。</p>
<h2 id="映射">映射</h2><p> 在Hibernate中使用Annotation，跟以前xml配置的方式相比： </p>
<ol>
<li>仍然需要cfg.xml </li>
<li>在cfg.xml中需要配置要通过注解来配置的类，例如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapping <span class="keyword">package</span>=<span class="string">"test.animals"</span>/&gt; </span><br><span class="line">&lt;mapping <span class="class"><span class="keyword">class</span></span>=<span class="string">"test.Flight"</span>/&gt;</span><br></pre></td></tr></table></figure></li>
<li>程序里面，原来的new Configuration()的地方，可以变成：new AnnotationConfiguration()，也可以不用改。 </li>
<li>可以通过编程的方式来添加要映射的类，例如：  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new <span class="function"><span class="title">AnnotationConfiguration</span><span class="params">()</span></span>.<span class="function"><span class="title">addPackage</span><span class="params">(<span class="string">"test.animals"</span>)</span></span> </span><br><span class="line">          .<span class="function"><span class="title">addAnnotatedClass</span><span class="params">(Flight.class)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="映射实体">映射实体</h3><ul>
<li>@Entity，注册在类头上，将一个类声明为一个实体bean(即一个持久化POJO类) 。 </li>
<li><p>@Table，注册在类头上，注解声明了该实体bean映射指定的表（table ）。 </p>
<p>  @Table元素有name、schema、catalog 和 uniqueConstraints属性，如果需要可以指定相应的值. 结合使用@UniqueConstraint注解可以定义表的唯一约束(unique constraint) (对于绑定到单列的唯一约束,请参考@Column注解)</p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Table</span>(name=<span class="string">"tbl_sky"</span>, uniqueConstraints = &#123;<span class="variable">@UniqueConstraint</span>(columnNames=&#123;<span class="string">"month"</span>, <span class="string">"day"</span>&#125;)&#125;)</span><br></pre></td></tr></table></figure>
<p>  上面这个例子中,在month和day这两个字段上定义唯一约束. 注意columnNames数组中的值指的是逻辑列名.</p>
</li>
</ul>
<h3 id="映射属性">映射属性</h3><p>在对一个类进行注解时,你可以选择对它的的属性或者方法进行注解,根据你的选择,Hibernate的访问类型分别为 field或property. EJ3规范要求在需要访问的元素上进行注解声明,例如,如果访问类型为 property就要在getter方法上进行注解声明, 如果访问类型为 field就要在字段上进行注解声明.应该尽量避免混合使用这两种访问类型. Hibernate根据@Id 或 @EmbeddedId的位置来判断访问类型.</p>
<p>@Id用来注册主属性，@GeneratedValue用来注册主属性的生成策略，@Column用来注册属性，@Version用来注册乐观锁，@Transient用来注册不是属性。 </p>
<p>@Transient注册在多余的属性或多余的getter上，但是必须与以上的@Column等对应。 </p>
<p>Hibernate Annotations还支持将内置的枚举类型映射到一个顺序列(保存了相应的序列值) 或一个字符串类型的列(保存相应的字符串).默认是保存枚举的序列值, 但是你可以通过@Enumerated注解来进行调整</p>
<p>在核心的Java API中并没有定义时间精度(temporal precision). 因此处理时间类型数据时,你还需要定义将其存储在数据库中所预期的精度. 在数据库中,表示时间类型的数据有DATE, TIME, 和 TIMESTAMP三种精度(即单纯的日期,时间,或者两者兼备). 可使用@Temporal注解来调整精度.</p>
<p>@Lob注解表示属性将被持久化为Blob或者Clob类型, 具体取决于属性的类型, java.sql.Clob, Character[], char[] 和 java.lang.String这些类型的属性都被持久化为Clob类型, 而java.sql.Blob, Byte[], byte[] 和 serializable类型则被持久化为Blob类型.</p>
<h4 id="非主属性">非主属性</h4><p>@Column<br>   标识属性对应的字段，示例：@Column(name=”userName”) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Column</span>( </span><br><span class="line">    name=<span class="string">"columnName"</span>;                                (<span class="number">1</span>) </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;                   (<span class="number">2</span>) </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">nullable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;                  (<span class="number">3</span>) </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">insertable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;                (<span class="number">4</span>) </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">updatable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;                 (<span class="number">5</span>) </span><br><span class="line">    <span class="function">String <span class="title">columnDefinition</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;             (<span class="number">6</span>) </span><br><span class="line">    <span class="function">String <span class="title">table</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;                        (<span class="number">7</span>) </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;                         (<span class="number">8</span>) </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">precision</span><span class="params">()</span> <span class="keyword">default</span> 0</span>; <span class="comment">// decimal precision   (9) </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">scale</span><span class="params">()</span> <span class="keyword">default</span> 0</span>; <span class="comment">// decimal scale           (10)</span></span><br></pre></td></tr></table></figure>
<p>(1) name 可选,列名(默认值是属性名)<br>(2) unique 可选,是否在该列上设置唯一约束(默认值false)<br>(3) nullable 可选,是否设置该列的值可以为空(默认值false)<br>(4) insertable 可选,该列是否作为生成的insert语句中的一个列(默认值true)<br>(5) updatable 可选,该列是否作为生成的update语句中的一个列(默认值true)<br>(6) columnDefinition 可选: 为这个特定列覆盖SQL DDL片段 (这可能导致无法在不同数据库间移植)<br>(7) table 可选,定义对应的表(默认为主表)<br>(8) length 可选,列长度(默认值255)<br>(9) precision 可选,列十进制精度(decimal precision)(默认值0)<br>(10) scale 可选,如果列十进制数值范围(decimal scale)可用,在此设置(默认值0)<br>如果某属性没有注解,该属性将遵守下面的规则:</p>
<p><strong>无注解之属性的默认值</strong></p>
<p>如果属性为单一类型,则映射为@Basic<br>否则,如果属性对应的类型定义了@Embeddable注解,则映射为@Embedded<br>否则,如果属性对应的类型实现了Serializable, 则属性被映射为@Basic并在一个列中保存该对象的serialized版本<br>否则,如果该属性的类型为java.sql.Clob 或 java.sql.Blob,则作为@Lob并映射到适当的LobType.</p>
<h4 id="主属性">主属性</h4><p>@Id，标识这个属性是实体类的唯一识别的值。<br>注意：这个注解只能标注单一列构成的主键，有两个字段组成的联合主键由其他注解标识。 </p>
<p>@Id，只是标识这个属性是主键，但是并没有指出其生成策略<br>如果仅仅写出@Id，即是使用默认生成策略，如： </p>
<p><strong>JPA通用策略生成器</strong><br>JPA提供的四种标准用法为TABLE，SEQUENCE，IDENTITY，AUTO，默认AUTO</p>
<ul>
<li>AUTO - 可以是identity column类型,或者sequence类型或者table类型,取决于不同的底层数据库.</li>
<li>TABLE - 使用一个特定的数据库表格来保存主键</li>
<li>IDENTITY - 主键由数据库自动生成(主要是自动增长型)</li>
<li>SEQUENCE - 根据地层数据库的序列来生成主键，条件是数据库支持序列，主要是Oracle</li>
</ul>
<p><strong>hibernate主键策略生成器</strong></p>
<p>hibernate提供多种主键生成策略，有点是类似于JPA，有的是hibernate特有： </p>
<ul>
<li>native: 对于 oracle 采用 Sequence 方式，对于MySQL 和 SQL Server 采用identity（自增主键生成机制），native就是将主键的生成工作交由数据库完成，hibernate不管（很常用）。 </li>
<li>uuid: 采用128位的uuid算法生成主键，uuid被编码为一个32位16进制数字的字符串。占用空间大（字符串类型）。 </li>
<li>hilo: 使用hilo生成策略，要在数据库中建立一张额外的表，默认表名为hibernate_* unique_key,默认字段为integer类型，名称是next_hi（比较少用）。 </li>
<li>assigned: 在插入数据的时候主键由程序处理（很常用），这是 <generator>元素没有指定时的默认生成策略。等同于JPA中的AUTO。 </generator></li>
<li>identity: 使用SQL Server 和 MySQL 的自增字段，这个方法不能放到 Oracle 中，Oracle 不支持自增字段，要设定sequence（MySQL 和 SQL Server 中很常用）。等同于JPA中的INDENTITY。 </li>
<li>select: 使用触发器生成主键（主要用于早期的数据库主键生成机制，少用）。 </li>
<li>sequence: 调用底层数据库的序列来生成主键，要设定序列名，不然hibernate无法找到。 </li>
<li>seqhilo: 通过hilo算法实现，但是主键历史保存在Sequence中，适用于支持 Sequence 的数据库，如 Oracle（比较少用） </li>
<li>increment: 插入数据的时候hibernate会给主键添加一个自增的主键，但是一个hibernate实例就维护一个计数器，所以在多个实例运行的时候不能使用这个方法。 </li>
<li>foreign: 使用另外一个相关联的对象的主键。通常和<one-to-one>联合起来使用。 </one-to-one></li>
<li>guid: 采用数据库底层的guid算法机制，对应MYSQL的uuid()函数，SQL Server的newid()函数，ORACLE的rawtohex(sys_guid())函数等。 </li>
<li>uuid.hex: 看uuid，建议用uuid替换。 </li>
<li>sequence-identity: sequence策略的扩展，采用立即检索策略来获取sequence值，需要JDBC3.0和JDK4以上（含1.4）版本 </li>
</ul>
<p>hibernate提供了多种生成器供选择,基于Annotation的方式通过@GenericGenerator实现.<br>hibernate每种主键生成策略提供接口org.hibernate.id.IdentifierGenerator的实现类,如果要实现自定义的主键生成策略也必须实现此接口</p>
<p>如果想使用Oracle支持的sequence取主键，必须通过@GeneratedValue来指定生成策略，而由@SequenceGenerator指定如何使用sequence。 </p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Id</span></span><br><span class="line"><span class="variable">@GeneratedValue</span>(strategy = GenerationType.SEQUENCE,generator=<span class="string">"payablemoney_seq"</span>)</span><br><span class="line"><span class="variable">@SequenceGenerator</span>(name=<span class="string">"payablemoney_seq"</span>, sequenceName=<span class="string">"seq_payment"</span>)</span><br></pre></td></tr></table></figure>
<p>@SequenceGenerator定义 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Target</span>(&#123;TYPE, METHOD, FIELD&#125;)   </span><br><span class="line"><span class="annotation">@Retention</span>(RUNTIME)  </span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> SequenceGenerator &#123;  </span><br><span class="line"> <span class="function">String <span class="title">name</span><span class="params">()</span></span>;  </span><br><span class="line"> <span class="function">String <span class="title">sequenceName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">initialValue</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">allocationSize</span><span class="params">()</span> <span class="keyword">default</span> 50</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>name属性表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的”generator”值中。<br>sequenceName属性表示生成策略用到的数据库序列名称。<br>initialValue表示主键初识值，默认为0。<br>allocationSize表示每次主键值增加的大小，例如设置成1，则表示每次创建新记录后自动加1，默认为50。 </p>
<p><strong>自定义主键生成策略</strong><br>自定义主键生成策略，由@GenericGenerator实现。<br>hibernate在JPA的基础上进行了扩展，可以用一下方式引入hibernate独有的主键生成策略，就是通过@GenericGenerator加入的。</p>
<p>比如说，JPA标准用法<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Id</span>  </span><br><span class="line"><span class="variable">@GeneratedValue</span>(GenerationType.AUTO)</span><br></pre></td></tr></table></figure></p>
<p>就可以用hibernate特有以下用法来实现<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GeneratedValue</span>(generator = <span class="string">"paymentableGenerator"</span>)    </span><br><span class="line"><span class="variable">@GenericGenerator</span>(name = <span class="string">"paymentableGenerator"</span>, strategy = <span class="string">"assigned"</span>)</span><br></pre></td></tr></table></figure></p>
<p>@GenericGenerator有三个属性</p>
<ul>
<li>name属性指定生成器名称。 </li>
<li>strategy属性指定具体生成器的类名。 </li>
<li>parameters得到strategy指定的具体生成器所用到的参数。 </li>
</ul>
<h4 id="乐观锁和不用持久化">乐观锁和不用持久化</h4><ul>
<li>@Version<br>  标识这个属性用来映射乐观锁的version。entity manager使用该字段来检测更新冲突(防止更新丢失,请参考last-commit-wins策略).<br>  根据EJB3规范,version列可以是numeric类型(推荐方式)也可以是timestamp类型. Hibernate支持任何自定义类型,只要该类型实现了UserVersionType. </li>
<li>@Transient<br>标识这个属性不用持久化 </li>
</ul>
<h4 id="复合属性—组件映射">复合属性—组件映射</h4><ul>
<li><p>@Embeddable 【小对象的头上】 </p>
<p>  标识实体中可以定义一个嵌入式组件(embedded component)。组件类必须在类一级定义@Embeddable注解。 </p>
</li>
<li><p>@Embedded 【大对象的属性头上】 </p>
<p>  引用定义的小对象。 </p>
<p>  使用@Embedded和 @AttributeOverride注解可以覆盖该属性对应的嵌入式对象的列映射</p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Embedded</span></span><br><span class="line"><span class="variable">@AttributeOverrides</span>( &#123;</span><br><span class="line">    <span class="variable">@AttributeOverride</span>(name=<span class="string">"iso2"</span>, column = <span class="variable">@Column</span>(name=<span class="string">"bornIso2"</span>) ),</span><br><span class="line">    <span class="variable">@AttributeOverride</span>(name=<span class="string">"name"</span>, column = <span class="variable">@Column</span>(name=<span class="string">"bornCountryName"</span>) ) &#125; )</span><br><span class="line">Country bornIn;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="复合属性—复合主键">复合属性—复合主键</h4><p>下面是定义组合主键的几种语法:</p>
<ul>
<li>将组件类注解为@Embeddable,并将组件的属性注解为@Id</li>
<li>将组件的属性注解为@EmbeddedId</li>
<li><p>将类注解为@IdClass,并将该实体中所有属于主键的属性都注解为@Id</p>
</li>
<li><p>@Embeddable 【小对象的头上】 </p>
<p>  标识实体中可以定义一个嵌入式组件(embedded component)。组件类必须在类一级定义@Embeddable注解。<br>  注意：如果这个小对象作为复合主键，一定要实现Serializable接口。这并不是注解决定的，而是Hibernate的主键都需要实现Serializable接口。 </p>
</li>
<li><p>@EmbeddedId  【大对象的属性头上】 </p>
<p>  引用定义的小对象作为主键。<br>  注意：不需要再使用@Id注解。 </p>
</li>
</ul>
<h3 id="集合映射">集合映射</h3><p>你可以对 Collection ,List (指有序列表, 而不是索引列表), Map和Set这几种类型进行映射. EJB3规范定义了怎么样使用@javax.persistence.OrderBy 注解来对有序列表进行映射： 该注解接受的参数格式：用逗号隔开的(目标实体)属性名及排序指令, 如firstname asc, age desc,如果该参数为空,则默认以id对该集合进行排序. 如果某个集合在数据库中对应一个关联表(association table)的话,你不能在这个集合属性上面使用@OrderBy注解. 对于这种情况的处理方法,请参考Hibernate Annotation Extensions. EJB3 允许你利用目标实体的一个属性作为Map的key, 这个属性可以用@MapKey(name=”myProperty”)来声明. 如果使用@MapKey注解的时候不提供属性名, 系统默认使用目标实体的主键. map的key使用和属性相同的列：不需要为map key定义专用的列，因为map key实际上就表达了一个目标属性。 注意一旦加载,key不再和属性保持同步, 也就是说,如果你改变了该属性的值,在你的Java模型中的key不会自动更新 (请参考Hibernate Annotation Extensions). 很多人被<map>和@MapKey弄糊涂了。 其他它们有两点区别.@MapKey目前还有一些限制,详情请查看论坛或者 我们的JIRA缺陷系统。 注意一旦加载,key不再和属性保持同步, 也就是说,如果你改变了该属性的值,在你的Java模型中的key不会自动更新. (Hibernate 3中Map支持的方式在当前的发布版中还未得到支持).</map></p>
<p>Hibernate将集合分以下几类.</p>
<table>
<thead>
<tr>
<th>语义</th>
<th>Java实现类</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bag 语义</td>
<td>java.util.List, java.util.Collection</td>
<td>@org.hibernate.annotations.CollectionOfElements 或 @OneToMany 或 @ManyToMany</td>
</tr>
<tr>
<td>List 语义</td>
<td>java.util.List</td>
<td>(@org.hibernate.annotations.CollectionOfElements 或 @OneToMany 或 @ManyToMany) 以及 @org.hibernate.annotations.IndexColumn</td>
</tr>
<tr>
<td>Set 语义</td>
<td>java.util.Set</td>
<td>@org.hibernate.annotations.CollectionOfElements 或 @OneToMany 或 @ManyToMany</td>
</tr>
<tr>
<td>Map 语义</td>
<td>java.util.Map</td>
<td>(@org.hibernate.annotations.CollectionOfElements 或 @OneToMany 或 @ManyToMany) 以及 (空 或 @org.hibernate.annotations.MapKey/MapKeyManyToMany(支持真正的map), 或 @javax.persistence.MapKey</td>
</tr>
</tbody>
</table>
<p>从上面可以明确地看到,没有@org.hibernate.annotations.IndexColumn 注解的java.util.List集合将被看作bag类.<br>EJB3规范不支持原始类型,核心类型,嵌入式对象的集合.但是Hibernate对此提供了支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@OneToMany</span>(mappedBy=<span class="string">"city"</span>)</span><br><span class="line">    <span class="annotation">@OrderBy</span>(<span class="string">"streetName"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Street&gt; <span class="title">getStreets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> streets;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Entity</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Street</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStreetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> streetName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ManyToOne</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> City <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Software</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@OneToMany</span>(mappedBy=<span class="string">"software"</span>)</span><br><span class="line">    <span class="annotation">@MapKey</span>(name=<span class="string">"codeName"</span>)</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Version&gt; getVersions() &#123;</span><br><span class="line">        <span class="keyword">return</span> versions;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@Table</span>(name=<span class="string">"tbl_version"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Version</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCodeName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ManyToOne</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Software <span class="title">getSoftware</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子中,City 中包括了以streetName排序的Street的集合. 而Software中包括了以codeName作为 key和以Version作为值的Map.</p>
<p>除非集合为generic类型,否则你需要指定targetEntity. 这个注解属性接受的参数为目标实体的class.</p>
<p>Hibernate Annotations还支持核心类型集合(Integer, String, Enums, ……)、 可内嵌对象的集合,甚至基本类型数组.这就是所谓的元素集合.</p>
<p>元素集合可用@CollectionOfElements来注解(作为@OneToMany的替代). 为了定义集合表(译注：即存放集合元素的表,与下面提到的主表对应),要在关联属性上使用@JoinTable注解, joinColumns定义了介乎实体主表与集合表之间的连接字段(inverseJoincolumn是无效的且其值应为空). 对于核心类型的集合或基本类型数组,你可以在关联属性上用@Column来覆盖存放元素值的字段的定义. 你还可以用@AttributeOverride来覆盖存放可内嵌对象的字段的定义. 要访问集合元素,需要将该注解的name属性值设置为”element”(“element”用于核心类型,而”element.serial” 用于嵌入式对象的serial属性).要访问集合的index/key,则将该注解的name属性值设置为”key”.</p>
<h3 id="映射继承关系">映射继承关系</h3><p>EJB3支持三种类型的继承映射:</p>
<ul>
<li>每个类一张表(Table per class)策略: 在Hibernate中对应<union-class>元素:</union-class></li>
<li>每个类层次结构一张表(Single table per class hierarchy)策略:在Hibernate中对应<subclass>元素</subclass></li>
<li>连接的子类(Joined subclasses)策略:在Hibernate中对应 <joined-subclass>元素</joined-subclass></li>
</ul>
<p>你可以用 @Inheritance注解来定义所选择的策略. 这个注解需要在每个类层次结构(class hierarchy) 最顶端的实体类上使用.</p>
<h4 id="每个类一张表">每个类一张表</h4><p>这种策略有很多缺点(例如:多态查询和关联),EJB3规范, Hibernate参考手册, Hibernate in Action,以及其他许多地方都对此进行了描述和解释. Hibernate使用SQL UNION查询来实现这种策略. 通常使用场合是在一个继承层次结构的顶端:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@Inheritance</span>(strategy = InheritanceType.TABLE_PER_CLASS)</span><br><span class="line">public class Flight implements Serializable&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>这种策略支持双向的一对多关联. 这里不支持IDENTITY生成器策略,因为id必须在多个表间共享. 当然,一旦使用这种策略就意味着你不能使用 AUTO 生成器和IDENTITY生成器.</p>
<h4 id="每个类层次结构一张表">每个类层次结构一张表</h4><p>整个继承层次结构中的父类和子类的所有属性都映射到同一个表中, 他们的实例通过一个辨别符(discriminator)列来区分.:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@Inheritance</span>(strategy=InheritanceType.SINGLE_TABLE)</span><br><span class="line"><span class="variable">@DiscriminatorColumn</span>(</span><br><span class="line">    name=<span class="string">"planetype"</span>,</span><br><span class="line">    discriminatorType=DiscriminatorType.STRING</span><br><span class="line">)</span><br><span class="line"><span class="variable">@DiscriminatorValue</span>(<span class="string">"Plane"</span>)</span><br><span class="line">public class Plane &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@DiscriminatorValue</span>(<span class="string">"A320"</span>)</span><br><span class="line">public class A320 extends Plane &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中,Plane是父类,在这个类里面将继承策略定义为 <code>InheritanceType.SINGLE_TABLE</code>,并通过 @DiscriminatorColumn注解定义了辨别符列(还可以定义辨别符的类型). 最后,对于继承层次结构中的每个类,@DiscriminatorValue注解指定了用来辨别该类的值. 辨别符列的名字默认为 DTYPE,其默认值为实体名(在@Entity.name中定义)，其类型 为DiscriminatorType.STRING. A320是子类,如果不想使用默认的辨别符,只需要指定相应的值即可. 其他的如继承策略,辨别标志字段的类型都是自动设定的.</p>
<p>@Inheritance 和 @DiscriminatorColumn 注解只能用于实体层次结构的顶端.</p>
<h4 id="连接的子类">连接的子类</h4><p>当每个子类映射到一个表时, @PrimaryKeyJoinColumn 和@PrimaryKeyJoinColumns 注解定义了每个子类表关联到父类表的主键:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@Inheritance</span>(strategy=InheritanceType.JOINED)</span><br><span class="line">public class Boat implements Serializable &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Entity</span></span><br><span class="line">public class Ferry extends Boat &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@PrimaryKeyJoinColumn</span>(name=<span class="string">"BOAT_ID"</span>)</span><br><span class="line">public class AmericaCupClass  extends Boat &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>以上所有实体都使用了JOINED策略, Ferry表和Boat表使用同名的主键. 而AmericaCupClass表和Boat表使用了条件 <code>Boat.id = AmericaCupClass.BOAT_ID</code>进行关联.</p>
<h4 id="从父类继承的属性">从父类继承的属性</h4><p>有时候通过一个(技术上或业务上)父类共享一些公共属性是很有用的, 同时还不用将该父类作为映射的实体(也就是该实体没有对应的表). 这个时候你需要使用@MappedSuperclass注解来进行映射.</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@MappedSuperclass</span></span><br><span class="line">public class BaseEntity &#123;</span><br><span class="line">    <span class="variable">@Basic</span></span><br><span class="line">    <span class="variable">@Temporal</span>(TemporalType.TIMESTAMP)</span><br><span class="line">    public Date <span class="function">getLastUpdate</span>() &#123; ... &#125;</span><br><span class="line">    public String <span class="function">getLastUpdater</span>() &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Entity</span> class Order extends BaseEntity &#123;</span><br><span class="line">    <span class="variable">@Id</span> public Integer <span class="function">getId</span>() &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在数据库中,上面这个例子中的继承的层次结构最终以Order表的形式出现, 该表拥有id, lastUpdate 和 lastUpdater三个列.父类中的属性映射将复制到其子类实体. 注意这种情况下的父类不再处在继承层次结构的顶端.</p>
<p>注意：<br>注意,没有注解为@MappedSuperclass的父类中的属性将被忽略。<br>除非显式使用Hibernate annotation中的@AccessType注解, 否则将从继承层次结构的根实体中继承访问类型(包括字段或方法)。<br>这对于@Embeddable对象的父类中的属性持久化同样有效. 只需要使用@MappedSuperclass注解即可 (虽然这种方式不会纳入EJB3标准)。<br>可以将处在在映射继承层次结构的中间位置的类注解为@MappedSuperclass。<br>在继承层次结构中任何没有被注解为@MappedSuperclass 或@Entity的类都将被忽略。</p>
<p>你可以通过 @AttributeOverride注解覆盖实体父类中的定义的列. 这个注解只能在继承层次结构的顶端使用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyingObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAltitude</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> altitude;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Transient</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMetricAltitude</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> metricAltitude;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ManyToOne</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropulsionType <span class="title">getPropulsion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> metricAltitude;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@AttributeOverride</span>( name=<span class="string">"altitude"</span>, column = <span class="annotation">@Column</span>(name=<span class="string">"fld_altitude"</span>) )</span><br><span class="line"><span class="annotation">@AssociationOverride</span>( name=<span class="string">"propulsion"</span>, joinColumns = <span class="annotation">@JoinColumn</span>(name=<span class="string">"fld_propulsion_fk"</span>) )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">extends</span> <span class="title">FlyingObject</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中,altitude属性的值最终将持久化到Plane 表的<code>fld_altitude</code>列.而名为propulsion的关联则保存在<code>fld_propulsion_fk</code>外间列.</p>
<p>你可以为@Entity和@MappedSuperclass注解的类 以及那些对象为@Embeddable的属性定义 @AttributeOverride和@AssociationOverride.</p>
<h3 id="关联关系映射">关联关系映射</h3><h4 id="关联关系映射—简介">关联关系映射—简介</h4><p>在hibernate中，支持对象之间的关联关系映射，这样可以减少我们的dao操作，操作一个对象的时候，就可以顺带操作它的关联对象。我们知道，hibernate支持三种关联关系，1:1，1:M，M:N。但，这只是对象之间的关系。数据库的设计当然也支持1:1，1:M，M:N三种关系。比如，我们经常说的1:M，就是把1这张表的主键拿到多那边做外键。但是，很多同学经常迷惑，为什么网上介绍的1:M，比我们讲的还要复杂的多？我们只需要<set>和<many-to-one>，但是网上介绍的还有一种使用<set>和<join>的？这里我们就不得不提出 “数据库设计的降级使用”这个概念了。 </join></set></many-to-one></set></p>
<h4 id="关联关系映射—数据库降级使用">关联关系映射—数据库降级使用</h4><p>标准的1:M </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----------+          +----------+</span><br><span class="line">|<span class="string">tbl_parent</span>|<span class="string">          </span>|<span class="string">tbl_child </span>|<span class="string"> </span><br><span class="line">+----------+          +----------+</span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;  </span>|<span class="string">          </span>|<span class="string"> uuid&lt;PK&gt; </span>|</span><br><span class="line">+----------+          |<span class="string"> puuid&lt;FK&gt;</span>|</span><br><span class="line">                      +----------+</span><br></pre></td></tr></table></figure>
<p>标准的M:N </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +---------------+     +-----------+ </span><br><span class="line">|<span class="string">tbl_student</span>|<span class="string">     </span>|<span class="string">   tbl_grade   </span>|<span class="string">     </span>|<span class="string">tbl_course </span>|<span class="string">  </span><br><span class="line">+-----------+     +---------------+     +-----------+ </span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">     </span>|<span class="string"> suuid&lt;PK&gt;&lt;FK&gt; </span>|<span class="string">     </span>|<span class="string">cuuid&lt;PK&gt;  </span>|<span class="string"> </span><br><span class="line">+-----------+     </span>|<span class="string"> cuuid&lt;PK&gt;&lt;FK&gt; </span>|<span class="string">     +-----------+ </span><br><span class="line">                  +---------------+</span></span><br></pre></td></tr></table></figure>
<p>将M:N的数据库设计降级为1:M使用 </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +-----------------------+     +-----------+ </span><br><span class="line">|<span class="string">tbl_parent </span>|<span class="string">     </span>|<span class="string"> tbl_parent_child      </span>|<span class="string">     </span>|<span class="string">tbl_child  </span>|<span class="string">  </span><br><span class="line">+-----------+     +-----------------------+     +-----------+ </span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">     </span>|<span class="string"> puuid&lt;PK&gt;&lt;FK&gt;         </span>|<span class="string">     </span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string"> </span><br><span class="line">+-----------+     </span>|<span class="string"> cuuid&lt;PK&gt;&lt;FK&gt;&lt;UNIQUE&gt; </span>|<span class="string">     +-----------+ </span><br><span class="line">                  +-----------------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="关联关系映射—1:1—共享主键">关联关系映射—1:1—共享主键</h4><p>标准的1:1 </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----------+          +----------------+</span><br><span class="line">|<span class="string">tbl_product</span>|<span class="string">          </span>|<span class="string">tbl_product_info</span>|<span class="string"> </span><br><span class="line">+-----------+          +----------------+</span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">          </span>|<span class="string">  uuid&lt;PK&gt;&lt;FK&gt;  </span>|</span><br><span class="line">+-----------+          +----------------+</span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML的配置 </p>
<p>  主1 【tbl_product】： </p>
  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="constant">one</span>-<span class="built_in">to</span>-<span class="constant">one</span> name= <span class="string">"info"</span> cascade=<span class="string">"all"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>  从1 【tbl_product_info】： </p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="property">id</span> <span class="property">name</span>= <span class="string">"uuid"</span>&gt; </span><br><span class="line">&lt;generator <span class="type">class</span>=<span class="string">"foreign  【写死，使用外来生成策略】"</span>&gt; </span><br><span class="line">        &lt;param <span class="property">name</span>=<span class="string">"property"</span>&gt;product  【引用自己的Java属性名】 </span><br><span class="line">        &lt;/param&gt; </span><br><span class="line">&lt;/generator&gt; </span><br><span class="line">&lt;/<span class="property">id</span>&gt; </span><br><span class="line">&lt;one-<span class="keyword">to</span>-one <span class="property">name</span>= <span class="string">"product"</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解的配置 </p>
<p>  主1 【tbl_product】： </p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@OneToOne</span>(cascade=CascadeType.ALL) </span><br><span class="line"><span class="variable">@PrimaryKeyJoinColumn</span> </span><br><span class="line">private ProductInfoModel info;</span><br></pre></td></tr></table></figure>
<p>  从1 【tbl_product_info】： </p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Id</span> </span><br><span class="line"><span class="variable">@Column</span> </span><br><span class="line"><span class="variable">@GeneratedValue</span>(generator=<span class="string">"copy 【引用生成策略】"</span>) </span><br><span class="line"><span class="variable">@GenericGenerator</span>(name=<span class="string">"copy  【定义生成策略】"</span>,strategy=<span class="string">"foreign  【写死，使用外来策略】"</span>,parameters=<span class="variable">@Parameter</span>(name=<span class="string">"property"</span>,value=<span class="string">"product  【引用自己的Java属性】"</span>)) </span><br><span class="line">private int uuid; </span><br><span class="line"><span class="variable">@OneToOne</span>(mappedBy=<span class="string">"info  【引用对方的Java属性】"</span>) </span><br><span class="line">private ProductModel product;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关联关系映射—1:M—外键">关联关系映射—1:M—外键</h4><p>标准的1:M </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----------+          +----------+</span><br><span class="line">|<span class="string">tbl_parent</span>|<span class="string">          </span>|<span class="string">tbl_child </span>|<span class="string"> </span><br><span class="line">+----------+          +----------+</span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;  </span>|<span class="string">          </span>|<span class="string"> uuid&lt;PK&gt; </span>|</span><br><span class="line">+----------+          |<span class="string"> puuid&lt;FK&gt;</span>|</span><br><span class="line">                      +----------+</span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML的配置</p>
<p>  1 【tbl_parent】： </p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">set</span> <span class="property">name</span>= <span class="string">"children"</span>&gt; </span><br><span class="line">    &lt;key column=<span class="string">"puuid  【对方的数据库外键列名】"</span>/&gt; </span><br><span class="line">    &lt;one-<span class="keyword">to</span>-many <span class="type">class</span>=<span class="string">"cn.j avass.model.c.ChildModel  【对方的Java类名】"</span>/&gt; </span><br><span class="line">&lt;/<span class="keyword">set</span>&gt;</span><br></pre></td></tr></table></figure>
<p>  多 【tbl_child】： </p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;many-<span class="keyword">to</span>-one <span class="property">name</span>=<span class="string">"parent"</span> column=<span class="string">"puuid 【自己的数据库外键列名】"</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>注解的配置<br>  1 【tbl_parent】：   <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@OneToMany</span> </span><br><span class="line"><span class="variable">@JoinColumn</span>(name=<span class="string">"puuid 【对方的数据库外键列名】"</span>) </span><br><span class="line">private Set&lt;ChildModel&gt; children = new HashSet&lt;ChildModel&gt;();</span><br></pre></td></tr></table></figure>
  多 【tbl_child】：   <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@ManyToOne</span> </span><br><span class="line"><span class="variable">@JoinColumn</span>(name=<span class="string">"puuid 【自己的数据库外键列名】"</span>) </span><br><span class="line">private ParentModel parent;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关联关系映射—M:N—联接表">关联关系映射—M:N—联接表</h4><p>标准的M:N </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +---------------+     +-----------+ </span><br><span class="line">|<span class="string">tbl_student</span>|<span class="string">     </span>|<span class="string">   tbl_grade   </span>|<span class="string">     </span>|<span class="string">tbl_course </span>|<span class="string">  </span><br><span class="line">+-----------+     +---------------+     +-----------+ </span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">     </span>|<span class="string"> suuid&lt;PK&gt;&lt;FK&gt; </span>|<span class="string">     </span>|<span class="string"> uuid&lt;PK&gt;  </span>|<span class="string"> </span><br><span class="line">+-----------+     </span>|<span class="string"> cuuid&lt;PK&gt;&lt;FK&gt; </span>|<span class="string">     +-----------+ </span><br><span class="line">                  +---------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML的配置 </p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">set</span> <span class="property">name</span>=<span class="string">"courses"</span> table=<span class="string">"tbl_grade  【联接表】"</span>&gt; </span><br><span class="line">    &lt;key column=<span class="string">"suuid 【联接表里代表自己的数据库字段名】"</span>/&gt; </span><br><span class="line">    &lt;many-<span class="keyword">to</span>-many column=<span class="string">"cuuid 【联接表里代表对方的数据库字段名】"</span> </span><br><span class="line">    <span class="type">class</span>=<span class="string">"cn.ja vass.model.e.CourseMode  【对方的类名】l"</span>/&gt; </span><br><span class="line">&lt;/<span class="keyword">set</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解的配置 </p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@ManyToMany</span> </span><br><span class="line"><span class="variable">@JoinTable</span>( </span><br><span class="line">name=<span class="string">"tbl_grade  【联接表】"</span>, </span><br><span class="line">joinColumns=<span class="variable">@JoinColumn</span>(name=<span class="string">"suuid 【联接表里代表自己的数据库字段名】"</span>), </span><br><span class="line">inverseJoinColumns=<span class="variable">@JoinColumn</span>(name=<span class="string">"cuuid   【联接表里代表对方的数据库字段名】"</span> ) </span><br><span class="line">) </span><br><span class="line">private Set&lt;CourseModel&gt; courses = new HashSet&lt;CourseModel&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>关联关系映射—1:1—引用外键 </p>
<p>标准的1:M </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +-----------------------+  </span><br><span class="line">|<span class="string">tbl_product</span>|<span class="string">     </span>|<span class="string"> tbl_product_info      </span>|<span class="string">  </span><br><span class="line">+-----------+     +-----------------------+ </span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">     </span>|<span class="string"> uuid&lt;PK&gt;              </span>|<span class="string"> </span><br><span class="line">+-----------+     </span>|<span class="string"> puuid&lt;FK&gt;&lt;UNIQUE&gt;     </span>|<span class="string"> </span><br><span class="line">                  +-----------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML的配置</p>
<p>  主1 【tbl_product】： </p>
  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="constant">one</span>-<span class="built_in">to</span>-<span class="constant">one</span> name=<span class="string">"info"</span> foreign-key= <span class="string">"puuid  【对方的数据库外键列名】"</span>  cascade=<span class="string">"all"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>  从1 【tbl_product_info】： </p>
  <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;many-to-one <span class="variable">name=</span><span class="string">"product"</span> <span class="variable">column=</span><span class="string">"puuid 【自己的数据库外键列名】"</span> <span class="variable">unique=</span><span class="string">"true 【写死】"</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>注解的配置 </p>
<p>  主1 【tbl_product】： </p>
  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@OneToOne</span>(cascade=CascadeType.ALL,mappedBy=<span class="string">"product  【对方的Java类属性名】"</span>) </span><br><span class="line"><span class="keyword">private</span> ProductInfoModel info;</span><br></pre></td></tr></table></figure>
<p>  从1 【tbl_product_info】： </p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@OneToOne</span> </span><br><span class="line"><span class="variable">@JoinColumn</span>(name=<span class="string">"puuid 【自己的数据库外键列名】"</span>) </span><br><span class="line">private ProductModel product;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关联关系映射—1:M—联接表">关联关系映射—1:M—联接表</h4><p>标准的1:M </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +-----------------------+     +-----------+ </span><br><span class="line">|<span class="string">tbl_parent </span>|<span class="string">     </span>|<span class="string"> tbl_parent_child      </span>|<span class="string">     </span>|<span class="string">tbl_child  </span>|<span class="string">  </span><br><span class="line">+-----------+     +-----------------------+     +-----------+ </span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">     </span>|<span class="string"> puuid&lt;PK&gt;&lt;FK&gt;         </span>|<span class="string">     </span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string"> </span><br><span class="line">+-----------+     </span>|<span class="string"> cuuid&lt;PK&gt;&lt;FK&gt;&lt;UNIQUE&gt; </span>|<span class="string">     +-----------+ </span><br><span class="line">                  +-----------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML的配置<br>  1 【tbl_parent 】： </p>
  <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;set <span class="variable">name=</span><span class="string">"children"</span> <span class="variable">table=</span><span class="string">"tbl_parent_child  【联接表】"</span>&gt; </span><br><span class="line">    &lt;key <span class="variable">column=</span><span class="string">"puuid  【联接表里代表自己的数据库列名】"</span>/&gt; </span><br><span class="line">    &lt;many-to-many <span class="variable">column=</span><span class="string">"cuuid 【联接表里代表对方的数据库列名】"</span> <span class="variable">unique=</span><span class="string">"true 【写死】"</span> <span class="variable">class=</span><span class="string">"cn.javass.model.d.ChildModel  【对方的Java类名】"</span>/&gt; </span><br><span class="line">&lt;/set&gt; </span><br><span class="line">&lt;join <span class="variable">table=</span><span class="string">"tbl_parent_child  【联接表】"</span>&gt; </span><br><span class="line">    &lt;key <span class="variable">column=</span><span class="string">"cuuid 【联接表里代表自己的数据库列名】"</span>/&gt; </span><br><span class="line">    &lt;many-to-one <span class="variable">name=</span> <span class="string">"parent"</span> <span class="variable">column=</span><span class="string">"puuid  【联接表里代表对方的数据库列名】"</span> <span class="variable">unique=</span><span class="string">"true 【写死】"</span>/&gt; </span><br><span class="line">&lt;/join&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解的配置<br>  1 【tbl_parent 】： </p>
  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@OneToMany</span>(mappedBy=<span class="string">"parent  【对方的Java类属性名】"</span>) </span><br><span class="line"><span class="keyword">private</span> Set&lt;ChildModel&gt; children = <span class="keyword">new</span> HashSet&lt;ChildModel&gt;();</span><br></pre></td></tr></table></figure>
<p>  多 【tbl_child】： </p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@ManyToOne</span> </span><br><span class="line"><span class="variable">@JoinTable</span>( </span><br><span class="line">name=<span class="string">"tbl_parent_child 【联接表】"</span>, </span><br><span class="line">joinColumns=<span class="variable">@JoinColumn</span>(name=<span class="string">"cuuid 【联接表里代表自己的数据库字段名】"</span>), </span><br><span class="line">inverseJoinColumns=<span class="variable">@JoinColumn</span>(name=<span class="string">"puuid 【联接表里代表对方的数据库字段名】"</span>) </span><br><span class="line">) </span><br><span class="line">private ParentModel parent;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关联关系映射—1:1—联接表">关联关系映射—1:1—联接表</h4><p>标准的1:M </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +-----------------------+     +----------------+ </span><br><span class="line">|<span class="string">tbl_product</span>|<span class="string">     </span>|<span class="string"> tbl_product_relation  </span>|<span class="string">     </span>|<span class="string">tbl_product_info</span>|<span class="string">  </span><br><span class="line">+-----------+     +-----------------------+     +----------------+ </span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">     </span>|<span class="string"> puuid&lt;PK&gt;&lt;FK&gt;&lt;UNIQUE&gt; </span>|<span class="string">     </span>|<span class="string">uuid&lt;PK&gt;        </span>|<span class="string"> </span><br><span class="line">+-----------+     </span>|<span class="string"> cuuid&lt;PK&gt;&lt;FK&gt;&lt;UNIQUE&gt; </span>|<span class="string">     +----------------+ </span><br><span class="line">                  +-----------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML的配置<br>  1 【tbl_product 】： </p>
  <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;join <span class="variable">table=</span><span class="string">"tbl_product_relation  【联接表】"</span>&gt; </span><br><span class="line">    &lt;key <span class="variable">column=</span><span class="string">"puuid  【联接表里代表自己的列名】"</span>/&gt; </span><br><span class="line">    &lt;many-to-one <span class="variable">name=</span><span class="string">"course  【自己的Java属性名】"</span> <span class="variable">column=</span><span class="string">"cuuid  【联接表里代表对方的列名】"</span> <span class="variable">unique=</span><span class="string">"true 【写死】"</span>/&gt; </span><br><span class="line">&lt;/join&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解的配置<br>  1 【tbl_product 】： </p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@ManyToOne</span> </span><br><span class="line"><span class="variable">@JoinTable</span>( </span><br><span class="line">name=<span class="string">"tbl_product_relation 【联接表】"</span>, </span><br><span class="line">joinColumns=<span class="variable">@JoinColumn</span>(name=<span class="string">"suuid 【联接表里代表自己的列名】"</span>), </span><br><span class="line">inverseJoinColumns=<span class="variable">@JoinColumn</span>(name=<span class="string">"cuuid 【联接表里代表对方的列名】"</span>,unique=true 【写死】) </span><br><span class="line">) </span><br><span class="line">private CourseModel course;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="二级缓存">二级缓存</h3><p>@Cache示例<br>定义在实体类上，示例如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span> </span><br><span class="line"><span class="variable">@Cache</span>(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE) </span><br><span class="line">public class Forest &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="批量处理">批量处理</h2><p>可以使用循环进行批量处理。批量插入、更新时为了避免运行失败，定时将Session缓存的数据刷入数据库</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加器i是20的倍数时，将Session中的数据刷入数据库，并清空Session缓存</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(i % <span class="number">20</span> == <span class="number">0</span>)</span> &#123;</span><br><span class="line">    session.flush<span class="params">()</span>;</span><br><span class="line">    session.clear<span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>批量更新时，如果需要返回多行数据，应该使用scroll()方法，从而充分利用服务器端游标所带来的性能优势。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Session session = HibernateUtil.currentSession<span class="params">()</span>;</span><br><span class="line">Transaction tx = session.beginTransaction<span class="params">()</span>;</span><br><span class="line">ScrollableResults users = session.createQuery<span class="params">(<span class="string">"from User"</span>)</span>.setCacheMode<span class="params">(CacheMode.IGNORE)</span>.scroll<span class="params">(ScrollMode.FORWARD_ONLY)</span>;</span><br><span class="line">int count = <span class="number">0</span>;</span><br><span class="line">while<span class="params">(users.next<span class="params">()</span>)</span>&#123;</span><br><span class="line">    User u = <span class="params">(User)</span>users.get<span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line">    u.setName<span class="params">(<span class="string">"新用户"</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span><span class="params">(++count % <span class="number">20</span> == <span class="number">0</span>)</span>&#123;</span><br><span class="line">        session.flush<span class="params">()</span>;</span><br><span class="line">        session.clear<span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">tx.commit<span class="params">()</span>;</span><br><span class="line">HibernateUtil.closeSession<span class="params">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>Hibernate提供HQL语句也可以批量更新、删除。语法<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">UPDATE</span> | <span class="keyword">DELETE</span> <span class="keyword">FROM</span>? &lt;CLASSNAME&gt; [<span class="keyword">WHERE</span> WHERE_CONDITIONS]</span></span><br></pre></td></tr></table></figure></p>
<p>FROM子句中，FROM关键字是可选的。<br>在FROM子句中只能有一个类名，该类名不能有别名。<br>不能再批量HQL语句中使用连接，显式或者银石都不行。但可以在WHERE子句的语法中使用子查询。<br>整个WHERE子句是可选的。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> updateEntities = session.createQuery(hql).executeUpdate<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<h2 id="使用HQL查询">使用HQL查询</h2><p>步骤</p>
<ol>
<li>获取Hibernate Session对象</li>
<li>编写HQL语句</li>
<li>以HQL语句作为参数，调用Session的createQuery方法创建查询对象。</li>
<li>如果HQL语句包含参数，则调用Query的setXXX方法为参数赋值。</li>
<li>调用Query对象的list等方法返回查询结果列表（持久化实体集）</li>
</ol>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Session session = HibernateUtil.currentSession<span class="params">()</span>;</span><br><span class="line">Transaction tx = session.beginTransaction<span class="params">()</span>;</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat<span class="params">(<span class="string">"yyyy-MM-dd"</span>)</span>;</span><br><span class="line">Date start = sdf.parse<span class="params">(<span class="string">"2005-01-01"</span>)</span>;</span><br><span class="line">List pl = session.createQuery<span class="params">(<span class="string">"select distinct p from Person p"</span></span><br><span class="line">        + <span class="string">" inner join p.myEvents event where event.happenDate"</span></span><br><span class="line">        + <span class="string">" between :firstDate and :endDate"</span>)</span></span><br><span class="line">            .setDate<span class="params">(<span class="string">"firstDate"</span>, start)</span></span><br><span class="line">            .setDate<span class="params">(<span class="string">"endDate"</span>, new Date<span class="params">()</span>)</span></span><br><span class="line">            .list<span class="params">()</span>;</span><br><span class="line"><span class="keyword">for</span><span class="params">(Iterator pit = pl.iterator<span class="params">()</span>;pit.hasNext<span class="params">()</span>;)</span>&#123;</span><br><span class="line">    Person p = <span class="params">(Person)</span> pit.next<span class="params">()</span>;</span><br><span class="line">    System.out.println<span class="params">(p.getName<span class="params">()</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">tx.commit<span class="params">()</span>;</span><br><span class="line">HibernateUtil.closeSession<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>执行HQL语句类似于用PreparedStatement执行SQL语句，因此HQL语句中可以使用占位符作为参数。HQL的占位符既可使用英文问好(?)，这与SQL语句中的占位符一样；也可使用有名字的占位符，使用有名字的占位符时，应该在占位符名字前增加英文冒号(:)。</p>
<p>setXXX()：方法有两个版本，分别根据参数索引赋值和根据参数名字赋值。<br>list(): 返回查询到的全部结果<br>setFirstResult(int firstResult)：设置返回的结果集从第几条开始<br>setMaxResults(int maxResults)：设置本次查询返回的结果数目</p>
<p>后两个方法用于对HQL查询实现分页控制</p>
<p>HQL语句本身是不区分大小写的。也就是说，HQL语句的关键字、函数都是不区分大小写的。但HQL语句中所使用的包名、类名、实例名、属性名都区分大小写。</p>
<h3 id="from子句">from子句</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span></span><br><span class="line">from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure>
<p>建议为每个实例起别名。as关键字是可选的，为了增加可读性，建议保留。</p>
<h3 id="关联和连接">关联和连接</h3><p>两种形式关联连接：隐式和显式</p>
<p>隐式连接形式不使用join关键字，使用英文点号（.）来隐式连接关联实体，Hibernate底层自动进行关联查询。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span> p where p.myEvents.title &gt; :title</span><br></pre></td></tr></table></figure></p>
<p>显示连接则需要使用 xxx join关键字<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span> p</span><br><span class="line">inner join p.myEvents event</span><br><span class="line">where event.happenDate &lt; :endDate</span><br></pre></td></tr></table></figure></p>
<p>可使用几种连接方式</p>
<ul>
<li>inner join，内连接，可简写成join。</li>
<li>left outer join，左外连接，可简写成，left join</li>
<li>right outer join，右外连接，可简写成，right join</li>
<li>full join，全连接，不常用</li>
</ul>
<p>还可通过with关键字来提供额外的连接条件。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from Person <span class="tag">p</span></span><br><span class="line">inner join <span class="tag">p</span><span class="class">.myEvents</span> event</span><br><span class="line">with <span class="tag">p</span><span class="class">.id</span> &gt; event<span class="class">.id</span></span><br><span class="line">where event<span class="class">.happenDate</span> &lt; :endDate</span><br></pre></td></tr></table></figure></p>
<p>省略select关键字，返回的结果也是集合，但集合元素是被查询持久化对象、所有被关联的持久化对象所组成的数组。如上查询将会返回person、event_table表中的所有数据。</p>
<p>为了查询结果不重复可以使用distinct关键字</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select <span class="keyword">distinct</span> p <span class="keyword">from</span> <span class="type">Person</span> p</span><br><span class="line">inner join p.myEvents e</span><br><span class="line">where e.title := eventTitle</span><br></pre></td></tr></table></figure>
<p>如果关联实体是集合如myEvents这时不可以用隐式连接，必须显式连接关联实体或组件。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span> as p</span><br><span class="line">join fetch p.scores</span><br></pre></td></tr></table></figure></p>
<p>上次的fetch关键字将导致Hibernate在初始化Person对象时，同时抓取Person关联的scores集合属性。也可以在配置文件中制定<code>lazy=&quot;false&quot;</code></p>
<p>fetch关键字注意：</p>
<ul>
<li>fetch不应该与setMaxResults()与setFirstResult()共用。因为这些操作是基于结果集的，而在预先抓取集合类时可能包含重复的数据，即无法预先知道精确的行数。</li>
<li>fetch不能与独立的with条件一起使用</li>
<li>如果在一次查询中fetch多个集合，可以查询返回笛卡尔积，因此要多加注意。</li>
<li>对bag映射而言，同时join fetch多个集合时可能出现非预期结果，因此需要谨慎使用。</li>
<li>full join fetch 与 right join fetch是没有任何意义的</li>
</ul>
<p>也可以通过fetch all properties 来强制Hibernate立即抓取这些属性。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Document fetch all properties order <span class="keyword">by</span> <span class="property">name</span></span><br></pre></td></tr></table></figure></p>
<h3 id="select子句">select子句</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select p.name.firstName from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure>
<p>select可以选择组件属性包含的属性<br>通常情况下，使用select子句查询的结果是集合，而集合元素是select后的实例、属性等组成的数组。<br>如果select后只有一项（包括持久化实例或属性），则查询得到的集合元素就是该持久化实例或属性。<br>如果select后有多个项，则每个集合元素就是选择出的多项组成的数组。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select p.name, p from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure></p>
<p>集合元素类似于[String,Person]结构的数组，其中第一个元素是Person实例的name属性，第二个是Person实例</p>
<p>将选出的属性存入一个List对象。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select new list(p.name,p.address) from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure></p>
<p>返回的集合元素是list而不是数组<br>也可以将选出的属性封装为对象，必须有对应的构造方法<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select new ClassTest(p.name,p.address) from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure></p>
<p>还可以给选出元素命名别名<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select p.name as personName from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure></p>
<p>这种用法与new map结合使用更加普遍。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select new map(p.name as personName) from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure></p>
<p>选出的集合元素是Map对象，以personName作为Map的key，实际选出的值作为Map的value</p>
<h3 id="HQL查询的聚集函数">HQL查询的聚集函数</h3><ul>
<li>avg：计算属性平均值</li>
<li>count：统计选择对象的数量</li>
<li>max：统计属性值的最大值</li>
<li>min：统计属性值的最小值</li>
<li>sum：计算属性值的总和</li>
</ul>
<p>select子句还支持字符串连接符、算术运算符，以及SQL函数。也支持使用distinct和all关键字。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select p.name || <span class="string">""</span> || p.address from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure></p>
<h3 id="多态查询">多态查询</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure>
<p>该查询语句不仅会查出Person的全部实例，还会查询出Person的子类。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from java<span class="class">.lang</span><span class="class">.Object</span> o</span><br></pre></td></tr></table></figure></p>
<p>该查询可以返回所有被持久化的对象。此查询无法使用order by子句对结果集排序，从而不允许对这些查询结果使用Query.scroll()</p>
<h3 id="HQL查询的where子句">HQL查询的where子句</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Cat cat <span class="keyword">where</span> cat.mate.<span class="property">name</span> like <span class="string">"kit%"</span></span><br></pre></td></tr></table></figure>
<p>如果cat.mate是集合属性，Hibernate3.2.3以后的版本不支持这种用法。<br>class关键字用来存取一个实例的鉴别值。嵌入where子句中的java类名，将被作为该类的鉴别值。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Cat</span> <span class="keyword">cat</span> where <span class="keyword">cat</span>.<span class="keyword">class</span> = DomesticCat</span><br></pre></td></tr></table></figure></p>
<p>当where子句的运算符只支持基本类型或字符串时，where子句中的属性表达式必须以基本类型或者字符串结尾，不要使用组件类型属性结尾。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from Account as a where a.<span class="keyword">person</span>.name.firstName like <span class="string">"dd%"</span></span><br></pre></td></tr></table></figure></p>
<p>下面的语句则是错误的<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from Account as a where a.<span class="keyword">person</span>.name like <span class="string">"dd%"</span></span><br></pre></td></tr></table></figure></p>
<p>‘=’可以用于实例。</p>
<h3 id="表达式">表达式</h3><p>在where子句中允许使用的表达式包括 大多数你可以在SQL使用的表达式种类:</p>
<ul>
<li>数学运算符<code>+, -, *, /</code></li>
<li>二进制比较运算符<code>=, &gt;=, &lt;=, &lt;&gt;, !=, like</code></li>
<li>逻辑运算符<code>and, or, not</code></li>
<li>in, not in, between, is null, is not null, is empty, is not empty, member of and not member of</li>
<li>“简单的” case, case … when … then … else … end,和 “搜索” case, case when … then … else … end</li>
<li>字符串连接符…||… or concat(…,…)</li>
<li>current_date(), current_time(), current_timestamp()</li>
<li>second(…), minute(…), hour(…), day(…), month(…), year(…),</li>
<li>EJB-QL 3.0定义的任何函数或操作：substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length()</li>
<li>coalesce() 和 nullif()</li>
<li>cast(… as …), 其第二个参数是某Hibernate类型的名字，以及extract(… from …)，只要ANSI cast() 和 extract() 被底层数据库支持</li>
<li>任何数据库支持的SQL标量函数，比如sign(), trunc(), rtrim(), sin()</li>
<li>JDBC参数传入 ?</li>
<li>命名参数:name, :start_date, :x1</li>
<li>SQL 直接常量 ‘foo’, 69, ‘1970-01-01 10:00:01.0’</li>
<li><p>Java public static final 类型的常量 eg.Color.TABBY</p>
</li>
<li><p>关键字in与between可按如下方法使用:</p>
  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> DomesticCat cat <span class="keyword">where</span> cat.name between <span class="string">'A'</span> <span class="keyword">and</span> <span class="string">'B'</span></span><br><span class="line"><span class="keyword">from</span> DomesticCat cat <span class="keyword">where</span> cat.name <span class="keyword">in</span> ( <span class="string">'Foo'</span>, <span class="string">'Bar'</span>, <span class="string">'Baz'</span> )</span><br></pre></td></tr></table></figure></li>
<li><p>而且否定的格式也可以如下书写：</p>
  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> DomesticCat cat <span class="keyword">where</span> cat.name <span class="keyword">not</span> between <span class="string">'A'</span> <span class="keyword">and</span> <span class="string">'B'</span></span><br><span class="line"><span class="keyword">from</span> DomesticCat cat <span class="keyword">where</span> cat.name <span class="keyword">not</span> <span class="keyword">in</span> ( <span class="string">'Foo'</span>, <span class="string">'Bar'</span>, <span class="string">'Baz'</span> )</span><br></pre></td></tr></table></figure>
</li>
<li><p>同样, 子句is null与is not null可以被用来测试空值(null).</p>
</li>
<li><p>在Hibernate配置文件中声明HQL“查询替代（query substitutions）”之后， 布尔表达式（Booleans）可以在其他表达式中轻松的使用:</p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"hibernate.query.substitutions"</span>&gt;<span class="constant">true</span> <span class="number">1</span>, <span class="constant">false</span> <span class="number">0</span>&lt;/<span class="keyword">property</span>&gt;</span><br></pre></td></tr></table></figure>
<p>  系统将该HQL转换为SQL语句时，该设置表明将用字符 1 和 0 来 取代关键字true 和 false:</p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Cat cat <span class="keyword">where</span> cat.alive = <span class="constant">true</span></span><br></pre></td></tr></table></figure></li>
<li>你可以用特殊属性size, 或是特殊函数size()测试一个集合的大小。  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from Cat <span class="built_in">cat</span> where <span class="built_in">cat</span>.kittens.<span class="built_in">size</span> &gt; <span class="number">0</span></span><br><span class="line">from Cat <span class="built_in">cat</span> where <span class="built_in">size</span>(<span class="built_in">cat</span>.kittens) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li>对于索引了（有序）的集合，你可以使用minindex 与 maxindex函数来引用到最小与最大的索引序数。 同理，你可以使用minelement 与 maxelement函数来 引用到一个基本数据类型的集合中最小与最大的元素。  <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Calendar cal <span class="keyword">where</span> maxelement(cal.holidays) &gt; current <span class="built_in">date</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Order</span> <span class="keyword">order</span> <span class="keyword">where</span> maxindex(<span class="keyword">order</span>.items) &gt; <span class="number">100</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Order</span> <span class="keyword">order</span> <span class="keyword">where</span> minelement(<span class="keyword">order</span>.items) &gt; <span class="number">10000</span></span><br></pre></td></tr></table></figure></li>
<li><p>在传递一个集合的索引集或者是元素集(elements与indices 函数) 或者传递一个子查询的结果的时候，可以使用SQL函数any, some, all, exists, in</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select mother from Cat as mother, Cat as kit</span><br><span class="line">where kit <span class="keyword">in</span> <span class="function"><span class="title">elements</span><span class="params">(foo.kittens)</span></span></span><br><span class="line">select <span class="tag">p</span> from NameList list, Person <span class="tag">p</span></span><br><span class="line">where <span class="tag">p</span><span class="class">.name</span> = some <span class="function"><span class="title">elements</span><span class="params">(list.names)</span></span></span><br><span class="line">from Cat cat where exists <span class="function"><span class="title">elements</span><span class="params">(cat.kittens)</span></span></span><br><span class="line">from Player <span class="tag">p</span> where <span class="number">3</span> &gt; all <span class="function"><span class="title">elements</span><span class="params">(p.scores)</span></span></span><br><span class="line">from Show show where <span class="string">'fizard'</span> <span class="keyword">in</span> <span class="function"><span class="title">indices</span><span class="params">(show.acts)</span></span></span><br></pre></td></tr></table></figure>
<p>  注意，在Hibernate3种，这些结构变量- size, elements, indices, minindex, maxindex, minelement, maxelement - 只能在where子句中使用。</p>
</li>
<li><p>一个被索引过的（有序的）集合的元素(arrays, lists, maps)可以在其他索引中被引用（只能在where子句中）：</p>
  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from Order order where order.items<span class="comment">[0]</span>.id = 1234</span><br><span class="line">select <span class="keyword">person</span> from <span class="keyword">Person</span> <span class="keyword">person</span>, Calendar calendar</span><br><span class="line">where calendar.holidays<span class="comment">['national day']</span> = <span class="keyword">person</span>.birthDay</span><br><span class="line">    and <span class="keyword">person</span>.nationality.calendar = calendar</span><br><span class="line">select item from Item item, Order order</span><br><span class="line">where order.items<span class="comment">[ order.deliveredItemIndices<span class="comment">[0]</span> ]</span> = item and order.id = 11</span><br><span class="line">select item from Item item, Order order</span><br><span class="line">where order.items<span class="comment">[ maxindex(order.items) ]</span> = item and order.id = 11</span><br></pre></td></tr></table></figure>
<p>  在[]中的表达式甚至可以是一个算数表达式。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> item <span class="keyword">from</span> Item item, <span class="keyword">Order</span> <span class="keyword">order</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">order</span>.items[ <span class="keyword">size</span>(<span class="keyword">order</span>.items) - <span class="number">1</span> ] = item</span></span><br></pre></td></tr></table></figure>
<p>  对于一个一对多的关联（one-to-many association）或是值的集合中的元素， HQL也提供内建的index()函数，</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select item, <span class="function"><span class="title">index</span><span class="params">(item)</span></span> from Order <span class="attribute">order</span> </span><br><span class="line">    join <span class="attribute">order</span><span class="class">.items</span> item</span><br><span class="line">where <span class="function"><span class="title">index</span><span class="params">(item)</span></span> &lt; <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>  如果底层数据库支持标量的SQL函数，它们也可以被使用</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from DomesticCat cat where <span class="function"><span class="title">upper</span><span class="params">(cat.name)</span></span> like <span class="string">'FRI%'</span></span><br></pre></td></tr></table></figure>
<p>  如果你还不能对所有的这些深信不疑，想想下面的查询。如果使用SQL，语句长度会增长多少，可读性会下降多少：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select cust</span><br><span class="line">from Product prod,</span><br><span class="line">    Store store</span><br><span class="line">    inner join store<span class="class">.customers</span> cust</span><br><span class="line">where prod<span class="class">.name</span> = <span class="string">'widget'</span></span><br><span class="line">    and store<span class="class">.location</span><span class="class">.name</span> <span class="keyword">in</span> ( <span class="string">'Melbourne'</span>, <span class="string">'Sydney'</span> )</span><br><span class="line">    and prod = all <span class="function"><span class="title">elements</span><span class="params">(cust.currentOrder.lineItems)</span></span></span><br></pre></td></tr></table></figure>
<p>  提示: 会像如下的语句</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust<span class="class">.name</span>, cust<span class="class">.address</span>, cust<span class="class">.phone</span>, cust<span class="class">.id</span>, cust<span class="class">.current_order</span></span><br><span class="line">FROM customers cust,</span><br><span class="line">    stores store,</span><br><span class="line">    locations loc,</span><br><span class="line">    store_customers sc,</span><br><span class="line">    product prod</span><br><span class="line">WHERE prod<span class="class">.name</span> = <span class="string">'widget'</span></span><br><span class="line">    AND store<span class="class">.loc_id</span> = loc<span class="class">.id</span></span><br><span class="line">    AND loc<span class="class">.name</span> IN ( <span class="string">'Melbourne'</span>, <span class="string">'Sydney'</span> )</span><br><span class="line">    AND sc<span class="class">.store_id</span> = store<span class="class">.id</span></span><br><span class="line">    AND sc<span class="class">.cust_id</span> = cust<span class="class">.id</span></span><br><span class="line">    AND prod<span class="class">.id</span> = ALL(</span><br><span class="line">        SELECT item<span class="class">.prod_id</span></span><br><span class="line">        FROM line_items item, orders o</span><br><span class="line">        WHERE item<span class="class">.order_id</span> = o<span class="class">.id</span></span><br><span class="line">            AND cust<span class="class">.current_order</span> = o<span class="class">.id</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="order_by子句">order by子句</h3><p>查询返回的列表(list)可以按照一个返回的类或组件（components)中的任何属性（property）进行排序：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from DomesticCat <span class="keyword">cat</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">cat</span>.name asc, <span class="keyword">cat</span>.weight <span class="keyword">desc</span>, <span class="keyword">cat</span>.birthdate</span><br></pre></td></tr></table></figure></p>
<p>可选的asc或desc关键字指明了按照升序或降序进行排序.默认是升序排序。</p>
<h3 id="group_by子句">group by子句</h3><p>一个返回聚集值(aggregate values)的查询可以按照一个返回的类或组件（components)中的任何属性（property）进行分组：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select cat<span class="class">.color</span>, <span class="function"><span class="title">sum</span><span class="params">(cat.weight)</span></span>, <span class="function"><span class="title">count</span><span class="params">(cat)</span></span> </span><br><span class="line">from Cat cat</span><br><span class="line">group by cat<span class="class">.color</span></span><br><span class="line">select foo<span class="class">.id</span>, <span class="function"><span class="title">avg</span><span class="params">(name)</span></span>, <span class="function"><span class="title">max</span><span class="params">(name)</span></span> </span><br><span class="line">from Foo foo join foo<span class="class">.names</span> name</span><br><span class="line">group by foo.id</span><br></pre></td></tr></table></figure>
<p>having子句在这里也允许使用.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select cat<span class="class">.color</span>, <span class="function"><span class="title">sum</span><span class="params">(cat.weight)</span></span>, <span class="function"><span class="title">count</span><span class="params">(cat)</span></span> </span><br><span class="line">from Cat cat</span><br><span class="line">group by cat<span class="class">.color</span> </span><br><span class="line">having cat<span class="class">.color</span> <span class="keyword">in</span> (eg<span class="class">.Color</span><span class="class">.TABBY</span>, eg<span class="class">.Color</span><span class="class">.BLACK</span>)</span><br></pre></td></tr></table></figure>
<p>如果底层的数据库支持的话(例如不能在MySQL中使用)，SQL的一般函数与聚集函数也可以出现 在having与order by 子句中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> cat</span><br><span class="line"><span class="keyword">from</span> Cat cat</span><br><span class="line">    <span class="keyword">join</span> cat.kittens kitten</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cat</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(kitten.weight) &gt; <span class="number">100</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">count</span>(kitten) <span class="keyword">asc</span>, <span class="keyword">sum</span>(kitten.weight) <span class="keyword">desc</span></span></span><br></pre></td></tr></table></figure>
<p>注意group by子句与 order by子句中都不能包含算术表达式（arithmetic expressions）.</p>
<h3 id="子查询">子查询</h3><p>对于支持子查询的数据库，Hibernate支持在查询中使用子查询。一个子查询必须被圆括号包围起来（经常是SQL聚集函数的圆括号）。 甚至相互关联的子查询（引用到外部查询中的别名的子查询）也是允许的。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Cat <span class="keyword">as</span> fatcat </span><br><span class="line"><span class="keyword">where</span> fatcat.weight &gt; ( </span><br><span class="line">    <span class="function"><span class="keyword">select</span> <span class="title">avg</span>(<span class="params">cat.weight</span>) <span class="keyword">from</span> DomesticCat cat </span><br><span class="line">)</span></span><br></pre></td></tr></table></figure></p>
<p>在select列表中包含一个表达式以上的子查询，你可以使用一个元组构造符（tuple constructors）：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Cat</span> <span class="keyword">as</span> <span class="keyword">cat</span> </span><br><span class="line">where not ( <span class="keyword">cat</span>.name, <span class="keyword">cat</span>.color ) <span class="keyword">in</span> ( </span><br><span class="line">    select <span class="keyword">cat</span>.name, <span class="keyword">cat</span>.color from DomesticCat <span class="keyword">cat</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>注意在某些数据库中（不包括Oracle与HSQL），你也可以在其他语境中使用元组构造符， 比如查询用户类型的组件与组合：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span> where name = ('Gavin', 'A', 'King')</span><br></pre></td></tr></table></figure>
<p>该查询等价于更复杂的：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span> where name.first = 'Gavin' and name.initial = 'A' and name.last = 'King')</span><br></pre></td></tr></table></figure>
<p>有两个很好的理由使你不应当作这样的事情：首先，它不完全适用于各个数据库平台；其次，查询现在依赖于映射文件中属性的顺序。</p>
<h3 id="命名查询">命名查询</h3><p>命名查询实际上就是给查询语句起个名字，执行查询的时候就是直接使用起的这个名字，避免重复写HQL语句，使查询在代码中得到更多的重用。</p>
<ol>
<li><p>使用@NamedQuery注解在实体类中定义命名查询。</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function"><span class="title">NamedQuery</span><span class="params">(name=<span class="string">"findAllUser"</span>,query=<span class="string">"SELECT u FROM User u"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p> @NamedQuery中的属性name指定命名查询的名称，query属性指定命名查询的语句。</p>
<p> 如果要定义多个命名查询，需要使用@NamedQueries。</p>
 <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@NamedQueries</span>(&#123;</span><br><span class="line">    <span class="variable">@NamedQuery</span>(name=<span class="string">"findAllUser"</span>,query=<span class="string">"SELECT u FROM User u"</span>),</span><br><span class="line">    <span class="variable">@NamedQuery</span>(name=<span class="string">"findUserWithId"</span>,query=<span class="string">"SELECT u FROM User u WHERE u.id = ?1"</span>),</span><br><span class="line">    <span class="variable">@NamedQuery</span>(name=<span class="string">"findUserWithName"</span>,query=<span class="string">"SELECT u FROM User u WHERE u.name = :name"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义好命名查询后，可以使用EntityManager的createNamedQuery方法传入命名查询的名称创建查询。例如：createNamedQuery(“findAllUser”);</p>
</li>
<li>一个简单的例子。　　</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.NamedQueries;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.NamedQuery;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"> </span><br><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@Table</span>(name=<span class="string">"t_user"</span>)</span><br><span class="line"><span class="annotation">@NamedQueries</span>(&#123;</span><br><span class="line">        <span class="annotation">@NamedQuery</span>(name=<span class="string">"findAllUser"</span>,query=<span class="string">"SELECT u FROM User u"</span>),</span><br><span class="line">        <span class="annotation">@NamedQuery</span>(name=<span class="string">"findUserWithId"</span>,query=<span class="string">"SELECT u FROM User u WHERE u.id = ?1"</span>),</span><br><span class="line">        <span class="annotation">@NamedQuery</span>(name=<span class="string">"findUserWithName"</span>,query=<span class="string">"SELECT u FROM User u WHERE u.name = :name"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Id</span></span><br><span class="line">    <span class="annotation">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@Column</span>(name=<span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123; <span class="keyword">this</span>.id = id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Persistence;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Query;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> entity.User;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNamedQuery</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    EntityManagerFactory emf = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据在persistence.xml中配置的persistence-unit name 创建EntityManagerFactory</span></span><br><span class="line">        emf = Persistence.createEntityManagerFactory(<span class="string">"myJPA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//关闭EntityManagerFactory</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != emf) &#123;</span><br><span class="line">            emf.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedQuery1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EntityManager em = emf.createEntityManager();</span><br><span class="line">        List&lt;User&gt; users = em.createNamedQuery(<span class="string">"findAllUser"</span>).getResultList();<span class="comment">//根据User实体中定义的命名查询</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedQuery2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EntityManager em = emf.createEntityManager();</span><br><span class="line">        Query query =  em.createNamedQuery(<span class="string">"findUserWithId"</span>);<span class="comment">//根据User实体中定义的命名查询</span></span><br><span class="line">        query.setParameter(<span class="number">1</span>, <span class="number">2L</span>);</span><br><span class="line">        List&lt;User&gt; users = query.getResultList();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedQuery3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EntityManager em = emf.createEntityManager();</span><br><span class="line">        Query query =  em.createNamedQuery(<span class="string">"findUserWithName"</span>);<span class="comment">//根据User实体中定义的命名查询</span></span><br><span class="line">        query.setParameter(<span class="string">"name"</span>, <span class="string">"李坏"</span>);</span><br><span class="line">        List&lt;User&gt; users = query.getResultList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="条件查询">条件查询</h2><ul>
<li>Criteria：代表一次查询</li>
<li>Criterion：代表一个查询条件</li>
<li>Restrictions：产生查询条件的工具类</li>
</ul>
<p>执行条件查询的步骤如下：</p>
<ol>
<li>获得Hibernate的Session对象</li>
<li>以Session对象创建Criteria （org.hibernate.Criteria接口表示特定持久类的一个查询。Session是 Criteria实例的工厂。）</li>
<li>使用Restrictions的静态方法创建Criterion查询条件</li>
<li>向Criteria查询中添加Criterion查询条件</li>
<li>执行Criteria的list等方法返回结果集</li>
</ol>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> <span class="built_in">list</span> <span class="subst">=</span> session<span class="built_in">.</span>createCriteria(Student<span class="built_in">.</span>class)</span><br><span class="line"><span class="built_in">.</span>add(Restrictions<span class="built_in">.</span><span class="literal">gt</span>(<span class="string">"name"</span>,<span class="string">"a"</span>))</span><br><span class="line"><span class="built_in">.</span><span class="built_in">list</span>();</span><br></pre></td></tr></table></figure>
<p>Criteria常用方法</p>
<ul>
<li>Criteria setFirstResult(int firstResult):设置查询返回的第一行记录</li>
<li>Criteria setMaxResults(int maxResults):设置查询返回的记录数</li>
<li>Criteria add(Criterion criterion):增加查询条件</li>
<li>Criteria addOrder(Order order):增加排序规则</li>
</ul>
<p>Restrictions产生查询条件Criterion，常用静态方法</p>
<p>下面方法返回Criterion</p>
<ul>
<li>Restrictions.eq —&gt; equal,等于.</li>
<li>Restrictions.allEq —&gt; 参数为Map对象,使用key/value进行多个等于的比对,相当于多个Restrictions.eq的效果</li>
<li>Restrictions.gt —&gt; great-than &gt; 大于</li>
<li>Restrictions.ge —&gt; great-equal &gt;= 大于等于</li>
<li>Restrictions.lt —&gt; less-than, &lt; 小于</li>
<li>Restrictions.le —&gt; less-equal &lt;= 小于等于</li>
<li>Restrictions.between —&gt; 对应SQL的between子句</li>
<li>Restrictions.like —&gt; 对应SQL的LIKE子句</li>
<li>Restrictions.in —&gt; 对应SQL的in子句</li>
<li>Restrictions.and —&gt; and 关系</li>
<li>Restrictions.or —&gt; or 关系</li>
<li>Restrictions.not —&gt; 求否</li>
<li>Restrictions.isEmpty —&gt; 判断属性是否为空,为空则返回true</li>
<li>Restrictions.isNotEmpty —&gt; 与isNull相反</li>
<li>Restrictions.isNull —&gt; 判断属性是否为空,为空则返回true</li>
<li>Restrictions.isNotNull —&gt; 与isNull相反</li>
<li>Restrictions.sqlRestriction —&gt; SQL限定的查询</li>
<li>Restrictions.sizeEq —&gt; 判断某个属性的元素个数是否与size相等<br>下面方法返回Order</li>
<li>Restrictions.asc —&gt; 限定升序排序</li>
<li>Restrictions.desc —&gt; 限定降序排序</li>
</ul>
<h3 id="关联和动态关联">关联和动态关联</h3><p>你可以使用createCriteria()非常容易的在互相关联的实体间建立约束。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list = session.createCriteria<span class="params">(Student.class)</span></span><br><span class="line">    .add<span class="params">( Restrictions.like<span class="params">(<span class="string">"name"</span>, <span class="string">"F%"</span>)</span></span><br><span class="line">    .createCriteria<span class="params">(<span class="string">"enrolments"</span>)</span></span><br><span class="line">    .add<span class="params">( Restrictions.gt<span class="params">(<span class="string">"semester"</span>, <span class="number">2</span>)</span></span><br><span class="line">    .list<span class="params">()</span>;</span></span></span><br></pre></td></tr></table></figure>
<p>第一个查询条件是直接过滤Person的属性。第二个查询条件则过滤Person的关联实体的属性，其中enrolments是Person类的关联实体，而semester则是Enrolment类的属性。返回的并不是Enrolment对象，而是Person对象的集合。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list = session.createCriteria<span class="params">(Student.class)</span></span><br><span class="line">    .add<span class="params">( Restrictions.like<span class="params">(<span class="string">"name"</span>, <span class="string">"F%"</span>)</span></span><br><span class="line">    .createAlias<span class="params">(<span class="string">"enrolments"</span>,<span class="string">"en"</span>)</span></span><br><span class="line">    .add<span class="params">( Restrictions.gt<span class="params">(<span class="string">"en.semester"</span>, <span class="number">2</span>)</span></span><br><span class="line">    .list<span class="params">()</span>;</span></span></span><br></pre></td></tr></table></figure>
<p>createAlias()并不创建一个新的 Criteria实例。它只是给关联实体（包括集合里包含的关联实体）起一个别名，让后面的过滤条件可根据该关联实体进行筛选。</p>
<p>Student实例所保存的之前两次查询所返回的enrolments集合是没有被条件预过滤的。如果你希望只获得符合条件的enrolments， 你必须使用returnMaps()。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List list = session.createCriteria<span class="params">(Student.class)</span></span><br><span class="line">    .add<span class="params">( Restrictions.like<span class="params">(<span class="string">"name"</span>, <span class="string">"F%"</span>)</span></span><br><span class="line">    .createCriteria<span class="params">(<span class="string">"enrolments"</span>,<span class="string">"en"</span>)</span></span><br><span class="line">    .add<span class="params">( Restrictions.gt<span class="params">(<span class="string">"en.semester"</span>, <span class="number">2</span>)</span></span><br><span class="line">    .returnMaps<span class="params">()</span></span><br><span class="line">    .list<span class="params">()</span>;</span><br><span class="line">Iterator iter = list.iterator<span class="params">()</span>;</span><br><span class="line">while <span class="params">( iter.hasNext<span class="params">()</span> )</span> &#123;</span><br><span class="line">    Map map = <span class="params">(Map)</span> iter.next<span class="params">()</span>;</span><br><span class="line">    Student stu= <span class="params">(Student)</span> map.get<span class="params">(Criteria.ROOT_ALIAS)</span>;</span><br><span class="line">    Student en = <span class="params">(Student)</span> map.get<span class="params">(<span class="string">"en"</span>)</span>;</span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>动态关联抓取</strong></p>
<p>FetchMode里有如下几个常量：</p>
<ul>
<li>DEFAULT：使用配置文件指定的延迟加载策略处理</li>
<li>JOIN：使用外连接、预初始化所有关联实体</li>
<li>SELECT：启用延迟加载，系统将使用单独的select语句来初始化关联实体。只有当真正访问关联实体的时候，才会执行第二条select语句。</li>
</ul>
<p>你可以使用setFetchMode()在运行时定义动态关联抓取的语义。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> <span class="built_in">list</span> <span class="subst">=</span> session<span class="built_in">.</span>createCriteria(Student<span class="built_in">.</span>class)</span><br><span class="line">    <span class="built_in">.</span>add( Restrictions<span class="built_in">.</span>like(<span class="string">"name"</span>, <span class="string">"F%"</span>)</span><br><span class="line">    <span class="built_in">.</span>setFetchMode(<span class="string">"enrolments"</span>,FetchMode<span class="built_in">.</span><span class="keyword">JOIN</span>)</span><br><span class="line">    <span class="built_in">.</span><span class="built_in">list</span>();</span><br></pre></td></tr></table></figure>
<p>以上程序会预初始化Student关联的enrolments集合。</p>
<h3 id="投影(Projections)、聚合（aggregation）和分组（grouping）">投影(Projections)、聚合（aggregation）和分组（grouping）</h3><p>org.hibernate.criterion.Projections是 Projection 的实例工厂。我们通过调用 setProjection()应用投影到一个查询。</p>
<ul>
<li>AggregateProjection avg(String propertyName)：类似avg函数</li>
<li>CountProjection count(String propertyName)：类似count函数</li>
<li>CountProjection countDistinct(String propertyName)：类似count(distinct column)</li>
<li>PropertyProjection groupProperty(String propertyName)：类似添加group by子句</li>
<li>AggregateProjection max(String propertyName)：类似max函数</li>
<li>AggregateProjection min(String propertyName)：类似min函数</li>
<li>Projection rowCount()：类似count(*)</li>
<li>AggregateProjection sum(String propertyName)：类似sum函数</li>
</ul>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List results = session.createCriteria<span class="params">(Cat.class)</span></span><br><span class="line">    .setProjection<span class="params">( Projections.rowCount<span class="params">()</span> )</span></span><br><span class="line">    .add<span class="params">( Restrictions.eq<span class="params">(<span class="string">"color"</span>, Color.BLACK)</span> )</span></span><br><span class="line">    .list<span class="params">()</span>;</span><br><span class="line">List results = session.createCriteria<span class="params">(Cat.class)</span></span><br><span class="line">    .setProjection<span class="params">( Projections.projectionList<span class="params">()</span></span><br><span class="line">        .add<span class="params">( Projections.rowCount<span class="params">()</span> )</span></span><br><span class="line">        .add<span class="params">( Projections.avg<span class="params">(<span class="string">"weight"</span>)</span> )</span></span><br><span class="line">        .add<span class="params">( Projections.max<span class="params">(<span class="string">"weight"</span>)</span> )</span></span><br><span class="line">        .add<span class="params">( Projections.groupProperty<span class="params">(<span class="string">"color"</span>)</span> )</span></span><br><span class="line">    )</span></span><br><span class="line">    .list<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>在一个条件查询中没有必要显式的使用 “group by” 。某些投影类型就是被定义为 分组投影，他们也出现在SQL的group by子句中。</p>
<p>你可以选择把一个别名指派给一个投影，这样可以使投影值被约束或排序所引用。下面是两种不同的实现方式：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List results = session.createCriteria<span class="params">(Cat.class)</span></span><br><span class="line">    .setProjection<span class="params">( Projections.alias<span class="params">( Projections.groupProperty<span class="params">(<span class="string">"color"</span>)</span>, <span class="string">"colr"</span> )</span> )</span></span><br><span class="line">    .addOrder<span class="params">( Order.asc<span class="params">(<span class="string">"colr"</span>)</span> )</span></span><br><span class="line">    .list<span class="params">()</span>;</span><br><span class="line">List results = session.createCriteria<span class="params">(Cat.class)</span></span><br><span class="line">    .setProjection<span class="params">( Projections.groupProperty<span class="params">(<span class="string">"color"</span>)</span>.as<span class="params">(<span class="string">"colr"</span>)</span> )</span></span><br><span class="line">    .addOrder<span class="params">( Order.asc<span class="params">(<span class="string">"colr"</span>)</span> )</span></span><br><span class="line">    .list<span class="params">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>alias()和as()方法简便的将一个投影实例包装到另外一个别名的Projection实例中。简而言之，当你添加一个投影到一个投影列表中时你可以为它指定一个别名，使用ProjectionList的add()方法添加投影时指定别名</p>
<h3 id="离线(detached)查询和子查询">离线(detached)查询和子查询</h3><p>DetachedCriteria类使你在一个session范围之外创建一个查询，并且可以使用任意的 Session来执行它。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DetachedCriteria query = DetachedCriteria.forClass<span class="params">(Cat.class)</span></span><br><span class="line">    .add<span class="params">( Property.forName<span class="params">(<span class="string">"sex"</span>)</span>.eq<span class="params">('F')</span> )</span>;</span><br><span class="line">Session session = HibernateUtil.currentSession<span class="params">()</span>; </span><br><span class="line">Transaction txn = session.beginTransaction<span class="params">()</span>;</span><br><span class="line">List results = query.getExecutableCriteria<span class="params">(session)</span>.setMaxResults<span class="params">(<span class="number">100</span>)</span>.list<span class="params">()</span>;</span><br><span class="line">txn.commit<span class="params">()</span>;</span><br><span class="line">session.close<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>DetachedCriteria也可以用以表示子查询。条件实例包含子查询可以通过 Subqueries或者Property获得。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DetachedCriteria avgWeight = DetachedCriteria.forClass(<span class="keyword">Cat</span>.<span class="keyword">class</span>)</span><br><span class="line">	.setProjection( Property.forName(<span class="string">"weight"</span>).avg() );</span><br><span class="line">session.createCriteria(<span class="keyword">Cat</span>.<span class="keyword">class</span>)</span><br><span class="line">	.add( Property.forName("weight).gt(avgWeight) )</span><br><span class="line">	.<span class="keyword">list</span>();</span><br><span class="line">DetachedCriteria weights = DetachedCriteria.forClass(<span class="keyword">Cat</span>.<span class="keyword">class</span>)</span><br><span class="line">	.setProjection( Property.forName(<span class="string">"weight"</span>) );</span><br><span class="line">session.createCriteria(<span class="keyword">Cat</span>.<span class="keyword">class</span>)</span><br><span class="line">	.add( Subqueries.geAll(<span class="string">"weight"</span>, weights) )</span><br><span class="line">	.<span class="keyword">list</span>();</span><br></pre></td></tr></table></figure>
<p>甚至相互关联的子查询也是有可能的：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DetachedCriteria avgWeightForSex = DetachedCriteria.forClass<span class="params">(Cat.class, <span class="string">"cat2"</span>)</span></span><br><span class="line">	.setProjection<span class="params">( Property.forName<span class="params">(<span class="string">"weight"</span>)</span>.avg<span class="params">()</span> )</span></span><br><span class="line">	.add<span class="params">( Property.forName<span class="params">(<span class="string">"cat2.sex"</span>)</span>.eqProperty<span class="params">(<span class="string">"cat.sex"</span>)</span> )</span>;</span><br><span class="line">session.createCriteria<span class="params">(Cat.class, <span class="string">"cat"</span>)</span></span><br><span class="line">	.add<span class="params">( Property.forName<span class="params">(<span class="string">"weight).gt(avgWeightForSex) )</span><br><span class="line">	.list();</span></span></span></span><br></pre></td></tr></table></figure>
<h2 id="SQL查询">SQL查询</h2><p>SQL查询是通过SQLQuery接口来表示的。Query接口的子接口，可调用Query接口的方法：setFirstResult、setMaxResults、list。</p>
<p>此外还有两个重载的方法。</p>
<ul>
<li>addEntity()：将查询到的记录与特定的实体关联。</li>
<li>addScalar()：将查询到的记录关联成标量值。</li>
</ul>
<p>执行SQL查询的步骤如下：</p>
<ol>
<li>获取Hibernate Session对象 </li>
<li>编写SQL语句</li>
<li>以SQL语句为参数，调用Session的createSQLQuery方法创建查询对象</li>
<li>调用SQLQuery对象的addScalar或addEntity方法将选出的结果与标量值或实体进行关联，分别用于进行标量查询或实体查询。</li>
<li>如果SQL语句包含参数，则调用Query的setxxx方法为参数赋值。</li>
<li>调用Query的list方法返回查询的结果集。</li>
</ol>
<h3 id="标量查询">标量查询</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session.createSQLQuery<span class="params">(<span class="string">"select * from student_inf"</span>)</span></span><br><span class="line">    .addScalar<span class="params">(<span class="string">"name"</span>,StandardBasicTypes.STRING)</span></span><br><span class="line">    .list<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>list方法返回数组元素的List，但是像上面程序指定了name列，只会返回单个变量值的List</p>
<p>addScalar的作用</p>
<ul>
<li>指定查询结果包含哪些数据列—没有被addScalar选出的列将不会包含在查询结果中。</li>
<li>指定查询结果中数据列的数据类型。</li>
</ul>
<h3 id="实体查询">实体查询</h3><p>如果查询返回了某个数据表的全部数据列（<strong>记住：是选出全部数据列</strong>），且该数据表有对应的持久化类映射，我们就可把查询结果转换成实体查询。将查询结果转换成实体，可以使用addEntity方法。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="built_in">list</span> = session.createSQLQuery(<span class="string">"select enrolment_inf where year=:year"</span>)</span><br><span class="line">        .addEntity(<span class="type">Enrolment</span>.<span class="keyword">class</span>)</span><br><span class="line">        .setInteger(<span class="string">"year"</span>,<span class="number">2005</span>)</span><br><span class="line">        .<span class="built_in">list</span><span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<p>可以看出原生SQL语句一样支持使用参数。</p>
<p>Hibernate还支持将查询结果转换成多个实体。如果要将查询结果转换成多个实体，则需要指定别名，并调用addEntity(String alias, Class entityClass)方法将不同数据表转换成不同实体。<br>Hibernate还可将查询的结果转换成非持久化实体，只要该JavaBean为这些数据列提供了对应的setter和getter方法。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="built_in">list</span> = session.createSQLQuery(<span class="type">SQLQuery</span>).setResultTransformer(<span class="type">Transformers</span>.aliasToBean(<span class="type">StudentCourse</span>.<span class="keyword">class</span>)).<span class="built_in">list</span><span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="处理关联和继承">处理关联和继承</h3><p>将关联实体转换成查询结果的方法是SQLQuery addJoin(String alias, String path)，该方法第一个参数是转换后的实体名，第二个参数是待转换的实体属性。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">void</span> joinQuery()&#123;</span><br><span class="line">    <span class="type">Session</span> session = <span class="type">HibernateUtil</span>.currentSession();</span><br><span class="line">    <span class="type">Transaction</span> tx = session.beginTransaction();</span><br><span class="line">    <span class="type">String</span> sql = <span class="string">"select s.*,e.* from student_inf s,enrolment_inf e where s.student_id=e.student_id"</span>;</span><br><span class="line">    <span class="type">List</span> list = session.createSQLQuery(sql)</span><br><span class="line">                .addEntity(<span class="string">"s"</span>,<span class="type">Student</span>.class)</span><br><span class="line">                .addJoin(<span class="string">"e"</span>,<span class="string">"s.enrolments"</span>)</span><br><span class="line">                .list();</span><br><span class="line">    tx.commit();</span><br><span class="line">    <span class="type">HibernateUtil</span>.closeSession();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="keyword">iterator</span> = list.<span class="keyword">iterator</span>();<span class="keyword">iterator</span>.hasNext();)&#123;</span><br><span class="line">        //每个集合元素都是<span class="type">Person</span>、<span class="type">MyEvent</span>所组成的数组</span><br><span class="line">        <span class="type">Object</span>[] objects = (<span class="type">Object</span>[]) <span class="keyword">iterator</span>.next();</span><br><span class="line">        <span class="type">Student</span> stu = (<span class="type">Student</span>) objects[<span class="number">0</span>];</span><br><span class="line">        <span class="type">Enrolments</span> e = (<span class="type">Enrolments</span>) objects[<span class="number">1</span>];</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(s.getName()+<span class="string">"\t"</span>+e.getYear());</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序中可以看到的，程序将s.enrolments属性转换成别名为e的实体，也就是说程序执行的结果是Student、Enrolment对象数组的列表。</p>
<h3 id="命名SQL查询">命名SQL查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@SqlResultSetMapping</span>(name=<span class="string">"compositekey"</span>,</span><br><span class="line">        entities=<span class="annotation">@EntityResult</span>(entityClass=SpaceShip.class,</span><br><span class="line">            fields = &#123;</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"name"</span>, column = <span class="string">"name"</span>),</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"model"</span>, column = <span class="string">"model"</span>),</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"speed"</span>, column = <span class="string">"speed"</span>),</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"captain.firstname"</span>, column = <span class="string">"firstn"</span>),</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"captain.lastname"</span>, column = <span class="string">"lastn"</span>),</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"dimensions.length"</span>, column = <span class="string">"length"</span>),</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"dimensions.width"</span>, column = <span class="string">"width"</span>)</span><br><span class="line">                    &#125;),</span><br><span class="line">        columns = &#123; <span class="annotation">@ColumnResult</span>(name = <span class="string">"surface"</span>),</span><br><span class="line">                    <span class="annotation">@ColumnResult</span>(name = <span class="string">"volume"</span>) &#125; )</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NamedNativeQuery</span>(name=<span class="string">"compositekey"</span>,</span><br><span class="line">    query=<span class="string">"select name, model, speed, lname as lastn, fname as firstn, length, width, length * width as surface from SpaceShip"</span>, </span><br><span class="line">    resultSetMapping=<span class="string">"compositekey"</span>)</span><br><span class="line">&#125; )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String model;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> speed;</span><br><span class="line">    <span class="keyword">private</span> Captain captain;</span><br><span class="line">    <span class="keyword">private</span> Dimensions dimensions;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ManyToOne</span>(fetch= FetchType.LAZY)</span><br><span class="line">    <span class="annotation">@JoinColumns</span>( &#123;</span><br><span class="line">            <span class="annotation">@JoinColumn</span>(name=<span class="string">"fname"</span>, referencedColumnName = <span class="string">"firstname"</span>),</span><br><span class="line">            <span class="annotation">@JoinColumn</span>(name=<span class="string">"lname"</span>, referencedColumnName = <span class="string">"lastname"</span>)</span><br><span class="line">            &#125; )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Captain <span class="title">getCaptain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> captain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCaptain</span><span class="params">(Captain captain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.captain = captain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModel</span><span class="params">(String model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpeed</span><span class="params">(<span class="keyword">double</span> speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dimensions <span class="title">getDimensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dimensions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDimensions</span><span class="params">(Dimensions dimensions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dimensions = dimensions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@IdClass</span>(Identity.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Captain</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstname;</span><br><span class="line">    <span class="keyword">private</span> String lastname;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstname</span><span class="params">(String firstname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstname = firstname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastname</span><span class="params">(String lastname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastname = lastname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Session的getNamedQuery即可获取指定命名SQL查询。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.getNamedQuery(<span class="string">"compositekey"</span>).<span class="built_in">list</span><span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="调用存储过程">调用存储过程</h3><p>Hibernate可以通过命名SQL查询来调用存储过程或函数。对于函数，该函数必须返回一个结果集；对于存储过程，该存储过程的第一个参数必须是传出参数，且数据类型是结果集。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">select_all_student</span><span class="params">()</span></span><br><span class="line"><span class="title">select</span> *</span><br><span class="line"><span class="title">from</span> <span class="title">student_inf</span>;</span></span><br></pre></td></tr></table></figure>
<p>如果需要使用该存储过程，可以先将其定义成命名SQL查询，当使用原生SQL来调用存储过程或触发器时，应为<code>&lt;sql-query.../&gt;</code>元素指定<code>callable=&quot;true&quot;</code>。还需要使用<code>&lt;return-property .../&gt;</code>子元素将指定列转换成实体的属性。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql-query <span class="property">name</span>=<span class="string">"callProcedure"</span> callable=<span class="string">"true"</span>&gt;</span><br><span class="line">    &lt;<span class="constant">return</span> <span class="type">class</span>=<span class="string">"Student"</span>&gt;</span><br><span class="line">        &lt;<span class="constant">return</span>-<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"studentNumber"</span> column=<span class="string">"student_id"</span>/&gt;</span><br><span class="line">        &lt;<span class="constant">return</span>-<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"name"</span> column=<span class="string">"name"</span>/&gt;</span><br><span class="line">    &lt;/<span class="constant">return</span>&gt;</span><br><span class="line">    &#123;call select_all_student()&#125;</span><br><span class="line">&lt;/sql-query&gt;</span><br></pre></td></tr></table></figure>
<p>调用存储过程</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void callProcedure<span class="params">()</span>&#123;</span><br><span class="line">    Session session = HibernateUtil.currentSession<span class="params">()</span>;</span><br><span class="line">    Transaction tx=session.beginTransaction<span class="params">()</span>;</span><br><span class="line">    List list = session.getNamedQuery<span class="params">(<span class="string">"callProcedure"</span>)</span>.list<span class="params">()</span>;</span><br><span class="line">    tx.commit<span class="params">()</span>;</span><br><span class="line">    HibernateUtil.closeSession<span class="params">()</span>;</span><br><span class="line">    <span class="comment">//遍历结果集</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意</p>
<ul>
<li>建议采用的调用方式是标准SQL92语法，如<code>{?=call functionName(&lt;parameters&gt;)}</code>或 <code>{callprocedureName(&lt;parameters&gt;)}</code>，不支持原生的调用语法。</li>
<li>因为存储过程本身完成了查询的全部操作。因此，调用存储过程进行的查询无法使用setFirstResult/setMaxResults进行分页。</li>
</ul>
<p>对于Oracle有如下规则:</p>
<ul>
<li>存储过程必须返回一个结果集.它通过返回<code>SYS_REFCURSOR</code>实现(在Oracle9或10),在Oracle里你需要定义一个<code>REF CURSOR</code> 类型</li>
<li>推荐的格式是<code>{ ? = call procName(&lt;parameters&gt;) }</code>或<code>{ ? = call procName }</code>(这更像是Oracle规则而不是Hibernate规则)</li>
</ul>
<p>对于Sybase或者MS SQL server有如下规则:</p>
<ul>
<li>存储过程必须返回一个结果集。.注意这些servers可能返回多个结果集以及更新的数目.Hibernate将取出第一条结果集作为它的返回值， 其他将被丢弃。</li>
<li>如果你能够在存储过程里设定SET NOCOUNT ON，这可能会效率更高，但这不是必需的。</li>
</ul>
<h3 id="定制SQL">定制SQL</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@Table</span>(name=<span class="string">"CHAOS"</span>)</span><br><span class="line"><span class="annotation">@SQLInsert</span>( sql=<span class="string">"INSERT INTO CHAOS(size, name, nickname, id) VALUES(?,upper(?),?,?)"</span>)</span><br><span class="line"><span class="annotation">@SQLUpdate</span>( sql=<span class="string">"UPDATE CHAOS SET size = ?, name = upper(?), nickname = ? WHERE id = ?"</span>)</span><br><span class="line"><span class="annotation">@SQLDelete</span>( sql=<span class="string">"DELETE CHAOS WHERE id = ?"</span>)</span><br><span class="line"><span class="annotation">@SQLDeleteAll</span>( sql=<span class="string">"DELETE CHAOS"</span>)</span><br><span class="line"><span class="annotation">@Loader</span>(namedQuery = <span class="string">"chaos"</span>)</span><br><span class="line"><span class="annotation">@NamedNativeQuery</span>(name=<span class="string">"chaos"</span>, query=<span class="string">"select id, size, name, lower( nickname ) as nickname from CHAOS where id= ?"</span>, resultClass = Chaos.<span class="keyword">class</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chaos</span> &#123;</span></span><br><span class="line">    <span class="annotation">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long size;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="comment">//setter and getter</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用xml配置文件形式</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;class name=<span class="string">"Person"</span>&gt;</span><br><span class="line">    &lt;id name=<span class="string">"id"</span>&gt;</span><br><span class="line">        &lt;generator class=<span class="string">"increment"</span>/&gt;</span><br><span class="line">    &lt;/id&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> not-null=<span class="string">"true"</span>/&gt;</span><br><span class="line">    &lt;sql-insert&gt;INSERT INTO <span class="keyword">PERSON</span> (NAME, ID) VALUES ( UPPER(?), ? )&lt;/sql-insert&gt;</span><br><span class="line">    &lt;sql-update&gt;UPDATE <span class="keyword">PERSON</span> SET NAME=UPPER(?) WHERE ID=?&lt;/sql-update&gt;</span><br><span class="line">    &lt;sql-delete&gt;DELETE FROM <span class="keyword">PERSON</span> WHERE ID=?&lt;/sql-delete&gt;</span><br><span class="line">&lt;/class&gt;</span><br></pre></td></tr></table></figure>
<p>使用存储过程也是可以的，需要指定<code>callable=&quot;true&quot;</code>，调用存储过程的顺序必须和Hibernate所期待的顺序相同。程序将日志调试级别设为<code>org.hibernate.persister.entity</code>。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">not-null</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">sql-insert</span> <span class="attribute">callable</span>=<span class="value">"true"</span>&gt;</span>&#123;call createPerson(?,?)&#125;<span class="tag">&lt;/<span class="title">sql-insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">sql-update</span> <span class="attribute">callable</span>=<span class="value">"true"</span>&gt;</span>&#123;? = call updatePerson(?)&#125;<span class="tag">&lt;/<span class="title">sql-delete</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">sql-delete</span> <span class="attribute">callable</span>=<span class="value">"true"</span>&gt;</span>&#123;? = call deletePerson(?)&#125;<span class="tag">&lt;/<span class="title">sql-delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">class</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="数据过滤">数据过滤</h2><p>过滤器和定义在类和集合映射文件上的<code>where</code>属性非常相似。它们的区别是过滤器可以带参数，应用程序可以在运行时决定是否启用指定的过滤器，使用怎样的参数值。而映射文见上的<code>where</code>属性将一直生效，且无法动态传入参数。</p>
<p>过滤器的用法很想数据库视图，区别是视图在数据库中已经定义完成，而过滤器则还需在应用程序中确定参数值。</p>
<p>@org.hibernate.annotations.FilterDef 或 @FilterDefs 定义过滤器声明,为同名过滤器所用. 过滤器声明带有一个name()和一个parameters()数组,@ParamDef包含name和type, 你还可以为给定的@filterDef定义一个defaultCondition()参数, 当@Filter中没有任何定义时,可使用该参数定义缺省条件. @FilterDef (s)可以在类或包一级进行定义.</p>
<p>现在我们来定义应用于实体或集合加载时的SQL过滤器子句.我们使用@Filter,并将其置于实体或集合元素上。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@FilterDef</span>(name=<span class="string">"minLength"</span>, parameters=<span class="variable">@ParamDef</span>( name=<span class="string">"minLength"</span>, type=<span class="string">"integer"</span> ) )</span><br><span class="line"><span class="variable">@Filters</span>( &#123;</span><br><span class="line">    <span class="variable">@Filter</span>(name=<span class="string">"betweenLength"</span>, condition=<span class="string">":minLength &lt;= length and :maxLength &gt;= length"</span>),</span><br><span class="line">    <span class="variable">@Filter</span>(name=<span class="string">"minLength"</span>, condition=<span class="string">":minLength &lt;= length"</span>)</span><br><span class="line">&#125; )</span><br><span class="line">public class Forest &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>过滤器的目标是实体表，使用@Filter，如果是关联表使用@FilterJoinTable<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@OneToMany</span></span><br><span class="line"><span class="variable">@JoinTable</span></span><br><span class="line"><span class="comment">//filter on the target entity table</span></span><br><span class="line"><span class="variable">@Filter</span>(name=<span class="string">"betweenLength"</span>, condition=<span class="string">":minLength &lt;= length and :maxLength &gt;= length"</span>)</span><br><span class="line"><span class="comment">//filter on the association table</span></span><br><span class="line"><span class="variable">@FilterJoinTable</span>(name=<span class="string">"security"</span>, condition=<span class="string">":userlevel &gt;= requredLevel"</span>)</span><br><span class="line">public Set&lt;Forest&gt; <span class="function">getForests</span>() &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，Hibernate自动确定@Filter SQL条件中的所有点，这样别名需要被注入，设置@Filter中deduceAliasInjectionPoints为false。然后使用@SqlFragmentAlias注解，在SQL的条件语句中使用{alias}占位符。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@Table</span>(name=<span class="string">"T_TREE"</span>)</span><br><span class="line"><span class="variable">@Filters</span>(&#123;</span><br><span class="line">    <span class="variable">@Filter</span>(name=<span class="string">"isTall"</span>, condition=<span class="string">"&#123;alias&#125;.LENGTH &gt;= 100"</span>, deduceAliasInjectionPoints = false),</span><br><span class="line">    <span class="variable">@Filter</span>(name=<span class="string">"isOak"</span>, condition=<span class="string">"&#123;t&#125;.WOODTYPE like 'oak'"</span>, deduceAliasInjectionPoints = false,</span><br><span class="line">        aliases=&#123;<span class="variable">@SqlFragmentAlias</span>(alias=<span class="string">"t"</span>, table=<span class="string">"T_TREE"</span>)&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">public class Tree &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于xml配置文件方式，系统默认不启用过滤器，必须通过Session的enableFilter(String filterName)才可以启用过滤器，该方法返回一个Filter实例，Filter包含setParameter方法用于为过滤器参数赋值。</p>
<p>通常来说，如果某个筛选条件使用得非常频繁，那么我们可以将该筛选条件设置为过滤器；如果是临时的数据筛选，还是使用常规查询比较好。对于在SQL语句中使用行内表达式、视图的地方，现在可考虑使用过滤器。</p>
<h2 id="事物控制">事物控制</h2><h3 id="事务的概念">事务的概念</h3><p>事务是一步或几步基本操作组成的逻辑执行单元，这些基本操作作为一个整体执行单元，它们要么全部执行，要么全部取消，绝不能仅仅执行部分。一般而言，每次用户请求，对应一个业务逻辑方法，一个业务逻辑方法往往具有逻辑上的原子性，应该使用事务。</p>
<p>事务具备4个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持续性（Durability）。这四个特性简称ACID性。</p>
<h3 id="Session与事务">Session与事务</h3><p>Hibernate的事务（Transaction对象）通过Session的beginTransaction方法显式打开，Hibernate自身并不提供事务控制行为，底层直接使用JDBC连接、JTA资源或其他资源的事务。</p>
<p>从编程角度来看，Hibernate的事务由Session对象开启；从底层实现来看，Hibernate事务由TransactionFactory的实例来产生。</p>
<p>TransactionFactory是一个事务工厂的接口，有不同实现：CMTTransactionFactory（针对容器管理事务环境的实现类）、JDBCTransactionFactory（针对JDBC局部事务环境的实现类）、JTATransactionFactory（针对JTA全局事务环境的实现类）。</p>
<p>SessionFactory底层封装了TransactionFactory。SessionFactory创建的代价很高，它是线程安全的对象，被设计成可以被所有线程所共享。通常，SessionFactory会在应用启动时创建，一旦创建将不会轻易关闭，只有退出时才关闭。</p>
<p>Session是轻量级的，是线程不安全的。对于单个业务进程、单个的工作单元而言，Session只被使用一次。创建Session时，并不会立即打开与数据库之间的连接，只有需要进行数据库操作时，Session才会获取JDBC连接。因此，打开和关闭Session，并不会对性能造成很大影响。甚至即使无法确定一个请求是否需要数据访问，也可以打开Session对象，因为如果不进行数据库访问，Session不会获取JDBC连接。</p>
<p>数据库事务应该尽可能短，降低数据库锁定造成的资源争用。</p>
<p>Hibernate的所有持久化访问都必须在Session管理下进行，但并不推荐因为一次简单的数据库原子操作，就打开和关闭一次Session，数据库事务也是如此。</p>
<p>Hibernate建议采用每个请求对应一次Session的模式—因此一次请求通常表示需要执行一个完整的业务功能，这个功能由系列的数据库原子操作组成，而且它们应该是一个逻辑上的整体。</p>
<p>对于长事务，Hibernate有如下三种模式：</p>
<ul>
<li>自动版本化 - Hibernate能够自动进行乐观并发控制，如果在用户思考的过程中发生并发修改冲突，Hibernate能够自动检测到。</li>
<li>脱管对象（Detached Objects）- 如果你决定采用前面已经讨论过的 session-per-request模式，所有载入的实例在用户思考的过程中都处于与Session脱离的状态。Hibernate允许你把与Session脱离的对象重新关联到Session上，并且对修改进行持久化，这种模式被称为 session-per-request-with-detached-objects。自动版本化被用来隔离并发修改。</li>
<li>长生命周期的Session （Long Session）- Hibernate 的Session 可以在数据库事务提交之后和底层的JDBC连接断开，当一个新的客户端请求到来的时候，它又重新连接上底层的 JDBC连接。这种模式被称之为session-per-application-transaction，这种情况可 能会造成不必要的Session和JDBC连接的重新关联。自动版本化被用来隔离并发修改。</li>
</ul>
<p>如果程序打开Session很长时间，或载入过多数据，Session占用的内存会一直增长，直到抛出OutOfMemoryException。可以通过clear和evict方法管理Session的缓存。对于大批量的数据处理，推荐使用DML风格 的HQL语句完成。</p>
<p>如果在Session范围之外，访问未初始化的集合或代理（由Hibernate的延迟加载特性所引起），HIbernate将会抛出LazyInitializationException异常。</p>
<p>Hibernate的initialize静态方法可以强制初始化某个集合或代理。只要Session处于open状态，Hibernate.initialize(teacher)将会初始化teacher代理。</p>
<p>两种方法保证Session处于打开状态：</p>
<ul>
<li>在一个Web应用中，可以利用过滤器，在用户请求结束、页面生成结束时关闭Session。也就是保证视图显示层一直打开Session，这就是所谓的Open Session in View模式。当然采用这种模式时必须保证所有异常得到正确处理，在呈现视图界面之前，或在生成视图界面的过程中发生异常时，必须保证可以正确关闭Session，并结束事务。（Spring框架提供的OpenSessionInViewFilter就可以满足这个要求。</li>
<li>使用业务逻辑层负责准备数据，在业务逻辑层返回数据之前，业务逻辑层对每个所需集合调用Hibernate.initialize()方法，或者使用带fetch子句或FetchMode.JOIN的查询，事先取得所有数据，并将这些数据封装成VO（值对象）集合，然后程序可以关闭Session了。业务逻辑层将VO集传入视图层，让视图层只负责简单的显示逻辑。这种模式下，可以让视图层和Hibernate API彻底分离，保证视图层不会出现持久层API。</li>
</ul>
<h3 id="上下文相关的会话">上下文相关的会话</h3><p>从 3.1 开始，SessionFactory.getCurrentSession() 的后台实现是可拔插的。因此，我们引入了新的扩展接口（org.hibernate.context.CurrentSessionContext）和新的配置参数（hibernate.current_session_context_class），以便对什么是当前会话的范围（scope）和上下文（context）的定义进行拔插。</p>
<p>Hibernate 内置了org.hibernate.context.CurrentSessionContext 接口的三种实现：</p>
<ul>
<li>org.hibernate.context.JTASessionContext：当前会话根据 JTA 来跟踪和界定。这和以前的仅支持 JTA 的方法是完全一样的。详情请参阅 Javadoc。</li>
<li>org.hibernate.context.ThreadLocalSessionContext：当前会话通过当前执行的线程来跟踪和界定。详情也请参阅 Javadoc。</li>
<li>org.hibernate.context.ManagedSessionContext：当前会话通过当前执行的线程来跟踪和界定。但是，你需要负责使用这个类的静态方法将 Session 实例绑定、或者取消绑定，它并不会打开（open）、flush 或者关闭（close）任何 Session。</li>
</ul>
<p>对于在容器中使用Hibernate的场景而言，通常会采用第一种方式；对于独立的Hibernate应用而言，通常会采用第二种方式。</p>
<p>在hibernate.cfg.xml文件中增加以下中的一种配置<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;thread&lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;jta&lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;managed&lt;/<span class="keyword">property</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="二级缓存和查询缓存">二级缓存和查询缓存</h2><p>Hibernate 两个级别的缓存</p>
<ul>
<li>默认总是启用的Session级别的一级缓存</li>
<li>可选的SessionFactory级别的二级缓存</li>
</ul>
<p>其中Session级别的一级缓存不需要开发者关心，默认总是有效的，当应用保存持久化实体、修改持久化实体时，Session并不会立即把这种改变flush到数据库，而是缓存在当前Session的一级缓存中，除非程序显式调用Session的flush方法，或程序关闭Session时才会把这些改变一次性flush到底层数据库。</p>
<p>SessionFactory级别的二级缓存是全局性的，应用的所有Session都共享这个二级缓存。不过此级别的缓存默认是关闭的，必须由程序显式开启。Session优先从二级缓存抓取数据。</p>
<h3 id="开启二级缓存">开启二级缓存</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.cache.use_second_level_cache"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置二级缓存实现类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.cache.provider_class"</span>&gt;</span>org.hibernate.cache.EhCacheProvider<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>缓存策略提供商（Cache Providers）</p>
<table>
<thead>
<tr>
<th>Cache</th>
<th>Provider class</th>
<th>Type</th>
<th>Cluster Safe</th>
<th>Query Cache Supported</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hashtable</td>
<td>org.hibernate.cache.HashtableCacheProvider</td>
<td>memory</td>
<td></td>
<td>yes</td>
</tr>
<tr>
<td>EHCache</td>
<td>org.hibernate.cache.EhCacheProvider</td>
<td>memory, disk</td>
<td></td>
<td>yes</td>
</tr>
<tr>
<td>OSCache</td>
<td>org.hibernate.cache.OSCacheProvider</td>
<td>memory, disk</td>
<td></td>
<td>yes</td>
</tr>
<tr>
<td>SwarmCache</td>
<td>org.hibernate.cache.SwarmCacheProvider</td>
<td>clustered (ip multicast)</td>
<td>yes (clustered invalidation)</td>
<td></td>
</tr>
<tr>
<td>JBoss Cache    1.x</td>
<td>org.hibernate.cache.TreeCacheProvider</td>
<td>clustered (ip multicast), transactional</td>
<td>yes (replication)</td>
<td>yes (clock sync req.)</td>
</tr>
<tr>
<td>JBoss Cache    2</td>
<td>org.hibernate.cache.jbc.JBossCacheRegionFactory</td>
<td>clustered (ip multicast), transactional</td>
<td>yes (replication)</td>
<td>yes (clock sync req.)</td>
</tr>
</tbody>
</table>
<p>EHCache缓存配置文件ehcache.xml，将其放在类加载路径下稍作修改即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">ehcache</span>&gt;</span>  </span><br><span class="line">　<span class="tag">&lt;<span class="title">diskStore</span> <span class="attribute">path</span>=<span class="value">"java.io.tmpdir"</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--maxElementsInMemory设置缓存中最多可放多少个对象</span><br><span class="line">    eternal设置缓存是否永久有效</span><br><span class="line">    timeToldleSeconds设置缓存的对象多少秒没有被使用就会清理掉</span><br><span class="line">    timeToLiveSeconds设置缓存的对象在过期之前可以缓存多少秒</span><br><span class="line">    diskPersistent设置缓存是否被持久化到硬盘中，保存路径由diskStore元素指定</span><br><span class="line">    --&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="title">defaultCache</span>  </span><br><span class="line">　　　<span class="attribute">maxElementsInMemory</span>=<span class="value">"10000"</span></span><br><span class="line">　　　<span class="attribute">eternal</span>=<span class="value">"false"</span> </span><br><span class="line">　　　<span class="attribute">overflowToDisk</span>=<span class="value">"true"</span> </span><br><span class="line">　　　<span class="attribute">timeToIdleSeconds</span>=<span class="value">"300"</span></span><br><span class="line">　　　<span class="attribute">timeToLiveSeconds</span>=<span class="value">"180"</span> </span><br><span class="line">　　　<span class="attribute">diskPersistent</span>=<span class="value">"false"</span></span><br><span class="line">　　　<span class="attribute">diskExpiryThreadIntervalSeconds</span>= "<span class="attribute">120</span>"/&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="title">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>@org.hibernate.annotations.Cache定义了缓存策略及给定的二级缓存的范围. 此注解适用于根实体(非子实体),还有集合.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@Cache</span>(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Forest</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="annotation">@OneToMany</span>(cascade=CascadeType.ALL, fetch=FetchType.EAGER)</span><br><span class="line">    <span class="annotation">@JoinColumn</span>(name=<span class="string">"CUST_ID"</span>)</span><br><span class="line">    <span class="annotation">@Cache</span>(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SortedSet&lt;Ticket&gt; <span class="title">getTickets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tickets;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Cache<span class="params">(</span><br><span class="line">    CacheConcurrencyStrategy usage<span class="params">()</span>;                 <span class="params">(<span class="number">1</span>)</span></span><br><span class="line">    String region<span class="params">()</span> default <span class="string">""</span>;                       <span class="params">(<span class="number">2</span>)</span></span><br><span class="line">    String include<span class="params">()</span> default <span class="string">"all"</span>;                   <span class="params">(<span class="number">3</span>)</span></span><br><span class="line">)</span></span><br></pre></td></tr></table></figure>
<p>(1)    usage: 给定缓存的并发策略(NONE, READ_ONLY, NONSTRICT_READ_WRITE, READ_WRITE, TRANSACTIONAL)<br>(2)    region (可选的)：缓存范围(默认为类的全限定类名或是集合的全限定角色名)<br>(3)    include (可选的)：值为all时包括了所有的属性(proterty), 为non-lazy时仅含非延迟属性(默认值为all)</p>
<ul>
<li>只读策略缓存（Strategy: read only）<br>  如果你的应用程序只需读取一个持久化类的实例，而无需对其修改， 那么就可以对其进行只读 缓存。这是最简单，也是实用性最好的方法。甚至在集群中，它也能完美地运作。</li>
<li>读/写策略（Strategy: read/write）<br>  如果应用程序需要更新数据，那么使用读/写缓存 比较合适。 如果应用程序要求“序列化事务”的隔离级别（serializable transaction isolation level），那么就决不能使用这种缓存策略。 如果在JTA环境中使用缓存，你必须指定hibernate.transaction.manager_lookup_class属性的值， 通过它，Hibernate才能知道该应用程序中JTA的TransactionManager的具体策略。    在其它环境中，你必须保证在Session.close()、或Session.disconnect()调用前， 整个事务已经结束。 如果你想在集群环境中使用此策略，你必须保证底层的缓存实现支持锁定(locking)。Hibernate内置的缓存策略并不支持锁定功能。</li>
<li>非严格读/写策略（Strategy: nonstrict read/write）<br>  如果应用程序只偶尔需要更新数据（也就是说，两个事务同时更新同一记录的情况很不常见），也不需要十分严格的事务隔离， 那么比较适合使用非严格读/写缓存策略。如果在JTA环境中使用该策略， 你必须为其指定hibernate.transaction.manager_lookup_class属性的值， 在其它环境中，你必须保证在Session.close()、或Session.disconnect()调用前， 整个事务已经结束。</li>
<li>事务策略（transactional）<br>  Hibernate的事务缓存策略提供了全事务的缓存支持， 例如对JBoss TreeCache的支持。这样的缓存只能用于JTA环境中，你必须指定 为其hibernate.transaction.manager_lookup_class属性。</li>
</ul>
<h3 id="管理缓存和统计缓存">管理缓存和统计缓存</h3><p>无论何时，当你给save()、update()或 saveOrUpdate()方法传递一个对象时，或使用load()、 get()、list()、iterate() 或scroll()方法获得一个对象时, 该对象都将被加入到Session的内部缓存中。</p>
<p>当随后flush()方法被调用时，对象的状态会和数据库取得同步。 如果你不希望此同步操作发生，或者你正处理大量对象、需要对有效管理内存时，你可以调用evict() 方法，从一级缓存中去掉这些对象及其集合。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">News</span> <span class="keyword">news</span> = (<span class="keyword">News</span>) newsList.<span class="literal">get</span>(0);</span><br><span class="line">sess.evict(<span class="keyword">news</span>);</span><br></pre></td></tr></table></figure>
<p>Session还提供了一个contains()方法，用来判断某个实例是否处于当前session的缓存中。</p>
<p>如若要把所有的对象从session缓存中彻底清除，则需要调用Session.clear()。</p>
<p>对于二级缓存来说，在SessionFactory中定义了许多方法， 清除缓存中实例、整个类、集合实例或者整个集合。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sessionFactory.evict<span class="params">(Cat.class, catId)</span>; <span class="comment">//evict a particular Cat</span></span><br><span class="line">sessionFactory.evict<span class="params">(Cat.class)</span>;  <span class="comment">//evict all Cats</span></span><br><span class="line">sessionFactory.evictCollection<span class="params">(<span class="string">"Cat.kittens"</span>, catId)</span>; <span class="comment">//evict a particular collection of kittens</span></span><br><span class="line">sessionFactory.evictCollection<span class="params">(<span class="string">"Cat.kittens"</span>)</span>; <span class="comment">//evict all kitten collections</span></span><br></pre></td></tr></table></figure>
<p>如若需要查看二级缓存或查询缓存区域的内容，你可以使用统计（Statistics） API。</p>
<p>此时，你必须手工打开统计选项。可选的，你可以让Hibernate更人工可读的方式维护缓存内容。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启二级缓存的统计功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.generate_statistics"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置使用结构化方式来维护缓存项 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.cache.use_structured_entries"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map cacheEntries = sessionFactory.getStatistics<span class="params">()</span></span><br><span class="line">        .getSecondLevelCacheStatistics<span class="params">(regionName)</span></span><br><span class="line">        .getEntries<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用查询缓存">使用查询缓存</h3><p>大部分情况下查询缓存并不能提供应用性能，甚至反而会降低应用性能，因此实际项目中慎重使用查询缓存。</p>
<p>首先在配置文件中增加如下配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 启用查询缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.cache.use_query_cache"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>此外还需要调用Query对象的setCacheable(true)才会对查询结果进行缓存。</p>
<h2 id="事件机制">事件机制</h2><p>Hibernate的事件框架由两个部分组成</p>
<ul>
<li>拦截器机制：对于特定动作拦截，回调应用中的特定动作。</li>
<li>事件系统：重写Hibernate的事件监听器。</li>
</ul>
<h3 id="拦截器">拦截器</h3><p>Interceptor接口提供了从会话(session)回调(callback)应用程序(application)的机制，这种回调机制可以允许应用程序在持久化对象被保存、更新、删除或是加载之前，检查并（或）修改其属性。一个可能的用途，就是用来跟踪审核(auditing)信息。</p>
<ul>
<li><p>创建会话(session)的时候可以指定拦截器。</p>
  <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Session</span> session = sf.openSession( <span class="keyword">new</span> <span class="type">MyInterceptor</span><span class="literal">()</span> );</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以使用Configuration来设置一个全局范围的拦截器。</p>
  <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">Configuration</span><span class="literal">()</span>.setInterceptor( <span class="keyword">new</span> <span class="type">MyInterceptor</span><span class="literal">()</span> );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="事件系统">事件系统</h3><p>基本上，Session接口的每个方法都有相对应的事件。比如 LoadEvent，FlushEvent，等等（查阅XML配置文件 的DTD，以及org.hibernate.event包来获得所有已定义的事件的列表）。当某个方法被调用时，Hibernate Session会生成一个相对应的事件并激活所有配置好的事件监听器。系统预设的监听器实现的处理过程就是被监听的方法要做的（被监听的方法所做的其实仅仅是激活监听器，“实际”的工作是由监听器完成的）。不过，你可以自由地选择实现一个自己定制的监听器（比如，实现并注册用来处理处理LoadEvent的LoadEventListener接口），来负责处理所有的调用Session的load()方法的请求。</p>
<p>监听器应该被看作是单例(singleton)对象，也就是说，所有同类型的事件的处理共享同一个监听器实例，因此监听器不应该保存任何状态（也就是不应该使用成员变量）。</p>
<p>用户定制的监听器应该实现与所要处理的事件相对应的接口，或者从一个合适的基类继承（甚至是从Hibernate自带的默认事件监听器类继承，为了方便你这样做，这些类都被声明成non-final的了）。用户定制的监听器可以通过编程使用Configuration对象来注册，也可以在Hibernate的XML格式的配置文件中进行声明（不支持在Properties格式的配置文件声明监听器）。下面是一个用户定制的加载事件(load event)的监听器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyLoadListener</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">DefaultLoadEventListener</span> &#123;</span></span><br><span class="line">    <span class="comment">// this is the single method defined by the LoadEventListener interface</span></span><br><span class="line">    public <span class="type">Object</span> onLoad(<span class="type">LoadEvent</span> event, <span class="type">LoadEventListener</span>.<span class="type">LoadType</span> loadType)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">HibernateException</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="type">MySecurity</span>.isAuthorized( event.getEntityClassName(), event.getEntityId() ) ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">MySecurityException</span>(<span class="string">"Unauthorized access"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onLoad(event, loadType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还需要修改一处配置，来告诉Hibernate以使用选定的监听器来替代默认的监听器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">session-factory</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="title">listener</span> <span class="attribute">type</span>=<span class="value">"load"</span> <span class="attribute">class</span>=<span class="value">"MyLoadListener"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个事件配置多个监听器<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">event</span> type=<span class="string">"load"</span>&gt;</span><br><span class="line">    &lt;listener <span class="keyword">class</span>=<span class="string">"listener.MyLoadListener"</span> /&gt;</span><br><span class="line">    &lt;listener <span class="keyword">class</span>=<span class="string">"listener.DefaultLoadEventListener"</span> /&gt;</span><br><span class="line">&lt;/<span class="keyword">event</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>看看用另一种方式，通过编程的方式来注册它。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Configuration</span> cfg = <span class="keyword">new</span> <span class="type">Configuration</span><span class="literal">()</span>;</span><br><span class="line">cfg.getSessionEventListenerConfig<span class="literal">()</span>.setLoadEventListener( <span class="keyword">new</span> <span class="type">MyLoadListener</span><span class="literal">()</span> );</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Configuration</span> cfg = <span class="keyword">new</span> <span class="keyword">Configuration</span>();</span><br><span class="line">cfg.setListener(<span class="string">"load"</span>, <span class="string">"listener.MyLoadListener"</span>);</span><br></pre></td></tr></table></figure></p>
<p>注册多个事件<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LoadEventListener</span><span class="literal">[]</span> stack = &#123; <span class="keyword">new</span> <span class="type">MyLoadListener</span><span class="literal">()</span>, <span class="keyword">new</span> <span class="type">DefaultLoadEventListener</span><span class="literal">()</span>&#125;;</span><br><span class="line">cfg.getEventListeners<span class="literal">()</span>.setLoadEventListeners(stack);</span><br></pre></td></tr></table></figure></p>
<p>通过在XML配置文件声明而注册的监听器不能共享实例。如果在多个<listener>节点中使用了相同的类的名字，则每一个引用都将会产生一个独立的实例。如果你需要在多个监听器类型之间共享监听器的实例，则你必须使用编程的方式来进行注册。</listener></p>
<p>为什么我们实现了特定监听器的接口，在注册的时候还要明确指出我们要注册哪个事件的监听器呢？ 这是因为一个类可能实现多个监听器的接口。在注册的时候明确指定要监听的事件，可以让启用或者禁用对某个事件的监听的配置工作简单些。</p>
<p>参考：</p>
<p><a href="http://xiaogui9317170.iteye.com/blog/283526" target="_blank" rel="external">基于按annotation的hibernate主键生成策略</a><br><a href="https://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/" target="_blank" rel="external">Hibernate Annotations</a><br><a href="http://www.cnblogs.com/luxh/archive/2012/06/01/2531428.html" target="_blank" rel="external">JPA的查询语言—JPQL的命名查询@NamedQuery</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Hibernate]]>
    
    </summary>
    
      <category term="Hibernate" scheme="http://howiefh.github.io/tags/Hibernate/"/>
    
      <category term="JavaEE" scheme="http://howiefh.github.io/categories/JavaEE/"/>
    
      <category term="Hibernate" scheme="http://howiefh.github.io/categories/JavaEE/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java编程思想笔记九]]></title>
    <link href="http://howiefh.github.io/2015/02/07/thinking-in-java-note-9/"/>
    <id>http://howiefh.github.io/2015/02/07/thinking-in-java-note-9/</id>
    <published>2015-02-07T12:51:16.000Z</published>
    <updated>2015-02-08T13:12:54.000Z</updated>
    <content type="html"><![CDATA[<p>Swing中有一个非常令人称道的原则，称为“正交使用”。意思是，一旦你理解了库中的某个通用概念，你就可以把这个概念应用到其他地方。</p>
<h2 id="Swing_基础">Swing 基础</h2><p>Swing有它自己的专用线程来接收UI事件并更新屏幕，如果从其他线程着手对屏幕进行操作，那么就可能产生冲突和死锁。其他线程通过事件分发线程提交要执行的任务，可以通过将任务提交给SwingUtilities.invokeLater()来实现这种方式，这个方法会通过事件分发线程将任务放置到（最终将得到执行的）待执行事件队列中。程序中的所有代码都遵循这种通过SwingUtilities.invokeLater()来提交操作的方式。这包括启动程序自身，即main也不应该调用Swing方法，就像上面的程序一样，它应该向事件队列提交任务。</p>
<p>Java中设计和实现图形用户界面的工作主要有：</p>
<ol>
<li>创建组件（Component)：创建组成界面的各种元素，如按钮、文本框等。</li>
<li>指定布局（Layout）：根据具体需要排列组件的位置关系。</li>
<li>响应事件（Event）：定义图形用户界面的事件和各界面元素对不同事件的响应，从而实现图形用户界面与用户的交互功能。</li>
</ol>
<a id="more"></a>
<h3 id="组件">组件</h3><p>Swing GUI由顶层容器-中间容器-基本组件构成</p>
<ul>
<li>顶层容器，这些组件在Swing GUI层次体系的顶层，主要包括JFrame，JApplet，JDialog等</li>
<li>通用容器，具有普遍应用场合，包括Jpanel，JScrollPane，JSplitPane，JTabbedPane, JToolBar等</li>
<li>特殊容器，在GUI中起特殊作用的中间层容器，包括JInternalFrame，JLayeredPane，JRootPane等</li>
<li>基本控制组件，这些基本组件主要用于接收用户输入，它们一般能够显示简单的状态，包括JButton，JComboBox，JList，JMemu，JSlider，JTestField等</li>
<li>不可编辑的信息显示组件，完全用来显示信息的组件，包括JLabel，JProgressBar等</li>
<li>可编辑的信息显示组件，这些组件用来显示可被用户编辑修改的格式化信息，包括JTable，JFileChooser，JTree等</li>
</ul>
<p>Swing组件中，除了顶层容器组件，所有以J开头的组件都是JComponent类的子类，可以添加工具提示setToolTipText(String)</p>
<ul>
<li><p>对话框</p>
<ul>
<li>JOptionPane（简单标准的对话框）</li>
<li>ProgressMonitor（显示操作进程的对话框）</li>
<li>JColorChooser（标准对话框）</li>
<li>JFileChooser（标准对话框）</li>
<li>JDialog（可制定对话框）</li>
</ul>
</li>
<li><p>按钮类组件</p>
<ul>
<li>包括JButton，JCheckBox,JRadioButton, JMenuItem, JCheckBoxMenuItem</li>
<li>AbstractButton是一个抽象类，它是JButton，JCheckBox,JRadioButton, JMenuItem, JCheckBoxMenuItem类的父类</li>
</ul>
</li>
<li><p>文本组件</p>
<ul>
<li>JTextField</li>
<li>JPasswordField</li>
<li>JTextArea</li>
<li>JEditorPane</li>
<li>JTextPane</li>
</ul>
</li>
<li><p>标签JLable</p>
</li>
<li>列表JList</li>
<li>表格JTable</li>
<li>树JTree</li>
<li>选择框JComboBox</li>
<li>文件选择器JFileChooser</li>
<li>颜色选择器JColorChooser</li>
<li>进程条JProgressBar</li>
<li>滑动块Jslider</li>
<li>微调器JSpinner</li>
</ul>
<h3 id="布局管理">布局管理</h3><p>Java提供了下列布局管理器</p>
<ol>
<li><p>FlowLayout 流式布局管理器(JPanel的默认布局)</p>
<p> FlowLayout(int align, int hgap, int vgap)，组件按参数指定的对齐方式摆放，组件之间水平距离由hgap指定，垂直距离由vgap指定，aligh 默认居中，hgap，vgap默认5个像素。使用FlowLayout，所有组件将被压缩到它们的最小尺寸，如果重新调整视窗大小，那么布局管理器将随之重新流动所有组件。</p>
</li>
<li><p>BorderLayout 边界布局管理器(JFrame,JWindow的默认布局)</p>
<p> BorderLayout()：组件之间没有水平间隙与垂直间隙；BorderLayout(int hgap, int vgap)：指定组件之间的水平和垂直间隙</p>
<p> BorderLayout布局管理器将容器分为5个区：East, West, South, North和Center。对于除Center以外的所有位置，加入的组件被沿着一个方向压缩到最小尺寸，同时在另一个方向上拉伸到最大尺寸。不过对于Center，组件将在两个方向上同时拉伸，以覆盖中央区域。</p>
</li>
<li><p>GridLayout网格布局管理器</p>
<p> BorderLayout()：组件之间没有水平间隙与垂直间隙；BorderLayout(int hgap, int vgap)：指定组件之间的水平和垂直间隙；GridLayout(int rows, int cols, int hgap, int vgap)，容器划分为指定数目的网格，并制定组件间的水平垂直距离</p>
</li>
<li><p>GridBagLayout网格包布局管理器</p>
<p> GridBagLayout所管理的每个组件都与一个GridBagConstraints类的对象相关。这个约束对象指定了组建的显示区域在网格中的位置，以及在其显示区域中应该如何摆放组件</p>
<p> GridBagConstraints对象的定制是通过设置一个或者多个GridBagConstraints的变量来实现的：</p>
<ul>
<li>gridx,gridy指定组件左上角在网格中的行与列</li>
<li>gridwidth, gridheight指定组件显示区域所占的列数与行数</li>
<li>fill指定组件填充网格的方式</li>
<li>ipadx,ipady指定组件显示区域的内部填充</li>
<li>insets指定组件显示区域的外部填充</li>
<li>anchor指定组件在显示区域的摆放位置</li>
<li>weightx, weighty用来指定在容器大小改变是，增加或减少的孔家如何在组件间进行分配  </li>
</ul>
</li>
<li><p>BoxLayout箱式布局管理器</p>
<p> 箱式布局管理器将组件垂直摆放在一列或水平摆放的一行中，具体由BoxLayout.X_AXIS和BoxLayout.Y_AXIS指定</p>
</li>
<li><p>GroupLayout分组布局管理器</p>
<p> GroupLayout 是一个 LayoutManager，它将组件按层次分组，以决定它们在 Container 中的位置。GroupLayout 主要供生成器使用，但也可以手工编码。分组由 Group 类的实例来完成。GroupLayout 支持两种组。串行组 (sequential group) 按顺序一个接一个地放置其子元素。并行组 (parallel group) 能够以四种方式对齐其子元素。</p>
<p> 每个组可以包含任意数量的元素，其中元素有 Group、Component 或间隙 (gap)。间隙可被视为一个具有最小大小、首选大小和最大大小的不可见组件。此外，GroupLayout 还支持其值取自 LayoutStyle 的首选间隙。</p>
</li>
<li><p>CardLayout卡片布局管理器</p>
<p> CardLayout()，组件与左右上下界之间没有间隙， CardLayout(int hgap, int vgap)，参数hgap指定组件距离左右边界的间隙，参数vgap指定组件距离上下边界的间隙。</p>
<p> CardLayout常用的方法：<code>public void first (Container parent)</code>，显示第一张卡片，<code>public void next (Container parent)</code>，显示下一张卡片(如果当前是最后一张，则显示第一张)，<code>public void previous (Container parent)</code>，显示前一张卡片，<code>public void last (Container parent)</code>，显示最后一张卡片，<code>public void show (Container parent, String name)</code>，显示指定名称的组件，</p>
</li>
<li><p>无布局管理器</p>
<p> 使用setLayout(null)把容器的布局管理器设置为空。需要使用setLocation(), setSize(),setBounds()或者reshape()等方法手工设置组件大小和位置(这些方法会导致平台相关，不建议使用)</p>
</li>
</ol>
<p>第三方：FormLayout、MigLayout，TableLayout</p>
<h3 id="事件">事件</h3><p>事件处理模型中的3类对象</p>
<ul>
<li>事件<br>  当用户在界面上执行一个操作，如敲键盘、拖动或者单击鼠标，都产生了事件</li>
<li>事件源<br>  产生事件的组件就是一个事件源。如在一个Button上单击鼠标时，将产生一个ActionEvent类型的事件，这个Button就是事件源</li>
<li>事件处理器<br>  事件处理器是一个方法，该方法接收一个事件对象，对其进行解释，并做出相应的处理</li>
</ul>
<p>事件及其相应的监听器接口</p>
<table>
<thead>
<tr>
<th>事件类别</th>
<th>描述信息</th>
<th>接口名</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>　ActionEvent</td>
<td>激活组件</td>
<td>　　ActionListener</td>
<td>　actionPerformed(ActionEvent)</td>
</tr>
<tr>
<td>　ItemEvent</td>
<td>选择了某些项目</td>
<td>　　ItemListener</td>
<td>　itemStateChanged(ItemEvent)</td>
</tr>
<tr>
<td>　MouseEvent</td>
<td>鼠标移动</td>
<td>　　MouseMotionListener</td>
<td>　mouseDragged(MouseEvent) 　mouseMoved(MouseEvent)</td>
</tr>
<tr>
<td>  MouseEvent</td>
<td>鼠标点击等</td>
<td>　　MouseListener</td>
<td>　mousePressed(MouseEvent) 　mouseReleased(MouseEvent) 　mouseEntered(MouseEvent) 　mouseExited(MouseEvent) 　mouseClicked(MouseEvent)</td>
</tr>
<tr>
<td>　KeyEvent</td>
<td>键盘输入</td>
<td>　　KeyListener</td>
<td>　keyPressed(KeyEvent) 　keyReleased(KeyEvent) 　keyTyped(KeyEvent)</td>
</tr>
<tr>
<td>　FocusEvent</td>
<td>组件收到或失去焦点</td>
<td>　　FocusListener</td>
<td>　focusGained(FocusEvent) 　focusLost(FocusEvent)</td>
</tr>
<tr>
<td>　AdjustmentEvent</td>
<td>移动了滚动条等组件</td>
<td>　　AdjustmentListener</td>
<td>　adjustmentValueChanged(AdjustmentEvent)</td>
</tr>
<tr>
<td>　ComponentEvent</td>
<td>对象移动缩放显示隐藏等</td>
<td>　　ComponentListener</td>
<td>　componentMoved(ComponentEvent) 　componentHidden(ComponentEvent) 　componentResized(ComponentEvent) 　componentShown(ComponentEvent)</td>
</tr>
<tr>
<td>　WindowEvent</td>
<td>窗口收到窗口级事件</td>
<td>　　WindowListener</td>
<td>　windowClosing(WindowEvent) 　windowOpened(WindowEvent) 　windowIconified(WindowEvent) 　windowDeiconified(WindowEvent) 　windowClosed(WindowEvent) 　windowActivated(WindowEvent) 　windowDeactivated(WindowEvent)</td>
</tr>
<tr>
<td>　ContainerEvent</td>
<td>容器中增加删除了组件</td>
<td>　　ContainerListener</td>
<td>　componentAdded(ContainerEvent) componentRemoved(ContainerEvent)</td>
</tr>
<tr>
<td>　TextEvent</td>
<td>文本字段或文本区发生改变</td>
<td>　　TextListener</td>
<td>　textValueChanged(TextEvent)</td>
</tr>
</tbody>
</table>
<p>事件适配器 </p>
<ol>
<li>ComponentAdapter( 组件适配器) </li>
<li>ContainerAdapter( 容器适配器) </li>
<li>FocusAdapter( 焦点适配器) </li>
<li>KeyAdapter( 键盘适配器) </li>
<li>MouseAdapter( 鼠标适配器) </li>
<li>MouseMotionAdapter( 鼠标运动适配器)</li>
<li>WindowAdapter( 窗口适配器) </li>
</ol>
<p>可以创建一个全局的监听器，不过有时写成内部类会更有用。这不仅是因为将监听器类放在它们所服务的用户接口类或者业务逻辑类的内部时，可以在逻辑上对其进行分组，而且还因为内部类对象含有一个对其外部类对象的引用，这就为跨越类和子类系统边界的调用提供了一种优雅的方式。</p>
<p>Swing支持键盘快捷键，可以用键盘而不是鼠标来选择任何从AbstractButton继承而来的组件：只要使用重载的构造器，使它的第二个参数接受快捷键的标识符即可。如果没有这样的构造器，可以通过setMnemonic()方法<code>btn.setMnemonic(KeyEvent.VK_B)</code>。</p>
<p>setActionCommand()的用法。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先设置 </span></span><br><span class="line">menuitem.setActionCommand<span class="params">(<span class="string">"Open"</span>)</span>;</span><br><span class="line"><span class="comment">//在事件处理器中</span></span><br><span class="line">JMenuItem target = <span class="params">(JMenuItem)</span>e.getSource<span class="params">()</span>;</span><br><span class="line">String actionCommand = target.getActionCommand<span class="params">()</span>;</span><br><span class="line"><span class="keyword">if</span><span class="params">(actionCommand.equals<span class="params">(<span class="string">"Open"</span>)</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>任何能够接受文本的组件都可以接受html文本，且能根据html的规则来重新格式化文本。必须使文本以<code>&lt;html&gt;</code>开始，然后就可以使用普通的html标记了，注意，不会强制要求你添加普通的结束标记。</p>
<p>选择外观<br>try {<br>    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());<br>} catch(Exception e) {<br>    throw new RuntimeException(e);<br>}<br>不过你要确保在创建任何可视组件之前先调用这些代码。</p>
<h3 id="绘图">绘图</h3><ol>
<li><p>paint方法</p>
<p> public void paint(Graphics g)       以画布为参数，在画布上执行画图方法 </p>
</li>
<li><p>repaint方法</p>
<p> Applet重画时系统自动调用paint方法</p>
</li>
<li><p>update方法</p>
<p> public void update(Graphics g)       更新容器，向repaint发出刷新小应用程序的信号，缺省的update方法清除Applet画图区并调用paint方法</p>
</li>
</ol>
<p><strong>Graphics类</strong></p>
<p>Graphics类提供画各种图形的方法，其中包括线、圆和椭圆、矩形和多边形、图像以及各种字体的文本等。这些方法具体如下：</p>
<p>public abstract void clipRect(int x, int y, int width, int height)        指定的区域切分<br>public abstract void drawLine(int x1, int y1, int x2, int y2) 使用当前颜色，在点(x1, y1) 和 (x2, y2) 之间画线<br>public abstract void drawOval(int x, int y, int width, int height) 画椭圆<br>public abstract void fillOval(int x, int y, int width, int height) 画实心椭圆<br>public abstract void drawPolygon(int[] xPoints, int[] yPoints, int nPoints) 画x和y坐标定义的多边形<br>public void drawRect(int x, int y, int width, int height) 画矩形<br>public void fillRect(int x, int y, int width, int height) 画实心矩形<br>public abstract void drawRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight) 画圆角矩形<br>public abstract void drawString(String str, int x, int y) 使用当前字体和颜色画字符串str<br>public abstract void setColor(Color c) 设置图形上下文的当前颜色<br>public abstract void setPaintMode() 设置画模式<br>public abstract boolean drawImage (Image img, int x, int y, ImageObserver observer) 画特定图<br>public abstract void setFont(Font font) 设置特定的font字体。使用时首先得到font对象的一个实例，Font类常用构造函数为：public Font(String name, int style, int size) </p>
<p>Color类</p>
<p><code>public Color(int red, int green, int blue)</code><br><code>public Color(int red, int green, int blue, int alpha)</code>       其中：前三个分量即RGB颜色模式中的参数，第四个alpha分量指透明的程度。当alpha分量为255时，表示完全不透明，正常显示；当alpha分量为0时，表示完全透明，前三个分量不起作用</p>
<p>Graphics2D类</p>
<p>Graphics2D类继承于Graphics类，提供几何学、坐标变换、颜色管理以及文本排列等的更高级控制。Graphics2D类是Java平台上渲染二维图形、文字、以及图片的基础类，提供较好的对绘制形状、填充形状、旋转形状、绘制文本、绘制图像以及定义颜色的支持。在AWT编程接口中，用户通过paint方法接收Graphics对象作为参数，若是使用Graphics2D类，就需要在Paint方法中进行强制转换。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics old)</span></span>&#123;	Graphics2D <span class="keyword">new</span> = (Graphics2D)old;&#125;</span><br></pre></td></tr></table></figure>
<p>Graphics2D提供以下两个方法进行形状的绘制：<br>public abstract void draw(Shape s)         根据Graphics2D的环境设置画出形状s。<br>public abstract void fill(Shape s)         画实心形状s。</p>
<p>Shape的实现类：Line2D（线）、Rectangle2D（矩形）、RoundRectangle2D（圆角矩形）、Ellipse2D（椭圆）、GeneralPath（几何路径）。</p>
<h2 id="Swing与并发">Swing与并发</h2><h3 id="长期运行的任务">长期运行的任务</h3><p>在专用线程中执行长时间 GUI 交互任务的抽象类。 </p>
<p>使用 Swing 编写多线程应用程序时，要记住两个约束条件：（有关详细信息，请参阅 How to Use Threads）： </p>
<ul>
<li>不应该在事件指派线程 上运行耗时任务。否则应用程序将无响应。 </li>
<li>只能在事件指派线程 上访问 Swing 组件。 </li>
</ul>
<p>这些约束意味着需要时间密集计算操作的 GUI 应用程序至少需要以下两个线程：1) 执行长时间任务的线程； 2) 所有 GUI 相关活动的事件指派线程 （EDT）这涉及到难以实现的线程间通信。 </p>
<p>SwingWorker 设计用于需要在后台线程中运行长时间运行任务的情况，并可在完成后或者在处理过程中向 UI 提供更新。SwingWorker 的子类必须实现 doInBackground() 方法，以执行后台计算。 </p>
<p>工作流 </p>
<p>SwingWorker 的生命周期中包含三个线程： </p>
<ul>
<li>当前线程：在此线程上调用 execute() 方法。它调度 SwingWorker 以在 worker 线程上执行并立即返回。可以使用 get 方法等待 SwingWorker 完成。 </li>
<li>Worker 线程：在此线程上调用 doInBackground() 方法。所有后台活动都应该在此线程上发生。要通知 PropertyChangeListeners 有关绑定 (bound) 属性的更改，请使用 firePropertyChange 和 getPropertyChangeSupport() 方法。默认情况下，有两个可用的绑定属性：state 和 progress。 </li>
<li>事件指派线程：所有与 Swing 有关的活动都在此线程上发生。SwingWorker 调用 process 和 done() 方法，并通知此线程的所有 PropertyChangeListener。 </li>
</ul>
<p>通常，当前 线程就是事件指派线程。 </p>
<p>在 worker 线程上调用 doInBackground 方法之前，SwingWorker 通知所有 PropertyChangeListener 有关对 StateValue.STARTED 的 state 属性更改。doInBackground 方法完成后，执行 done 方法。然后 SwingWorker 通知所有 PropertyChangeListener 有关对 StateValue.DONE 的 state 属性更改。 </p>
<p>SwingWorker 被设计为只执行一次。多次执行 SwingWorker 将不会调用两次 doInBackground 方法。 </p>
<p>示例用法 </p>
<p>下例说明了最简单的使用范例：在后台完成某些处理，并在处理完成后更新 Swing 组件。 </p>
<p>假定想找到“Meaning of Life”并在 JLabel 中显示结果。 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">JLabel</span> label;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MeaningOfLifeFinder</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SwingWorker&lt;String</span>, <span class="title">Object&gt;</span> &#123;</span></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  public <span class="type">String</span> doInBackground() &#123;</span><br><span class="line">    <span class="keyword">return</span> findTheMeaningOfLife();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> void done() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      label.setText(get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">(<span class="keyword">new</span> <span class="type">MeaningOfLifeFinder</span>()).execute();</span><br></pre></td></tr></table></figure>
<h3 id="可视化线程机制">可视化线程机制</h3><p>调用repaint时，并未强制在这一时刻立即进行绘制，而只是设置了一个“脏标识”，表示当下一次事件分发线程准备好重绘时，这个区域是重绘的备选元素之一。</p>
<p>当事件分发线程实际执行paint时，首先调用paintComponent，然后是paintBorder和paintChildren。如果需要在导出组件中覆盖paint，就必须牢记调用基类版本的paint，以使得它仍旧可以执行正确的行为。</p>
<h2 id="可视化编程与JavaBean">可视化编程与JavaBean</h2><h3 id="什么是JavaBean">什么是JavaBean</h3><p>JavaBean 只是一个命名规则</p>
<ol>
<li>对于一个名称为xxx的属性，通常你要写两个方法；getXxx()和setXxx()。任何浏览这些方法的工具，都会把get或sett后面的第一个字母自动转换为小写，以产生属性名，get方法返回的类型要与set方法里参数的类型相同属性的名称与set和get所依据的类型毫无关系</li>
<li>对于布尔型属性可以使用以上get和set的方式，不过也可以把get替换成is</li>
<li>Bean的普通方法不必遵循以上命名规则，不过它们必须是public的。</li>
<li>对于事件，要使用Swing中处理监听器的方式。这与前面所见到的完全相同addBounceListener( BounceListener)和 removeBounceListener (BounceListener)用来处理BounceEvent事件。大多数情况下，内置的事件和监听器就能够满足需求了，不过也可以自己编写事件和监听器接口。</li>
</ol>
<h3 id="使用Introspector抽取BeanInfo">使用Introspector抽取BeanInfo</h3><p>Introspector（内省器），这个类最重要的就是静态的getBeanInfo方法。向这个方法传递一个Class对象引用，它能够完全侦测这个类，然后返回一个BeanInfo对象，可以通过这个对象得到Bean的属性、方法和事件。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public class BeanDumper extends JFrame &#123;  </span><br><span class="line">    private JTextField query = new JTextField<span class="params">(<span class="number">20</span>)</span>;  </span><br><span class="line">    private JTextArea results = new JTextArea<span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    public void print<span class="params">(String s)</span> &#123;  </span><br><span class="line">        results.append<span class="params">(s + <span class="string">" \n"</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void dump<span class="params">(Class&lt;?&gt; bean)</span> &#123;  </span><br><span class="line">        results.setText<span class="params">(<span class="string">""</span>)</span>;  </span><br><span class="line">        BeanInfo bi = null;  </span><br><span class="line">  </span><br><span class="line">        try &#123;  </span><br><span class="line">            bi = Introspector.getBeanInfo<span class="params">(bean, Object.class)</span>;  </span><br><span class="line">        &#125; catch <span class="params">(IntrospectionException e)</span> &#123;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"Couldn 't introspect"</span> + bean.getName<span class="params">()</span>)</span>;  </span><br><span class="line">            return;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 获取 bean属性 方法  </span></span><br><span class="line">        <span class="keyword">for</span> <span class="params">(PropertyDescriptor d : bi.getPropertyDescriptors<span class="params">()</span>)</span> &#123;  </span><br><span class="line">            Class&lt;?&gt; p = d.getPropertyType<span class="params">()</span>;  </span><br><span class="line">            <span class="keyword">if</span> <span class="params">(p == null)</span>  </span><br><span class="line">                continue;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"Property type:\n"</span> + p.getName<span class="params">()</span>)</span>;  </span><br><span class="line">            Method m = d.getReadMethod<span class="params">()</span>;  </span><br><span class="line">            <span class="keyword">if</span> <span class="params">(m != null)</span>  </span><br><span class="line">                System.out.println<span class="params">(<span class="string">"read method:+\n"</span> + m.getName<span class="params">()</span>)</span>;  </span><br><span class="line">            Method rm = d.getWriteMethod<span class="params">()</span>;  </span><br><span class="line">            <span class="keyword">if</span> <span class="params">(rm != null)</span>  </span><br><span class="line">                System.out.println<span class="params">(<span class="string">"write method:+\n"</span> + rm.getName<span class="params">()</span>)</span>;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"===================================="</span>)</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"public methods:"</span>)</span>;  </span><br><span class="line">        <span class="keyword">for</span> <span class="params">(MethodDescriptor ms : bi.getMethodDescriptors<span class="params">()</span>)</span> &#123;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"ms:"</span> + ms.getMethod<span class="params">()</span>.toString<span class="params">()</span>)</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"===================================="</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"envent support:"</span>)</span>;  </span><br><span class="line">        <span class="keyword">for</span> <span class="params">(EventSetDescriptor e : bi.getEventSetDescriptors<span class="params">()</span>)</span> &#123;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"listener type:\n"</span>  </span><br><span class="line">                    + e.getListenerType<span class="params">()</span>.getName<span class="params">()</span>)</span>;  </span><br><span class="line">            <span class="keyword">for</span> <span class="params">(Method lm : e.getListenerMethods<span class="params">()</span>)</span>  </span><br><span class="line">                System.out.println<span class="params">(<span class="string">"listener method:\n"</span> + lm.getName<span class="params">()</span>)</span>;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">for</span> <span class="params">(MethodDescriptor lmd : e.getListenerMethodDescriptors<span class="params">()</span>)</span>  </span><br><span class="line">                System.out.println<span class="params">(<span class="string">"listener methodDescriptor:\n"</span>  </span><br><span class="line">                        + lmd.getName<span class="params">()</span>)</span>;  </span><br><span class="line">            <span class="comment">//  </span></span><br><span class="line">            Method addListener = e.getAddListenerMethod<span class="params">()</span>;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"add listener method:\n"</span> + addListener)</span>;  </span><br><span class="line">            Method removeListener = e.getRemoveListenerMethod<span class="params">()</span>;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"Remove Listener Method:\n"</span> + removeListener)</span>;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"==========================================="</span>)</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ------------------------------------------------  </span></span><br><span class="line">    class Dumper implements ActionListener &#123;  </span><br><span class="line">  </span><br><span class="line">        @Override  </span><br><span class="line">        public void actionPerformed<span class="params">(ActionEvent e)</span> &#123;  </span><br><span class="line">            String name = query.getText<span class="params">()</span>;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"name=========&gt;"</span>+name)</span>;  </span><br><span class="line">            Class&lt;?&gt; c = null;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                c = Class.forName<span class="params">(name)</span>;  </span><br><span class="line">            &#125; catch <span class="params">(ClassNotFoundException e1)</span> &#123;  </span><br><span class="line">                results.setText<span class="params">(<span class="string">"couldn 't find "</span> + name)</span>;  </span><br><span class="line">                e1.printStackTrace<span class="params">()</span>;  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line">            dump<span class="params">(c)</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public BeanDumper<span class="params">()</span> &#123;  </span><br><span class="line">        JPanel p = new JPanel<span class="params">()</span>;  </span><br><span class="line">        p.setLayout<span class="params">(new FlowLayout<span class="params">()</span>)</span>;  </span><br><span class="line">        p.add<span class="params">(new JLabel<span class="params">(<span class="string">"qualifeied bean name:"</span>)</span>)</span>;  </span><br><span class="line">        p.add<span class="params">(query)</span>;  </span><br><span class="line">        add<span class="params">(BorderLayout.NORTH, p)</span>;  </span><br><span class="line">        add<span class="params">(new JScrollPane<span class="params">(results)</span>)</span>;  </span><br><span class="line">        Dumper dmpr = new Dumper<span class="params">()</span>;  </span><br><span class="line">        query.addActionListener<span class="params">(dmpr)</span>;  </span><br><span class="line">        query.setText<span class="params">(<span class="string">"org.rui.swing.bean.Frog"</span>)</span>;  </span><br><span class="line">        dmpr.actionPerformed<span class="params">(new ActionEvent<span class="params">(dmpr, <span class="number">0</span>, <span class="string">""</span>)</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main<span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">//工具类  </span></span><br><span class="line">        SwingConsole.run<span class="params">(new BeanDumper<span class="params">()</span>, <span class="number">600</span>, <span class="number">500</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JavaBean与同步">JavaBean与同步</h3><ol>
<li>尽可能地让Bean中的所有公共方法都是synchronized的。</li>
<li>当一个多路事件触发了一组对该事件感兴趣的监听器时，你必须假定，在你遍历列表进行通知的同时，监听器可能会被添加或移除。<br> 可以通过忽略synchronized关键字并使用单路事件处理方式，回避并发问题。 </li>
</ol>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是这是一个单播侦听器  </span></span><br><span class="line"><span class="comment">// 最简单形式的侦听器管理  </span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">addActionListener</span><span class="params">(ActionListener l)</span>  </span><br><span class="line">        <span class="keyword">throws</span> TooManyListenersException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (actionListener != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TooManyListenersException();  </span><br><span class="line">    &#125;  </span><br><span class="line">    actionListener = l;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断方法是否被同步需要考虑的问题</p>
<ol>
<li>这个方法会修改对象中“关键”变量的状态吗？要弄清楚变量是否“关键”，必须判断它们是否被程序中的其他线程读写。</li>
<li>这个方法依赖于那些“关键”变量吗？如果有某个同步方法会修改此方法所使用的变量，那么你应该把这个方法也同步。要是觉得问题不大，这种改变只起瞬时作用，你就可以做出不同步的决定，以避免同步方法调用所产生的开销。</li>
<li>第三个线索是查看基类版本的paintComponent是否同步，这只是一个线索。注意，同步不会继承，也就是说，基类方法是同步的，派生类中覆盖后的版本并非自动同步。</li>
<li>方法执行必须尽可能快。要尽可能把处理的开销移到方法外面。</li>
</ol>
<h3 id="对Bean更高级的支持">对Bean更高级的支持</h3><p>前面的例子只演示了单一属性，但也可以使用数组来表示多重属性。这称为索引属性。<br>属性可以被绑定，即它们能通过PropertyChangeEvent事件通知其他对象<br>属性可以被约束，即如果属性的改变是不可接受的，其他对象可以否决这个改变。</p>
<p>Swing的可替代选择flex，SWT</p>
]]></content>
    <summary type="html">
    <![CDATA[thinking in java; java编程思想; 图形化用户界面;]]>
    
    </summary>
    
      <category term="Thinking in Java" scheme="http://howiefh.github.io/tags/Thinking-in-Java/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java编程思想笔记八]]></title>
    <link href="http://howiefh.github.io/2015/02/06/thinking-in-java-note-8/"/>
    <id>http://howiefh.github.io/2015/02/06/thinking-in-java-note-8/</id>
    <published>2015-02-06T02:17:57.000Z</published>
    <updated>2015-04-06T06:17:45.000Z</updated>
    <content type="html"><![CDATA[<p>并发“具有可论证的正确性，但是实际上具有不可确定性”</p>
<h2 id="并发的多样性">并发的多样性</h2><p>并发解决的问题大体上可以分为“速度”和“设计可管理性”两种。</p>
<a id="more"></a>
<h3 id="更快的执行">更快的执行</h3><p>并发通常是提高运行在单处理器上的程序的性能。如果程序中的一个任务阻塞了，其他任务可以继续执行，如果没有阻塞，那么单处理器上使用并发就没有任何意义，反而还增加了上下文切换的代价。使用并发就好像cpu可以同时位于两处一样，这仅仅是错觉，但是多处理器的话，就不只是错觉了。</p>
<p>提高单处理器系统性能的常见示例是事件驱动的编程。实际上，使用并发最吸引人的一个原因就是要产生具有可响应的用户界面。</p>
<p>实现并发最直接的方式是在操作系统级别使用进程，进程是运行在自己的地址空间内的自包容程序。</p>
<p>操作系统通常会将进程相互隔离，因此它们不会彼此干涉，这使得用进程编程相对容易一些。与此相反的是，向java所使用的这种并发系统会共享注入内存和I/O这样的资源，因此编写多线程程序最基本的困难在于在协调不同线程驱动的任务之间对这些资源的使用，以使得这些资源不会同时被多个任务访问。</p>
<p>某些编程语言被设计为可以将并发任务彼此隔离，通常被称为函数型语言，其中每个函数调用都不会产生任何副作用（并因此而不能干涉其他函数），并因此可以当作独立的任务来驱动。</p>
<h3 id="改进代码设计">改进代码设计</h3><p>Java的线程机制是抢占式的，这表示调度机制会周期性的中断线程，将上下文切换到另一个线程，从而为每一个线程都提供时间片，使得每个线程都会分配到数量合理的时间去驱动任务。在协作式系统中，每个任务都会自动地放弃控制，这要求程序员要有意识的在每个任务中插入某种类型的让步语句。协作式系统的优势是双重的：上下文切换的开销通常比抢占式系统要低廉许多，并且对可以同时执行的线程数量在理论上没有任何限制。（注意：某些协作式系统并未设计为可以在多个处理器之前分布任务，这可能会非常受限）。</p>
<h2 id="基本的线程机制">基本的线程机制</h2><h3 id="定义任务">定义任务</h3><p>线程可以驱动任务，因此你需要一种描述任务的方式，这可以由实现 Runnable 接口提供。</p>
<p><strong>对静态方法Thread.yield()的调用是对线程调度器（java线程机制的一部分，可以将CPU从一个线程转移给另一个线程）的一种建议，它在声明：“我已经执行完生命周期中最重要的部分了，此刻正是切换给其他任务执行一段时间的大好时机。”这完全是选择性的</strong>。</p>
<h3 id="Thread类">Thread类</h3><p>Thread构造器只需要一个Runnable对象。调用start方法会迅速返回，run方法由其他线程“同时”执行。</p>
<p><strong>每个Thread都“注册”了它自己，因此确实有一个对它的引用，而且在它的任务退出其run并死亡之前，垃圾回收器无法清除它</strong>。</p>
<h3 id="使用Executor">使用Executor</h3><p>Executor执行器将为你管理Thread对象，从而简化并发编程。</p>
<p>ExecutorService（具有服务生命周期的Executor，例如关闭）知道如何构建恰当的上下文来执行Runnable对象。</p>
<p><strong>Executor.newCachedThreadPool()将为每一个任务都创建一个线程，然后在他回收旧线程时停止创建新线程，因此它是合理的Executor首选。只有当这种方式会引发问题时，才需要切换到FixedThreadPool</strong>。</p>
<p>常见的情况是，单个的Executor被用来创建和管理系统中所有的任务。</p>
<p>Executor.shutdown()方法的调用可以防止新任务被提交给Executor.</p>
<p><strong>Executor.newFixedThreadPool(int num)，可以一次性预先执行代价高昂的线程分配，因而也就可以限制线程的数量了。这可以节省时间，因为不用为每个任务都固定的付出创建线程的开销，在事件驱动的系统中，需要线程的事件处理器，通过直接从池中获取线程，如你所愿尽快的得到服务</strong>。</p>
<p>在任何线程池中，现有线程在可能的情况下，都会被自动复用。</p>
<p><strong>Executor.newSingleThreadExecutor()就像是线程数量为1的FixedThreadPool，并提供了一种重要的并发保证，其他线程不会（即没有两个线程会）被并发调用，这会改变任务的加锁需求。SingleThreadExecutor会序列化所有提交给他的任务，并维护他自己（隐藏）的悬挂任务队列。每个任务都是按照他们被提交的顺序，并且是在下一个任务开始之前完成的</strong>。</p>
<h3 id="从任务中产生返回值">从任务中产生返回值</h3><p><strong>可以通过实现Callable接口在任务结束时返回一个值。Callable是一个具有类型参数的泛型，其类型参数表示的是从方法call()返回的值，并且必须使用ExecutorService.submit()方法调用它</strong>。</p>
<p><strong>submit()方法会产生Future对象，它用Callable返回结果的特定类型进行了参数化。可以通过isDone()方法查询Future是否完成。当任务完成时，它具有一个结果，可以调用get()方法获取该结果。也可以不用isDone()进行检查就直接调用get()，此时，get()将阻塞，直至结果准备就绪。还可以调用具有超时的get()</strong></p>
<h3 id="休眠">休眠</h3><p>对 sleep()的调用可能抛出 InterruptedException 异常（这是调用 Thread的 interrupt()方法），并且你可以看到，它在 run()中被捕获。<strong>因为异常不能跨线程传播回 main，所以你必须在本地处理所有在任务内部产生的异常</strong>。</p>
<p>sleep() VS TimeUnit.MILLISECONDS.sleep()。后者可阅读性更强。</p>
<h3 id="优先级">优先级</h3><p>Thread.currentThread()获取对驱动该任务的Thread对象的引用。优先级是在run方法的开头设定的。</p>
<p>getPriority来读取线程的优先级，setPriority设置线程的优先级。优先级在run()的开头部分设定。JDK有十个优先级，一般调用优先级的时候只使用Thread.MAX_PRIORITY、Thread.NORM_PRIORITY和Thread.MIN_PRIORITY。</p>
<h3 id="让步">让步</h3><p>run()方法的循环中的一次迭代过程中所需的工作，就可以给线程调度机制一个暗示：我的工作已经差不多了，可以让别的线程使用 CPU 了。这个暗示将通过调用 yield()方法来作出（不过这只是一个提示，没有任何机制保证它将会被采纳）。当调用 yield()时，其实是在建议线程调度器去调度具有相同优先级的其他线程工作。</p>
<p><strong>大体上，对于任何重要的控制或在调整应用时，都不能依赖 yield()。实际上，yied()经常被误用</strong>。</p>
<h3 id="后台线程">后台线程</h3><p>后台（daemon）线程，是指程序运行的时候在后台提供一种通用服务的线程，并且这种线程不属于程序中不可或缺的部分。<strong>因此，当所有的非后台线程结束时，程序也就终止了，同时杀死进程中所有后台线程。这样意味着，并不能保证后台线程中的代码可以完全执行</strong>。</p>
<p><strong>必须在线程启动之前调用setDaemon()方法，才能把它设置为后台线程</strong>。</p>
<p>Daemon线程派生的子线程，即使没有显式的设置为后台线程，但确实是后台线程。</p>
<p><strong>应该意识到后台线程在不执行finally子句的情况下就会终止其run()方法</strong>。</p>
<h3 id="编码的变体">编码的变体</h3><p>可以继承Thread类，重写run方法。</p>
<p>在构造器中启动线程可能会变得很有问题，因为另一个任务可能会在构造器结束之前开始任务，这意味着该任务能够访问处于不稳定状态的对象。这是优选Executor而不是显式地创建Thread对象的另一个原因。</p>
<h3 id="术语">术语</h3><p>Thread类自身不执行任何操作，它只是驱动赋予它的任务。</p>
<p>在物理上创建线程可能会代价高昂，因此你必须保存并管理它们。这样，从实现的角度看，将任务从线程中分离出来是很有意义的。另外，java的线程机制基于来自C的低级的p线程方式，这是一种你必须深入研究，并且需要完全理解其所有事物的所有细节的方式。</p>
<h3 id="加入一个线程">加入一个线程</h3><p><strong>如果某线程调用t线程的t.join()，则此线程将被挂起，直到t线程结束才恢复(即t.isAlive()返回为假)</strong>。</p>
<p><strong>对join方法的调用可以被中断，做法是在调用线程上调用interrupt方法，上面的例子即调用t.interrupt()，调用此方法将给该线程设置一个标志，表明该线程已经被中断。然而，InterruptedException异常被捕获时将清理这个标志。可以用isInterrupted检测线程的中断状态</strong>。</p>
<p>java.util.concurrent类库包含诸如CyclicBarrier这样的工具，它们可能比最初的线程库中join更加合适。</p>
<h3 id="捕获异常">捕获异常</h3><p>由于线程的本质特性，使得你不能捕获从线程中逃逸的异常，一旦异常逃出任务的run()方法，就会向外传播到控制台，除非采用特殊的步骤捕获这种异常。</p>
<p><strong>为了解决这个问题，需要修改Executor生产线程的方式。Thread.UncaughtExceptionHandler是Java SE5中的新接口，它允许在每个Thread对象上都附着一个异常处理器。Thread.UncaughtExceptionHandler.uncaughtException()会在线程因为捕获的异常而临近死亡时被调用</strong>。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span> t <span class="subst">=</span> <span class="literal">new</span> <span class="keyword">Thread</span>(<span class="literal">new</span> Runnable()&#123;<span class="keyword">public</span> <span class="literal">void</span> run() &#123;&#125;);</span><br><span class="line">t<span class="built_in">.</span>setUncaughtExceptionHandler(<span class="literal">new</span> <span class="keyword">Thread</span><span class="built_in">.</span>UncaughtExceptionHandler()&#123;<span class="keyword">public</span> <span class="literal">void</span> uncaughtException(<span class="keyword">Thread</span> t, Throwable e) &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>如果确定将要在代码中处处使用相同的异常处理器，那么更简单的方式是在Thread类中设置一个静态域，并将这个处理器设置为默认的未捕获异常处理器。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Thread</span><span class="built_in">.</span>setDefaultUncaughtExceptionHandler(<span class="literal">new</span> <span class="keyword">Thread</span><span class="built_in">.</span>UncaughtExceptionHandler()&#123;<span class="keyword">public</span> <span class="literal">void</span> uncaughtException(<span class="keyword">Thread</span> t, Throwable e) &#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>这个处理器只有在不存在线程专有的未捕获异常处理器的情况下才会被调用。系统会检查线程专有版本，如果没有发现，则检查线程组是否有其专有的uncaughtException()方法，如果没有，再调用defaultUncaughtExceptionHandler。</p>
<h2 id="共享受限资源">共享受限资源</h2><h3 id="解决共享资源竞争">解决共享资源竞争</h3><p>基本上所有的并发模式在解决线程冲突问题的时候，都是采用序列化访问共享资源的方案。这意味着在给定时刻只允许一个任务访问共享资源。通常这是通过在代码前面加上一条锁语句来实现的，这种机制就是所谓的互斥量(mutex)。</p>
<p><strong>临界资源</strong>：共享资源一般是以对象形式存在的内存片段，也可以是文件、输入/输出端口，或者是打印机之类的东西</p>
<p><strong>临界区</strong>：有时，你只是希望防止多个线程同时访问方法内部的内部代码而不是整个方法，通过这种方式分离出来的代码段被称为临界区(critical section)，它也使用 synchronized 关键字建立。这里，synchronized 被用来指定某个对象，此对象的锁被用来对花括号内的代码进行同步控制。</p>
<p><strong>所有对象都自动含有单一的锁（也称为监视器）。当在对象上调用其任意synchronized方法的时候，此对象都被加锁，这时该对象上的其他synchronized方法只有等到前一个方法调用完毕并释放了锁之后才能被调用。所以，对于某个特定对象来说，其所有synchronized方法共享同一个锁，可以被用来防止多个任务同时访问被编码为对象内存</strong>。</p>
<p><strong>注意，在使用并发时，将域设置为 private 是非常重要的，否则，synchronized 关键字就不能防止其他任务直接访问域，这样会产生冲突</strong>。</p>
<p><strong>一个任务可以多次获得对象的锁。每当这个相同的任务在这个对象上获得锁时，计数都会递增。每当任务离开一个synchronized方法，计数递减，当计数为零的时候，锁被完全释放，此时别的任务就可以使用此资源</strong>。</p>
<p><strong>针对每个类，也有一个锁（作为类的 Class 对象的一部分），所以 synchronized static 方法可以在类的范围内防止对 static 数据的并发访问</strong>。</p>
<p><strong>每个访问临界共享资源的方法都必须被同步，否则它们就不会正常地工作</strong>。</p>
<p><strong>Java SE5的 java.util.concurrent 类库还包含有定义在 java.util.concurrent.locks 中的显式的互斥机制。Lock 对象必须显式的创建、锁定和释放。因此，它与 synchronized 提供的锁机制相比，代码缺少优雅性。但是对于有些场景，使用 Lock 会更加灵活</strong>。</p>
<p>通常只有在解决特殊问题时，才使用显式的Lock对象。例如，用synchronized关键字不能尝试这获取锁且最终获取锁会失败，或者尝试着获取锁一段时间，然后释放它。</p>
<p>显式的 Lock 对象在加锁和释放锁方面，相对于内建的 synchronized 锁来说，还赋予了你更细粒度的控制力。这对于实现专有同步结构是很有用的，例如用于遍历链接列表中的节点的节节传递的加锁机制（也称为锁耦合），这种遍历代码必须在释放当前节点的锁之前捕获下一个节点的锁。如果使用 synchronized 是做不到的。</p>
<h3 id="原子性和易变性">原子性和易变性</h3><p>原子操作是不能被线程调度机制中断的操作；一旦操作开始，那么它一定可以在可能发生的“上下文切换”之前执行完毕。原子性可以应用于除long和double之外的所有基本类型之上的简单操作。JVM可以将64位（long和double变量）的读取和写入当作两个分离的32位操作来执行，这有时被称为字撕裂。<strong>但，当定义long和double变量时，如果使用volatile关键字，就会获得（简单的赋值与返回操作的）原子性</strong>。</p>
<p>原子操作可由线程机制保证其不可中断，专家级程序员可以利用这一点编写无锁的代码，这些代码不需要被同步。即使如此，它也是一种过于简化的机制。不要尝试！</p>
<p>在多处理器系统上，相对于单处理器系统而言，可视性问题远比原子性问题多得多。一个任务做出的修改，即使在不中断的意义上讲是原子性的，对其他任务也可能是不可视的，（例如，修改只是暂时性地存储在本地处理器的缓存中），因此不同的任务对应用的状态有不同的视图。另一方面，同步机制强制在处理器系统中，一个任务做出的修改必须在应用中是可视的。</p>
<p><strong>volatile关键字还确保了应用中的可视性。同步也会导致向主存中刷新，因此如果一个域完全由synchronized方法或语句块来防护，那就不必将其设置为是volatile。volatile还可以禁止指令重排序优化</strong>。</p>
<p><strong>当一个域的值依赖于它之前的值时（例如递增一个计数器），volatile就无法工作了。如果一个域的值受到其他域的值的限制，那么volatile也无法工作</strong>，例如Range类的lower和upper边界就必须遵循lower&lt;=upper的限制。使用volatile而不是synchronized的唯一安全的情况是类中只有一个可变的域。第一选择应该是使用synchronized关键字，这是最安全的方式。</p>
<p><strong>Java中，对于除了long和double的基本类型的赋值和返回操作都是原子性的。i++ 不具有原子性，这与C++不同</strong>。</p>
<p>总结：除了long和double的基本类型的赋值和返回操作都是原子性的。使用volatile关键字可以使long和double的这两个操作也具有原子性。即使除了long和double的基本类型的赋值和返回操作都是原子性的，但是并不能保证它们是可视的（如果修改只是暂时保存在本地处理器中，不同任务对应用的状态就有不同的视图，这就不是可视的）。即使volatile可以保证可视性，但是并不能保证像i++这样的操作的原子性。因此，大多数情况使用synchronized更安全。</p>
<h3 id="原子类">原子类</h3><p>Java SE5引入了 AtomicInteger、AtomicLong、AtomicReference 等原子类(应该强调的是，Atomic 类被设计用来构建 java.util.concurrent 中的类，因此只有在特殊情况下才在自己的代码中使用它们，即便使用了也不能认为万无一失。通常依赖于锁会更安全)。它们提供下面形式的更新操作：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSet</span><span class="params">(expectedValue, updateValue)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="临界区">临界区</h3><p>防止多个线程同时访问方法内部的部分代码而不是防止访问整个方法，此代码段被称为临界区，也使用synchronized关键字。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">synchronized</span>(syncObject) &#123;</span><br><span class="line"><span class="comment">//This code can be accessd</span></span><br><span class="line"><span class="comment">//by only one task at a time</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这也被称为同步控制块，在进入这段代码前，必须获得 syncObject 对象的锁，如果其他线程已经得到这个锁，那么就得等到锁释放以后，才能进入临界区。</p>
<p><strong>synchronized块必须给定一个在其上进行同步的对象，并且最合理的方式是，使用其方法正在被调用的当前对象：synchronized(this)，这种方式中，如果获得了synchronized块上的锁，那么该对象的其他synchronized方法和临界区就不能被调用了，因此，如果在this上同步，临界区的效果就会直接缩小在同步的防范内</strong>。</p>
<p>有时，必须在另一个对象上同步，但是如果这么做，必须保证所有相关的任务都是在同一个对象上同步的。</p>
<p>可以看出synchronized方法，相当于synchronized(this)整个方法中的代码段。</p>
<h3 id="线程本地存储">线程本地存储</h3><p>防止任务在共享资源上产生冲突的第二种方式是根除对变量的共享。线程本地存储是一种自动化机制，可以为使用相同变量的每个不同的线程创建不同的存储。ThreadLocal对象通常当作静态域存储。在创建ThreadLocal时，你只能通过get()和set()方法来访问该对象的内容。</p>
<p><strong>synchronized 很简单，就是每个对象访问共享资源时，会检查对象头中的锁状态，然后进行串行访问共享资源；volatile 也很简单，它在使用中保证对变量的访问均在主内存进行，不存在对象副本，所以每个线程要使用的时候，都必须强制从主内存刷新，但是如果操作不具有原子性，也会导致共享资源的污染，所以 volatile 的使用场景要非常小心，在《深入理解 Java 虚拟机》中有详细的分析，这里就不细谈了；然后 ThreadLocal，其实 ThreadLocal 跟共享资源没关系，因为都是线程内部的，所以根本不存在共享这一说法</strong></p>
<p>这是一种对共享资源安全使用的方法，但是和 synchronized 有区别，它为每个线程都分配一个变量的内存空间，根除了线程对共享变量的竞争。但是因为每个线程，所以这个变量在不同线程之间是“透明的”、“无法感知的”，这就意味着各个线程的这个变量不能有联系，它只和当前的线程相关联。参考 <a href="http://github.thinkingbar.com/threadlocal/" target="_blank" rel="external">理解ThreadLocal</a></p>
<h2 id="终结任务">终结任务</h2><h3 id="在阻塞时终结">在阻塞时终结</h3><p><strong>线程的状态</strong><br>新建：当线程被创建时，它只会短暂的处于这种状态。此时它分配了必须的系统资源，并执行了初始化。此刻线程已经有资格获取 CPU 时间了。之后就靠调度器来调度<br>就绪：调度器分配时间片了就可以运行，不分配时间片就等待(不是阻塞！)。<br>阻塞：线程能够运行，但有某个条件阻止它的运行。当线程处于阻塞状态，调度器将忽略该线程，不会分配时间片，直到线程重新进入就绪状态<br>死亡：处于死亡状态的线程是不能再被调度的，并且再也不会得到时间片</p>
<p><strong>进入阻塞状态</strong><br><strong>调用了 sleep()方法使任务进入休眠状态</strong><br><strong>调用了 wait()使线程挂起，直到线程得到了 notify()或者 notifyAll()消息（或者在 Java SE5中的 java.lang.util.concurrent 类库中等价的 signal()或 signalAll()消息），线程才会进入就绪状态</strong><br><strong>任务等待某个输入/输出</strong><br><strong>任务试图在某个对象上调用其他同步控制方法，但是对象锁不可用，因为另一个任务已经获取了这个锁</strong></p>
<p>有时希望能中终止处于阻塞状态的任务。因为对处于阻塞状态的任务，你不能等待其到达代码中可以检查其状态值的某一点，进而决定让它主动终止，那么唯一的做法就是强制这个任务跳出阻塞状态。</p>
<h3 id="中断">中断</h3><p>当打断被阻塞的任务时，可能需要清理资源。正因为这一点，在任务的run()方法中间打断，更像是抛出的异常，因此在 Java 线程中的这种类型的异常中断中用到了异常（这会滑向对异常的不恰当使用，因为这意味着你需要用异常来控制正常的代码逻辑）。为了在阻塞中终止任务，返回一个良好的状态，就必须仔细考虑 catch 子句以正确的清理所有事物。</p>
<p><strong>当抛出该异常或者该任务调用Thread.interrupted()时，中断状态将被复位。Thread.interrupted()提供了离开run()循环而不抛出异常的第二种方式</strong>。</p>
<p><strong>调用 shutdownNow()将发送一个 interrupt()调用给它启动的所有线程</strong></p>
<p><strong>如果只想中断特定的任务，就要使用 submit()方法而不是 execute()来启动任务，前面说过 Runnable 的 run 是 void 的，而 Callable 的 run 会返回一个 Future&lt;?&gt;。也就是说通过 submit（）调用会持有任务的上下文。因为这里仅仅是为了调用 cancel()而不会调用 get()，所以可以用来中断任务。做法就是将 true 传递给 cancel()</strong></p>
<p><strong>能够中断对 sleep()的调用（或者任何要求抛出 InterruptedException 的调用）</strong><br><strong>不能中断正在试图获取 Synchronized 锁的线程</strong><br><strong>不能中断正在试图执行 I/O 操作的线程</strong></p>
<p>只要任务以不可中断的方式被阻塞，那么都有潜在的会锁住程序的可能。</p>
<p>对于io阻塞，有一个略显笨拙但是有时确实行之有效的解决方案，即关闭任务在其上发生阻塞的底层资源。nio类提供了更人性化的io中断，被阻塞的nio通道会自动地响应中断。</p>
<p>被互斥所阻塞</p>
<p>Java SE5并发类库中添加了一个特性，即在ReentrantLock上阻塞的任务具备可以被中断的能力。如果使用ReentrantLock而不是synchronized就可以调用interrupt方法打断被互斥所阻塞的调用。</p>
<h3 id="检查中断">检查中断</h3><p>中断发生的唯一时刻是在任务要进入到阻塞操作中，或者已经在阻塞操作内部时。</p>
<p>可以通过调用interrupted()来检查中断状态，这不仅可以告诉你interrupt()是否被调用过，而且还可以清除中断状态。</p>
<p><strong>清除中断状态可以确保并发结构不会就某个任务被中断这个问题通知你两次，你可以经由单一的InterruptedException或单一的成功的Thread.interrupted()测试来得到这种通知</strong>。</p>
<p>被设计用来响应 interrput()的类必须建立一种策略，来确保它将保持一致的状态。这通常意味着所有需要清理的对象创建操作的后面，都必须紧跟 try-catch-finally子句，从而使得无论 run()循环如何退出，清理都会发生。</p>
<h2 id="线程之间的协作">线程之间的协作</h2><p>当你使用线程来同时运行多个任务时，可以通过使用锁（互斥）来同步两个任务的行为，从而使得一个任务不会干涉另一个任务的资源。</p>
<p>现在的问题不是彼此之间的干涉，而是彼此之间的协调，因为在这类问题中，某些部分必须在其他部分被解决之前解决。当任务协作时，关键问题是这些任务之间的握手。为了实现这种握手，我们使用了相同的基础特性：互斥。在这种情况下，互斥能够确保只有一个任务可以响应某个信号，这样就可以根除任何可能的竞争条件。在互斥之上，我们为任务添加了一种途径，可以将其自身挂起，直至某些外部条件发生变化。</p>
<h3 id="wait()与notifyAll()">wait()与notifyAll()</h3><p><strong>调用sleep()和yield()时，锁并没有被释放。而调用wait()时，线程的执行被挂起，对象上的锁被释放。wait()表示无限期等待下去，直到notify或notifyAll，它也可以传入参数表示时间到期后恢复。当wait恢复时，会首先重新获取进入wait时释放的锁，在这个锁变为可用之前，是不会被唤醒的</strong>。</p>
<p><strong>只能在同步控制方法或者同步控制块里调用wait(), notify()和notifyAll()（因为不用操作锁，所以sleep()可以在非同步控制方法里调用）</strong>。否则虽然能够编译通过，但运行时将报异常：IllegalMonitorStateException。如果不这样做，就没有锁，就可能导致“错失的信号”。</p>
<p><strong>错失的信号</strong></p>
<p>当两个线程协作时，要特别注意可能会错过某个信号，例如下例T1通知T2，但是有可能T2收不到这个信号：</p>
<p>T1:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronized<span class="params">(shareMonitor)</span> &#123;</span><br><span class="line">     <span class="comment">//&lt;setup condition for T2&gt;</span></span><br><span class="line">     shareMonitor.notify<span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>T2:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">while<span class="params">(someCondition)</span> &#123;</span><br><span class="line">     <span class="comment">//Point 1</span></span><br><span class="line">     synchronized<span class="params">(shareMonitor)</span> &#123;</span><br><span class="line">          shareMonitor.wait<span class="params">()</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>以上代码运行到Point1时，如果调度到了T1，则T2收不到通知，就会永远在那里等待。T2正确的做法是：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">synchronized<span class="params">(shareMonitor)</span> &#123;</span><br><span class="line">     while<span class="params">(someCondition)</span> &#123;</span><br><span class="line">          shareMonitor.wait<span class="params">()</span>;</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="notify()与notifyAll()">notify()与notifyAll()</h3><p>两者的不同之处在于，前者只唤醒一个线程，而后者唤醒同一锁定的所有线程。当有多个等待线程时，notify唤醒哪一个线程由调度决定。<strong>notifyAll唤醒多个线程后，它们将先为锁而战，先取得锁的线程先执行</strong>。</p>
<p><strong>什么情况下使用notify或者notifyAll？在多个等待的线程中，如果它们都在等同一个条件，并且当条件变为真时，只有一个线程从中受益，那么用notify比notifyAll更好，因为它避免浪费CPU循环。 notify()只唤醒其中一个。因此当你使用notify时要确保只唤醒正确的那个</strong>。</p>
<p>notifyAll并不是唤醒所有等待线程，而是等待某个特定锁的所有线程。</p>
<p><strong>使用显式的Lock和Condition对象</strong></p>
<p>除了wait()、notify()和notifyAll()方法用于同步方法或者同步代码块外，也可以使用Lock、Condition、await()、signal()和signalAll()方法。示例如下：</p>
<p>可以通过在Condition上调用await()来挂起一个任务。当外部条件发生变化，意味着某个任务应该继续执行时，你可以通过调用signal()来通知这个任务，从而唤醒一个任务，或者调用signalAll()来唤醒所有在这个Condition上被其自身挂起的任务（与使用notifyAll()相比，signalAll()是更安全的方式）。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Car</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Lock <span class="keyword">lock</span> = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="keyword">private</span> Condition condition = <span class="keyword">lock</span>.newCondition();</span><br><span class="line">    <span class="keyword">private</span> boolean waxOn = <span class="keyword">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waxed</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            waxOn = <span class="keyword">true</span>;</span><br><span class="line">            condition.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">waitForWaxing</span>(<span class="params"></span>) throws InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">lock</span>.<span class="keyword">lock</span>();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (waxOn == <span class="keyword">false</span>) </span><br><span class="line">                condition.await();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">lock</span>.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，每个lock()的调用都必须紧跟一个try-finally子句，以保证所有情况都可以释放锁。在await()、signal()或signalAll()之前，必须拥有这个锁。</p>
<h3 id="生产者-消费者与队列">生产者-消费者与队列</h3><p><strong>使用wait()和notifyAll()这样的方法来解决任务互操作的问题比较复杂。在典型的生产者-消费者实现中，常使用先进先出队列来存储被生产和消费的对象。BlockingQueue接口提供了这样的同步队列，该接口有多种实现，常见的是LinkedBlockingQueue(无界队列)和ArrayBlockingQueue(固定尺寸)</strong>。</p>
<p>如果消费者试图从队列中获取对象，而此时该队列为空，那么消费者将挂起，直到队列中有可消费的内容。阻塞队列可以解决很多问题，比wait()和notifyAll()相比，要简单得多，也更加可靠。示例如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LiftOffRunner</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BlockingQueue&lt;LiftOff&gt; rockets;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">LiftOffRunner</span><span class="params">(BlockingQueue&lt;LiftOff&gt; queue)</span> </span>&#123;</span><br><span class="line">        rockets = queue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(LiftOff lo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            rockets.put(lo);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            print(<span class="string">"Interrupted during put"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(! Thread.interrupted)) &#123;</span><br><span class="line">                LiftOff rocket = rockets.take(); <span class="comment">//阻塞直至rockets中有东西</span></span><br><span class="line">                rocket.run();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">            print(<span class="string">"Exiting LiftOffRunner"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其它线程可以往rockets中添加内容，无需同步方法或者锁。</p>
<h3 id="任务间使用管道进行输入/输出">任务间使用管道进行输入/输出</h3><p>通过输入/输出在线程间进行通信也很有用。这种管道在Java IO库中的对应物就是PipedWriter类和PipedReader类。这也是“生产者-消费者”的变体。示例如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">Sender</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PipedWriter <span class="keyword">out</span> = <span class="keyword">new</span> PipedWriter();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PipedWriter <span class="title">getWriter</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="keyword">out</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">char</span> c = <span class="string">'A'</span>; c &lt;= <span class="string">'z'</span>; c++) &#123;</span><br><span class="line">                    <span class="keyword">out</span>.write(c);</span><br><span class="line">                    TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">500</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span>(IOException e) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException e ) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title">Receiver</span> <span class="title">implements</span> <span class="title">Runnable</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> PipedReader <span class="keyword">in</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Receiver</span>(<span class="params">Sender sender</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">in</span> = <span class="keyword">new</span> PipedReader(sender.getWriter());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                print(<span class="string">"read: "</span> + (<span class="keyword">char</span>) <span class="keyword">in</span>.read());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与普通I/O不能interrupt不同，PipedReader是可以中断的。<br>相比之下，BlockingQueue使用起来更加健壮而容易。</p>
<h2 id="死锁">死锁</h2><p>某个任务在等待另一个任务，而后者又等待别的任务，这样一直下去，知道这个链条上的任务又在等待第一个任务释放锁。这得到了一个任务之间相互等待的连续循环，没有哪个线程能继续。这被称为死锁。</p>
<p>当以下四个条件同时满足时，就会发生死锁：</p>
<ul>
<li><strong>互斥条件。任务使用的资源中至少有一个是不能共享的</strong>。</li>
<li><strong>至少有一个任务必须持有一个资源且正在等待获取一个当前被别的任务持有的资源</strong>。</li>
<li><strong>资源不能被任务抢占，任务必须把资源释放当作普通事件</strong>。</li>
<li><strong>必须有循环等待。A等待B持有的资源，B又等待C持有的资源，这样一直下去之后，直到X在等待A所持有的资源</strong>。<br>要防止死锁，只需破坏上述四条中的任意一条。破坏第4条是最容易的。</li>
</ul>
<h2 id="新类库中的构件">新类库中的构件</h2><p>java.util.concurrent引入的新类库，有助于编写更简单和健壮的并发程序。</p>
<h3 id="CountDownLatch">CountDownLatch</h3><p>用于同步一个或多个任务，强制它们等待由其他任务执行的一组操作完成。可以向CountDownLatch对象设置一初始值，任务在这个对象上调用await()方法都将阻塞，直到计数值为0。其它任务结束工作时，可以调用countDown()来减少这个计数值。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LatchDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Latch</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">        Latch(CountDownLatch latch) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch = latch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                doSomething();</span><br><span class="line">                System.out.println(<span class="string">"Latch runing..."</span>);</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">                System.out.println(<span class="string">"Latch sleeped 3 seconds."</span>);</span><br><span class="line">                <span class="comment">//2. 当完成后，调用countDown()，将计数减1</span></span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">LatchWaiter</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CountDownLatch latch;</span><br><span class="line">        LatchWaiter(CountDownLatch latch) &#123;</span><br><span class="line">            <span class="keyword">this</span>.latch = latch;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"LatchWaiter waiting..."</span>);</span><br><span class="line">                <span class="comment">//3. 一直等到latch的计数变为0</span></span><br><span class="line">                latch.await();</span><br><span class="line">                System.out.println(<span class="string">"LatchWaiter exit wait..."</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">//<span class="doctag"><span class="keyword">todo</span></span></span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doOtherthing</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1. 先赋一个值，例如1</span></span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        exec.execute(<span class="keyword">new</span> Latch(latch));</span><br><span class="line">        exec.execute(<span class="keyword">new</span> LatchWaiter(latch));</span><br><span class="line">        exec.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：CountDownLatch只会触发一次，计数值不能重置。</p>
<h3 id="CyclicBarrier">CyclicBarrier</h3><p>CyclicBarrier适用于有一组任务，它们并行工作，直到它们全部完成后，才一起向前移动。与CountDownLatch只会触发一次不同，CyclicBarrier可以多次重用。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierDemo</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Horse</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> CyclicBarrier barrier;</span><br><span class="line">        <span class="keyword">private</span> String id;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> stepCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> Random rand = <span class="keyword">new</span> Random(<span class="number">5000</span>);</span><br><span class="line"></span><br><span class="line">        Horse(String id, CyclicBarrier barrier) &#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.barrier = barrier;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            doSomething();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                        System.out.println(String.format(<span class="string">"Thread %s is doing."</span>,</span><br><span class="line">                                id));</span><br><span class="line">                        stepCount++;</span><br><span class="line">                        TimeUnit.MILLISECONDS.sleep(rand.nextInt(<span class="number">5000</span>));</span><br><span class="line">                        System.out.println(String.format(<span class="string">"Thread %s has done."</span>,</span><br><span class="line">                                id));</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// await：待所有线程都在这一步调用await方法。</span></span><br><span class="line">                    barrier.await();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (BrokenBarrierException e) &#123;</span><br><span class="line">                <span class="comment">// ...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getStepCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> stepCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">int</span> threadCount = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">final</span> Counter cycleCount = <span class="keyword">new</span> Counter();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意构造方法的参数</span></span><br><span class="line">        CyclicBarrier barrier = <span class="keyword">new</span> CyclicBarrier(threadCount, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 当所有threadCount线程结束时，执行到这里。</span></span><br><span class="line">                System.out.println(<span class="string">"All Thread has done."</span> + cycleCount.count);</span><br><span class="line">                cycleCount.count++;</span><br><span class="line">                <span class="keyword">if</span> (cycleCount.count == <span class="number">2</span>) &#123;</span><br><span class="line">                    exec.shutdownNow();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; threadCount; i++) &#123;</span><br><span class="line">            exec.execute(<span class="keyword">new</span> Horse(String.valueOf(i), barrier));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="DelayQueue">DelayQueue</h3><p><strong>DelayQueue是一个无界的BlockingQueue，用于放置实现了Delayed接口的对象，其中的对象只能在其到期时才能从队列中取走。队列是有序的，延迟时间最长的对象最先取出。如果没有任何延迟到期，那么就不会有任何头元素，并且poll()将会返回null（正因为这样，你不能将null放置到这种队列中）。可以使用多种获取方法：poll(取出并从队列删除，不等待), take(取出并从队列删除，如果队列中还没有则等待), peek(取出但不从队列删除，不等待，可能会返回未过期的)</strong>，详细区别见JavaDoc。</p>
<p><strong>DelayQueue适合的场景包括</strong>：</p>
<p>关闭空闲连接。服务器中，有很多客户端的连接，空闲一段时间之后需要关闭之。<br>缓存。缓存中的对象，超过了空闲时间，需要从缓存中移出。<br>任务超时处理。在网络协议滑动窗口请求应答式交互时，处理超时未响应的请求。</p>
<h3 id="PriorityBlockingQueue">PriorityBlockingQueue</h3><p><strong>这是一个很基础的优先级队列，具有可阻塞的读取操作。放入该队列的对象实现Comparable接口就可以轻松实现优先级调度了，优先级越小则优先级越高</strong>。代码示例：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PriorityBlockingQueue&lt;Runnable&gt; <span class="built_in">queue</span> = </span><br><span class="line">        <span class="keyword">new</span> PriorityBlockingQueue&lt;Runnable&gt;();</span><br><span class="line">ExecutorService exec = Executors.newCachedThreadPool();</span><br><span class="line">exec.execute(<span class="keyword">new</span> Producer(<span class="built_in">queue</span>, exec));</span><br><span class="line">exec.execute(<span class="keyword">new</span> Consumer(<span class="built_in">queue</span>));</span><br></pre></td></tr></table></figure>
<h3 id="ScheduledExecutor">ScheduledExecutor</h3><p>通过使用ScheduledExecutor.schedule()（运行一次任务）或者scheduleAtFixedRate()（每隔规则的时间重复执行任务），你可以将Runnable对象设置为在将来的某个时刻执行。代码示例：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SheduledThreadDemo</span> &#123;</span><br><span class="line">    ScheduledThreadPoolExecutor scheduler = <span class="keyword">new</span> ScheduledThreadPoolExecutor(<span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">repeat</span>(<span class="params">Runnable <span class="keyword">event</span>, <span class="keyword">long</span> initialDelay, <span class="keyword">long</span> period</span>) </span>&#123;</span><br><span class="line">        scheduler.scheduleAtFixedRate(<span class="keyword">event</span>, initialDelay, period, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span>(<span class="params">Runnable <span class="keyword">event</span>, <span class="keyword">long</span> delay</span>) </span>&#123;</span><br><span class="line">        scheduler.schedule(<span class="keyword">event</span>, delay, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过java.util.Collections实用工具synchronizedList()创建的List的所有方法都是synchronized的。</p>
<h3 id="Semaphore">Semaphore</h3><p>普通的锁（concurrent.locks或synchronized锁）在任何时刻都只允许一个任务访问一项资源，而计数信号量允许n个任务同时访问这个资源。作为一个示例，Pool是一个对象池，管理者数量有限的对象，要使用对象可以先签出，用完后再签入。</p>
<p><strong>Semaphore 可以很轻松完成信号量控制，Semaphore可以控制某个资源可被同时访问的个数，通过 acquire() 获取一个许可，如果没有就等待，而 release() 释放一个许可</strong>。比如在Windows下可以设置共享文件的最大客户端访问个数。</p>
<p>Semaphore实现的功能就类似厕所有5个坑，假如有10个人要上厕所，那么同时只能有多少个人去上厕所呢？同时只能有5个人能够占用，当5个人中 的任何一个人让开后，其中等待的另外5个人中又有一个人可以占用了。另外等待的5个人中可以是随机获得优先机会，也可以是按照先来后到的顺序获得机会，这取决于构造Semaphore对象时传入的参数选项。单个信号量的Semaphore对象可以实现互斥锁的功能，并且可以是由一个线程获得了“锁”，再由另一个线程释放“锁”，这可应用于死锁恢复的一些场合。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Pool&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> <span class="keyword">size</span>;</span><br><span class="line">    <span class="keyword">private</span> List&lt;T&gt; items = <span class="keyword">new</span> ArrayList&lt;T&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span>[] checkedOut; <span class="comment">//跟踪被签出的对象</span></span><br><span class="line">    <span class="keyword">private</span> Semaphore available;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> Pool(<span class="keyword">Class</span>&lt;T&gt; classObject, <span class="keyword">int</span> <span class="keyword">size</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.<span class="keyword">size</span> = <span class="keyword">size</span>;</span><br><span class="line">        checkedOut = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="keyword">size</span>];</span><br><span class="line">        available = <span class="keyword">new</span> Semaphore(<span class="keyword">size</span>, <span class="keyword">true</span>); <span class="comment">//size个许可，先进先出:true</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Assums a default constructor</span></span><br><span class="line">                items.add(classObject.newInstance());</span><br><span class="line">            &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> T checkOut() <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">        available.acquire(); <span class="comment">//从Semaphore获取一个许可，如果没有将阻塞</span></span><br><span class="line">        <span class="keyword">return</span> getItem();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> checkIn(T x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (releaseItem(x))</span><br><span class="line">            <span class="comment">//释放一个permit，返回到Semaphore， 可用许可加1</span></span><br><span class="line">            available.release();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> T getItem() &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; <span class="keyword">size</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (! checkedOut[i]) &#123;</span><br><span class="line">                checkedOut[i] = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">return</span> items.get(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> releaseItem(T item) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = items.indexOf(item);</span><br><span class="line">        <span class="keyword">if</span> (index == -<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (checkedOut[index]) &#123;</span><br><span class="line">            checkedOut[index] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Exchanger">Exchanger</h3><p>Exchanger用于实现两个人之间的数据交换，每个人在完成一定的事物后想与对方交换数据，第一个先拿出数据的人将一直等待第二个人拿着数据到来时，才能彼此交换数据。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public class ExchangerTest &#123;</span><br><span class="line">    public static void main<span class="params">(String[] args)</span> &#123;</span><br><span class="line">        ExecutorService service = Executors.newCachedThreadPool<span class="params">()</span>;</span><br><span class="line">        final Exchanger&lt;String&gt; exchanger = new Exchanger&lt;String&gt;<span class="params">()</span>;</span><br><span class="line">        service.execute<span class="params">(new Runnable<span class="params">()</span> &#123;</span><br><span class="line">            public void run<span class="params">()</span> &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    String data1 = <span class="string">"money"</span>;</span><br><span class="line">                    System.out.println<span class="params">(<span class="string">"线程"</span></span><br><span class="line">                            + Thread.currentThread<span class="params">()</span>.getName<span class="params">()</span> </span><br><span class="line">                            + <span class="string">"正在把数据"</span> + data1 + <span class="string">"换出去"</span>)</span>;</span><br><span class="line">                    Thread.sleep<span class="params">(<span class="params">(long)</span> <span class="params">(Math.random<span class="params">()</span> * <span class="number">10000</span>)</span>)</span>;</span><br><span class="line">                    String data2 = <span class="params">(String)</span> exchanger.exchange<span class="params">(data1)</span>;</span><br><span class="line">                    System.out.println<span class="params">(<span class="string">"线程"</span></span><br><span class="line">                            + Thread.currentThread<span class="params">()</span>.getName<span class="params">()</span> </span><br><span class="line">                            + <span class="string">"换回数据为"</span> + data2)</span>;</span><br><span class="line">                &#125; catch <span class="params">(InterruptedException e)</span> &#123;</span><br><span class="line">                    // TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace<span class="params">()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span>;</span><br><span class="line">        service.execute<span class="params">(new Runnable<span class="params">()</span> &#123;</span><br><span class="line">            public void run<span class="params">()</span> &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    String data1 = <span class="string">"drug"</span>;</span><br><span class="line">                    System.out.println<span class="params">(<span class="string">"线程"</span></span><br><span class="line">                            + Thread.currentThread<span class="params">()</span>.getName<span class="params">()</span> + <span class="string">"正在把数据"</span></span><br><span class="line">                            + data1 + <span class="string">"换出去"</span>)</span>;</span><br><span class="line">                    Thread.sleep<span class="params">(<span class="params">(long)</span> <span class="params">(Math.random<span class="params">()</span> * <span class="number">10000</span>)</span>)</span>;</span><br><span class="line">                    String data2 = <span class="params">(String)</span> exchanger.exchange<span class="params">(data1)</span>;</span><br><span class="line">                    System.out.println<span class="params">(<span class="string">"线程"</span></span><br><span class="line">                            + Thread.currentThread<span class="params">()</span>.getName<span class="params">()</span> + <span class="string">"换回数据为"</span></span><br><span class="line">                            + data2)</span>;</span><br><span class="line">                &#125; catch <span class="params">(InterruptedException e)</span> &#123;</span><br><span class="line">                    // TODO Auto-generated catch block</span><br><span class="line">                    e.printStackTrace<span class="params">()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="性能调优">性能调优</h2><h3 id="比较各种互斥技术">比较各种互斥技术</h3><p>从书中的测试中，可以看出性能从好到差：Atomic -&gt; Lock -&gt; BaseLine -&gt; synchronized。但是这个结果跟特定的机器平台还有关系。</p>
<p>安全的做法：以传统的互斥方式入手，只有性能方面的需求能够明确指示时，再替换为Atomic.</p>
<h3 id="免锁容器">免锁容器</h3><p>早期像Vector和Hashtable容器具有许多synchronized方法。用于非多线程的应用程序中时，便会导致不可接受的开销。</p>
<p>Java1.2中，新的容器类库是不同步的，并且Collections类提供了各种static的同步的装饰方法，从而来同步不同类型的容器。</p>
<p>Java SE5添加的新容器，通过更灵活的技术来消除加锁，从而提高性能。</p>
<p>这些免锁容器背后的通用策略是：<strong>对容器的修改可以与读取操作同时发生，只要读取者只能看到完成修改的结果即可。修改是在容器数据结构的某个部分的一个单独的副本（有时是整个数据结构的副本）上执行的，并且这个副本在修改过程中是不可视的。只有当修改完成时，被修改的结构才会自动地与主数据结构进行交换，之后读取者就可以看到这个修改了</strong>。</p>
<ul>
<li><p>在CopyOnWriteArrayList中，写入将导致创建整个底层数组的副本，而源数组将保留在原地，使得复制的数组在被修改时，读取操作可以安全地执行。当修改完成时，一个原子性的操作将把新的数组换入，使得新的读取操作可以看到这个新的修改。CopyOnWriteArrayList的好处之一是当多个迭代器同时遍历和修改这个列表时，不会抛出ConcurrentModificationException</p>
</li>
<li><p>乐观锁：CopyOnWriteArrayList可以替代Collections.synchronizedList(new ArrayList());synchronized ArrayList无论读取者和写入者的数量是多少，都具有大致相同的性能—读取者与其他读取者竞争锁的方式与写入者相同。但是，CopyOnWriteArrayList在没有写入者时，速度会快许多。</p>
</li>
<li><p>比较各种Map实现：ConcurrentHashMap 可以替代Collections.synchronizedMap(new HashMap());</p>
</li>
</ul>
<h3 id="乐观加锁">乐观加锁</h3><p>Atomic对象将执行像decrementAndGet()这样的原子性操作，但是某些Atomic类还允许你执行所谓的“乐观加锁”。这意味着当你执行某项计算时，实际上没有使用互斥，但是在这项计算完成，并且你准备更新这个Atomic对象时，你需要使用一个称为compareAndSet的方法。你将旧值和新值一起提交给这个方法，如果旧值与它在Atomic对象中发现的值不一致，那么这个操作就失败—这意味着某个其他的任务已经于此操作执行期间修改了这个对象。记住，我们在正常情况下将使用互斥来防止多个任务同时修改一个对象，但是这里我们是“乐观的“，因为我们保持数据为未锁定状态，并希望没有其他任务插入修改它。</p>
<h3 id="ReadWriteLock">ReadWriteLock</h3><p>ReadWriteLock对向数据结构相对不频繁地写入，但是有多个任务要经常读取这个数据结构的这类情况进行了优化。ReadWriteLock使得你可以同时有多个读取者，只要它们都不试图写入即可。如果写锁已经被其他任务持有，那么任何读取者都不能访问，直至这个写锁被释放为止。</p>
<p>只有当你在搜索可以提高性能的方法时，才应该想到用它。你的程序的第一个草案应该使用更直观的同步，并且只有在必需时再引入ReadWriteLock</p>
<h2 id="活动对象">活动对象</h2><p>java的线程机制看起来非常复杂，每个细节都很重要，你有责任处理所有事物，并且没有任何编译器检查形式的安全防护措施。这种机制来自过程型编程世界。可能还存在着另一种不同的并发模型，它更加适合面向对象编程。</p>
<p>有一种可替换的方式称为活动对象或行动者。之所以称这些对象是”活动的“，是因为每个对象都维护着它自己的工作线程和消息队列，并且所有对这种对象的请求都将进入队列排队，任何时刻都只能运行其中的一个。因此，有了活动对象，我们就可以串行化消息而不是方法，这意味着不再需要防备一个任务在其循环的中间被中断这种问题了。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> ActiveObjectDemo &#123;</span><br><span class="line">  <span class="keyword">private</span> ExecutorService ex =</span><br><span class="line">    Executors.newSingleThreadExecutor();</span><br><span class="line">  <span class="keyword">private</span> Random rand = <span class="keyword">new</span> Random(<span class="number">47</span>);</span><br><span class="line">  <span class="comment">// Insert a random delay to produce the effect</span></span><br><span class="line">  <span class="comment">// of a calculation time:</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">void</span> pause(<span class="keyword">int</span> factor) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      TimeUnit.MILLISECONDS.sleep(</span><br><span class="line">        <span class="number">100</span> + rand.nextInt(factor));</span><br><span class="line">    &#125; <span class="keyword">catch</span>(InterruptedException e) &#123;</span><br><span class="line">      <span class="keyword">print</span>(<span class="string">"sleep() interrupted"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Future&lt;Integer&gt;</span><br><span class="line">  calculateInt(<span class="keyword">final</span> <span class="keyword">int</span> x, <span class="keyword">final</span> <span class="keyword">int</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> ex.submit(<span class="keyword">new</span> Callable&lt;Integer&gt;() &#123;</span><br><span class="line">      <span class="keyword">public</span> Integer <span class="keyword">call</span>() &#123;</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"starting "</span> + x + <span class="string">" + "</span> + y);</span><br><span class="line">        pause(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> Future&lt;<span class="keyword">Float</span>&gt;</span><br><span class="line">  calculateFloat(<span class="keyword">final</span> <span class="keyword">float</span> x, <span class="keyword">final</span> <span class="keyword">float</span> y) &#123;</span><br><span class="line">    <span class="keyword">return</span> ex.submit(<span class="keyword">new</span> Callable&lt;<span class="keyword">Float</span>&gt;() &#123;</span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">Float</span> <span class="keyword">call</span>() &#123;</span><br><span class="line">        <span class="keyword">print</span>(<span class="string">"starting "</span> + x + <span class="string">" + "</span> + y);</span><br><span class="line">        pause(<span class="number">2000</span>);</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">void</span> shutdown() &#123; ex.shutdown(); &#125;</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) &#123;</span><br><span class="line">    ActiveObjectDemo d1 = <span class="keyword">new</span> ActiveObjectDemo();</span><br><span class="line">    <span class="comment">// Prevents ConcurrentModificationException:</span></span><br><span class="line">    List&lt;Future&lt;?&gt;&gt; results =</span><br><span class="line">      <span class="keyword">new</span> CopyOnWriteArrayList&lt;Future&lt;?&gt;&gt;();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">float</span> f = <span class="number">0.0</span>f; f &lt; <span class="number">1.0</span>f; f += <span class="number">0.2</span>f)</span><br><span class="line">      results.add(d1.calculateFloat(f, f));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)</span><br><span class="line">      results.add(d1.calculateInt(i, i));</span><br><span class="line">    <span class="keyword">print</span>(<span class="string">"All asynch calls made"</span>);</span><br><span class="line">    <span class="keyword">while</span>(results.<span class="keyword">size</span>() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span>(Future&lt;?&gt; f : results)</span><br><span class="line">        <span class="keyword">if</span>(f.isDone()) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">print</span>(f.get());</span><br><span class="line">          &#125; <span class="keyword">catch</span>(Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">          &#125;</span><br><span class="line">          results.remove(f);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    d1.shutdown();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由对Executors.newSingleThreadExecutor()的调用产生的单线程执行器维护着它自己的无界阻塞队列，并且只有—个线程从该队列中取走任务并执行它们直至完成，我们需要在calculateInt()和caculateFloat()中做的就是用submit()提交个新的Callable对象，以响应对这些方法的调用，这样就可以把方法调用转变为消息，而submit()的方法体包含在匿名内部类的call()方法中。注意，每个活动对象方法的返回值都是一个具有泛型参数的Future，而这个泛型参数就是该方法中实际的返回类型。通过这种方式，方法调用几乎可以立即返回，调用者可以使用Future来发现何时任务完成，并收集实际的返回值，这样可以处理最复杂的情况，但是如果调用没有任何返回值，那么这个过程将被简化。</p>
<p>注意使用CopyOnWriteArrayList可以移除为了防止ConcurrentModificationException而复制List时的这种需求。</p>
<p>为了能够在不经意间就可以方止线程之间的耦合，任何传递给活动对象方法调用的参数都必须是只读的其他活动对象，即没有连接任何其他任务的对象（这一点很难强制保障，因为没有任何语言支持它。有了活动对象</p>
<ol>
<li>每个对象都可以拥有自己的工作器线程：些普通的类</li>
<li>每个对象都将维护对它自己的域的全部控制权（这比普通的类要更严苛一些，普通的类只是拥有防护它们的域的选择权）  </li>
<li>所有在活动对象之间的通信都将以在这些对象之间的消息形式发生 </li>
<li>活动对象之间的所有消息都要排队。</li>
</ol>
<p>这些结果很吸引人，由于从一个活动对象到另一个活动对象的消息只能被排队时的延迟所阻塞，并且因为这个延迟总是非常短且独立于任何其他对象，所以发送消息实际上不是不可阻塞的（最坏情况也只是很短的延迟）。由于一个适动只经由消息来通信，所以两个对象在竞争调用另一个对象上的方法时，是不会被阻塞的，而这意味着不会发生死锁。因为在活动对象中的工作器线程在任何时刻只执行一个消息，所以不存在任何资源竞争，而你也不必操心应该如何同步方法。</p>
<p>活动对象、行动者或代理的信息，C.A.R. Hoare的通信顺序进程理论（Theory of Communicating Sequential Processes, CSP）</p>
]]></content>
    <summary type="html">
    <![CDATA[thinking in java; java编程思想; 并发;]]>
    
    </summary>
    
      <category term="Thinking in Java" scheme="http://howiefh.github.io/tags/Thinking-in-Java/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[jQuery 插件使用记录]]></title>
    <link href="http://howiefh.github.io/2014/12/24/jQuery-plug-in/"/>
    <id>http://howiefh.github.io/2014/12/24/jQuery-plug-in/</id>
    <published>2014-12-24T07:20:47.000Z</published>
    <updated>2014-12-24T15:30:16.000Z</updated>
    <content type="html"><![CDATA[<p>记录几个自己了解到的jQuery插件: dragsort、Validform、bootstrap-datetimepicker、highcharts、jQuery File Upload、uploadify、Plupload、Dropzonejs、Web Uploader、zyFile。</p>
<a id="more"></a>
<h2 id="dragsort">dragsort</h2><h3 id="下载地址：http://dragsort-codeplex-com/">下载地址：<a href="http://dragsort.codeplex.com/" target="_blank" rel="external">http://dragsort.codeplex.com/</a></h3><h3 id="使用方法">使用方法</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"ul"</span>).dragsort(&#123;</span><br><span class="line">    dragSelector: <span class="string">"li"</span>,</span><br><span class="line">    dragEnd: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; &#125;,</span><br><span class="line">    dragBetween: <span class="literal">false</span>,</span><br><span class="line">    placeHolderTemplate: <span class="string">"&lt;li&gt;&lt;/li&gt;"</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>jquery list dragsort列表拖动插件参数说明</p>
<ul>
<li>dragSelector<br>  CSS选择器内的元素的列表项的拖动手柄。默认值是“li”。</li>
<li>dragSelectorExclude<br>  CSS选择器的元素内的dragSelector不会触发dragsort的。默认值是“input, textarea, a[href]”。</li>
<li>dragEnd<br>  拖动结束后将被调用的回调函数.</li>
<li>dragBetween<br>  设置为“true”，如果你要启用多组列表之间拖动选定的列表。 默认值是false。</li>
<li>placeHolderTemplate<br>  拖动列表的HTML部分。默认值是<code>&lt;li&gt;&lt;/li&gt;</code>.</li>
<li>scrollContainer<br>  CSS选择器的元素，作为滚动容器，例如溢出的div设置为自动。 默认值是“窗口“.</li>
<li>scrollSpeed<br>  一个数字，它代表了速度，页面拖动某一项时，将滚动容器外，较高使用价值的是速度和较低的值是较慢的。 如果设置为“0”以禁用滚动。默认值是“5”.</li>
</ul>
<h3 id="一个table示例">一个table示例</h3><p>下载的压缩包中提供了ul的示例，下面是一个table的示例</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">table</span>  <span class="attribute">id</span>=<span class="value">'tableid'</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">td</span>&gt;</span>999999<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">td</span>&gt;</span>923123<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">td</span>&gt;</span>123123<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">td</span>&gt;</span>123123<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">    $(<span class="string">"#tableid"</span>).dragsort(&#123;</span><br><span class="line">    dragSelector : <span class="string">"tr"</span>,  <span class="comment">//可以不用设置，他会根据$("#tableid")的类型来决定是tr还是li</span></span><br><span class="line">    dragEnd : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log($(<span class="keyword">this</span>));  <span class="comment">//拖动完成的回调函数，$(this)当前拖动对象</span></span><br><span class="line">    &#125;,</span><br><span class="line">    scrollSpeed:<span class="number">0</span>,  <span class="comment">//默认为5，数值越大拖动的速度越快，为0则拖动时页面不会滚动</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Validform">Validform</h2><p>Validform：一行代码搞定整站的表单验证！</p>
<h3 id="下载地址：http://validform-rjboy-cn/">下载地址：<a href="http://validform.rjboy.cn/" target="_blank" rel="external">http://validform.rjboy.cn/</a></h3><h3 id="使用方法-1">使用方法</h3><p>Validform是国人写的插件，<a href="http://validform.rjboy.cn/document.html" target="_blank" rel="external">中文文档</a>很详细。下面介绍一下基本使用方法。</p>
<ol>
<li><p>引入css</p>
<p> 请查看下载文件中的style.css，把里面Validform必须部分复制到你的css中（文件里这个注释 “/<em>==========以下部分是Validform必须的===========</em>/“ 之后的部分是必须的）。之前发现有部分网友把整个style.css都引用在了页面里，然后发现样式冲突了。</p>
</li>
<li><p>引入js （jquery 1.4.3 以上版本都可以，官网写的是1.4.3以上版本，但是需要调用外部插件datepicker的话，最新的jQuery貌似不行，最好使用它使用的1.6.2版本的）</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"http://validform.rjboy.cn/wp-content/themes/validform/js/jquery-1.6.2.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"http://validform.rjboy.cn/Validform/v5.1/Validform_v5.1_min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>给需要验证的表单元素绑定附加属性</p>
 <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form <span class="variable">class=</span><span class="string">"demoform"</span>&gt;</span><br><span class="line">&lt;input <span class="variable">type=</span><span class="string">"text"</span> <span class="variable">value=</span><span class="string">""</span> <span class="variable">name=</span><span class="string">"name"</span> <span class="variable">datatype=</span><span class="string">"s5-16"</span> <span class="variable">errormsg=</span><span class="string">"昵称至少5个字符,最多16个字符！"</span> /&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>初始化，就这么简单</p>
 <figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$<span class="params">(<span class="string">".demoform"</span>)</span>.Validform<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="绑定附加属性">绑定附加属性</h3><ul>
<li>datatype<br>  内置基本的datatype类型有： <code>* | *6-16 | n | n6-16 | s | s6-18 | p | m | e | url</code>。最新版本可以直接绑定正则：如可用这样写<code>datatype=&quot;/\w{3,6}/i&quot;</code>，并且网站提供了一个datatype扩展文件<a href="http://validform.rjboy.cn/Validform/Validform_Datatype.js" target="_blank" rel="external">Validform_Datatype</a>。</li>
<li>nullmsg<br>  当表单元素值为空时的提示信息，不绑定，默认提示”请填入信息！”。5.3+会自动查找class为Validform_label下的文字作为提示文字</li>
<li>sucmsg 5.3+<br>  当表单元素通过验证时的提示信息，不绑定，默认提示”通过信息验证！”。</li>
<li>errormsg<br>  输入内容不能通过验证时的提示信息，默认提示”请输入正确信息！”。</li>
<li>ignore<br>  绑定了ignore=”ignore”的表单元素，在有输入时，会验证所填数据是否符合datatype所指定数据类型，没有填写内容时则会忽略对它的验证；</li>
<li>recheck<br>  表单里面经常需要检查两次密码输入是否一致，recheck就是用来指定需要比较的另外一个表单元素。</li>
<li>ajaxurl<br>  指定ajax实时验证的后台文件的地址。Ajax中会POST过来变量param和name。param是文本框的值，name是文本框的name属性。  <figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var demo=$<span class="params">(<span class="string">".formsub"</span>)</span>.Validform<span class="params">()</span></span><br><span class="line">demo.config<span class="params">(&#123;</span><br><span class="line">    ajaxurl:&#123;</span><br><span class="line">        //可以传入$.ajax<span class="params">()</span>能使用的，除dataType外的所有参数;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span></span><br></pre></td></tr></table></figure>
  后台返回json格式的数据:<code>{status:&quot;y&quot;,info:&quot;tip&quot;}</code>，如果status是y则提示成功，n则提示失败。</li>
<li>plugin<br>  指定需要使用的插件。<br>  5.3版开始，对于日期、swfupload和密码强度检测这三个插件，绑定了plugin属性即可以初始化对应的插件，可以不用在validform初始化时传入空的usePlugin了。</li>
</ul>
<h3 id="参数说明">参数说明</h3><ul>
<li>tiptype<br>  可用的值有：1、2、3、4和function函数，默认tiptype为1。 3、4是5.2.1版本新增<br>  1=&gt; 自定义弹出框提示；<br>  2=&gt; 侧边提示(会在当前元素的父级的next对象的子级查找显示提示信息的对象，表单以ajax提交时会弹出自定义提示框显示表单提交状态)；<br>  3=&gt; 侧边提示(会在当前元素的siblings对象中查找显示提示信息的对象，表单以ajax提交时会弹出自定义提示框显示表单提交状态)；<br>  4=&gt; 侧边提示(会在当前元素的父级的next对象下查找显示提示信息的对象，表单以ajax提交时不显示表单的提交状态)；  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    $(<span class="string">".registerform"</span>).Validform(&#123;</span><br><span class="line">        tiptype:<span class="function"><span class="keyword">function</span>(<span class="params">msg,o,cssctl</span>)</span>&#123;</span><br><span class="line">            <span class="comment">//msg：提示信息;</span></span><br><span class="line">            <span class="comment">//o:&#123;obj:*,type:*,curform:*&#125;, obj指向的是当前验证的表单元素（或表单对象），type指示提示的状态，值为1、2、3、4， 1：正在检测/提交数据，2：通过验证，3：验证失败，4：提示ignore状态, curform为当前form对象;</span></span><br><span class="line">            <span class="comment">//cssctl:内置的提示信息样式控制函数，该函数需传入两个参数：显示提示信息的对象 和 当前提示的状态（既形参o中的type）;</span></span><br><span class="line">            <span class="keyword">if</span>(!o.obj.is(<span class="string">"form"</span>))&#123;<span class="comment">//验证表单元素时o.obj为该表单元素，全部验证通过提交表单时o.obj为该表单对象;</span></span><br><span class="line">                <span class="keyword">var</span> objtip=o.obj.siblings(<span class="string">".Validform_checktip"</span>);</span><br><span class="line">                cssctl(objtip,o.type);</span><br><span class="line">                objtip.text(msg);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">var</span> objtip=o.obj.find(<span class="string">"#msgdemo"</span>);</span><br><span class="line">                cssctl(objtip,o.type);</span><br><span class="line">                objtip.text(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        ajaxPost:<span class="literal">true</span></span><br><span class="line">    &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li>
<li>ajaxPost<br>  可用值： true | false。<br>  默认为false，使用ajax方式提交表单数据，将会把数据POST到config方法或表单action属性里设定的地址；</li>
<li>datatype<br>  传入自定义datatype类型，可以是正则，也可以是函数。  <figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">datatyp:</span>&#123;</span><br><span class="line">    <span class="string">"zh2-4"</span><span class="symbol">:/^</span>[\u4E0<span class="number">0</span>-\u9FA5\uf90<span class="number">0</span>-\ufa2d]&#123;<span class="number">2</span>,<span class="number">4</span>&#125;<span class="variable">$/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>callback<br>  在使用ajax提交表单数据时，数据提交后的回调函数。返回数据data是Json对象：{“info”:”demo info”,”status”:”y”}。后台可以返回额外的数据供处理</li>
</ul>
<h3 id="公用对象">公用对象</h3><p>$.Showmsg(msg)<br>调用Validform自定义的弹出框。<br>参数msg是要显示的提示文字。<br>如$.Showmsg(“这是提示文字”); //如果不传入信息则不会有弹出框出现，像$.Showmsg()这样是不会弹出提示框的。</p>
<h2 id="bootstrap-datetimepicker">bootstrap-datetimepicker</h2><p>用Google搜索可以搜到三个不同的同名插件</p>
<ol>
<li><a href="http://eonasdan.github.io/bootstrap-datetimepicker/" target="_blank" rel="external">http://eonasdan.github.io/bootstrap-datetimepicker/</a></li>
<li><a href="http://www.bootcss.com/p/bootstrap-datetimepicker/" target="_blank" rel="external">http://www.bootcss.com/p/bootstrap-datetimepicker/</a> bootstrap中文网有详细介绍</li>
<li><a href="http://tarruda.github.io/bootstrap-datetimepicker/" target="_blank" rel="external">http://tarruda.github.io/bootstrap-datetimepicker/</a> 作者是neovim项目的发起者，这个项目fork自eonasdan，已经很久没更新了</li>
</ol>
<p>简单介绍一下第一个，首先需要引入一下这些文件</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> <span class="attribute">href</span>=<span class="value">"css/bootstrap.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">link</span> <span class="attribute">rel</span>=<span class="value">"stylesheet"</span> <span class="attribute">type</span>=<span class="value">"text/css"</span> <span class="attribute">href</span>=<span class="value">"css/bootstrap-datetimepicker.min.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"js/jquery-1.8.2.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"js/bootstrap.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"js/moment.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span> <span class="attribute">src</span>=<span class="value">"js/bootstrap-datetimepicker.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 需要给input添加一个属性  data-date-format 设置日期的格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">class</span>=<span class="value">"form-control"</span> <span class="attribute">id</span>=<span class="value">"datetimepicker2"</span> <span class="attribute">data-date-format</span>=<span class="value">"YYYY-MM-DD HH:mm:ss"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="javascript"></span><br><span class="line">$(<span class="string">'input[data-date-format]'</span>).datetimepicker(&#123;</span><br><span class="line">	useSeconds: <span class="literal">true</span>     <span class="comment">//设置时间时可以设置秒</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="highcharts">highcharts</h2><p>功能强大、开源、美观、图表丰富、兼容绝大多数浏览器的纯js图表库</p>
<h3 id="下载地址:_http://code-highcharts-com/">下载地址: <a href="http://code.highcharts.com/" target="_blank" rel="external">http://code.highcharts.com/</a></h3><h3 id="中文网:_http://www-hcharts-cn/">中文网: <a href="http://www.hcharts.cn/" target="_blank" rel="external">http://www.hcharts.cn/</a></h3><h2 id="上传文件">上传文件</h2><p>这类组件比较多，下面列出我搜到的几个还不错的。</p>
<h3 id="jQuery_File_Upload"><a href="https://github.com/blueimp/jQuery-File-Upload" target="_blank" rel="external">jQuery File Upload</a></h3><p>jQuery File Upload 是一个Jquery图片上传组件，支持多文件上传、取消、删除，上传前缩略图预览、列表显示图片大小，支持上传进度条显示；支持各种动态语言开发的服务器端。<br>jQuery File Upload有多个文件选择，拖放上传控件拖放支持，进度条，验证和预览图像，音频和视频 。<br>支持跨域，分块和可恢复的文件上传和客户端图像大小调整。适用于任何服务器端平台（PHP, Python, Ruby on Rails, Java, Node.js, Go etc.） ，支持标准的HTML表单文件上传。</p>
<p>两篇可以参考的博客<br><a href="http://blog.csdn.net/huangcongjie/article/details/38793909" target="_blank" rel="external">jQuery File Upload 与SpringMVC结合</a><br><a href="http://www.yihaomen.com/article/java/416.htm" target="_blank" rel="external">最适合中国国情的jquery file upload 批量上传改版插件,结合spring mvc</a></p>
<h3 id="Uploadify"><a href="http://www.uploadify.com/" target="_blank" rel="external">Uploadify</a></h3><p>1、高度地定义化，参数、方法和事件丰富<br>2、支持Flash和html两种版本<br>3、强大的社区支持<br>4、支持多文件上传和进度显示</p>
<h3 id="Plupload"><a href="http://www.plupload.com/" target="_blank" rel="external">Plupload</a></h3><p>Plupload这个JavaScript控件可以让你选择Adobe Flash、Google Gears、HTML5、Microsoft Silverlight、Yahoo BrowserPlus或正常表单Form等多种方法进行文件上传。Plupload还提供其它功能包括：上传进度提醒、图片缩小、多文件上传，拖拽文件到上传控件，文件类型过滤和Chunked上传等。这些功能在不同的上传方式中支持情况会受到限制。</p>
<h3 id="DropzoneJS"><a href="https://github.com/enyo/dropzone" target="_blank" rel="external">DropzoneJS</a></h3><p>特点是Dropzone 不依赖其它框架（比如jQuery)。提供 AJAX 异步上传功能。</p>
<h3 id="Web_Uploader"><a href="http://fex.baidu.com/webuploader/" target="_blank" rel="external">Web Uploader</a></h3><p>WebUploader是由Baidu WebFE(FEX)团队开发的一个简单的以HTML5为主，FLASH为辅的现代文件上传组件。在现代的浏览器里面能充分发挥HTML5的优势，同时又不摒弃主流IE浏览器，沿用原来的FLASH运行时，兼容IE6+，iOS 6+, android 4+。两套运行时，同样的调用方式，可供用户任意选用。<br>采用大文件分片并发上传，极大的提高了文件上传效率。</p>
<h3 id="zyFile"><a href="http://www.czlqibu.com/show.html?id=190" target="_blank" rel="external">zyFile</a></h3><p>zyFile特点是简单，中文注释挺全，可以修改一下满足自己的需求。</p>
]]></content>
    <summary type="html">
    <![CDATA[dragsort; Validform; bootstrap-datetimepicker; highcharts; jQuery File Upload; uploadify; Plupload; Dropzonejs; Web Uploader; zyFile;]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://howiefh.github.io/tags/JavaScript/"/>
    
      <category term="jQuery" scheme="http://howiefh.github.io/tags/jQuery/"/>
    
      <category term="JavaScript" scheme="http://howiefh.github.io/categories/JavaScript/"/>
    
      <category term="jQuery" scheme="http://howiefh.github.io/categories/JavaScript/jQuery/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaMail简介]]></title>
    <link href="http://howiefh.github.io/2014/12/24/javamail/"/>
    <id>http://howiefh.github.io/2014/12/24/javamail/</id>
    <published>2014-12-24T06:50:40.000Z</published>
    <updated>2014-12-24T07:54:56.000Z</updated>
    <content type="html"><![CDATA[<h1 id="JavaMail">JavaMail</h1><h2 id="简介">简介</h2><p>虽然<a href="http://www.oracle.com/technetwork/java/javamail/index-138643.html" target="_blank" rel="external">JavaMail</a>是Sun的API之一，但它目前还没有被加在标准的java开发工具包中（Java Development Kit），这就意味着你在使用前必须另外下载<a href="http://www.oracle.com/technetwork/java/javamail/index-138643.html" target="_blank" rel="external">JavaMail</a>文件。除此以外，你还需要有Sun的JavaBeans Activation Framework （<a href="http://www.oracle.com/technetwork/java/javasebusiness/downloads/java-archive-downloads-java-plat-419418.html#jaf-1.1.1-fcs-oth-JPR" target="_blank" rel="external">JAF</a>）。JavaBeans Activation Framework的运行很复杂，在这里简单的说就是<a href="http://www.oracle.com/technetwork/java/javamail/index-138643.html" target="_blank" rel="external">JavaMail</a>的运行必须得依赖于它的支持。JAF在Java6之后已经合并到JDK中，而JDK5之前需要另外下载JAF的类库。使用JavaMail，我们可以实现类似OutLook的软件。<br><a id="more"></a><br>压缩包的主要内容</p>
<ul>
<li>README.txt：整体介绍JavaMail，需要看一下</li>
<li>docs/javadocs：The JavaMail API javadocs</li>
<li>mail.jar：包括JavaMail API和提供所有服务，大部分用户只需要该jar包</li>
<li>lib/mailapi.jar：只有JavaMail API 不提供其他服务</li>
<li>lib/imap.jar：The IMAP service provider</li>
<li>lib/smtp.jar：The SMTP service provider</li>
<li>lib/pop3.jar：The POP3 service provider</li>
<li>lib/dsn.jar：multipart/report DSN message support</li>
<li>lib/imap.jar：Google IMAP provider</li>
<li>demo：demo示例，简单了解，有需要再看</li>
</ul>
<p>JavaMail包含两部分内容，一部分是JavaMail API，定义了一组平台无关、独立于通讯协议的邮件程序框架，该部分称为应用级接口，也就是供我们调用的部分，另一部分是service provider，该部分使用特定的协议语言来实现第一部分定义的抽象类和接口，这些协议包括：SMTP、NNTP、POP3、IMAP，如果让JavaMail与邮件服务器通信，就需要相应的协议支持，该部分称为服务提供者接口，也就是JavaMail自身需要的协议支持。大多数情况下只需要使用mail.jar就可以了。</p>
<h2 id="示例">示例</h2><p>一个发送文本的简单示例</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">Properties props = new Properties<span class="params">()</span>;</span><br><span class="line"><span class="comment">// 开启debug调试</span></span><br><span class="line">props.setProperty<span class="params">(<span class="string">"mail.debug"</span>, <span class="string">"true"</span>)</span>;</span><br><span class="line"><span class="comment">// 发送服务器需要身份验证</span></span><br><span class="line">props.setProperty<span class="params">(<span class="string">"mail.smtp.auth"</span>, <span class="string">"true"</span>)</span>;</span><br><span class="line"><span class="comment">// 设置邮件服务器主机名</span></span><br><span class="line">props.setProperty<span class="params">(<span class="string">"mail.smtp.host"</span>, <span class="string">"smtp.163.com"</span>)</span>;</span><br><span class="line"><span class="comment">// 设置邮件服务端口号</span></span><br><span class="line">props.setProperty<span class="params">(<span class="string">"mail.smtp.port"</span>, <span class="string">"25"</span>)</span>;</span><br><span class="line">Session session = Session.getInstance<span class="params">(props)</span>;</span><br><span class="line"></span><br><span class="line">try &#123;</span><br><span class="line">    <span class="comment">// 创建邮件对象  </span></span><br><span class="line">    Message msg = new MimeMessage<span class="params">(session)</span>;  </span><br><span class="line">    msg.setSubject<span class="params">(<span class="string">"JavaMail hello world example"</span>)</span>;</span><br><span class="line">    <span class="comment">// 设置邮件内容  </span></span><br><span class="line">    msg.setText<span class="params">(<span class="string">"Hello, world!\n"</span>)</span>;</span><br><span class="line">    <span class="comment">// 设置发件人  </span></span><br><span class="line">    msg.setFrom<span class="params">(new InternetAddress<span class="params">(<span class="string">"me@163.com"</span>)</span>)</span>;  </span><br><span class="line">    msg.setRecipients<span class="params">(Message.RecipientType.TO, <span class="string">"you@example.com"</span>)</span>;</span><br><span class="line">    msg.setSentDate<span class="params">(new Date<span class="params">()</span>)</span>;</span><br><span class="line">      </span><br><span class="line">    Transport transport = session.getTransport<span class="params">()</span>;  </span><br><span class="line">    <span class="comment">// 发送邮件  </span></span><br><span class="line">    Transport.send<span class="params">(msg, <span class="string">"me@163.com"</span>, <span class="string">"my-password"</span>)</span>;</span><br><span class="line">    <span class="comment">// 关闭连接  </span></span><br><span class="line">    transport.close<span class="params">()</span>;  </span><br><span class="line">&#125; catch <span class="params">(MessagingException mex)</span> &#123;</span><br><span class="line">    System.out.println<span class="params">(<span class="string">"send failed, exception: "</span> + mex)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的<code>me@163.com</code>、<code>my-password</code>、<code>you@example.com</code>要进行替换。<br>163新注册的邮箱不能发邮件，否则会抛出javax.mail.MessagingException</p>
<ul>
<li>java.util.Properties：属性对象</li>
<li>javax.mail.Session：上下文环境信息，如服务器的主机名、端口号、协议名称等</li>
<li>javax.mail.Message：邮件模型，发送邮件和接收邮件的媒介，封装了邮件的信息，如发件人、收件人、邮件标题、邮件内容等，一般用的是子类MimeMessage</li>
<li>javax.mail.Transport：连接邮件SMTP服务器，发送邮件</li>
<li>javax.mail.Address:地址类,这个地址类主要是表示邮件发送人和邮件接收人的地址，一般主要用的是InternetAddress。</li>
<li>javax.mail.Store：连接邮件POP3、IMAP服务器，收取邮件</li>
<li>javax.mail.Folder:文件夹类，该文件夹就是消息的具体所在文件夹，默认的邮件均在INBOX文件中。</li>
</ul>
<p>国内常见的几个免费邮件服务器名如下：</p>
<ul>
<li>网易免费邮箱：发送服务器：smtp.163.com     接收服务器：pop.163.com</li>
<li>新浪免费邮箱：发送服务器：smtp.sina.com.cn 接收服务器：pop3.sina.com.cn</li>
<li>搜狐邮箱：发送服务器：smtp.sohu.com        接收服务器：pop3.sohu.com</li>
</ul>
<p>参考<br><a href="http://blog.csdn.net/ghsau/article/details/17839983" title="Java Mail&#40;二&#41;：JavaMail介绍及发 一封简单邮件" target="_blank" rel="external">Java Mail(二)：JavaMail介绍及发送一封简单邮件</a><br><a href="http://blog.csdn.net/qiaqia609/article/details/11580589" title="javamail发送邮件的简单实例" target="_blank" rel="external">javamail发送邮件的简单实例</a><br><a href="http://computerdragon.blog.51cto.com/6235984/1197390" title="Java网络编程之JavaMail发送邮件和接受邮件" target="_blank" rel="external">Java网络编程之JavaMail发送邮件和接受邮件</a></p>
]]></content>
    <summary type="html">
    <![CDATA[javamail; 发送email; javamail 使用]]>
    
    </summary>
    
      <category term="Java" scheme="http://howiefh.github.io/tags/Java/"/>
    
      <category term="JavaMail" scheme="http://howiefh.github.io/tags/JavaMail/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java编程思想笔记七]]></title>
    <link href="http://howiefh.github.io/2014/11/06/thinking-in-java-note-7/"/>
    <id>http://howiefh.github.io/2014/11/06/thinking-in-java-note-7/</id>
    <published>2014-11-06T03:02:46.000Z</published>
    <updated>2015-04-05T09:02:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="枚举类型">枚举类型</h2><h3 id="基本enum特性">基本enum特性</h3><ul>
<li>Enum类是枚举的一个封装类，是所有枚举类型的超类，它是一个没有抽象方法的抽象类。Enum类实现了Comparable接口，所以它具有compareTo() 方法。同时它还实现了Serializable接口。</li>
<li>ordinal() : 获取枚举元素声明时的顺序，从0开始计算 </li>
<li>可以使用”==”来比较两个枚举实例相同与否，由于编译器自动实现了equals()和hashCode()两个方法</li>
<li>调用getDeclaringClass()方法，我们就能知道其所属的enum类</li>
<li>name() : 返回enum实例声明时的名字，与使用toString()方法效果相同</li>
<li>valueOf() : Enum中的static方法，根据给定的名字返回相应的enum实例，如果不存在给定实例的名字，将会抛出异常。</li>
<li>values() : 这个方法不是Enum提供的。</li>
</ul>
<a id="more"></a>
<h4 id="将静态导入用于enum">将静态导入用于enum</h4><p>如果使用静态导入不会使你的代码难以理解，那么使用静态导入还是有好处的。</p>
<p>在定义enum的同一个文件中，这种技巧无法使用；在默认包中定义enum，这种技巧也无法使用。</p>
<h3 id="向enum中添加新方法">向enum中添加新方法</h3><p><strong>基本上可以将enum看作一个常规的类，也就是说可以向enum添加方法，甚至可以由main方法</strong>。</p>
<p><strong>如果打算添加自己的方法，那么必须在enum实例的最后添加一个分号，而且必须先定义enum实例，实例之前不能有任何方法，否则报错</strong>。</p>
<p>因为我们只能在enum定义的内部使用其构造器创建enum实例，所以enum构造器声明为private并没有什么影响。</p>
<p>此外我们也可以覆盖enum的方法</p>
<h3 id="switch语句中的enum">switch语句中的enum</h3><p>一般情况下我们必须使用enum类型来修饰一个enum实例（Color.RED），但是case语句中却不必如此。</p>
<h3 id="values()的神秘之处">values()的神秘之处</h3><p>enum类都继承自Enum类，但是Enum类中并没有values()方法。<strong>values()是由编译器添加的static方法。编译器还添加了一个只有一个参数的valueOf()方法，和一个static初始化语句块</strong>。</p>
<p>如果将enum实例向上转型为Enum，那么values()方法就不可访问了。不过，在Class中有一个getEnumConstants()方法，所以即便Enum接口中没有values()方法，我们仍然可以通过Class对象取得所有enum实例。</p>
<h3 id="实现，而非继承">实现，而非继承</h3><p><strong>所有enum都继承了Enum类，所以enum不能再继承其他类，但是可以实现一个或多个接口</strong>。</p>
<h3 id="随机选取">随机选取</h3><p>工具类net.mindview.util.Enums可以实现enum实例的随机选择。</p>
<h3 id="使用接口组织枚举">使用接口组织枚举</h3><p>我们希望从enum继承子类，是由于有时我们希望扩展远enum中的元素，有时是因为我们希望使用子类将一个enum中的元素进行分组。</p>
<p><strong>在一个接口的内部，创建实现该接口的枚举，以此将元素进行分组，可以达到将枚举元素分类组织的目的</strong>。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Food</span> &#123;</span></span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Appetizer</span> <span class="keyword">implements</span> <span class="title">Food</span> &#123;</span></span><br><span class="line">    SALAD, SOUP, SPRING_ROLLS;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">MainCourse</span> <span class="keyword">implements</span> <span class="title">Food</span> &#123;</span></span><br><span class="line">    LASAGNE, BURRITO, PAD_THAI,</span><br><span class="line">    LENTILS, HUMMOUS, VINDALOO;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Dessert</span> <span class="keyword">implements</span> <span class="title">Food</span> &#123;</span></span><br><span class="line">    TIRAMISU, GELATO, BLACK_FOREST_CAKE,</span><br><span class="line">    FRUIT, CREME_CARAMEL;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="class"><span class="keyword">enum</span> <span class="title">Coffee</span> <span class="keyword">implements</span> <span class="title">Food</span> &#123;</span></span><br><span class="line">    BLACK_COFFEE, DECAF_COFFEE, ESPRESSO,</span><br><span class="line">    LATTE, CAPPUCCINO, TEA, HERB_TEA;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想创建一个“枚举的枚举”，那么可以创建一个新的enum，然后用其实例包装Food中的每一个enum类。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public enum Course &#123;</span><br><span class="line">  APPETIZER(Food.Appetizer.class),</span><br><span class="line">  MAINCOURSE(Food.MainCourse.class),</span><br><span class="line">  DESSERT(Food.Dessert.class),</span><br><span class="line">  COFFEE(Food.Coffee.class);</span><br><span class="line">  private Food<span class="comment">[]</span> values;</span><br><span class="line">  private Course(Class&lt;? extends Food&gt; <span class="keyword">kind</span>) &#123;</span><br><span class="line">    values = <span class="keyword">kind</span>.getEnumConstants();</span><br><span class="line">  &#125;</span><br><span class="line">  public Food randomSelection() &#123;</span><br><span class="line">    return Enums.random(values);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一种管理枚举的方法</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">enum SecurityCategory &#123;</span><br><span class="line">  STOCK(Security.Stock.class), BOND(Security.Bond.class);</span><br><span class="line">  Security<span class="comment">[]</span> values;</span><br><span class="line">  SecurityCategory(Class&lt;? extends Security&gt; <span class="keyword">kind</span>) &#123;</span><br><span class="line">    values = <span class="keyword">kind</span>.getEnumConstants();</span><br><span class="line">  &#125;</span><br><span class="line">  interface Security &#123;</span><br><span class="line">    enum Stock implements Security &#123; SHORT, LONG, MARGIN &#125;</span><br><span class="line">    enum Bond implements Security &#123; MUNICIPAL, JUNK &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  public Security randomSelection() &#123;</span><br><span class="line">    return Enums.random(values);</span><br><span class="line">  &#125;</span><br><span class="line">  public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">    for(int i = 0; i &lt; 10; i++) &#123;</span><br><span class="line">      SecurityCategory category =</span><br><span class="line">        Enums.random(SecurityCategory.class);</span><br><span class="line">      System.out.println(category + <span class="string">": "</span> +</span><br><span class="line">        category.randomSelection());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用EnumSet替代标志">使用EnumSet替代标志</h3><p>EnumSet（可能）就是将一个long值作为比特向量，所以EnumSet非常快速高效。</p>
<p>allOf(Class<e> elementType) 创建一个包含指定元素类型的所有元素的 EnumSet。<br>clone() 返回set的副本<br>complementOf(EnumSet<e> s) 创建一个其元素类型与指定 EnumSet 相同的 EnumSet，最初包含指定 set 中所不包含的此类型的所有元素。<br>copyOf(Collection<e> c) 创建一个从指定 collection 初始化的枚举 set。<br>copyOf(EnumSet<e> s) 创建一个其元素类型与指定 EnumSet 相同的 EnumSet，最初包含相同的元素（如果有的话）。<br>noneOf(Class<e> elementType) 创建一个具有指定元素类型的空 EnumSet。<br>of() 创建一个最初包含指定元素的EnumSet。有很多个重载版本，接收1到5个参数的，以及可变参数的，表现出EnumSet对性能的注重。<br>range(E from, E to) 创建一个最初包含由两个指定端点所定义范围内的所有元素的EnumSet。 </e></e></e></e></e></p>
<h3 id="使用EnumMap">使用EnumMap</h3><p>EnumMap速度很快，只能讲enum的实例作为键来调用put()方法，其它操作和一般Map差不多。</p>
<p>需要在EnumMap的构造器中指定enum类型。</p>
<p>与EnumSet一样，enum实例定义时的次序决定了其在EnumMap中的顺序。</p>
<p>与常量相关的方法相比，EnumMap有一个优点，那EnumMap允许程序员改变值对象，而常量相关的方法在编译期就固定了。</p>
<h3 id="常量相关的方法">常量相关的方法</h3><p><strong>Java允许enum实例编写方法，从而为每个enum实例赋予各自不同的行为。你需要为enum定义一个或多个abstract方法，然后为每个enum实例实现该抽象方法</strong>。</p>
<p>通过相应的enum实例，我们可以调用其上的方法。这通常也称为表驱动的代码，注意它与命令模式的区别。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">enum</span> LikeClasses &#123;</span><br><span class="line">  WINKEN &#123; <span class="function"><span class="keyword">void</span> <span class="title">behavior</span><span class="params">()</span> </span>&#123; print(<span class="string">"Behavior1"</span>); &#125; &#125;,</span><br><span class="line">  BLINKEN &#123; <span class="function"><span class="keyword">void</span> <span class="title">behavior</span><span class="params">()</span> </span>&#123; print(<span class="string">"Behavior2"</span>); &#125; &#125;,</span><br><span class="line">  NOD &#123; <span class="function"><span class="keyword">void</span> <span class="title">behavior</span><span class="params">()</span> </span>&#123; print(<span class="string">"Behavior3"</span>); &#125; &#125;;</span><br><span class="line">  <span class="keyword">abstract</span> <span class="function"><span class="keyword">void</span> <span class="title">behavior</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>enum实例的这种特性，很像是子类的行为。enum元素都是static final的。</p>
<p>除了实现abstract方法外，也可以覆盖常量相关的方法。</p>
<p>使用enum可以实现职责链，状态机。</p>
<h3 id="多路分发">多路分发</h3><p>Java只支持单路分发。也就是说，如果要执行的操作包含了不止一个类型未知的对象时，那么Java的动态绑定机制只能处理其中一个类型。</p>
<p>例如，Number是各种数字的超类，a，b都是Number类对象，执行a.plus(b)时，java的动态绑定机制可以判断调用方法的对象a的确切类型，但是却不知道b的确切类型。</p>
<p><strong>解决问题的办法就是多路分发（在上例中只有两个分发，一般称之为两路分发）。如果想使用两路分发，那么就必须有两个方法调用：第一个方法调用决定第一个未知类型，第二个方法调用决定第二个未知的类型。例如在plus方法中再执行 b.plus(this)</strong></p>
<p>书中举了“石头、剪刀、布”的例子，使用enum、常量相关的方法、EnumMap、二维数组进行多路的分发。</p>
<h2 id="注解">注解</h2><blockquote>
<p>注解：注解把元数据与源代码文件结合起来，使得我们能够以由编译器来测试和验证格式，存储有关程序的额外信息。注解在实际的源代码级别保存所有的信息，而不是某种注释性文字。</p>
</blockquote>
<p>Java SE5内置了三种，定义在java.lang中的注解：</p>
<ol>
<li>@Override，表示当前的方法定义将覆盖超类中的方法。如果你不小心拼写错误，或者方法签名对不上被覆盖的方法，编译器就会发出错误提示。</li>
<li>@Deprecated，如果程序员使用了注解为它的元素，那么编译器会发出警告信息</li>
<li>@SuppressWarnings，关闭不当的编译器警告信息。在Java SE5之前的版本中，也可以使用该注解，不过会被忽略不起作用。</li>
</ol>
<p>每当你创建描述符性质的类或接口时，一旦其中包括了重复性的工作，那就可以考虑使用注解来简化与自动化该过程。</p>
<h3 id="基本语法">基本语法</h3><p>从语法角度看，注解的使用方式几乎和修饰符的使用一样。</p>
<h4 id="定义注解">定义注解</h4><p>包 java.lang.annotation 中包含所有定义自定义注解所需用到的原注解和接口。<strong>如接口 java.lang.annotation.Annotation 是所有注解继承的接口,并且是自动继承，不需要定义时指定，类似于所有类都自动继承Object</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> UseCase &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">id</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">description</span><span class="params">()</span> <span class="keyword">default</span> “no description”</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordUtils</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@UseCase</span>(id=<span class="number">47</span>, description=”Password must contain at least one numeric”)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validatePassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> password.matches(“\\w*\\d\\w*”);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>定义注解时会需要一些元注解，@Target定义注解应用的地方；@Retention定义注解应用的级别</strong>。</p>
<p>注解中，一般都会包含一些元素以表示某些值。当分析处理注解时，程序或工具可以利用这些值。注解的元素看起来就像接口的方法，唯一的区别是你可以为其指定默认值。没有元素的注解称为标记注解。</p>
<p>description元素有一个default值，如果在注解某个方法时没有给出description的值，则该注解的处理器就会使用此元素的默认值。</p>
<h4 id="元注解">元注解</h4><p>元注解专职负责注解其他的注解。Java只内置了三种标准注解以及四种元注解。元注解定义如下：</p>
<table>
<thead>
<tr>
<th>接口</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Target</td>
<td>定义注解应用的地方。包括：CONSTRUCTOR-构造器声明；FIELD-域声明；LOCAL_VARIABLE-局部变量声明；METHOD-方法声明；PACKAGE-包声明；PARAMETER-参数声明；TYPE-类、接口或enum声明</td>
</tr>
<tr>
<td>@Retention</td>
<td>定义注解应用的级别。包括：SOURCE-注解将被编译器丢弃；CLASS-注解在class文件中可用，但会被VM丢弃；RUNTIME-VM将在运行期也保留注解，因此可通过反射机制读取注解信息</td>
</tr>
<tr>
<td>@Documented</td>
<td>将此注解包含在JavaDoc中</td>
</tr>
<tr>
<td>@Inherited</td>
<td>允许子类继承父类中的注解</td>
</tr>
</tbody>
</table>
<h3 id="编写注解处理器">编写注解处理器</h3><p>使用注解的过程中，重要的部分是创建与使用注解处理器。Java SE5扩展了反射机制API，以帮助构造该类工具；同时，提供外部工具apt帮助解析带有注解的Java代码。<br><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> UseCaseTracker &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> trackUseCases(List&lt;Integer&gt; useCases, <span class="keyword">Class</span>&lt;?&gt; cl) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Method m : cl.getDeclaredMethods()) &#123;</span><br><span class="line">            UseCase uc = m.getAnnotation(UseCase.<span class="keyword">class</span>);</span><br><span class="line">            <span class="keyword">if</span> (uc != <span class="keyword">null</span>) &#123;</span><br><span class="line">                System.out.<span class="keyword">println</span>(“Found Use <span class="keyword">Case</span>: ” + uc.id() </span><br><span class="line">                + “ ” + uc.<span class="keyword">description</span>());</span><br><span class="line">                useCases.remove(<span class="keyword">new</span> Integer(uc.id()));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i : UseCases) &#123;</span><br><span class="line">            System.out.<span class="keyword">println</span>(“Warning: Missing use <span class="keyword">case</span>-” + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>反射方法getDeclaredMethods()与getAnnotation()均属于AnnotationElement接口，Class、Method、Field均实现了该接口。getAnnotation()方法返回指定类型的注解对象。使用反射获取到注解对象之后，类似使用调用方法的方式获取注解的值，如uc.id()等</strong>。</p>
<h4 id="注解元素">注解元素</h4><p><strong>注解元素可用基本类型包括：所有基本类型、String、Class、enum、Annotation以及所有前面这些类型的数组。不允许使用任何包装类型，注解可以嵌套</strong>。</p>
<p><strong>因为注解是由编译器计算而来的，因此，所有元素值必须是编译期常量</strong>。</p>
<p>如果元素值是一个数组，要将它的值用大括号括起来<code>@Test(array={&quot;a&quot;,&quot;b&quot;})</code>，如果只有一个值，也可以省去括号。</p>
<h4 id="默认值限制">默认值限制</h4><p><strong>注解元素不能有不确定的值，也就是说，元素必须要么具有默认值，要么使用注解时提供元素的值</strong>。<br><strong>不能以null作为其值。为了绕开这个约束，可以定义一些特殊的值，例如空字符串或负数，以表示某个元素不存在</strong>。</p>
<h4 id="生成外部文件">生成外部文件</h4><p>部分Framework需要提供额外信息如XML描述文件才能与源代码协同工作，此时同一个类拥有两个单独的信息源，这常导致代码同步问题。但是使用注解，则可将所有信息都保存在JavaBean源文件中。</p>
<p>@Target注解中指定的每一个ElementType就是一个约束，它告诉编译器，这个自定义的注解只能应用于该类型。程序员可以指定enum ElementType中的某个值，或者以逗号分隔的形式指定多个值。如果想要将注解应用于所有ElementType，那么可以省去@Target元注解，不过这并不常见。</p>
<p>注解嵌套：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> Constraints &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">primaryKey</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">allowNull</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Target</span>(ElementType.FIELD)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> SQLString &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;</span><br><span class="line">    <span class="function">String <span class="title">name</span><span class="params">()</span> <span class="keyword">default</span> “”</span>;</span><br><span class="line">    <span class="function">Constraints <span class="title">constraints</span><span class="params">()</span> <span class="keyword">default</span> @<span class="title">Constraints</span><span class="params">(unique=<span class="keyword">true</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SQLString中元素constraints的类型就是一个注解。</p>
<p>快捷方式：<br><strong>注解中定义了名为value的元素，且在应用该注解时，若该元素是唯一需赋值元素，则无需使用名-值对语法，只需在括号内给出value值即可</strong>。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">pubic</span> <span class="tag">class</span> <span class="tag">Member</span> &#123;</span><br><span class="line">    <span class="variable">@SQLString</span>(<span class="number">30</span>)</span><br><span class="line">    String firstName;</span><br><span class="line">    <span class="variable">@SQLString</span>(value = <span class="number">30</span>, constraints = <span class="variable">@Constraints</span>(primaryKey = true))</span><br><span class="line">    String handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中<code>@SQLString(30)</code>就是只提供了一个值。</p>
<p><strong>变通之道</strong><br>嵌套注解有时会使代码非常复杂，可以同时使用两个注解类型来注解一个域。</p>
<h4 id="注解不支持继承">注解不支持继承</h4><p><strong>由于注解没有继承机制，所以要获得近似多态的行为，使用getDeclaredAnnotations()是唯一的办法（Field类中提供该方法）</strong>。</p>
<h3 id="使用apt处理注解">使用apt处理注解</h3><blockquote>
<p>apt工具及其关联的API已被javac和标准注释处理API javax.annotation.processing 和 javax.lang.model取代。</p>
</blockquote>
<p>与Javac一样，apt被设计为操作Java源文件，而不是编译后的类；自定义的每个注解都需要自己的处理器，而apt工具能够很容易的将多个注解处理器组合在一起。使用apt时必须指明一个工厂类，或者指明能找到apt所需工厂类的路径，apt需要工厂类来为其指明正确的处理器；使用apt生成注解处理器时，无法利用Java反射机制，因为操作的是源代码。</p>
<p>使用apt，以书中的annotations包为例。<br>首先，确保CLASSPATH变量中有tools.jar包，然后<code>cd TIJ4-code</code>，执行<code>javac annotations\InterfaceExtractorProcessorFactory.java</code>编译完成后，然后执行<code>apt -factory annotations.InterfaceExtractorProcessorFactory annotations\Multiplier.java -s annotations</code></p>
<h3 id="将观察者模式应用于apt">将观察者模式应用于apt</h3><p>mirror API提供了对访问者设计模式的支持。<br>一个访问者会遍历某个数据结构或一个对象的集合，对其中的每一个对象执行一个操作，该数据结构无需有序，而你对每个对象执行的操作，都是特定于此对象的类型。这就是操作与对象解耦，也就是说，你可以添加新的操作，而无需向类的定义中添加方法。</p>
<h3 id="基于注解单元测试">基于注解单元测试</h3><p>单元测试工具：JUnit。作者在书中提供了一个工具类库。</p>
<p>javassist应用于字节码工程。</p>
<h3 id="javac处理注解">javac处理注解</h3><p>Java SE 6 引入了一个新的功能，叫做 可插入注解处理（Pluggable Annotation Processing） 框架，它提供了标准化的支持来编写自定义的注解处理器。之所以称为“可插入”，是因为注解处理器可以动态插入到 javac 中，并可以对出现在 Java 源文件中的一组注解进行操作。此框架具有两个部分：一个用于声明注解处理器并与其交互的 API — 包 javax.annotation.processing — 和一个用于对 Java 编程语言进行建模的 API — 包 javax.lang.model。</p>
<p>下面的例子可以提取出一个类中的public方法，构造成一个新的接口。<br>InterfaceExtractorProcessor.java 文件</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">package annotations;</span><br><span class="line"></span><br><span class="line"><span class="built_in">import</span> javax.annotation.processing.<span class="built_in">*</span>;</span><br><span class="line"><span class="built_in">import</span> java.io.<span class="built_in">*</span>;</span><br><span class="line"><span class="built_in">import</span> java.util.<span class="built_in">*</span>;</span><br><span class="line"><span class="built_in">import</span> javax.tools.<span class="built_in">*</span>;</span><br><span class="line"><span class="built_in">import</span> javax.lang.model.<span class="built_in">*</span>;</span><br><span class="line"><span class="built_in">import</span> javax.lang.model.util.<span class="built_in">*</span>;</span><br><span class="line"><span class="built_in">import</span> javax.lang.model.element.<span class="built_in">*</span>;</span><br><span class="line"></span><br><span class="line">@SupportedAnnotationTypes<span class="params">(<span class="string">"annotations.ExtractInterface"</span>)</span></span><br><span class="line">@SupportedSourceVersion<span class="params">(SourceVersion.RELEASE_8)</span></span><br><span class="line">public class InterfaceExtractorProcessor extends AbstractProcessor &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public boolean process<span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> <span class="params">(Element e : roundEnv.getElementsAnnotatedWith<span class="params">(ExtractInterface.class)</span>)</span> &#123;</span><br><span class="line">            Set&lt;ExecutableElement&gt; interfaceMethods = new HashSet&lt;&gt;<span class="params">()</span>;</span><br><span class="line">            ExtractInterface annot = e.getAnnotation<span class="params">(ExtractInterface.class)</span>;</span><br><span class="line">            <span class="keyword">for</span><span class="params">(ExecutableElement m : ElementFilter.methodsIn<span class="params">(e.getEnclosedElements<span class="params">()</span>)</span>)</span> &#123;</span><br><span class="line">                <span class="keyword">if</span><span class="params">(m.getModifiers<span class="params">()</span>.contains<span class="params">(Modifier.PUBLIC)</span> &amp;&amp;</span><br><span class="line">                        !<span class="params">(m.getModifiers<span class="params">()</span>.contains<span class="params">(Modifier.STATIC)</span>)</span></span><br><span class="line">                        )</span></span><br><span class="line">                    interfaceMethods.add<span class="params">(m)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span><span class="params">(interfaceMethods.size<span class="params">()</span> &gt; <span class="number">0</span>)</span> &#123;</span><br><span class="line">                try &#123;</span><br><span class="line">                    JavaFileObject sourceFile = processingEnv.getFiler<span class="params">()</span>.createSourceFile<span class="params">(</span><br><span class="line">                            annot.value<span class="params">()</span>)</span>;</span><br><span class="line">                    PrintWriter writer = new PrintWriter<span class="params">(sourceFile.openWriter<span class="params">()</span>)</span>;</span><br><span class="line">                    writer.println<span class="params">(<span class="string">"package "</span> +</span><br><span class="line">                            processingEnv.getElementUtils<span class="params">()</span>.getPackageOf<span class="params">(e)</span>.getQualifiedName<span class="params">()</span> +<span class="string">";"</span>)</span>;</span><br><span class="line">                    writer.println<span class="params">(<span class="string">"public interface "</span> +</span><br><span class="line">                            annot.value<span class="params">()</span> + <span class="string">" &#123;"</span>)</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span><span class="params">(ExecutableElement m : interfaceMethods)</span> &#123;</span><br><span class="line">                        writer.print<span class="params">(<span class="string">"  public "</span>)</span>;</span><br><span class="line">                        writer.print<span class="params">(m.getReturnType<span class="params">()</span> + <span class="string">" "</span>)</span>;</span><br><span class="line">                        writer.print<span class="params">(m.getSimpleName<span class="params">()</span> + <span class="string">" ("</span>)</span>;</span><br><span class="line">                        int i = <span class="number">0</span>;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">for</span><span class="params">(VariableElement parm : m.getParameters<span class="params">()</span>)</span> &#123;</span><br><span class="line">                            writer.print<span class="params">(parm.asType<span class="params">()</span> + <span class="string">" "</span> +</span><br><span class="line">                                    parm.getSimpleName<span class="params">()</span>)</span>;</span><br><span class="line">                            <span class="keyword">if</span><span class="params">(++i &lt; m.getParameters<span class="params">()</span>.size<span class="params">()</span>)</span></span><br><span class="line">                                writer.print<span class="params">(<span class="string">", "</span>)</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        writer.println<span class="params">(<span class="string">");"</span>)</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    writer.println<span class="params">(<span class="string">"&#125;"</span>)</span>;</span><br><span class="line">                    writer.close<span class="params">()</span>;</span><br><span class="line">                &#125; catch<span class="params">(IOException ioe)</span> &#123;</span><br><span class="line">                    throw new RuntimeException<span class="params">(ioe)</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        return <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>
<p>ExtractInterface.java文件</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> ExtractInterface &#123;</span><br><span class="line">  <span class="keyword">public</span> <span class="function">String <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125; <span class="comment">///:~</span></span><br></pre></td></tr></table></figure>
<p>Multiplier.java文件</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotations;</span><br><span class="line"><span class="annotation">@ExtractInterface</span>(<span class="string">"IMultiplier"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Multiplier</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">multiply</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++)</span><br><span class="line">      total = add(total, y);</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123; <span class="keyword">return</span> x + y; &#125;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Multiplier m = <span class="keyword">new</span> Multiplier();</span><br><span class="line">    System.out.println(<span class="string">"11*16 = "</span> + m.multiply(<span class="number">11</span>, <span class="number">16</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义注解处理器继承 AbstractProcessor（这是 Processor 接口的默认实现），并覆盖 process() 方法。</p>
<p>注解处理器类将使用两个类级别的注解 @SupportedAnnotationTypes 和 @SupportedSourceVersion 来装饰。 SupportedSourceVersion 注解指定注解处理器支持的最新的源版本。SupportedAnnotationTypes 注解指示此特定的注解处理器对哪些注解感兴趣。例如，如果处理器只需处理 Java Persistence API (JPA) 注解，则将使用 @SupportedAnnotationTypes (“javax.persistence.<em>“)。值得注意的一点是，如果将支持的注解类型指定为 @SupportedAnnotationTypes(“</em>“)，即使没有任何注解，仍然会调用注解处理器。这允许我们有效利用建模 API 以及 Tree API 来执行通用的源码处理。使用这些 API，可以获得与修改符、字段、方法等有关的大量有用的信息。</p>
<p>是否调用注解处理器取决于源码中存在哪些注解，哪些处理器配置为可用，哪些注解类型是可用的后处理器进程。注解处理可能发生在多个轮回中。例如，在第一个轮回中，将处理原始输入 Java 源文件；在第二个轮回中，将考虑处理由第一个轮回生成的文件，等等。自定义处理器应覆盖 AbstractProcessor 的 process()。此方法接受两个参数：</p>
<ul>
<li>源文件中找到的一组 TypeElements/ 注解。</li>
<li>封装有关注解处理器当前处理轮回的信息的 RoundEnvironment。</li>
</ul>
<p>如果处理器声明其支持的注解类型，则 process() 方法返回 true，而不会为这些注解调用其他处理器。否则，process() 方法返回 false 值，并将调用下一个可用的处理器（如果存在的话）。</p>
<p>我们使用下面的调用来创建源文件。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">JavaFileObject</span> sourceFile = processingEnv.getFiler<span class="literal">()</span>.createSourceFile(annot.<span class="keyword">value</span><span class="literal">()</span>);</span><br><span class="line"><span class="type">PrintWriter</span> writer = <span class="keyword">new</span> <span class="type">PrintWriter</span>(sourceFile.openWriter<span class="literal">()</span>);</span><br></pre></td></tr></table></figure>
<p>Java SE 6 的 javac 实用程序提供一个称为 -processor 的选项，来接受要插入到的注解处理器的完全限定名。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -processor ProcessorClass<span class="label">Name1</span>,ProcessorClass<span class="label">Name2</span>,...  sourceFiles</span><br></pre></td></tr></table></figure>
<p>先编译注解处理器<br><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">javac</span> annotations/InterfaceExtractorProcessor.java</span><br></pre></td></tr></table></figure></p>
<p>然后运行<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">javac -processor annotations<span class="class">.InterfaceExtractorProcessor</span> annotations/Multiplier.java</span><br></pre></td></tr></table></figure></p>
<p>接口文件IMultiplier.java已经在当前路径下生成。</p>
]]></content>
    <summary type="html">
    <![CDATA[thinking in java; java编程思想; 枚举类型;]]>
    
    </summary>
    
      <category term="Thinking in Java" scheme="http://howiefh.github.io/tags/Thinking-in-Java/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java编程思想笔记六]]></title>
    <link href="http://howiefh.github.io/2014/11/04/thinking-in-java-note-6/"/>
    <id>http://howiefh.github.io/2014/11/04/thinking-in-java-note-6/</id>
    <published>2014-11-04T12:53:54.000Z</published>
    <updated>2015-04-07T03:41:51.000Z</updated>
    <content type="html"><![CDATA[<h2 id="Java_I/O_系统">Java I/O 系统</h2><h3 id="File类">File类</h3><p>File类是文件和目录路径名的抽象表示形式。</p>
<a id="more"></a>
<h4 id="目录列表器">目录列表器</h4><p>若在不含自变量（参数）的情况下调用list()，会获得 File 对象包含的一个完整列表。然而，若想对这个列表进行某些限制，就需要使用一个“目录过滤器”，该类的作用是指出应如何选择 File 对象来完成显示。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FilenameFilter</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>File类的list()的重载方法接收一个FilenameFilter对象，并且会为此目录对象下的每个文件调用accept()方法，来判断该文件是否包含在内。这是一个策略模式的例子，因为list()实现了基本的功能，而且按照FilenameFilter的形式提供这个策略，以便完善list()在提供服务时所需的算法。</p>
<p>书中用实现接口，和匿名内部类的方式实现了FilenameFilter接口。Java SE8中引入了Lambda表达式，而FilenameFilter是“函数式接口”（只有一个方法）。我们还可以使用Lambda表达式实现，代码更加简洁。<br><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.regex.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DirList4</span> &#123;</span></span><br><span class="line">  public static <span class="literal">void</span> main(final String[] args) &#123;</span><br><span class="line">    File path = <span class="keyword">new</span> File(<span class="string">"."</span>);</span><br><span class="line">    String[] list;</span><br><span class="line">    <span class="keyword">if</span>(args.length == <span class="number">0</span>) &#123;</span><br><span class="line">      list = path.list();</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	  final Pattern pattern = Pattern.compile(args[<span class="number">0</span>]);</span><br><span class="line">      list = path.list<span class="function"><span class="params">((dir, name) -&gt; &#123;</span><br><span class="line">          <span class="keyword">return</span> pattern.matcher(name).matches();</span><br><span class="line">      &#125;)</span>;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="title">Arrays</span>.<span class="title">sort</span><span class="params">(list, String.CASE_INSENSITIVE_ORDER)</span>;</span><br><span class="line">    <span class="title">for</span><span class="params">(String dirItem : list)</span></span><br><span class="line">      <span class="title">System</span>.<span class="title">out</span>.<span class="title">println</span><span class="params">(dirItem)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="目录使用工具">目录使用工具</h4><p>书中提供了目录使用工具类net.mindview.util.Directory，local()方法产生由本地目录中文件构成的File对象数组，walk()方法产生给定目录下的有整个目录树中所有文件构成的List<file>。</file></p>
<h4 id="目录的检查及创建">目录的检查及创建</h4><p>File类保存文件或目录的各种元数据信息，包括文件名、文件长度、最后修改时间、是否可读、获取当前文件的路径名，判断指定文件是否存在、获得当前目录中的文件列表，创建、删除文件和目录等方法。</p>
<h3 id="输出和输入">输出和输入</h3><p>我们很少用单个类创建自己的系统对象。一般情况下，我们都是将多个对象重叠在一起，提供期望的功能（这是装饰器设计模式）。</p>
<h4 id="InputStream类型">InputStream类型</h4><p>InputStream 的作用是标志那些从不同起源地产生输入的类。这些起源地包括（每个都有一个相关的InputStream 子类）：</p>
<ul>
<li>字节数组</li>
<li>String 对象</li>
<li>文件</li>
<li>“管道”，它的工作原理与现实生活中的管道类似：将一些东西置入一端，它们在另一端出来。</li>
<li>一系列其他流，以便我们将其统一收集到单独一个流内。</li>
<li>其他起源地，如 Internet 连接等</li>
</ul>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构建器参数／如何使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ByteArrayInputStream</td>
<td>允许内存中的一个缓冲区作为 InputStream 使用</td>
<td>从中提取字节的缓冲区／作为一个数据源使用。通过将其同一个 FilterInputStream 对象连接，可提供一个有用的接口</td>
</tr>
<tr>
<td>StringBufferInputStream</td>
<td>将一个 String 转换成 InputStream  一个 String（字串）。</td>
<td>基础的实施方案实际采用一个 StringBuffer（字串缓冲）／作为一个数据源使用。通过将其同一个 FilterInputStream 对象连接，可提供一个有用的接口</td>
</tr>
<tr>
<td>FileInputStream</td>
<td>用于从文件读取信息</td>
<td>代表文件名的一个 String，或者一个 File 或 FileDescriptor 对象 ／作为一个数据源使用。通过将其同一个 FilterInputStream 对象连接，可提供一个有用的接口</td>
</tr>
<tr>
<td>PipedInputStream</td>
<td>产生为相关的 PipedOutputStream 写的数据。实现了“管道化”的概念</td>
<td>PipedOutputStream／作为一个数据源使用。通过将其同一个 FilterInputStream 对象连接，可提供一个有用的接口</td>
</tr>
<tr>
<td>SequenceInputStream</td>
<td>将两个或更多的 InputStream 对象转换成单个 InputStream 使用</td>
<td>两个InputStream 对象或者一个 Enumeration，用于 InputStream 对象的一个容器／作为一个数据源使用。通过将其同一个FilterInputStream 对象连接，可提供一个有用的接口</td>
</tr>
<tr>
<td>FilterInputStream</td>
<td>抽象类，作为装饰器的接口，装饰器为其他InputStream 类提供了有用的功能。</td>
<td></td>
</tr>
</tbody>
</table>
<h4 id="OutputStream类型">OutputStream类型</h4><table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构建器参数／如何使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>ByteArrayOutputStream</td>
<td>在内存中创建一个缓冲区。我们发送给流的所有数据都会置入这个缓冲区。</td>
<td>可选缓冲区的初始大小／用于指出数据的目的地。若将其同 FilterOutputStream 对象连接到一起，可提供一个有用的接口</td>
</tr>
<tr>
<td>FileOutputStream</td>
<td>将信息发给一个文件</td>
<td>用一个 String 代表文件名，或选用一个 File 或 FileDescriptor 对象／用于指出数据的目的地。若将其同 FilterOutputStream 对象连接到一起，可提供一个有用的接口</td>
</tr>
<tr>
<td>PipedOutputStream</td>
<td>我们写给它的任何信息都会自动成为相关的 PipedInputStream 的输出。</td>
<td>实现了“管道化”的概念PipedInputStream／为多线程处理指出自己数据的目的地／将其同 FilterOutputStream 对象连接到一起，便可提供一个有用的接口</td>
</tr>
<tr>
<td>FilterOutputStream</td>
<td>抽象类，作为装饰器的接口；装饰器为其他 OutputStream 类提供了有用的功能。</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="添加属性和有用的接口">添加属性和有用的接口</h3><p>装饰器必须拥有与它装饰的那个对象相同的接口，但装饰器亦可对接口作出扩展，这种情况见诸于几个特殊的“过滤器”类中</p>
<p>装饰器为我们提供了大得多的灵活性（因为可以方便地混合与匹配属性），但它们也使自己的代码变得更加复杂。原因在于 Java IO 库操作不便，我们必须创建许多类——“核心”IO 类型加上所有装饰器——才能得到自己希望的单个 IO 对象。</p>
<h4 id="通过_FilterInputStream_从_InputStream_里读入数据">通过 FilterInputStream 从 InputStream 里读入数据</h4><p>基本都是使用基本的InputStream类型作为构造器参数创建这些类对象。下面的最后两个类我们基本不会用到</p>
<table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构建器参数／如何使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>DataInputStream</td>
<td>与 DataOutputStream 联合使用，使自己能以机动方式读取一个流中的基本数据类型（int，char ，long 等等）</td>
<td>InputStream/ 包含了一个完整的接口，以便读取基本数据类型</td>
</tr>
<tr>
<td>BufferedInputStream</td>
<td>避免每次想要更多数据时都进行物理性的读取，告诉它“请先在缓冲区里找”</td>
<td>InputStream，没有可选的缓冲区大小／本身并不能提供一个接口，只是发出使用缓冲区的要求。要求同一个接口对象连接到一起</td>
</tr>
<tr>
<td>LineNumberInputStream</td>
<td>跟踪输入流中的行号；可调用 getLineNumber()以及 setLineNumber(int)</td>
<td>只是添加对数据行编号的能力，所以可能需要同一个真正的接口对象连接</td>
</tr>
<tr>
<td>PushbackInputStream</td>
<td>有一个字节的后推缓冲区，以便后推读入的上一个字符</td>
<td>InputStream／通常由编译器在扫描器中使用，因为 Java 编译器需要它。一般不在自己的代码中使用</td>
</tr>
</tbody>
</table>
<h4 id="通过_FilterOutputStream_向_OutputStream_里写入数据">通过 FilterOutputStream 向 OutputStream 里写入数据</h4><table>
<thead>
<tr>
<th>类</th>
<th>功能</th>
<th>构建器参数／如何使用</th>
</tr>
</thead>
<tbody>
<tr>
<td>DataOutputStream</td>
<td>与 DataInputStream 配合使用，以便采用方便的形式将基本数据类型（int，char，long等）写入一个数据流</td>
<td>OutputStream ／包含了完整接口，以便我们写入基本数据类型</td>
</tr>
<tr>
<td>PrintStream</td>
<td>用于产生格式化输出。DataOutputStream 控制的是数据的“存储”，而 PrintStream 控制的是“显示”</td>
<td>OutputStream ，可选一个布尔参数，指示缓冲区是否与每个新行一同刷新／对于自己的OutputStream 对象，应该用“final”将其封闭在内。可能经常都要用到它</td>
</tr>
<tr>
<td>BufferedOutputStream</td>
<td>用它避免每次发出数据的时候都要进行物理性的写入，要求它“请先在缓冲区里找”。可调用 flush()，对缓冲区进行刷新</td>
<td>OutputStream ，可选缓冲区大小／本身并不能提供一个接口，只是发出使用缓冲区的要求。需要同一个接口对象连接到一起</td>
</tr>
</tbody>
</table>
<p>PrintStream 内两个重要的方法是 print()和 println() 。另外，PrintStream也未完全国际化，不能以平台无关的方式处理换行动作。</p>
<h3 id="Reader_和_Writer">Reader 和 Writer</h3><p>InputStream和OutputStream在以面向字节形式的I/O中扔可以提供极有价值的功能，Reader和Writer则提供兼容Unicode与面向字符的I/O功能。</p>
<p>“适配器”类：InputStreamReader 将一个 InputStream 转换成 Reader，OutputStreamWriter 将一个 OutputStream 转换成 Writer。</p>
<p>新类库的设计使得它的操作比旧类库更快。</p>
<h4 id="数据的来源和去处">数据的来源和去处</h4><p>最明智的做法是尽量尝试使用 Reader 和 Writer 类。若代码不能通过编译，便知道必须面向字节的类库。</p>
<table>
<thead>
<tr>
<th>来源和去处: Java 1.0 类</th>
<th>相应的 Java 1.1 类</th>
</tr>
</thead>
<tbody>
<tr>
<td>InputStream</td>
<td>Reader 适配器: InputStreamReader</td>
</tr>
<tr>
<td>OutputStream</td>
<td>Writer 适配器: OutputStreamWriter</td>
</tr>
<tr>
<td>FilelnputStream</td>
<td>FileReader</td>
</tr>
<tr>
<td>FileOutputStream</td>
<td>FileWriter</td>
</tr>
<tr>
<td>StringBufferlnputStream (已弃用)</td>
<td>StringReader</td>
</tr>
<tr>
<td>(没有相应的类)</td>
<td>StringWriter</td>
</tr>
<tr>
<td>ByteArrayInputStream</td>
<td>CharArrayReader</td>
</tr>
<tr>
<td>ByteArrayOutputStream</td>
<td>CharArrayWriter</td>
</tr>
<tr>
<td>PipedInputStream</td>
<td>PipedReader</td>
</tr>
<tr>
<td>PipedOutputStream</td>
<td>PipedWriter</td>
</tr>
</tbody>
</table>
<h4 id="更改数据流的行为">更改数据流的行为</h4><p>尽管 BufferedOutputStream 是 FilterOutputStream 的一个子类，但是 BufferedWriter 并不是 FilterWriter 的子类（尽管FilterWriter是一个抽象类，但没有任何子类，把它放在那里也只是把它作为一个占位符））。然而，两个类的接口是非常相似的</p>
<table>
<thead>
<tr>
<th>过滤器：Java 1.0 类</th>
<th>对应的 Java 1.1 类</th>
</tr>
</thead>
<tbody>
<tr>
<td>FilterInputStream</td>
<td>FilterReader</td>
</tr>
<tr>
<td>FilterOutputStream</td>
<td>FilterWriter （没有子类的抽象类）</td>
</tr>
<tr>
<td>BufferedInputStream</td>
<td>BufferedReader（也有 readLine()）</td>
</tr>
<tr>
<td>BufferedOutputStream</td>
<td>BufferedWriter</td>
</tr>
<tr>
<td>DataInputStream</td>
<td>使用 DataInputStream（除非要使用 readLine()，这时需要使用一个 BufferedReader）</td>
</tr>
<tr>
<td>PrintStream</td>
<td>PrintWriter</td>
</tr>
<tr>
<td>LineNumberInputStream</td>
<td>LineNumberReader</td>
</tr>
<tr>
<td>StreamTokenizer</td>
<td>StreamTokenizer （使用接收Reader的构造器）</td>
</tr>
<tr>
<td>PushBackInputStream</td>
<td>PushBackReader</td>
</tr>
</tbody>
</table>
<p>为了将向 PrintWriter 的过渡变得更加自然，它提供了能接受任何Writer对象又能接受任何 OutputStream 对象的构造器。<br>有一种PrintWriter构造器还有一个选项，就是“自动执行清空”选项(自动刷新缓存区)。如果构造器设置此选项，则在每个println()执行后，便会自动清空。</p>
<h4 id="未发生改变的类">未发生改变的类</h4><p>没有对应 Java 1.1 类的 Java 1.0 类 </p>
<ul>
<li>DataOutputStream</li>
<li>File</li>
<li>RandomAccessFile</li>
<li>SequenceInputStream</li>
</ul>
<h3 id="自我独立的类：RandomAccessFile">自我独立的类：RandomAccessFile</h3><p><strong>RandomAccessFile 适用于由大小已知的记录组成的文件，所以我们能用 seek()从一条记录移至另一条，然后读取或修改那些记录</strong>。</p>
<p>RandomAccessFile 类似 DataInputStream 和 DataOutputStream 的联合使用。其中，getFilePointer()用于了解当前在文件的什么地方，seek()用于移至文件内的一个新地点，length() 用于判断文件的最大长度。此外，构建器要求使用另一个变量（与 C 的 fopen()完全一样），指出是读（”r”），还是读写（”rw” ）。</p>
<p>BufferedInputStream 确实允许我们标记一个位置（使用 mark()，它的值容纳于单个内部变量中），并用 reset()重设那个位置。</p>
<h3 id="I/O流的经典适用方式">I/O流的经典适用方式</h3><ul>
<li>缓冲输入文件  <figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader <span class="keyword">in</span> = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line"><span class="built_in">StringBuffer</span> sb = <span class="keyword">new</span> <span class="built_in">StringBuffer</span>();</span><br><span class="line"><span class="keyword">while</span>((s=<span class="keyword">in</span>.readLine())!=<span class="keyword">null</span>)</span><br><span class="line">	sb.append(s+<span class="string">"\n"</span>);</span><br><span class="line"><span class="keyword">in</span>.close();</span><br></pre></td></tr></table></figure>
  readLine()方法会去掉换行符</li>
<li>从内存输入  <figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"hello world"</span>;</span><br><span class="line">StringReader in = <span class="keyword">new</span> StringReader(<span class="built_in">str</span>);</span><br><span class="line"><span class="built_in">int</span> c;</span><br><span class="line"><span class="keyword">while</span>((c=in.read())!=-<span class="number">1</span>)</span><br><span class="line">	System.out.<span class="built_in">println</span>((<span class="built_in">char</span>)c);</span><br></pre></td></tr></table></figure></li>
<li>格式化的内存输入   <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DataInputStream</span> <span class="keyword">in</span> = <span class="keyword">new</span> <span class="type">DataInputStream</span>(<span class="keyword">new</span> <span class="type">ByteArrayInputStream</span>(<span class="string">"FormattedMemoryInput.java"</span>.getBytes<span class="literal">()</span>)); </span><br><span class="line"><span class="keyword">while</span>(<span class="keyword">in</span>.available<span class="literal">()</span> != <span class="number">0</span>) </span><br><span class="line">	<span class="type">System</span>.out.print((<span class="built_in">char</span>)<span class="keyword">in</span>.readByte<span class="literal">()</span>);</span><br></pre></td></tr></table></figure>
  <strong>可以使用available()方法查看还有多少可供存取的字符。必须为ByteArrayInputStream提供字节数组。available()的工作方式会随着所读取的媒介类型的不同而有所不同，字面意思就是“在没有阻塞的情况下所能读取的字节数”</strong>。</li>
<li>基本的文件输出  <figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader <span class="keyword">in</span> = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(filename));</span><br><span class="line">PrintWriter <span class="keyword">out</span> = <span class="keyword">new</span> PrintWriter(<span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"file.out"</span>))); </span><br><span class="line">//PrintWriter <span class="keyword">out</span> = <span class="keyword">new</span> PrintWriter(<span class="string">"file.out"</span>);  //Java SE5提供了更加快捷的构造器，仍然使用缓存，但是不用自己实现</span><br><span class="line">int lineCount = <span class="number">1</span>; </span><br><span class="line"><span class="typename">String</span> s; </span><br><span class="line"><span class="keyword">while</span>((s = <span class="keyword">in</span>.readLine()) != <span class="keyword">null</span> ) </span><br><span class="line">	<span class="keyword">out</span>.println(lineCount++ + <span class="string">": "</span> + s); </span><br><span class="line"><span class="keyword">out</span>.close(); </span><br><span class="line"><span class="keyword">in</span>.close();</span><br></pre></td></tr></table></figure></li>
<li>存储和恢复数据<br>  为了输出可供另一个流恢复的数据，我们需要用DataInputStream写入数据，并用DataInputStream恢复数据。当使用DataOutputStream时，写字符串并且让DataInputStream能够恢复它的唯一可靠的做法就是使用UTF-8，在这个示例中是用writeUTF()和readUTF()来实现的。Java使用的UTF-8的变体，所以使用其他语言恢复数据时，需要编写一些特殊的代码。  <figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DataOutputStream <span class="keyword">out</span> = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Data.txt"</span>))); </span><br><span class="line"><span class="keyword">out</span>.writeDouble(<span class="number">3.1</span><span class="number">4159</span>); </span><br><span class="line"><span class="keyword">out</span>.writeUTF(<span class="string">"That was pi"</span>); </span><br><span class="line"><span class="keyword">out</span>.writeDouble(<span class="number">1.4</span><span class="number">1413</span>); </span><br><span class="line"><span class="keyword">out</span>.writeUTF(<span class="string">"Square root of 2"</span>); </span><br><span class="line"><span class="keyword">out</span>.close(); </span><br><span class="line">DataInputStream <span class="keyword">in</span> = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Data.txt"</span>))); </span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="keyword">in</span>.readDouble()); </span><br><span class="line"><span class="comment">// Only readUTF() will recover the </span></span><br><span class="line"><span class="comment">// Java-UTF String properly: </span></span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="keyword">in</span>.readUTF()); </span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="keyword">in</span>.readDouble()); </span><br><span class="line">System.<span class="keyword">out</span>.println(<span class="keyword">in</span>.readUTF());</span><br></pre></td></tr></table></figure></li>
<li>读写随机访问文件  <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.*; </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> UsingRandomAccessFile &#123; </span><br><span class="line">	<span class="keyword">static</span> String <span class="keyword">file</span> = <span class="string">"rtest.dat"</span>; </span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">void</span> display() <span class="keyword">throws</span> IOException &#123; </span><br><span class="line">		RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">file</span>, <span class="string">"r"</span>); </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) </span><br><span class="line">			System.out.<span class="keyword">println</span>(<span class="string">"Value "</span> + i + <span class="string">": "</span> + rf.readDouble()); </span><br><span class="line">		System.out.<span class="keyword">println</span>(rf.readUTF()); </span><br><span class="line">		rf.close(); </span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) <span class="keyword">throws</span> IOException &#123; </span><br><span class="line">		RandomAccessFile rf = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">file</span>, <span class="string">"rw"</span>); </span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">7</span>; i++) </span><br><span class="line">			rf.writeDouble(i*<span class="number">1.414</span>); </span><br><span class="line">		rf.writeUTF(<span class="string">"The end of the file"</span>); </span><br><span class="line">		rf.close(); </span><br><span class="line">		display(); </span><br><span class="line">		rf = <span class="keyword">new</span> RandomAccessFile(<span class="keyword">file</span>, <span class="string">"rw"</span>); </span><br><span class="line">		rf.seek(<span class="number">5</span>*<span class="number">8</span>); </span><br><span class="line">		rf.writeDouble(<span class="number">47.0001</span>); </span><br><span class="line">		rf.close(); </span><br><span class="line">		display(); </span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>管道流  <figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">PipedInputStream pin = new PipedInputStream<span class="params">()</span>;</span><br><span class="line">   PipedOutputStream pout = new PipedOutputStream<span class="params">()</span>;</span><br><span class="line">   pin.connect<span class="params">(pout)</span>; <span class="comment">// 输入流与输出流连接</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="文件读写的实用工具">文件读写的实用工具</h3><p>书中提供了工具类net.mindview.util.TextFile。可以使用java.util.Scanner类。但是只能用于读取文件，而不能用于写入文件。</p>
<h3 id="标准I/O">标准I/O</h3><h4 id="从标准输入中读取">从标准输入中读取</h4><p>Java 提供了System.in，System.out 以及 System.err。System.out 已预封装成一个 PrintStream 对象。System.err 同样是一个 PrintStream，但 System.in 是一个原始的 InputStream ，未进行任何封装处理。这意味着尽管能直接使用 System.out 和 System.err，但必须事先封装 System.in，否则不能从中读取数据。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BufferedReader</span> stdin = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(System.in)); </span><br><span class="line"><span class="keyword">String</span> s;</span><br><span class="line"><span class="keyword">while</span>((s = stdin.readLine()) != <span class="keyword">null</span> &amp;&amp; s.length()!= <span class="number">0</span>) </span><br><span class="line">	System.out.<span class="built_in">println</span>(s); </span><br><span class="line"><span class="comment">// An empty line or Ctrl-Z terminates the program</span></span><br></pre></td></tr></table></figure>
<p><code>Scanner scanner = new Scanner(System.in);</code>也可以从标准输入中读取，System.in和大多数流一样，通常应该对它缓存。</p>
<h4 id="将System-out转换成PrintWriter">将System.out转换成PrintWriter</h4><p><code>PrintWriter(OutputStream out, boolean autoFlush)</code>，此构造器可以实现，第一个参数设置为System.out，第二个参数设为true，以便开启自动刷新缓存区的功能，否则，你可能看不到输出。</p>
<h4 id="标准I/O重定向">标准I/O重定向</h4><p>System类提供了<code>setIn(InputStream)</code>，<code>setOut(PrintStream)</code>，<code>setErr(PrintStream)</code>三个静态方法重定向标准I/O，我们可以将其重定向到文件中，以便查看。I/O 重定向操纵的是字节流，而不是字符流。</p>
<h3 id="进程控制">进程控制</h3><p>工具类net.mindview.util.OSExecute可以运行外部程序，并将产生的输出发送到控制台。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> command = <span class="string">"ls"</span>;</span><br><span class="line">Process process = <span class="keyword">new</span> ProcessBuilder(command.<span class="built_in">split</span>(<span class="string">" "</span>)).start(); </span><br><span class="line"><span class="keyword">BufferedReader</span> results = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(process.getInputStream())); </span><br><span class="line"><span class="keyword">String</span> s; </span><br><span class="line"><span class="keyword">while</span>((s = results.readLine())!= <span class="keyword">null</span>) </span><br><span class="line">	System.out.<span class="built_in">println</span>(s); </span><br><span class="line"><span class="keyword">BufferedReader</span> errors = <span class="keyword">new</span> <span class="keyword">BufferedReader</span>(<span class="keyword">new</span> InputStreamReader(process.getErrorStream())); </span><br><span class="line"><span class="comment">// Report errors and return nonzero value </span></span><br><span class="line"><span class="comment">// to calling process if there are problems: </span></span><br><span class="line"><span class="keyword">while</span>((s = errors.readLine())!= <span class="keyword">null</span>) &#123; </span><br><span class="line">	System.err.<span class="built_in">println</span>(s); </span><br><span class="line">	err = <span class="keyword">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="新I/O">新I/O</h3><p>JDK 1.4的<code>java.nio.*</code>包中引入了新的Java I/O类库，其目的在于提高速度。实际上，旧的I/O包已经使用nio重新实现过，以便充分利用这种速度提高。</p>
<p>速度的提高来自于所使用的结构更接近于操作系统执行I/O的方式：通道和缓冲器。我们没有和通道交互，只是和缓冲器交互，并把缓冲器派送到通道。通道要么从缓冲器获得数据，要么向缓冲器发送数据。</p>
<p>唯一直接与通道交互的缓冲器是<code>ByteBuffer</code>，可以存储未加工字节的缓冲器。通过告知分配多少存储空间来创建一个<code>ByteBuffer</code>对象，并且还有一个方法选择集，用于以原始的字节形式或基本数据类型输出和读取数据。但是，没办法输出或读取对象，即使是字符串对象也不行。这是大多数操作系统中更有效的映射方式。</p>
<p>旧I/O类库中有三个类（<code>FileInputStream</code>、<code>FileOutputStream</code>、<code>RandomAccessFile</code>）被修改了，用以产生<code>FileChannel</code>。注意这些都是字节操纵流，与底层的nio性质一致。<code>Reader</code>和<code>Writer</code>这种字符模式类不能用于产生通道；但是<code>java.nio.channels.Channels</code>类提供了实用方法，用以在通道中产生<code>Reader</code>和<code>Writer</code>。</p>
<p><code>getChannel()</code>将会产生一个<code>FileChannel</code>。通道是一种相当基础的东西：可以向它传送用于读写的<code>ByteBuffer</code>，并且可以锁定文件的某些区域用于独占式访问。</p>
<p>将字节存放在<code>ByteBuffer</code>的方法之一是：使用一种“put”方法直接对它们进行填充，填入一个或多个字节，或基本数据类型的值。也可以使用<code>wrap()</code>方法将已存在的字节数组“包装”到ByteBuffer中。一旦如此，就不再复制底层的数组，而是把它作为所产生的ByteBuffer的存储器，称之为数组支持的<code>ByteBuffer</code>。</p>
<p>对于只读操作，必须显式的使用静态的<code>allocate()</code>方法来分配<code>ByteBuffer</code>，分配的大小单位是字节。nio的目标就是快速移动大量数据，因此<code>ByteBuffer</code>的大小就显得尤为重要—实际上，这里使用的1K可能比通常使用的小一点（必须通过实际运行应用程序来找到最佳尺寸）。</p>
<p>甚至达到更高的速度也有可能，方法就是使用<code>allocateDirect()</code>而不是<code>allocate()</code>，以产生一个与操作系统有更高耦合性的“直接”缓冲器。但是，这种分配的开支会更大，并且具体实现也随操作系统的不同而不同，因此必须再次实际运行应用程序来查看直接缓冲是否可以使程序获得速度上的优势。</p>
<p>一旦调用<code>read()</code>来告知<code>FileChannel</code>向<code>ByteBuffer</code>存储字节，就必须调用缓冲器上的<code>flip()</code>,让它做好让别人读取字节的准备。（适用于获取最大速度）如果打算使用缓冲器执行进一步的<code>read()</code>操作，也必须得调用<code>clear()</code>来为每个<code>read()</code>做好准备。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> final <span class="keyword">int</span> BSIZE = <span class="number">1024</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(args.length != <span class="number">2</span>)&#123;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"arguments: sourcefile destfile"</span>);</span><br><span class="line">		System.exit(<span class="number">1</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	FileChannel <span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">			<span class="keyword">out</span> = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line">	ByteBuffer buffer = ByteBuffer.allocate(BSIZE);</span><br><span class="line">	<span class="keyword">while</span>(<span class="keyword">in</span>.read(buffer) != -<span class="number">1</span>)&#123;</span><br><span class="line">		buffer.flip();<span class="comment">//Prepare for writing</span></span><br><span class="line">		<span class="keyword">out</span>.write(buffer);</span><br><span class="line">		buffer.clear();<span class="comment">//Prepare for reading</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>当<code>FileChannel.read()</code>返回-1时（一个分界符，源于Unix和C），表示已经到达了输入的末尾。每次<code>read()</code>操作之后，就会将数据输入到缓冲器中，<code>flip()</code>则是准备缓冲器以便它的信息可以由<code>write()</code>提取。<code>write()</code>操作之后，信息仍在缓冲器中，接着<code>clear()</code>操作则对所有的内部指针重新安排，以便缓冲器在另一个<code>read()</code>操作期间能够做好接收数据的准备</strong>。</p>
<p>特殊方法<code>transferTo()</code>和<code>transferFrom()</code>允许将一个通道和另一个通道直接相连。</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FileChannel <span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(args[<span class="number">0</span>]).getChannel(),</span><br><span class="line">		<span class="keyword">out</span> = <span class="keyword">new</span> FileOutputStream(args[<span class="number">1</span>]).getChannel();</span><br><span class="line"><span class="keyword">in</span>.transferTo(<span class="number">0</span>, <span class="keyword">in</span>.size(), <span class="keyword">out</span>);</span><br><span class="line">//<span class="keyword">Or</span>:</span><br><span class="line">//<span class="keyword">out</span>.transferFrom(<span class="keyword">in</span>, <span class="number">0</span>, <span class="keyword">in</span>.size());</span><br></pre></td></tr></table></figure>
<h4 id="转换数据">转换数据</h4><p><code>java.nio.CharBuffer</code>的<code>toString()</code>方法返回一个包含缓冲器中所有字符的字符串。Bytebuffer可以看做是具有<code>asCharBuffer()</code>方法的<code>CharBuffer</code></p>
<p>缓冲器容纳的是普通的字节，为了把它们转换成字符，要么在输入它们的时候对其进行编码（这样，它们输出时才具有意义，否则会有乱码），要么在将其从缓冲器输出时对它们进行解码。java.nio.charset.Charset类提供了把数据编码成多种不同类型的字符集的工具</p>
<p><strong>缓存器的<code>rewind()</code>方法：返回到数据开始部分</strong><br><code>System.getProperty(“file.encoding”)</code>发现默认字符集，产生代表字符集名称的字符串。</p>
<h4 id="获取基本类型">获取基本类型</h4><p><code>ByteBuffer</code>只能保存字节类型的数据，但是它具有从其所容纳的字节中产生出各种不同基本类型值的方法。 </p>
<p>分配一个<code>ByteBuffer</code>之后，缓冲器（ByteBuffer）自动把自己的内容置为零。 </p>
<p>向<code>ByteBuffer</code>插入基本类型数据的最简单的方法是：利用<code>asCharBuffer()</code>、<code>asShortBuffer()</code>等获得该缓冲器上的视图，然后使用视图的<code>put()</code>方法。此方法适用于所有基本数据类型。使用<code>ShorBuffer</code>的<code>put()</code>方法时，需要进行类型转换（注意类型转换会截取或改变结果）。而其他所有的视图缓冲器在使用<code>put()</code>方法时，不需要进行类型转换。</p>
<h4 id="视图缓冲器">视图缓冲器</h4><p>视图缓冲器（view buffer）可以让我们通过某个特定的基本数据类型的视窗查看其底层的<code>ByteBuffer</code>。<code>ByteBuffer</code>依然是实际存储数据的地方，“支持”着前面的视图，因此，<strong>对视图的任何修改都会映射成为对<code>ByteBuffer</code>中数据的修改</strong>。视图还允许从<code>ByteBuffer</code>一次一个地（与<code>ByteBuffer</code>所支持的方式相同）或者成批地（放入数组中）读取基本类型值。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ByteBuffer bb = ByteBuffer.allocate<span class="params">(BSIZE)</span>;</span><br><span class="line">IntBuffer ib = bb.asIntBuffer<span class="params">()</span>;</span><br><span class="line"><span class="comment">//Store an array of int:</span></span><br><span class="line">ib.put<span class="params">(new int[]&#123;<span class="number">11</span>,<span class="number">42</span>,<span class="number">47</span>,<span class="number">99</span>,<span class="number">143</span>,<span class="number">811</span>,<span class="number">1016</span>&#125;)</span>;</span><br><span class="line"><span class="comment">//Absolute location read and write:</span></span><br><span class="line">System.out.println<span class="params">(ib.get<span class="params">(<span class="number">3</span>)</span>)</span>;</span><br><span class="line">ib.put<span class="params">(<span class="number">3</span>,<span class="number">1811</span>)</span>;</span><br><span class="line"><span class="comment">//Setting a new limit before rewinding the buffer.</span></span><br><span class="line">ib.flip<span class="params">()</span>;</span><br><span class="line">while<span class="params">(ib.hasRemaining<span class="params">()</span>)</span>&#123;</span><br><span class="line">	int i = ib.get<span class="params">()</span>;</span><br><span class="line">	System.out.println<span class="params">(i)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>get()</code>和<code>put()</code>方法调用直接访问底层<code>ByteBuffer</code>中的某个整数位置。注意，这些通过直接与<code>ByteBuffer</code>对话访问绝对位置的方式也同样适用于基本类型。 </p>
<p>一旦底层的<code>ByteBuffer</code>通过视图缓冲器填满了整数或其他类型数据时，就可以直接被写到通道中了。使用视图缓冲器可以把任何数据都转化成某一特定的基本类型。</p>
<p><strong>字节存放次序</strong></p>
<p>不同的机器可能会使用不同的字节排序方法来存储数据。“big endian”（高位字节优先）将高位字节存放在地址最低的存储器单元。“litter endian”（低位字节优先）则是将高位字节放在地址最高的存储器单元。当存储量大于一个字节时，像<code>int</code>、<code>float</code>等，就要考虑字节的顺序问题了。<code>ByteBuffer</code>是以高字节优先的形式存储数据的，并且数据在网上传送时也常常使用高位优先的形式。可以使用带有参数的<code>ByteOrder.BIG_ENDIAN</code>或<code>ByteOrder.LITTLE_ENDIAN</code>的<code>order()</code>方法改变<code>ByteBuffer</code>的字节排序方式。 </p>
<p>如果以<code>short</code>(<code>ByteBuffer.asShortBuffer</code>)形式读取数据，得到的数字是97（二进制的形式为00000000 01100001）；但是如果将<code>ByteBuffer</code>更改成低位优先形式，得到的数字却是24832（01100001 00000000） </p>
<p><code>ByteBuffer</code>有足够的空间，以存储作为外部缓冲器的<code>charArray</code>中的所有字节，因此可以调用<code>array()</code>方法显示视图底层的字节。<code>array()</code>方法是“可选的”，并且只能对由数组支持的缓冲器调用此方法；否则，将会抛出<code>UnsupportedOperationException</code>。 </p>
<h4 id="用缓冲器操纵数据">用缓冲器操纵数据</h4><p>注意，<strong><code>ByteBuffer</code>是将数据移进移出通道的唯一方式，并且只能创建一个独立的基本类型缓冲器，或者使用“as”方法从<code>ByteBuffer</code>中获得</strong>。也就是说，不能把基本类型的缓冲器转换成<code>ByteBuffer</code>。然而，由于可以经由视图缓冲器将基本类型数据移进移出ByteBuffer，所以这也不是什么真正的限制了。 </p>
<h4 id="缓冲器的细节">缓冲器的细节</h4><p>Buffer由数据和可以高效地访问及操纵这些数据的四个索引（mark（标记）、position（位置）、limit（界限）、capacity（容量））组成。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>capacity( )</td>
<td>返回缓冲区容量</td>
</tr>
<tr>
<td>clear( )</td>
<td>清空缓冲区，将position设置为0，limit设置为容量。我们可以调用此方法覆写缓冲区。</td>
</tr>
<tr>
<td>flip( )</td>
<td>将position和limit设置为0，此方法用于准备从缓冲区读取已经写入的数据。</td>
</tr>
<tr>
<td>limit( )</td>
<td>返回limit值</td>
</tr>
<tr>
<td>limit(int lim)</td>
<td>设置limit值</td>
</tr>
<tr>
<td>mark( )</td>
<td>将mark设置为position</td>
</tr>
<tr>
<td>reset()</td>
<td>将position设置为mark</td>
</tr>
<tr>
<td>rewind()</td>
<td>将position设置为0，mark设置为-1</td>
</tr>
<tr>
<td>position( )</td>
<td>返回position值</td>
</tr>
<tr>
<td>position(int pos)</td>
<td>设置position值</td>
</tr>
<tr>
<td>remaining( )</td>
<td>返回(limit - position)</td>
</tr>
<tr>
<td>hasRemaining( )</td>
<td>若有介于position和limit之间的元素，则返回true</td>
</tr>
</tbody>
</table>
<p>io.UsingBuffers的例子可以很好的理解这些方法。尽管可以通过对某个char数组调用<code>wrap()</code>方法（<code>CharBuffer java.nio.CharBuffer.wrap(CharSequence csq)</code>）来直接产生一个<code>CharBuffer</code>，但是在本例中取而代之的是分配一个底层的<code>ByteBuffer</code>，产生的<code>CharBuffer</code>只是<code>ByteBuffer</code>上的一个视图而已。这里要强调的是，我们总是以操纵<code>ByteBuffer</code>为目标，因为它可以和通道进行交互。 </p>
<h4 id="内存映射文件">内存映射文件</h4><p>内存映射文件允许我们创建和修改那些因为太大而不能放入内存的文件。有了内存映射文件，我们就可以假定整个文件都放在内存中，而且可以完全把它当作非常大的数组来访问。这种方法极大地简化了用于修改文件的代码。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">import java.io.RandomAccessFile;</span><br><span class="line">import java.nio.MappedByteBuffer;</span><br><span class="line">import java.nio.channels.FileChannel;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LargeMappedFiles</span> &#123;</span><br><span class="line">	<span class="keyword">static</span> <span class="keyword">int</span> length = <span class="number">0X8FFFFFF</span>;<span class="comment">// 128MB</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Exception </span>&#123;</span><br><span class="line">		MappedByteBuffer <span class="keyword">out</span> = <span class="keyword">new</span> RandomAccessFile(<span class="string">"test.data"</span>, <span class="string">"rw"</span>)</span><br><span class="line">				.getChannel().map(FileChannel.MapMode.READ_WRITE, <span class="number">0</span>, length);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">			<span class="keyword">out</span>.put((<span class="keyword">byte</span>)<span class="string">'x'</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		System.<span class="keyword">out</span>.println(<span class="string">"Finished writing"</span>);</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">int</span> i = length/<span class="number">2</span>; i &lt; length/<span class="number">2</span> + <span class="number">6</span>;i++)&#123;</span><br><span class="line">			System.<span class="keyword">out</span>.print((<span class="keyword">char</span>)<span class="keyword">out</span>.<span class="keyword">get</span>(i));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>为了既能写又能读，先由RandomAccessFile开始，获得该文件上的通道，然后调用map()产生MappedByteBuffer，这是一种特殊类型的直接缓冲器。注意必须指定映射文件的初始位置和映射区域的长度，这意味着可以映射某个大文件的较小的部分。</p>
<p>MappedByteBuffer由ByteBuffer继承而来，因此它具有ByteBuffer的所有方法（包括asCharBuffer()）。<br>只有一部份文件放入了内存，文件的其他部分被交换了出去，用这种方式，很大的文件（可达2GB）也可以很容易地修改。注意底层操作系统的文件映射工具是用来最大化地提高性能。</p>
<p><strong>性能</strong></p>
<p><strong>尽管“映射写”似乎要用到FileOutputStream，但是映射文件中的所有输出必须使用RandomAccessFile</strong>。<br>即使建立映射文件的花费很大，但是整体受益比起I/O流来说还是很显著的。</p>
<h4 id="文件加锁">文件加锁</h4><p>文件锁对其他的操作系统进程是可见的，因为Java的文件加锁直接映射到了本地操作系统的加锁工具。</p>
<p><strong>通过对FileChannel调用tryLock()或lock()，就可以获得整个文件的FileLock。（SocketChannel、DatagramChannel和ServerSocketChannel不需要加锁，因为它们是从单进程实体继承而来，我们通常不再两个进程之间共享网络socket）。tryLock()是非阻塞式的，它设法获得锁，但是如果不能获得（当其他一些进程已经持有相同的锁，并且不共享时），它将直接从方法调用返回。lock()则是阻塞式的，它要阻塞进程直至锁可以获得，或调用lock()的线程中断，或调用lock()的通道关闭。使用FileLock.release()可以释放锁</strong>。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tryLock(<span class="keyword">long</span> position, <span class="keyword">long</span> <span class="keyword">size</span>, <span class="keyword">boolean</span> shared)</span><br><span class="line">lock(<span class="keyword">long</span> position, <span class="keyword">long</span> <span class="keyword">size</span>, <span class="keyword">boolean</span> shared)</span><br></pre></td></tr></table></figure>
<p>加锁的区域有size-position决定。第三个参数指定是否是共享锁。<br>锁的类型可以通过FileLock.isShared()进行查询。</p>
<p><strong>对映射文件的部分加锁</strong><br>文件映射通常用于极大的文件。我们需要对这种巨大的文件进行部分加锁，以便其他进程可以修改文件中未被加锁的部分。</p>
<h3 id="压缩">压缩</h3><table>
<thead>
<tr>
<th>压缩类</th>
<th>功能</th>
</tr>
</thead>
<tbody>
<tr>
<td>CheckedInputStream</td>
<td>GetCheckSum()为任何 InputStream 产生校验和（不仅是解压）</td>
</tr>
<tr>
<td>CheckedOutputStream</td>
<td>GetCheckSum()为任何 OutputStream 产生校验和（不仅是解压）</td>
</tr>
<tr>
<td>DeflaterOutputStream</td>
<td>用于压缩类的基础类</td>
</tr>
<tr>
<td>ZipOutputStream</td>
<td>一个 DeflaterOutputStream，将数据压缩成 Zip 文件格式</td>
</tr>
<tr>
<td>GZIPOutputStream</td>
<td>一个 DeflaterOutputStream，将数据压缩成 GZIP 文件格式</td>
</tr>
<tr>
<td>InflaterInputStream</td>
<td>用于解压类的基础类</td>
</tr>
<tr>
<td>ZipInputStream</td>
<td>一个 DeflaterInputStream，解压用 Zip 文件格式保存的数据</td>
</tr>
<tr>
<td>GZIPInputStream</td>
<td>一个 DeflaterInputStream，解压用 GZIP 文件格式保存的数据</td>
</tr>
</tbody>
</table>
<h4 id="用GZIP进行简单压缩">用GZIP进行简单压缩</h4><p>GZIP接口非常简单，因此如果我们只想对单个数据流（而不是一系列互异数据）进行压缩，那么它可能是比较适合的选择。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BufferedReader in = new BufferedReader<span class="list">(<span class="keyword">new</span> FileReader<span class="list">(<span class="keyword">args</span>[<span class="number">0</span>])</span>)</span><span class="comment">;</span></span><br><span class="line">BufferedOutputStream out = new BufferedOutputStream<span class="list">(<span class="keyword">new</span> GZIPOutputStream<span class="list">(<span class="keyword">new</span> FileOutputStream<span class="list">(<span class="string">"test.gz"</span>)</span>)</span>)</span><span class="comment">;</span></span><br><span class="line">BufferedReader in2 = new BufferedReader<span class="list">(<span class="keyword">new</span> InputStreamReader<span class="list">(<span class="keyword">new</span> GZIPInputStream<span class="list">(<span class="keyword">new</span> FileInputStream<span class="list">(<span class="string">"test.gz"</span>)</span>)</span>)</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="用Zip进行简单压缩">用Zip进行简单压缩</h4><p>java对zip支持更加全面，利用该库可以方便保存多个文件。使用的是标准zip格式，所以能与当前那些可通过因特网下载的压缩工具很好地协作。<br>两种Checksum类型：Adler32（快一些）和CRC32（慢一些，但是更准确）</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">import</span> java.util.zip.<span class="built_in">*</span>;</span><br><span class="line"><span class="built_in">import</span> java.io.<span class="built_in">*</span>;</span><br><span class="line"><span class="built_in">import</span> java.util.<span class="built_in">*</span>;</span><br><span class="line"><span class="built_in">import</span> static net.mindview.util.Print.<span class="built_in">*</span>;</span><br><span class="line">public class ZipCompress &#123;</span><br><span class="line">  public static void main<span class="params">(String[] args)</span></span><br><span class="line">  throws IOException &#123;</span><br><span class="line">    FileOutputStream f = new FileOutputStream<span class="params">(<span class="string">"test.zip"</span>)</span>;</span><br><span class="line">    CheckedOutputStream csum =</span><br><span class="line">      new CheckedOutputStream<span class="params">(f, new Adler32<span class="params">()</span>)</span>;</span><br><span class="line">     ZipOutputStream zos = new ZipOutputStream<span class="params">(csum)</span>;</span><br><span class="line">     BufferedOutputStream out =</span><br><span class="line">      new BufferedOutputStream<span class="params">(zos)</span>;</span><br><span class="line">    zos.setComment<span class="params">(<span class="string">"A test of Java Zipping"</span>)</span>;</span><br><span class="line">    <span class="comment">// No corresponding getComment(), though.</span></span><br><span class="line">    <span class="keyword">for</span><span class="params">(String arg : args)</span> &#123;</span><br><span class="line">      print<span class="params">(<span class="string">"Writing file "</span> + arg)</span>;</span><br><span class="line">      BufferedReader in =</span><br><span class="line">        new BufferedReader<span class="params">(new FileReader<span class="params">(arg)</span>)</span>;</span><br><span class="line">      zos.putNextEntry<span class="params">(new ZipEntry<span class="params">(arg)</span>)</span>;</span><br><span class="line">      int c;</span><br><span class="line">      while<span class="params">(<span class="params">(c = in.read<span class="params">()</span>)</span> != -<span class="number">1</span>)</span></span><br><span class="line">        out.write<span class="params">(c)</span>;</span><br><span class="line">      in.close<span class="params">()</span>;</span><br><span class="line">      out.flush<span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    out.close<span class="params">()</span>;</span><br><span class="line">    <span class="comment">// Checksum valid only after the file has been closed!</span></span><br><span class="line">    print<span class="params">(<span class="string">"Checksum: "</span> + csum.getChecksum<span class="params">()</span>.getValue<span class="params">()</span>)</span>;</span><br><span class="line">    <span class="comment">// Now extract the files:</span></span><br><span class="line">    print<span class="params">(<span class="string">"Reading file"</span>)</span>;</span><br><span class="line">    FileInputStream fi = new FileInputStream<span class="params">(<span class="string">"test.zip"</span>)</span>;</span><br><span class="line">    CheckedInputStream csumi =</span><br><span class="line">      new CheckedInputStream<span class="params">(fi, new Adler32<span class="params">()</span>)</span>;</span><br><span class="line">    ZipInputStream in2 = new ZipInputStream<span class="params">(csumi)</span>;</span><br><span class="line">    BufferedInputStream bis = new BufferedInputStream<span class="params">(in2)</span>;</span><br><span class="line">    ZipEntry ze;</span><br><span class="line">    while<span class="params">(<span class="params">(ze = in2.getNextEntry<span class="params">()</span>)</span> != null)</span> &#123;</span><br><span class="line">      print<span class="params">(<span class="string">"Reading file "</span> + ze)</span>;</span><br><span class="line">      int x;</span><br><span class="line">      while<span class="params">(<span class="params">(x = bis.read<span class="params">()</span>)</span> != -<span class="number">1</span>)</span></span><br><span class="line">        System.out.write<span class="params">(x)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span><span class="params">(args.length == <span class="number">1</span>)</span></span><br><span class="line">    print<span class="params">(<span class="string">"Checksum: "</span> + csumi.getChecksum<span class="params">()</span>.getValue<span class="params">()</span>)</span>;</span><br><span class="line">    bis.close<span class="params">()</span>;</span><br><span class="line">    <span class="comment">// Alternative way to open and read Zip files:</span></span><br><span class="line">    ZipFile zf = new ZipFile<span class="params">(<span class="string">"test.zip"</span>)</span>;</span><br><span class="line">    Enumeration e = zf.entries<span class="params">()</span>;</span><br><span class="line">    while<span class="params">(e.hasMoreElements<span class="params">()</span>)</span> &#123;</span><br><span class="line">      ZipEntry ze2 = <span class="params">(ZipEntry)</span>e.nextElement<span class="params">()</span>;</span><br><span class="line">      print<span class="params">(<span class="string">"File: "</span> + ze2)</span>;</span><br><span class="line">      <span class="comment">// ... and extract the data as before</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* if(args.length == 1) */</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="comment">/* (Execute to see output) */</span><span class="comment">//:~</span></span><br></pre></td></tr></table></figure>
<p>对于要加入压缩档的每一个文件，都必须调用 putNextEntry()，并将其传递给一个 ZipEntry 对象。ZipEntry 对象包含了一个功能全面的接口，利用它可以获取和设置 Zip 文件内那个特定的 Entry（入口）上能够接受的所有数据：名字、压缩后和压缩前的长度、日期、CRC 校验和、额外字段的数据、注释、压缩方法以及它是否一个目录入口等等。然而，虽然 Zip 格式提供了设置密码的方法，但 Java 的 Zip 库没有提供这方面的支持。而且尽管 CheckedInputStream 和 CheckedOutputStream 同时提供了对 Adler32 和CRC32 校验和的支持，但是 ZipEntry 只支持 CRC 的接口。这虽然属于基层 Zip 格式的限制，但却限制了我们使用速度更快的 Adler32。</p>
<p>为解压文件，ZipInputStream 提供了一个 getNextEntry()方法，能在有的前提下返回下一个 ZipEntry 。作为一个更简洁的方法，可以用 ZipFile 对象读取文件。该对象有一个 entries()方法，可以为 ZipEntry 返回一个 Enumeration（枚举）。</p>
<p>使用 GZIP 或 Zip 库时并不仅仅限于文件——可以压缩任何东西，包括要通过网络连接发送的数据。</p>
<h4 id="Java档案文件">Java档案文件</h4><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">jar</span> <span class="attr_selector">[选项]</span> 说明<span class="attr_selector">[详情单]</span> 输入文件</span><br></pre></td></tr></table></figure>
<p>其中，“选项”用一系列字母表示（不必输入连字号或其他任何指示符）和tar命令类似。如下所示：</p>
<ul>
<li>c 创建新的或空的压缩档</li>
<li>t 列出目录表 </li>
<li>x 解压所有文件</li>
<li>x file 解压指定文件</li>
<li>f 指出“我准备向你提供文件名”。若省略此参数，jar 会假定它的输入来自标准输入；或者在它创建文件时，输出会进入标准输出内</li>
<li>m 指出第一个参数将是用户自建的详情表文件的名字</li>
<li>v 产生详细输出，对 jar 做的工作进行巨细无遗的描述</li>
<li>O 只保存文件；不压缩文件（用于创建一个 JAR 文件，以便我们将其置入自己的类路径中）</li>
<li>M 不自动生成详情表文件</li>
</ul>
<h3 id="对象序列化">对象序列化</h3><p>如果需要一个更严格的持久性机制，可以考虑像Hibernate之类的工具。对象序列化加入到语言中是为了支持两种主要特性，一是Java的远程方法调用（Remote Method Invocation，RMI）；二是Java Beans，后者由 Java 1.1 引入。使用一个 Bean 时，它的状态信息通常在设计期间配置好。</p>
<p><strong>对象实现了Serializable接口，序列化对象就会很简单。首先要创建某些 OutputStream 对象，然后将其封装到 ObjectOutputStream 对象内。此时，只需调用 writeObject() 即可完成对象的序列化，并将其发送给 OutputStream。相反的过程是将一个InputStream 封装到 ObjectInputStream 内，然后调用 readObject()。和往常一样，我们最后获得的是指向一个上溯造型 Object 的句柄，所以必须下溯造型，以便能够直接设置</strong>。</p>
<p>每个类都持有一个特定的serialVersionUID，如果待序列化的对象和目标对象的serialVersionUID不同，那么在反序列化时就会抛出InvalidClassException异常。</p>
<p>对象序列化特别“聪明”的一个地方是它不仅保存了对象的“全景图”，而且能追踪对象内包含的所有句柄并保存那些对象；接着又能对每个对象内包含的句柄进行追踪；以此类推。我们有时将这种情况称为“对象网”</p>
<h4 id="寻找类">寻找类</h4><p>另一台计算机上的程序要想利用序列化的文件内容还原对象，必须保证Java虚拟机能找到相关class文件。</p>
<h4 id="序列化的控制">序列化的控制</h4><p>通过实现 Externalizable 接口，用它代替 Serializable 接口，便可控制序列化的具体过程。这个 Externalizable 接口扩展了 Serializable，并增添了两个方法：writeExternal()和 readExternal() 。在序列化和重新装配的过程中，会自动调用这两个方法，以便我们执行一些特殊操作。</p>
<p><strong>与恢复一个 Serializable（可序列化）对象不同。在后者的情况下，对象完全以它保存下来的二进制位为基础恢复，不存在构建器调用。而对一个 Externalizable 对象，所有普通的默认构建行为都会发生（包括在字段定义时的初始化），而且会调用 readExternal()。必须注意这一事实——特别注意所有默认的构建行为都会进行——否则很难在自己的 Externalizable 对象中产生正确的行为。所以默认构造器得是public的，否则会抛出异常</strong>。</p>
<p>为了让一切正常运作起来，千万不可仅在 writeExternal()方法执行期间写入对象的重要数据（没有默认的行为可用来为一个 Externalizable 对象写入所有成员对象）的，而是必须在 readExternal()方法中也恢复那些数据。</p>
<p><strong>transient（临时）关键字</strong></p>
<p>即使那种信息在对象中具有“private”（私有）属性，但一旦经序列化处理，人们就可以通过读取一个文件，或者拦截网络传输得到它。为解决这个问题，可以用transient（临时）逐个字段地关闭序列化</p>
<p>static 代表类成员，也不会被序列化</p>
<p><strong>Externalizable 的替代方法</strong></p>
<p>我们可以实现 Serializable 接口，并添加（注意是“添加”，而非“覆盖”或者“实现”）名为 writeObject() 和 readObject()的方法。一旦对象被序列化或者重新装配，就会分别调用那两个方法。也就是说，只要提供了这两个方法，就会优先使用它们，而不考虑默认的序列化机制。<br>这些方法必须含有下列准确的签名：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">writeObject</span><span class="params">(ObjectOutputStream stream)</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> readObject(ObjectInputStream stream) <span class="keyword">throws</span> IOException, ClassNotFoundException</span><br></pre></td></tr></table></figure></p>
<p><strong>从设计的角度出发，情况变得有些扑朔迷离。首先，大家可能认为这些方法不属于基础类或者 Serializable接口的一部分，它们应该在自己的接口中得到定义。但请注意它们被定义成“private”，这意味着它们只能由这个类的其他成员调用。然而，我们实际并不从这个类的其他成员中调用它们，而是由ObjectOutputStream 和 ObjectInputStream 的 writeObject() 及 readObject()方法来调用我们对象的writeObject() 和 readObject()方法</strong>。</p>
<p>我们调用 ObjectOutputStream.writeObject()的时候，我们传递给它的 Serializable 对象似乎会被检查是否实现了自己的 writeObject() 。若答案是肯定的是，便会跳过常规的序列化过程，并调用writeObject() 。readObject()也同样。</p>
<p><strong>在我们的 writeObject() 内部，可以调用 defaultWriteObject()，从而决定执行默认的writeObject()。准备通过默认机制写入对象的非 transient 部分，那么必须调用 defaultWriteObject()，令其作为writeObject() 中的第一个操作；并调用 defaultReadObject()，令其作为 readObject()的第一个操作</strong>。</p>
<h4 id="使用持久性">使用持久性</h4><p>针对一个字节数组应用对象的序列化，从而实现对任何 Serializable（可序列化）对象的一个“全面复制”（全面复制意味着复制的是整个对象网，而不仅是基本对象和它的句柄）。</p>
<p>只要将所有东西都序列化到单独一个数据流里，就能恢复获得与以前写入时完全一样的对象网，不会不慎造成对象的重复（实际两个引用都是指向同一个对象，但是如果分开写入不同的流，恢复时，会重复恢复出不同的对象）。</p>
<p>如果想保存系统状态，最安全的做法是当作一种“原子”操作序列化。应将构成系统状态的所有对象都置入单个容器内，并在一次操作里完成那个容器的写入。这样一来，同样只需一次方法调用，即可成功恢复之。</p>
<p>如将一个 static 字段置入基础类，结果只会产生一个字段，因为 static 字段未在衍生类中复制。假如想序列化 static 值，必须亲自动手。</p>
<h3 id="XML">XML</h3><p>书中提到了<code>javax.xml.*</code>类库，XOM类库。此外还有dom4j。</p>
<h3 id="Preferences">Preferences</h3><p>userNodeForPackage()用于个别用户偏好，systemNodeForPackage()用于通用的安装配置。在非静态方法内部，通常用getClass() 标识节点，静态方法中可以用.class。<br>keys()方法以String[]的形式返回。<br>put()，get()有系列针对基本类型的方法<br>get()如果没有这个条目，将使用第二个参数设置该条目。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Preferences prefs = Preferences.userNodeForPackage<span class="params">(PreferencesDemo.class)</span>; </span><br><span class="line">int usageCount = prefs.getInt<span class="params">(<span class="string">"UsageCount"</span>, <span class="number">0</span>)</span>; </span><br><span class="line">usageCount++; </span><br><span class="line">prefs.putInt<span class="params">(<span class="string">"UsageCount"</span>, usageCount)</span>;</span><br></pre></td></tr></table></figure>
<p>第一次运行程序时，UsageCount值为0，随后引用中，他将会是非零值。</p>
<p>数据存储在哪里，不同的系统会不同，例如在windows中，就使用注册表。</p>
<p><strong>Properties</strong></p>
<p>Properties 类表示了一个持久的属性集。Properties 可保存在流中或从流中加载。属性列表中每个键及其对应值都是一个字符串。 </p>
<p>一个属性列表可包含另一个属性列表作为它的“默认值”；如果未能在原有的属性列表中搜索到属性键，则搜索第二个属性列表。（重载的构造器提供了这种功能） </p>
<p>因为 Properties 继承于 Hashtable，所以可对 Properties 对象应用 put 和 putAll 方法。但不建议使用这两个方法，因为它们允许调用者插入其键或值不是 String 的项。相反，应该使用 setProperty 方法。如果在“不安全”的 Properties 对象（即包含非 String 的键或值）上调用 store 或 save 方法，则该调用将失败。类似地，如果在“不安全”的 Properties 对象（即包含非 String 的键）上调用 propertyNames 或 list 方法，则该调用将失败。 </p>
<p>load(Reader) / store(Writer, String) 方法按下面所指定的、简单的面向行的格式在基于字符的流中加载和存储属性。除了输入/输出流使用 ISO 8859-1 字符编码外，load(InputStream) / store(OutputStream, String) 方法与 load(Reader)/store(Writer, String) 对的工作方式完全相同。可以使用 Unicode 转义来编写此编码中无法直接表示的字符；转义序列中只允许单个 ‘u’ 字符。可使用 native2ascii 工具对属性文件和其他字符编码进行相互转换。 </p>
<p>loadFromXML(InputStream) 和 storeToXML(OutputStream, String, String) 方法按简单的 XML 格式加载和存储属性。默认使用 UTF-8 字符编码，但如果需要，可以指定某种特定的编码。XML 属性文档具有以下 DOCTYPE 声明： </p>
<p> &lt;!DOCTYPE properties SYSTEM “<a href="http://java.sun.com/dtd/properties.dtd&quot;&gt;" target="_blank" rel="external">http://java.sun.com/dtd/properties.dtd&quot;&gt;</a><br> 注意，导入或导出属性时不 访问系统 URI (<a href="http://java.sun.com/dtd/properties.dtd)；该系统" target="_blank" rel="external">http://java.sun.com/dtd/properties.dtd)；该系统</a> URI 仅作为一个唯一标识 DTD 的字符串： </p>
<p><strong>JSON</strong></p>
<p>json类库将在Java SE9中加入</p>
]]></content>
    <summary type="html">
    <![CDATA[thinking in java; java编程思想; Java I/O系统;]]>
    
    </summary>
    
      <category term="Thinking in Java" scheme="http://howiefh.github.io/tags/Thinking-in-Java/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java编程思想笔记五]]></title>
    <link href="http://howiefh.github.io/2014/10/30/thinking-in-java-note-5/"/>
    <id>http://howiefh.github.io/2014/10/30/thinking-in-java-note-5/</id>
    <published>2014-10-30T03:54:53.000Z</published>
    <updated>2015-04-05T04:22:16.000Z</updated>
    <content type="html"><![CDATA[<h2 id="数组">数组</h2><h3 id="数组为什么特殊">数组为什么特殊</h3><p>数组和其它容器之间的区别有三方面：效率、编译期类型检查和保存基本类型的能力，但是由于有了泛型容器和自动包装机制，现在最主要的区别就是效率。ArrayList效率低很多。<br><a id="more"></a></p>
<h3 id="数组是第一级对象">数组是第一级对象</h3><p>数组标示符其实是一个引用，指向堆中创建的一个真实对象，可以作为数组初始化语法的一部分隐式的创建此对象，或者用new表达式显示的创建。只读成员length是唯一一个可以访问的字段，通过length你知道的仅仅是数组的大小，而不是里面元素的个数。[]是访问数组对象的唯一方式。</p>
<p>对象数组和基本类型数组在使用上几乎是相同的，唯一区别是对象数组保存的是引用，基本类型数组直接保存基本类型的值。</p>
<p>新生成一个数组，其中所有引用被自动初始化为null，基本类型被初始化为0（boolean是false）。</p>
<p>初始化为指向一个BerylliumSphere引用的数组并给每个元素赋值<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BerylliumSphere</span>[] <span class="built_in">c</span> = <span class="keyword">new</span> <span class="type">BerylliumSphere</span>[<span class="number">4</span>];</span><br><span class="line"><span class="keyword">for</span>(int i = <span class="number">0</span>; i &lt; <span class="built_in">c</span>.length; i++)</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">c</span>[i] == null) <span class="comment">// Can test for null reference</span></span><br><span class="line">        <span class="built_in">c</span>[i] = <span class="keyword">new</span> <span class="type">BerylliumSphere</span>();</span><br></pre></td></tr></table></figure></p>
<p>聚集初始化语法创建数组对象：隐式的使用new语法在堆中创建(Aggregate initialization):<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">BerylliumSphere</span><span class="literal">[]</span> d = &#123; <span class="keyword">new</span> <span class="type">BerylliumSphere</span><span class="literal">()</span>,</span><br><span class="line">        <span class="keyword">new</span> <span class="type">BerylliumSphere</span><span class="literal">()</span>, <span class="keyword">new</span> <span class="type">BerylliumSphere</span><span class="literal">()</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>动态聚集初始化语法创建数组对象，这种方法可以在任意位置创建和初始化数组对象：(Dynamic aggregate initialization):<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="keyword">new</span> <span class="type">BerylliumSphere</span><span class="literal">[]</span>&#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">BerylliumSphere</span><span class="literal">()</span>, <span class="keyword">new</span> <span class="type">BerylliumSphere</span><span class="literal">()</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="返回一个数组">返回一个数组</h3><p>C或者C++中不能返回一个数组，而只能返回一个指向数组的指针，这回造成一些问题，使得控制数组的生命周期变得很困难，并且容易造成内存泄露。Java中，只需要直接返回一个数组即可。</p>
<h3 id="多维数组">多维数组</h3><p>使用花括号创建多维数组，每对花括号括起来的集合都会把你带到下一级数组：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int[][] a = <span class="list">&#123; &#123; 1, 2, 3, &#125;</span>, <span class="list">&#123; 4, 5, 6, &#125;</span>, &#125;;</span><br><span class="line">System.out.println(<span class="keyword">Arrays</span>.deepToString(a));</span><br></pre></td></tr></table></figure></p>
<p><strong>使用Arrays.deepToString()将多维数组转换为多个String</strong></p>
<p><strong>粗糙数组：数组中构成矩阵的每个向量都可以具有任意的长度</strong><br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Random rand = new Random(47);</span><br><span class="line">// 3-D array with varied-length vectors:</span><br><span class="line">int[<span class="link_label"></span>][<span class="link_reference"></span>][<span class="link_label"></span>] a = new int[<span class="link_label">rand.nextInt(7)</span>][<span class="link_reference"></span>][<span class="link_label"></span>];</span><br><span class="line">for(int i = 0; i <span class="xml"><span class="tag">&lt; <span class="attribute">a.length</span>; <span class="attribute">i</span>++) &#123;</span><br><span class="line">    <span class="attribute">a</span>[<span class="attribute">i</span>] = <span class="attribute">new</span> <span class="attribute">int</span>[<span class="attribute">rand.nextInt</span>(<span class="attribute">5</span>)][];</span><br><span class="line">    <span class="attribute">for</span>(<span class="attribute">int</span> <span class="attribute">j</span> = <span class="attribute">0</span>; <span class="attribute">j</span> &lt; <span class="attribute">a</span>[<span class="attribute">i</span>]<span class="attribute">.length</span>; <span class="attribute">j</span>++)</span><br><span class="line">        <span class="attribute">a</span>[<span class="attribute">i</span>][<span class="attribute">j</span>] = <span class="attribute">new</span> <span class="attribute">int</span>[<span class="attribute">rand.nextInt</span>(<span class="attribute">5</span>)];</span><br><span class="line">&#125;</span><br><span class="line"><span class="attribute">System.out.println</span>(<span class="attribute">Arrays.deepToString</span>(<span class="attribute">a</span>));</span></span></span><br></pre></td></tr></table></figure></p>
<p>也可以使用聚集初始化语法创造粗糙数组。自动包装机制对数组初始化器也起作用</p>
<h3 id="数组与泛型">数组与泛型</h3><p><strong>通常，数组与泛型不能很好结合，你不能实例化具有参数化类型的数组。<code>Peel&lt;Banana&gt;[] peels = new Peel&lt;&gt;[10];</code>不合法，擦除会移除参数类型信息，而数组必须知道它们所持有的确切类型，以强制保证类型安全</strong>。</p>
<p><strong>但是它允许你创建对这种数组的引用。你可以创建非泛型的数组，然后将其转型</strong>。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;[] la = (<span class="built_in">List</span>&lt;<span class="built_in">String</span>&gt;[]) <span class="keyword">new</span> ArrayList[<span class="number">10</span>];</span><br></pre></td></tr></table></figure></p>
<p>这样的问题是数组是协变类型的，因此<code>List&lt;String&gt;[]</code>也是一个Object[]，并且利用这点可以把<code>ArrayList&lt;Integer&gt;</code>赋值到数组中，不会有任何编译期或运行时错误。如果知道将来不会向上转型，并且需求也相对比较简单，那么你仍旧可以创建泛型数组。</p>
<p>你也可以参数化数组本身的类型：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassParameter</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> T[] f(T[] arg) &#123; <span class="keyword">return</span> arg; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MethodParameter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] f(T[] arg) &#123; <span class="keyword">return</span> arg; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>一般而言，泛型在类或方法的边界处很有效，而在类或方法的内部，擦除会使得泛型变得不适用，例如，你不能创建泛型数组：<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 非法！</span><br><span class="line">//!<span class="instruction"> array </span>=<span class="instruction"> new </span>T<span class="keyword">[</span>size];<span class="instruction"></span><br><span class="line">array </span>=<span class="function"> (</span>T<span class="keyword">[</span>]<span class="function">)</span>new Object<span class="keyword">[</span>size]; // <span class="string">"unchecked"</span> Warning</span><br><span class="line">// 非法！</span><br><span class="line">//!<span class="keyword"> public</span> &lt;T&gt; T<span class="keyword">[</span>]<span class="function"> makeArray(</span><span class="function">)</span> &#123;<span class="instruction"> return </span>new T<span class="keyword">[</span>10]; &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>由于试图创建的类型已被擦除，所以是类型未知的数组，你可以创建Object数组然后将其转型，但是会得到一个”不受检查”的警告，因为这个数组没有真正持有或动态检查类型T</strong>。</p>
<h3 id="创建测试数据">创建测试数据</h3><h4 id="Arrays-fill()">Arrays.fill()</h4><p><strong>只能用同一个值</strong>（同一个对象引用，因此数组中所有元素都指向同一个对象）填充各个位置，可以填充整个数组或数组的某个区域。</p>
<h4 id="数据生成器">数据生成器</h4><p>为了更灵活的创建更有意义的数组，可以使用数据生成器。<br><figure class="highlight capnproto"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Generator</span>&lt;T&gt; </span>&#123; T next(); &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Arrays实用功能">Arrays实用功能</h3><p>Arrays类有一套用于数组的静态方法（所有这些方法对各种基本类型和Object类而重载过）：</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>equals()</td>
<td>比较两个数字是否相等</td>
</tr>
<tr>
<td>deepEquals()</td>
<td>用于多维数组比较</td>
</tr>
<tr>
<td>fill()</td>
<td>填充数组</td>
</tr>
<tr>
<td>sort()</td>
<td>数组排序</td>
</tr>
<tr>
<td>binarySearch()</td>
<td>在已经排序的数组中查找元素</td>
</tr>
<tr>
<td>toString</td>
<td>产生数组的String表示</td>
</tr>
<tr>
<td>hashCode()</td>
<td>产生数组的散列码</td>
</tr>
<tr>
<td>asList()</td>
<td>接受任意的序列或数组作为其参数，并转换为List容器</td>
</tr>
</tbody>
</table>
<h4 id="复制数组">复制数组</h4><p><strong>System.arraycopy(): 复制数组，比用for循环复制要快很多，该方法对所有类型做了重载</strong><br><strong>注意复制对象数组的时候，只是浅复制</strong>。另外，System.arraycopy()不会执行自动包装和自动拆包，两个数组必须具有相同的类型。</p>
<h4 id="数组的比较">数组的比较</h4><p>Arrays.equals(): 相等的条件：元素个数相等，对应位置的元素也相等。</p>
<h4 id="数组元素的比较">数组元素的比较</h4><p><strong>程序设计的基本目标是“将保持不变的事物与发生改变的事物相分离”。使用策略设计模式，可以将“会发生变化的代码”封装在单独的类中，你可以将策略对象传递给总是相同的代码，这些代码将使用策略来完成其算法</strong>。</p>
<p>Java有两种方式来提供比较功能。第一种是通过类实现Comparable接口（此接口只有一个compareTo()方法）。<br>第二种是创建实现了Comparator接口的单独的类。这种方法在已有的类并没有实现Comparable接口或实现了该接口但是实现方式不太满意的时候使用。</p>
<p>Collections的reverseOrder方法可以产生一个Comparator，可以反转自然的排序顺序：</p>
<h4 id="数组排序">数组排序</h4><p>使用内置的排序方法，可以对任意的基本类型数组排序，也可以对对象数组排序，只要该对象实现了Comparable接口，或者具有相关联的Comparator<br>Java标准库中的排序算法针对正排序的特殊类型进行了优化： <strong>针对基本类型的快速排序；针对对象设计的“稳定归并排序”</strong>。所以无需担心排序的性能问，除非确实确定了排序不分是程序效率的瓶颈。</p>
<h4 id="在已排序的数组中查找">在已排序的数组中查找</h4><p>如果数组排好序了，可以使用Arrays.binarySearch()进行查找，对未排序的数组使用binarySearch，会产生意想不到的结果。</p>
<ul>
<li>查找到了则返回大于等于0的整数</li>
<li>否则返回负值，表示保持数组排序状态下此目标所应该插入的位置，此负值计算方法： <code>-(插入点) - 1</code></li>
</ul>
<p>如果使用Comparator排序对象数组（基本类型数组无法使用Comparator进行排序）了，使用binarySearch对对象数组进行排序的时候必须提供同样的Comparator</p>
<p>优先容器而不是数组，只有在证明性能成为问题，并且切换到数组对性能有所帮助时，你才应该将程序重构为使用数组。</p>
<h2 id="容器深入研究">容器深入研究</h2><h3 id="完整的容器分类法">完整的容器分类法</h3><p><img src="http://fh-1.qiniudn.com/full_container_taxonomy.png" alt="完整的容器分类法"><br>虚线框表示abstract类，Abstract开头的类是部分实现了特定接口的工具。</p>
<h3 id="填充容器">填充容器</h3><p><strong>static方法<code>Collections.fill()</code>、<code>Collections.nCopies()</code>只复制一个对象引用来填充整个容器，并且只对List对象有用，但是所产生的列表可以传递给构造器或<code>addAll()</code>方法</strong>。</p>
<p><strong><code>Collections.fill()</code>方法只能替换已经在List中存在的元素，而不能添加新的元素</strong>。</p>
<p><code>Object.toString()</code>：该类的名字+该对象的散列码(无符号十六进制表示，通过调用<code>hashCode()</code>生成的)</p>
<h4 id="一种Generator解决方案">一种Generator解决方案</h4><p>所有的Collection子类型都有一个接收另一个Collection对象的构造器，用所接收的Collection对象中的元素来填充新的容器。 </p>
<h4 id="Map生成器">Map生成器</h4><p>可以使用工具来创建任何用于Map或Collection的生成数据集，然后通过构造器或<code>Map.putAll()</code>和<code>Collection.addAll()</code>方法来初始化Map和Collection。</p>
<h4 id="使用Abstract类">使用Abstract类</h4><p>对于产生用于容器的测试数据问题，另一种解决方式是创建定制的Collection和Map实现。每个java.util容器都有其自己的Abstract类，它们提供了该容器的部分实现，因此你必须做的只是去实现那些产生想要的容器所必需的方法。如果所产生的容器是只读的，那么你提供的方法数量将减少到最少。</p>
<p>亨元：在普通的解决方案需要过多的对象，或者产生普通对象太占用空间时使用亨元。亨元模式使得对象的一部分可以被具体化，因此，与对象中的所有事物都包含在对象内部不同，我们可以在更高效的外部表中查找对象的一部分或整体（或者通过其他节省空间的计算来产生对象的一部分或整体）。 </p>
<p>为了创建只读的Map，可以继承AbstractMap并实现<code>entrySet()</code>，为了创建只读的Set，可以继承AbstractSet并实现<code>iterator()</code>和<code>size()</code>。</p>
<p>net/mindview/util/Countries.java代码:<code>FlyweightMap</code>必须实现<code>entrySet()</code>方法，它需要定制的Set实现和定制的<code>Map.Entry</code>类。这里正是亨元部分：每个<code>Map.Entry</code>对象都只存储了它的索引，而不是实际的键和值。当你调用<code>getKey()</code>和<code>getValue()</code>时，它们会使用该索引来返回恰当的DATA元素。EntrySet可以确保它的size不会大于DATA。</p>
<h3 id="Collection的功能方法">Collection的功能方法</h3><p>是Set或List可以执行的操作(List还有额外的功能),Map不是继承自Collection的。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述 </th>
</tr>
</thead>
<tbody>
<tr>
<td><code>boolean add(T)</code></td>
<td>确保容器持有具有泛型类型T的参数。如果没有将此参数添加进容器，则返回false（这是可选的方法）</td>
</tr>
<tr>
<td><code>boolean addAll(Collection&lt;? extends T&gt;)</code></td>
<td>添加参数中所有元素。只要添加了任意元素就返回true（可选）</td>
</tr>
<tr>
<td><code>void clear()</code></td>
<td>移除容器中的所有元素(可选)</td>
</tr>
<tr>
<td><code>boolean contains(T)</code></td>
<td>如果容器中已经持有具有泛型类型T此参数，则返回true</td>
</tr>
<tr>
<td><code>boolean containsAll(Collection&lt;?&gt;)</code></td>
<td>如果容器持有此参数中的所有元素，则返回true</td>
</tr>
<tr>
<td><code>boolean isEmpty()</code></td>
<td>容器中没有元素时返回true。</td>
</tr>
<tr>
<td><code>Iterator&lt;T&gt; iterator()</code></td>
<td>返回一个<code>Iterator&lt;T&gt;</code>，可以用来遍历容器中的所有元素。</td>
</tr>
<tr>
<td><code>boolean remove(Object)</code></td>
<td>如果参数在容器中，则移除此元素的一个实例。如果做了移除动作，则返回true(可选的)</td>
</tr>
<tr>
<td><code>boolean removeAll(Collection&lt;?&gt;)</code></td>
<td>移除参数中的所有元素。只要有移除动作发生就返回true。（可选的）</td>
</tr>
<tr>
<td><code>boolean retainAll(Collection&lt;?&gt;)</code></td>
<td>只保存参数中的元素（应用集合论的“交集”概念）。只要Collection发生了改变就返回true。(可选)</td>
</tr>
<tr>
<td><code>int size()</code></td>
<td>返回容器中元素的数目</td>
</tr>
<tr>
<td><code>Object[] toArray()</code></td>
<td>返回一个数组，该数组包含容器中的所有元素。</td>
</tr>
<tr>
<td><code>&lt;T&gt; T[] toArray(T[] a)</code></td>
<td>返回一个数组，该数组包含容器中的所有元素。返回结果的运行时类型与参数数组a的类型相同，而不是单纯的Object。</td>
</tr>
</tbody>
</table>
<p><strong>请注意，其中不包括随机访问选择元素的get()方法。因为Collection包括Set，而Set是自己维护内部顺序的（这使得随机访问变得没有意义）。因此，如果想检查Collection中的元素，就必须使用迭代器。</strong></p>
<h3 id="可选操作">可选操作</h3><p>执行各种不同的添加和移除的方法在Collection接口中都是可选操作。这意味着实现类并不需要为这些方法提供功能定义。</p>
<p>这是一种不寻常的接口定义方式。接口是面向对象设计中的契约，它声明“无论你选择如何实现该接口，我保证你可以向该接口（描述正式的interface关键字和“任何类或子类支持的方法”）发送这些消息。”但是可选操作违反了这个非常基本的原则，它声明调用这些方法将不会执行有意义的行为，相反，它们会抛出异常。这看起来好像是编译器类型安全被抛弃了。 </p>
<p>事情并不那么糟。如果一个操作是可选的，编译器仍旧会严格要求你只能调用该接口中的方法。这与动态语言不同，动态语言可以在任何对象上调用任何方法，并且可以在运行时发现某个特定调用是否可以工作。</p>
<p><strong>为什么你会将方法定义为可选的呢？那是因为这样做可以防止在设计中出现接口爆炸的情况。“未获支持的操作”这种方式可以实现Java容器类库的一个重要目标：容器应该易学易用。未获支持的操作是一种特例，可以延迟到需要时再实现</strong>。但是，为了让这种方式能够工作：</p>
<ul>
<li>UnsupportedOperationException必须是一种罕见事情。即，对于大多数类来说，所有操作都应该可以工作，只有在特例中才会有未获支持的操作。在Java容器类库中确实如此，因为你在90%的时间里面使用的容器类，如ArrayList、LinkedList、HashSet和HashMap，以及其他的具体实现，都支持所有的操作。这种设计留下了一个“后门”，如果你想创建新的Collection，但是没有为Collection接口中的所有方法都提供有意义的定义，那么它仍旧适合现有的类库。</li>
<li>如果一个操作是未获支持的，那么在实现接口的时候可能就会导致UnsupportedOperationException异常，而不是将产品交给客户以后才出现异常，这种情况是有道理的。毕竟，它表示编程上有错误：使用了不正确的接口实现。</li>
</ul>
<p>值得注意的是，未获支持的操作只有在运行时才能探测到，因此它们表示动态类型检查。如果你以前使用的是像C++这样的静态类型语言，那么可能会觉得Java也只是另一种静态类型语言，但是它还有大量的动态类型机制，因此很难说它到底是哪一种类型的语言。</p>
<h4 id="未获支持的操作">未获支持的操作</h4><p>最常见的未获支持的操作，都来源于背后由固定尺寸的数据结构支持的容器。当你用Arrays.asList()将数组转换为List时，就会得到这样的容器。你还可以通过使用Collection类中“不可修改”的方法，选择创建任何会抛出UnsupportedOperationException的容器（包括Map）。</p>
<p><strong>因为<code>Arrays.asList()</code>会生成一个List，它基于一个固定大小的数组，任何会引起对底层数据结构的尺寸进行修改的方法都会产生一个<code>UnsupportedOperationException</code>异常，以表示对未获支持操作的调用（一个编程错误）</strong>。</p>
<p>注意，应该把<code>Arrays.asList()</code>的结果作为构造器的参数传递给任何Collection（或者使用<code>addAll()</code>方法或<code>Collections.addAll()</code>静态方法），这样可以生成允许使用所有的方法的普通容器。Collections类中的“不可修改”的方法（unmodifiableList()）将容器包装到一个代理中，只要你执行任何视图修改容器的操作，这个代理都会产生<code>UnsupportedOperationException</code>异常。使用这些方法的目标就是产生“常量”容器对象。</p>
<p><strong><code>Arrays.asList()</code>返回固定尺寸的List，而<code>Collections.unmodifiableList()</code>产生不可修改的列表</strong>。</p>
<h3 id="List的功能方法">List的功能方法</h3><p>基本的List使用：调用<code>add()</code>添加对象，使用<code>get()</code>一次取出一个元素，以及调用<code>iterator()</code>获取用于该序列的Iterator。</p>
<h3 id="Set和存储顺序">Set和存储顺序</h3><table>
<thead>
<tr>
<th>类</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Set(interface)</td>
<td>存入Set的每个元素都必须是唯一的，因为Set不保存重复元素。加入Set的元素必须定义equals()方法以确保对象唯一性。Set与Collection有完全一样的接口。Set接口不保证维护元素的次序。</td>
</tr>
<tr>
<td>HashSet</td>
<td>如果没有其他的限制，这就应该是你默认的选择，因为它对速度进行了优化，为快速查找而设计的Set。存入HashSet的元素必须定义hashCode()</td>
</tr>
<tr>
<td>TreeSet（SortedSet的唯一实现）</td>
<td>保存次序的Set，底层为树结构。使用它可以从Set中提取有序的序列。元素必须实现Comparable接口</td>
</tr>
<tr>
<td>LinkedHashSet</td>
<td>具有HashSet的查询速度，且内部使用链表维护元素的顺序（插入的次序））。于是在使用迭代器遍历Set时，结果会按元素插入的次序显示。元素也必须定义hashCode()方法</td>
</tr>
</tbody>
</table>
<p>你必须为散列存储和树形存储都创建一个<code>equals()</code>方法，但是<strong><code>hashCode()</code>只有在这个类将会被置于<code>HashSet</code>(这是有可能的，因为它通常是你的Set实现的首先)或者<code>LinkedHashSet</code>中时才是必须的。但是，对于良好的编程风格而言，你应该在覆盖<code>eqauls()</code>方法时，总是同时覆盖<code>hashCode()</code>方法</strong>。</p>
<p><strong>在<code>compareTo()</code>中，我没有使用“简洁明了”的形式<code>return i – i2</code>，因为这是一个常见的编程错误，它只有在i和i2都是无符号的int时才能正确工作。对于Java的有符号int，它就会出错，因为int不够大，不足以表现两个有符号的int的差。例如i是很大的正整数，而j是很大的负整数，<code>i-j</code>就会溢出并且返回负值，这就不正确了</strong>。</p>
<h4 id="SortedSet">SortedSet</h4><p><code>SortedSet</code>中的元素可以保证处于排序状态：<br><code>Comparator comparator()</code> 返回当前Set使用的Comparator；或者返回null，表示以自然方式排序。<br><code>Object first()</code>返回容器中的第一个元素<br><code>Object last()</code>返回容器中的最末一个元素<br><code>SortedSet subSet(fromElement,toElement)</code>生成此Set的子集，范围从fromElement(包含)到toElement(不包含)<br><code>SortedSet headSet(toElement)</code>生成此Set的子集，由小于toElement的元素组成<br><code>SortedSet tailSet(fromElement)</code> 生成此Set的子集，由大于或等于fromElement的元素组成</p>
<h3 id="队列">队列</h3><p>除了并发应用，Queue在Java SE5中仅有的两个实现是<code>LinkedList</code>和<code>PriotityQueue</code>，它们的差异在于排序行为而不是性能。 </p>
<p>除了优先级队列，<code>Queue</code>将精确地按照元素被置于<code>Queue</code>中的顺序产生它们。</p>
<h4 id="双向队列">双向队列</h4><p>可以在任何一端添加或移除元素</p>
<p>在<code>LinkedList</code>中包含支持双向队列的方法，但是在Java标准类库中没有任何显式的用于双向队列的接口。因此<code>LinkedList</code>无法去实现这样的接口，你也无法像在前面的实例中转型到<code>Queue</code>那样去向上转型到<code>Deque</code>。但是，你可以使用组合来创建一个<code>Deque</code>类，并直接从LinkedList中暴露相关的方法。</p>
<h3 id="理解Map">理解Map</h3><h4 id="性能">性能</h4><p>散列码是“相对唯一的”、用以代表对象的int值，它是通过将该对象的某些信息进行转换而生成的。</p>
<table>
<thead>
<tr>
<th>class</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr>
<td>HashMap(默认选择，速度最快)</td>
<td>Map基于散列表的实现（它取代了Hashtable）。插入和查询“键值对”的开销是固定的。可以通过构造器设置容量和负载因子，以调整容器的性能。</td>
</tr>
<tr>
<td>LinkedHashMap</td>
<td>类似于HashMap，但是迭代遍历它时，取得“键值对”的顺序是其插入次序，或者是最近最少使用(LRU)的次序。只比HashMap慢一点；而在迭代访问时反而更快，因为它使用链表维护内部次序。</td>
</tr>
<tr>
<td>TreeMap</td>
<td>基于红黑树的实现。查看“键”或“键值对”时，它们会被排序（次序由Comparable或Comparator决定）。TreeMap的特点在于，所得到的结果是经过排序的。TreeMap是唯一的带有subMap()方法的Map，它可以访问一个子树。</td>
</tr>
<tr>
<td>WeakHashMap</td>
<td>弱键(weak key)映射，允许释放映射所指向的对象；这是为解决某类特殊问题而设计的。如果映射之外没有引用指向某个“键”，则此“键”可以被垃圾回收器回收</td>
</tr>
<tr>
<td>ConcurrentHashMap</td>
<td>一种线程安全的Map，它不涉及同步加锁。</td>
</tr>
<tr>
<td>IdentityHashMap</td>
<td>使用==代替equals()对“键”进行比较的散列映射。专为解决特殊问题而设计的。</td>
</tr>
</tbody>
</table>
<p>对Map中使用的键的要求与对Set中的元素的要求一样，任何键都必须具有一个<code>equals()</code>方法；如果键被用于散列Map，那么它必须还具有恰当的<code>hashCode()</code>方法；如果键被用于<code>TreeMap</code>，那么它必须实现<code>Comparable</code>。</p>
<h4 id="SortedMap">SortedMap</h4><p>使用<code>SortedMap</code>(<code>TreeMap</code>是其现阶段的唯一实现)，可以确保键处于排序状态。这使得它具有额外的功能。</p>
<p><code>Comparator comparator()</code>：返回当前Map使用的Comparator；或者返回null，表示以自然方式排序。<code>K firstKey()</code>返回Map中的第一个键。<code>K lastKey()</code>返回Map中的最末一个键。<code>SortedMap subMap(K fromKey, K toKey)</code>生成此Map的子集，范围由fromKey（包含）到toKey（不包含）的键确定。<code>SortedMap headMap(K toKey)</code>生成此Map的子集，由键小于toKey的所有键值对组成。<code>SortedMap tailMap(K fromKey)</code>生成此Map的子集，由键大于或等于fromKey的所有键值对组成。</p>
<h4 id="LinkedHashMap">LinkedHashMap</h4><p>为了提高速度，<code>LinkedHashSet</code>散列化所有的元素，但是在遍历键值对时，却又以元素的插入顺序返回键值对。此外，可以在构造器中设定<code>LinkedHashSet</code>，使之采用基于访问的最少使用(LRU)算法，于是没有被访问过的（可被看作需要删除的）元素就会出现在队列的前面。对于需要定期清理元素以节省空间的程序来说，此功能使得程序很容易得以实现。</p>
<h3 id="散列与散列码">散列与散列码</h3><p>标准类库中的类被用作<code>HashMap</code>的键，它用得很好，因为它具备了键所需的全部性质。当你创建用作<code>HashMap</code>的键的类，有可能会忘记在其中放置必需的方法，而这是通常会犯的一个错误。</p>
<h4 id="正确的equals()方法必须满足下列5个条件：">正确的equals()方法必须满足下列5个条件：</h4><ul>
<li>自反性。对任意x，<code>x.equals(x)</code>一定返回true。</li>
<li>对称性。对任意x和y，如果<code>y.equals(x)</code>返回true，则<code>x.equals(y)</code>也返回true。 </li>
<li>传递性。对任意x、y、z，如果<code>x.equals(y)</code>返回true，<code>y.equals(z)</code>返回true，则<code>x.equals(z)</code>一定返回true。</li>
<li>一致性。对任意x和y，如果对象中用于等价比较的信息没有改变，那么无论调用<code>x.equals(y)</code>多少次，返回的结果应该保持一致，要么一直是true，要么一直是false。</li>
<li>对任何不是null的x，<code>x.equals(null)</code>一定返回false。</li>
</ul>
<p>再次强调，默认的<code>Object.equals()</code>只是比较对象的地址，所以一个<code>Groundhog(3)</code>并不等于另一个<code>Groundhog(3)</code>。因此，如果要使用自己的类作为HashMap的键，必须同时重载<code>hashCode()</code>和<code>equals()</code>。</p>
<p><code>hashCode()</code>并不需要总是能够返回唯一的标识码，但是<code>equals()</code>方法必须严格地判断两个对象是否相同。<br><strong><code>instanceof</code>悄悄地检查了此对象是否为<code>null</code>，因为如果<code>instanceof</code>左边的参数为<code>null</code>，它会返回<code>false</code></strong>。</p>
<h4 id="理解hashCode()">理解hashCode()</h4><p>如果不为你的键覆盖<code>hashCode()</code>和<code>equals()</code>，那么使用散列的数据结构（<code>HashSet</code>，<code>HashMap</code>，<code>LinkedHashSet</code>或<code>LinkedHashMap</code>）就无法正确处理你的键。</p>
<p><strong><code>entrySet()</code>的恰当实现应该在Map中提供视图，而不是副本，并且这个视图允许对原始映射表进行修改（副本就不行）</strong>。<br>在MapEntry中的eqauls()方法必须同时检查键和值。</p>
<h4 id="为速度而散列">为速度而散列</h4><p>散列的价值在于速度：散列使得查询得以快速进行。由于瓶颈位于键的查询速度，因此解决方案之一就是保持键的排序状态，然后使用<code>Collections.binarySearch()</code>进行查询。</p>
<p>存储一组元素最快的数据结构是数组，所以使用它来表示键的信息（请小心留意，我是说键的信息，而不是键本身）。数组并不保存键本身。而是通过键对象生成一个数字，将其作为数组的下标。这个数字就是散列码，由定义在Object中的、且可能由你的类覆盖的<code>hashCode()</code>方法（在计算机科学的术语中称为散列函数）生成。</p>
<p><strong>为解决数组容量被固定的问题，不同的键可以产生相同的下标。也就是说，可能会有冲突。因此，数组多大就不重要了，任何键总能在数组中找到它的位置。通常，冲突由外部链接处理：数组并不直接保存值，而是保持值的list。然后对list中的值使用equals()方法进行线性的查询</strong>。这部分的查询自然会比较慢，但是，如果散列函数好的话，数组的每个位置就只有较少的值。因此，不是查询整个list，而是快速地跳到数组的某个位置，只对很少的元素进行比较。这便是HashMap会如此快的原因。</p>
<p>散列表中的槽位通常称为桶位(bucket)。</p>
<p>为使散列分布均匀，桶的数量通常使用质数。事实证明，质数实际上并不是散列桶的理想容量。近来，（经过广泛的测试）Java的散列函数都使用2的整数次方。对现在的处理器来说，除法与求余是最慢的操作。使用2的整数次方长度的散列表，可以用掩码代替除法。因为<code>get()</code>是使用最多的操作，求余数的%操作是其开销最大的部分，而使用2的整数次方可以消除此开销（也可能对hashCode()有些影响）。</p>
<h4 id="覆盖hashCode()">覆盖hashCode()</h4><p>设计<code>hashCode()</code>时最重要的因素就是：无论何时，对同一个对象调用<code>hashCode()</code>都应该生成同样的值。如果在将一个对象用<code>put()</code>添加进HashMap时产生一个<code>hashCode()</code>，而用<code>get()</code>取出时却产生了另一个<code>hashCode()</code>值，那么就无法重新取得该对象了。</p>
<p>此外，也不应该使<code>hashCode()</code>依赖于具有唯一性的对象信息，尤其是使用this的值，这只能产生很糟糕的<code>hashCode()</code>。因为这样做无法生成一个新的键，使之与<code>put()</code>中原始的键值对中的键相同。应该使用对象内有意义的识别信息。</p>
<p>对于String而言，<code>hashCode()</code>明显是基于String的内容的。</p>
<p>因此，要想使<code>hashCode()</code>实用，它必须速度快并且必须有意义。也就是说，它必须基于对象的内容生成散列码。散列码不必是独一无二的（应该更关注生成速度，而不是唯一性），但是通过<code>hashCode()</code>和<code>equals()</code>，必须能够完全确定对象的身份。</p>
<p>因为在生成桶的下标前，<code>hashCode()</code>还需要做进一步的处理，所以散列码的生成范围并不重要，只要是<code>int</code>即可。</p>
<p>还有另外一个影响因素：好的<code>hashCode()</code>应该能够产生分布均匀的散列码。如果散列码都集中在一块，那么<code>HashMap</code>或者<code>HashSet</code>在某些区域的负载会很重，这样就不如分布均匀的散列函数快。</p>
<ul>
<li>给<code>int</code>变量result赋予某个非零常量</li>
<li>为对象内每个有意义的域f(即每个可以做equals()操作的域)计算出一个int散列码e:</li>
</ul>
<table>
<thead>
<tr>
<th>域类型</th>
<th>计算                                                           </th>
</tr>
</thead>
<tbody>
<tr>
<td>boolean</td>
<td><code>c=(f?0:1)</code>                                                    </td>
</tr>
<tr>
<td>byte、char、short或int</td>
<td><code>c=(int)f</code>                                                     </td>
</tr>
<tr>
<td>long</td>
<td><code>c=(int)(f^(f&gt;&gt;&gt;32))</code>                                          </td>
</tr>
<tr>
<td>float</td>
<td><code>c=Float.floatToIntBits(f);</code>                                   </td>
</tr>
<tr>
<td>double</td>
<td><code>long l = Double.doubleToLongBits(f);&lt;br/&gt;c=(int)(l ^ (l&gt;&gt;&gt;32))</code></td>
</tr>
<tr>
<td>Object，其equals()调用这个域的equals()</td>
<td><code>c=f.hashCode()</code>                                               </td>
</tr>
<tr>
<td>数组</td>
<td>对每个元素应用上述规则                                         </td>
</tr>
</tbody>
</table>
<ul>
<li>合并计算得到的散列码：<br>  result = 37*result + c;</li>
<li>返回result。</li>
<li>检查<code>hashCode()</code>最后生成的结果，确保相同的对象有相同的散列码。</li>
</ul>
<p><strong>编写正确的hashCode()和equals()类库</strong><br>Apache的Jakarta Commons项目中有很多工具可以帮助你编写正确的<code>hashCode()</code>和<code>equals()</code>。</p>
<h3 id="选择接口的不同实现">选择接口的不同实现</h3><p>只有四种容器：<code>Map</code>、<code>List</code>、<code>Set</code>和<code>Queue</code>。<code>Hashtable</code>、<code>Vector</code>和<code>Stack</code>的“特征”是，它们是过去遗留下来的类，目的只是为了支持老的程序。（最好不要在新的程序中使用它们）。</p>
<h3 id="性能测试框架">性能测试框架</h3><p>为了防止代码重复以及为了提供测试的一致性，将测试过程的基本功能放置到了一个测试框架中。(模板方法设计模式)</p>
<p>通常System.nanoTime()所产生的值的粒度都会大于1（这个粒度会随机器和操作系统的不同而不同），因此，在结果中可能会存在在某些时间点上的重合。</p>
<h4 id="对List的选择">对List的选择</h4><p><strong>最佳的做法可能是将ArrayList作为默认首选，只有你需要使用额外的功能，或者当程序的性能因为经常从表中间进行插入和删除而变坏的时候，才去选择LinkedList</strong>。如果使用的是固定数量的元素，那么既可以选择使用背后有数组支持的List(就像Arrays.asList产生的列表)，也可以选择真正的数组。<br>CopyOnWriteArrayList是List的一个特殊实现，专门用于并发编程。</p>
<h4 id="微基准测试的危险">微基准测试的危险</h4><p>在编写所谓的微基准测试时，你必须要当心，不能做太多的假设，并且要将你的测试窄化。你还必须仔细地确保你的测试运行足够长的时间，以产生有意义的数据，并且要考虑到某些Java HotSpot技术只有在程序运行了一段时间之后才会踢爆问题（这对于短期运行的程序来说也很重要）。根据计算机和所使用的JVM的不同，所产生的结果也会有所不同。</p>
<p>剖析器可以把性能分析工作做得比你好。Java提供了一个剖析器。</p>
<h4 id="对Set的选择">对Set的选择</h4><p>HashSet的性能基本上总是比TreeSet好，特别是在添加和查询元素时，而这两个操作也是最重要的操作。TreeSet存在的唯一原因是它可以维持元素的排序状态，所以，只有当需要一个排好序的Set时，才应该使用TreeSet。因为其内部结构支持排序，并且因为迭代是我们更有可能执行的操作，所以，用TreeSet迭代通常比用HashSet要快。</p>
<p>注意，对于插入操作，LinkedHashSet比HashSet的代价更高；这是由维护链表所带来额外开销造成的。</p>
<h4 id="对Map的选择">对Map的选择</h4><p>除了IdentityHashMap，所有的Map实现的插入操作都会随着Map尺寸的变大而明显变慢。但是，查找的代价通常比插入要小得多，这是个好消息，因为我们执行查找元素的操作要比执行插入元素的操作多得多。</p>
<p>Hashtable的性能大体上与HashMap相当。因为HashMap是用来代替Hashtable的，因此它们使用了相同的底层存储和查找机制。<br>TreeMap通常比HashMap要慢。与使用TreeSet一样，TreeMap是一种创建有序列表的方式。树的行为是：总是保证有序，并且不必进行特殊的排序。一旦你填充了一个TreeMap，就可以调用keySet()方法来获取键的Set视图，然后调用toArray()来产生由这些键构成的数组。之后，你可以使用静态方法Arrays.binarySearch()在排序数组中快速查找对象。当然，这只有在HashMap的行为不可接受的情况下才有意义，因为HashMap本身就被设计为可以快速查找键。你还可以很方便地通过单个的对象创建操作，或者是调用putAll()，从TreeMap中创建HashMap。最后，当使用Map时，你的第一选择应该是HashMap，只有在你要求Map始终保持有序时，才需要使用TreeMap。<br>LinkedHashMap在插入时比HashMap慢一点，因为它维护了散列数据结构的同时还要维护链表（以保持插入顺序）。这是由于这个列表，使得其迭代速度更快。<br>IdentityHashMap则具有完全不同的性能，因为它使用==而不是equals()来比较元素。</p>
<p><strong>HashMap的性能因子</strong><br>可以通过手工调整HashMap来提高其性能，从而满足我们特定应用的需求。<br>容量：表中的桶位数<br>初始容量：表在创建时所拥有的桶位数。HashMap和HashSet都具有允许你指定初始容量的构造器。<br>尺寸：表中当前存储的项数。<br>负载因子：尺寸/容量。空表的负载因子是0，而半满表的负载因子是0.5，依次类推。负载轻的表产生冲突的可能性小，因此对于插入和查找都是最理想的（但是会减慢使用迭代器进行遍历的过程）。HashMap和HashSet都具有允许你指定负载因子的构造器，表示当负载情况达到该负载因子的水平时，容器将自动增加其容量（桶位数），实现方式是使容量大致加倍，并重新将现有对象分布到新的桶位集中（则被称为再散列）</p>
<p>HashMap使用的默认负载因子是0.75（只有当表达到四分之三满时，才进行再散列），这个因子在时间和空间代价之间达到了平衡。更高的负载因子可以减低表所需的空间，但是会增加查找代价，这很重要，因为查找是我们在大多数时间里所做的操作（包括get()和put()）。<br>如果你知道将在HashMap中存储多少项，那么创建一个具有恰当大小的初始容量将可以避免自动再散列的开销。</p>
<h3 id="实用方法(java-util-Collections)">实用方法(java.util.Collections)</h3><ul>
<li>产生Collection或者Collection的具体子类型的动态类型安全的视图。在不可能使用静态检查版本时使用这些方法。  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">checkedCollection</span><span class="params">(Collection&lt;T&gt;, Class&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function"><span class="title">checkedList</span><span class="params">(List&lt;T&gt;,Class&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function"><span class="title">checkedMap</span><span class="params">(Map&lt;K,V&gt;,Class&lt;K&gt; keyType,Class&lt;V&gt; valueType)</span></span></span><br><span class="line"><span class="function"><span class="title">checkedSet</span><span class="params">(Set&lt;T&gt;,Class&lt;T&gt; type)</span></span></span><br><span class="line"><span class="function"><span class="title">checkedSortedMap</span><span class="params">(SortedMap&lt;K,V&gt;,Class&lt;K&gt; keyType,Class&lt;V&gt; valueType)</span></span></span><br><span class="line"><span class="function"><span class="title">checkedSortedSet</span><span class="params">(SortedSet&lt;T&gt;,Class&lt;T&gt; type)</span></span></span><br></pre></td></tr></table></figure></li>
<li>返回参数Collection中最大或最小的元素——采用Collection内置的自然比较法  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">max</span><span class="params">(Collection)</span></span></span><br><span class="line"><span class="function"><span class="title">min</span><span class="params">(Collection)</span></span></span><br></pre></td></tr></table></figure></li>
<li>返回参数Collection中最大或最小的元素——采用Comparator进行比较  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">max</span><span class="params">(Collection,Comparator)</span></span></span><br><span class="line"><span class="function"><span class="title">min</span><span class="params">(Collection,Comparator)</span></span></span><br></pre></td></tr></table></figure></li>
<li>返回target在source中第一次出现的位置，或者在找不到时返回-1<br>  <code>indexOfSubList(List source，List target)</code></li>
<li>返回target在source中最后一次出现的位置，或者在找不到时返回-1<br>  <code>lastIndexOfSubList(List source，List target)</code></li>
<li>使用newVal替换所有的oldVal<br>  <code>replaceAll(List&lt;T&gt;,T oldVal,T newVal)</code></li>
<li>逆转所有元素的次序<br>  <code>reverse(List)</code></li>
<li>返回一个Comparator，它可以逆转实现了<code>Comparator&lt;T&gt;</code>的对象集合的自然顺序。第二个版本可以逆转所提供的Comparator的顺序  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">reverseOrder</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">reverseOrder</span><span class="params">(Comparator&lt;T&gt;)</span></span></span><br></pre></td></tr></table></figure></li>
<li>所有元素向后移动distance个位置，将末尾的元素循环到前面来<br>  <code>rotate(List,int idstance)</code></li>
<li>随机改变指定列表的顺序。第一种形式提供了其自己的随机机制，你可以通过第二种形式提供自己的随机机制  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">shuffle</span><span class="params">(List)</span></span></span><br><span class="line"><span class="function"><span class="title">shuffle</span><span class="params">(List,Random)</span></span></span><br></pre></td></tr></table></figure></li>
<li>使用<code>List&lt;T&gt;</code>中的自然顺序排序。第二种形式允许提供用于排序的Comparator  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">sort</span><span class="params">(List)</span></span></span><br><span class="line"><span class="function"><span class="title">sort</span><span class="params">(List,Random)</span></span></span><br></pre></td></tr></table></figure></li>
<li>将src中的元素复制到dest<br>  <code>copy(List&lt;? super T&gt; dest,List&lt;? extends T&gt; src)</code></li>
<li>交换list中位置i和位置j的元素。通常比你自己写的代码快。<br>  <code>swap(List,int i,int j)</code></li>
<li>用对象x替换list中的所有元素<br>  <code>fill(List&lt;? super T&gt;,T x)</code></li>
<li>返回大小为n的<code>List&lt;T&gt;</code>,此List不可改变，其中的引用都指向x。<br>  <code>nCopies(int n,T x)</code></li>
<li>当两个集合没有任何相同元素时，返回true<br>  <code>disjoint(Collection,Collection)</code></li>
<li>返回Collection中等于x的元素的个数<br>  <code>frequency(Collection,Object x)</code></li>
<li>返回不可变的空List、Map或Set。这些方法都是泛型的，因此所产生的结果将被参数化为所希望的类型  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">emptyList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">emptyMap</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="title">emptySet</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></li>
<li>产生不可变的<code>Set&lt;T&gt;</code>、<code>List&lt;T&gt;</code>或<code>Map&lt;K,V&gt;</code>,它们都只包含基于所给定参数的内容而形成的单一项。  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">singleton</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"><span class="title">singletonList</span><span class="params">(T x)</span></span></span><br><span class="line"><span class="function"><span class="title">singletonMap</span><span class="params">(K key,V value)</span></span></span><br></pre></td></tr></table></figure></li>
<li>产生一个<code>ArrayList&lt;T&gt;</code>，它包含的元素的顺序，与（旧式的）Enumeration(Iterator的前身)返回这些元素的顺序相同。用来转换遗留的老代码。<br>  <code>list(Enumeration&lt;T&gt; e)</code></li>
<li>为参数生成一个旧式的<code>enumeration&lt;T&gt;</code><br>  <code>enumeration(Collection&lt;T&gt;)</code></li>
</ul>
<p>注意：min()和max()能作用于Collection对象，所以你无需担心Collection是否应该被排序(只有在执行binarySearch()之前，才确实需要对List或数组进行排序)<br>与使用数组进行查询和排序一样，如果使用Comparator进行排序，那么binarySearch()必须使用相同的Comparator。</p>
<h4 id="设定Collection或Map为不可修改">设定Collection或Map为不可修改</h4><p>对特定类型的“不可修改的”方法的调用并不会产生编译时的检查，但是转换完成后，任何会改变容器内容的操作都会引起UnsupportedOperationException异常。<br>无论哪一种情况，在将容器设为只读之前，必须填入有意义的数据。装载数据后，就应该使用“不可修改的”方法返回的引用去替换掉原本的引用。这样，就不必担心无意中修改了只读的内容。另一方面，此方法允许你保留一份可修改的容器，作为类的private成员，然后通过某个方法调用返回该容器的“只读”的引用。这样一来，就只有你可以修改容器的内容，而别人只能读取。</p>
<h4 id="Collection或Map的同步控制">Collection或Map的同步控制</h4><p>Collections类有办法能够自动同步整个容器。其语法与“不可修改的”方法相似。</p>
<p>快速报错<br>Java容器有一种保护机制，能够防止多个进程同时修改同一个容器的内容。Java容器类类库采用快速报错机制(fail-fast)。它会探查容器上的任何除了你的进程所进行的操作以外的所有变化，一旦它发现其他进程修改了容器，就会立刻抛出ConcurrentModificationException异常。这就是“快速报错”的意思——即，不是使用复制的算法在事后来检查问题。<br>“快速报错”机制的工作原理：只需创建一个迭代器，然后向迭代器所指向的Collection添加点什么</p>
<p>在容器取得迭代器之后，又有东西被放入到了该容器中。当程序的不同部分修改同一个容器时，就可能导致容器的状态不一致，所以，此异常提醒你，应该修改代码。在此例中，应该添加完所有的元素之后，再获取迭代器。</p>
<p>ConcurrentHashMap、CopyOnWriteArrayList、CopyOnWriteArraySet都使用了可以避免ConcurrentModificationException 的技术</p>
<h3 id="持有引用">持有引用</h3><p>java.lang.ref类库包含了一组类，这些类为垃圾回收提供了更大的灵活性。当存在可能会耗尽内存的大对象的时候，这些类显得特别有用。有三个继承自抽象类Reference的类：SoftReferenct、WeakReference和PhantomReference。当垃圾回收器正在考察的对象只能通过某个Reference对象才“可获得”时，上述这些不同的派生类为垃圾回收器提供了不同级别的间接性指示。</p>
<p>对象是可获得的（reachable），是指此对象可在程序中的某处找到。这意味着你在栈中有一个普通的引用，而它正指向此对象；也可能是你的引用指向某个对象，而那个对象含有另一引用指向正在讨论的对象；也可能有更多的中间链接。如果一个对象是“可获得的”，垃圾回收器就不能释放它，因为它仍然为你的程序所用。如果一个对象不是“可获得的”，那么你的程序将无法使用到它，所以将其回收是安全的。</p>
<p>如果想继续持有对某个对象的引用，希望以后还能够访问到该对象，但是也希望能够允许垃圾回收器释放它，这时就应该使用Reference对象。这样，你可以继续使用该对象，而在内存消耗殆尽的时候又允许释放该对象。</p>
<p><strong>以Reference对象作为你和普通引用之间的媒介（代理），另外，一定不能有普通的引用指向那个对象，这样就能达到上述的目的。（普通的引用指没有经Reference对象包装过的引用。）如果垃圾回收器发现某个对象通过普通引用是可获得的，该对象就不会被释放</strong>。</p>
<p><strong>SoftReference、WeakReference和PhantomReference由强到弱排列，对应不同级别的“可获得”。SoftReference用以实现内存敏感的高速缓存。WeakReference是为实现“规范映射”（canonicalizing mapping）而设计的，它不妨碍垃圾回收器回收映射的“键”（或“值”）。“规范映射”中对象的实例可以在程序的多处被同时使用，以节省存储空间。PhantomReference用以调度回收前的清理工作，它比Java终止机制更灵活</strong>。</p>
<p>使用SoftReference和WeakReference时，可以选择是否要将它们放入ReferenceQueue（用作“回收前清理工作”的工具）。而PhantomReference只能依赖于ReferenceQueue。</p>
<h4 id="WeakHashMap">WeakHashMap</h4><p>容器类中有一种特殊的Map，即WeakHashMap，它被用来保存WeakReference。它使得规范映射更易于使用。在这种映射中，每个值只保存一份实例以节省存储空间。当程序需要那个“值”的时候，便在映射中查询现有的对象，然后使用它（而不是重新再创建）。映射可将值作为其初始化中的一部分，不过通常是在需要的时候才生成“值”。</p>
<p>这是一种节约存储空间的技术，因为WeakHashMap允许垃圾回收器自动清理键和值，所以它显得十分便利。对于向WeakHashMap添加键和值的操作，则没有什么特殊要求。映射会自动使用WeakReference包装它们。允许清理元素的触发条件是：不再需要此键了。</p>
<p>运行此程序，会看到垃圾回收器每个三个键就跳过一个，因为那个键的普通引用被存入keys数组，所以那些对象不能被垃圾回收器回收。</p>
<h3 id="Java_1-0/1-1的容器">Java 1.0/1.1的容器</h3><p>避免使用Vector,Enumeration,Hashtable,Stack,BitSet，尽量使用ArrayList,Iterator,HashMap,LinkedList,EnumSet来替代它们。</p>
<h4 id="BitSet">BitSet</h4><p>如果想要高效率地存储大量“开/关”信息，BitSet是很好的选择。不过它的效率仅是对空间而言；如果需要高效的访问时间，BitSet比本地数组稍慢一点。</p>
<p>BitSet的最小容量是long:64位。如果存储的内容比较小，例如8位，那么BitSet就浪费了一些空间。</p>
<p>如果拥有一个可以命名的固定的标志集合，那么EnumSet和BitSet相比，通常是一种更好的选择，因为EnumSet允许你按照名字而不是数字位的位置进行操作，因此可以减少错误。EnumSet还可以防止你因不注意而添加新的标志位置，这种行为能够引发严重的、难以发现的缺陷。你应该使用BitSet而不是EnumSet的理由只包括：只有在运行时才知道需要多少个标志；对标志命名不合理；需要BitSet中的某些特殊操作。</p>
]]></content>
    <summary type="html">
    <![CDATA[thinking in java; java编程思想; 数组; 容器深入研究]]>
    
    </summary>
    
      <category term="Thinking in Java" scheme="http://howiefh.github.io/tags/Thinking-in-Java/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
</feed>