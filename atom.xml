<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  
  <title><![CDATA[净土]]></title>
  <subtitle><![CDATA[乐不在外而在心，心以为乐，则是境皆乐；心以为苦，则无境不苦。]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://howiefh.github.io//"/>
  <updated>2015-09-01T04:05:51.000Z</updated>
  <id>http://howiefh.github.io//</id>
  
  <author>
    <name><![CDATA[howiefh]]></name>
    <email><![CDATA[howiefh@gmail.com]]></email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[JavaScript 总结]]></title>
    <link href="http://howiefh.github.io/2015/09/01/javascript-summary/"/>
    <id>http://howiefh.github.io/2015/09/01/javascript-summary/</id>
    <published>2015-09-01T02:22:17.000Z</published>
    <updated>2015-09-01T04:05:51.000Z</updated>
    <content type="html"><![CDATA[<p>这篇是对前面<a href="2015/08/28/javascript-grammar/">JavaScript 基本语法</a>，<a href="2015/08/28/javascript-reference-type/">JavaScript 引用类型</a>，<a href="2015/08/28/javascript-oop-function-expression-and-async/">JavaScript 面向对象程序设计、函数表达式和异步编程</a>三篇笔记的总结。</p>
<a id="more"></a>
<h1 id="变量">变量</h1><p>有三个关键字可以用于声明变量：var,let,const。后面两个是ES6新加的。如果没有使用任何关键字，变量是全局变量（不推荐）。</p>
<p>var 声明的变量会被提升到当前作用域的最前面，它的作用域范围也就是当前作用域，即使它是在语句块中声明。</p>
<p>let、const 声明的变量会绑定当前语句块（暂时性死区，temporal dead zone，简称TDZ），被声明之后才可以使用。只在声明所在的块级作用域内有效；不存在“变量提升“现象，只能在声明的位置后面使用；也不可重复声明。不同的是const声明之后不可变，如果声明的是对象，不能再指向另一个对象，但是对象属性可以变。使用Object.freeze方法可以使对象属性也不可变。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//if中的声明语句会被提升到这里</span></span><br><span class="line">  <span class="comment">//var a;</span></span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  a = <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(a);<span class="comment">//10</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(b); <span class="comment">//ReferenceError: can't access lexical declaration `b' before initialization</span></span><br><span class="line">    <span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">//ReferenceError: b is not defined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baz</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">const</span> c = <span class="number">2</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(c); <span class="comment">//ReferenceError: c is not defined</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6规定，var和function声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。</p>
<h2 id="声明提升">声明提升</h2><p>var 声明的变量，function声明的函数会被提升到当前作用域顶端。只有声明才会提升，表达式不会。</p>
<h1 id="数据类型">数据类型</h1><p>共有七种数据类型：Undefined, Null, Boolean, String, Symbol, Number和Object.</p>
<p>前六种是简单（基本）数据类型，其中Boolean, String, Number有基本包装类型，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象</p>
<p>ES6新加了Symbol类型，是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用。</p>
<h2 id="typeof">typeof</h2><ul>
<li>“undefined” 如果这个值未定义</li>
<li>“boolean” 如果这个值是布尔值</li>
<li>“string” 如果这个值是字符串</li>
<li>“number” 如果这个值是数值</li>
<li>“object” 如果这个值是对象或者null</li>
<li>“function” 如果这个值是函数</li>
<li>“symbol” 如果这个值是Symbol类型（ES6新增）</li>
</ul>
<p>实际上JavaScript中函数也是对象。</p>
<p>大体上来说,基本类型的值应该使用 typeof 来检测,而对象的值则应该使用 instanceof 来检测。</p>
<h2 id="对象的类定义">对象的类定义</h2><p>JavaScript 标准文档只给出了一种获取 [[Class]] 值的方法，那就是使用 Object.prototype.toString。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">is</span>(<span class="params">type, obj</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clas = <span class="built_in">Object</span>.prototype.toString.call(obj).slice(<span class="number">8</span>, -<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> obj !== <span class="literal">undefined</span> &amp;&amp; obj !== <span class="literal">null</span> &amp;&amp; clas === type;</span><br><span class="line">&#125;</span><br><span class="line">is(<span class="string">'String'</span>, <span class="string">'test'</span>); <span class="comment">// true</span></span><br><span class="line">is(<span class="string">'String'</span>, <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'test'</span>)); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面例子中，Object.prototype.toString 方法被调用，this 被设置为了需要获取 [[Class]] 值的对象。</p>
<p>Object.prototype.toString 返回一种标准格式字符串，所以上例可以通过 slice 截取指定位置的字符串，如下所示：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.prototype.toString.call([])    <span class="comment">// "[object Array]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(&#123;&#125;)    <span class="comment">// "[object Object]"</span></span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(<span class="number">2</span>)    <span class="comment">// "[object Number]"</span></span><br></pre></td></tr></table></figure></p>
<h2 id="undefined_&amp;_null">undefined &amp; null</h2><p>这两种类型分别都只有一个值，分别是undefined和null。</p>
<p>未声明的变量或声明后没有初始化的变量都是undefined的，typeof会返回undefined。全局变量中有undefined变量，其值也是undefined。函数中没有定义return或return没有显示返回任何内容时返回值会是undefined。函数参数没有显示传递值也会是undefined。</p>
<p>null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因</p>
<p>实际上，undefined值是派生自null值的，<code>null == undefined</code>将会返回true。</p>
<h2 id="类型转换">类型转换</h2><p>在使用相等(==)和不相等(!=)操作符,或者在 if 、 for 及 while 等流控制语句中使用非布尔值时, 最常发生类型转换。避免隐式类型转换，可能会带来不期望的结果。尽量使用<code>===</code>,<code>!==</code>替代<code>==</code>,<code>!=</code>。</p>
<p>最好是使用显示类型转换，如下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//转为数值</span></span><br><span class="line"><span class="keyword">var</span> n1 = +<span class="string">'123'</span>; <span class="comment">//123 和下面等效</span></span><br><span class="line"><span class="keyword">var</span> n2 = <span class="built_in">Number</span>(<span class="string">'123'</span>); <span class="comment">//123</span></span><br><span class="line"><span class="keyword">var</span> n3 = <span class="built_in">parseInt</span>(<span class="string">'123.3blue'</span>); <span class="comment">//123</span></span><br><span class="line"><span class="keyword">var</span> n4 = <span class="built_in">parseInt</span>(<span class="string">'blue123'</span>); <span class="comment">//NaN</span></span><br><span class="line"><span class="keyword">var</span> n5 = <span class="built_in">parseInt</span>(<span class="string">'0123.23'</span>, <span class="number">8</span>); <span class="comment">//83</span></span><br><span class="line"><span class="keyword">var</span> n6 = <span class="built_in">parseFloat</span>(<span class="string">'123.23.12blue'</span>); <span class="comment">//123.23</span></span><br><span class="line"><span class="comment">//转为字符串</span></span><br><span class="line"><span class="keyword">var</span> s1 = <span class="string">''</span> + <span class="number">123</span>; <span class="comment">//"123" 和下面等效</span></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">String</span>(<span class="number">123</span>);<span class="comment">//"123"</span></span><br><span class="line"><span class="comment">//转为布尔值</span></span><br><span class="line"><span class="keyword">var</span> b1 = !!<span class="string">'123'</span>;<span class="comment">//true 和下面等效</span></span><br><span class="line"><span class="keyword">var</span> b3 = <span class="built_in">Boolean</span>(<span class="string">'123'</span>);<span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>技巧<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">''</span> + <span class="number">10</span> === <span class="string">'10'</span>; <span class="comment">// true</span></span><br><span class="line">+<span class="string">'10'</span> === <span class="number">10</span>; <span class="comment">// true</span></span><br><span class="line">!!<span class="string">'foo'</span>;   <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>内置类型（比如 Number 和 String）的构造函数在被调用时，使用或者不使用 new 的结果完全不同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) === <span class="number">10</span>;     <span class="comment">// false, 对象与数字的比较</span></span><br><span class="line"><span class="built_in">Number</span>(<span class="number">10</span>) === <span class="number">10</span>;         <span class="comment">// true, 数字与数字的比较</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">10</span>) + <span class="number">0</span> === <span class="number">10</span>; <span class="comment">// true, 由于隐式的类型转换</span></span><br></pre></td></tr></table></figure>
<p>布尔类型转换规则</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true的值</th>
<th>转换为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>非空字符串</td>
<td>“”</td>
</tr>
<tr>
<td>Number</td>
<td>非零数字值（包括无穷大）</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>n/a（不适用）</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<h2 id="Symbol">Symbol</h2><p>Symbol，表示独一无二的值。对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<p>Symbol 不可以使用new关键字，Symbol函数可以接受字符串参数使其返回值容易被区分，只是作为描述，即使参数相同Symbol函数返回值也不等。</p>
<p>Symbol值作为对象属性名时，不能用点运算符。同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。</p>
<p>Symbol作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。</p>
<p>Symbol.for方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。注意，Symbol函数是总是返回新的值。</p>
<p>Symbol.keyFor方法返回一个已登记的Symbol类型值的key。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.for(<span class="string">'foo'</span>);</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br><span class="line">a === b <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">a === s2 <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(a) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>除了定义自己使用的Symbol值以外，ES6还提供一些内置的Symbol值：对象的Symbol.hasInstance属性，对象的Symbol.iterator属性等等。</p>
<h2 id="Number">Number</h2><p>最小数值和最大数值分别为Number.MIN_VALUE，Number.MAX_VALUE</p>
<p>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在ECMAScript中，0除以0会返回NaN，正数除以0返回Infinity，负数除以0返回-Infinity，因此不会影响其他代码的执行。 NaN本身有两个非同寻常的特点。首先，任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身</p>
<p>ES6提供了二进制和八进制数值的新的写法，分别用前缀0b和0o表示。</p>
<h2 id="模板字符串">模板字符串</h2><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line"><span class="string">`In JavaScript '\n' is a line-feed.`</span></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line"><span class="string">`In JavaScript this is</span><br><span class="line"> not legal.`</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`string text line 1</span><br><span class="line">string text line 2`</span>);</span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`\`Hello <span class="subst">$&#123;name&#125;</span>, how are you <span class="subst">$&#123;time&#125;</span>?\`</span><br><span class="line"><span class="subst">$&#123;'Mr. ' + name&#125;</span></span><br><span class="line">`</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="标签模板">标签模板</h2><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p>
<p>函数tag依次会接收到多个参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">stringArr, ...values</span>)</span>&#123; <span class="comment">// ...  &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p>tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。</p>
<p>tag函数所有参数的实际值如下。</p>
<ul>
<li>第一个参数：[‘Hello ‘, ‘ world ‘, ‘’]</li>
<li>第二个参数: 15</li>
<li>第三个参数：50</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;2+3&#125;</span>!`</span>; <span class="comment">// "Hi\\n5!"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>; <span class="comment">// 'Hi\\u000A!'</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw(&#123; raw: <span class="string">'test'</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 't0e1s2t'</span></span><br></pre></td></tr></table></figure>
<h1 id="操作符">操作符</h1><p>ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的valueOf()和（或）toString()方法，以便取得可以操作的值。</p>
<ul>
<li>一元操作符(<code>++,--,+,-</code>)<br>  在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换。如<code>+&#39;10&#39; === 10 //true</code></li>
<li><p>位操作符(<code>~,&amp;,|,^,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;</code>)<br>  ECMAScript中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。对于开发人员来说，由于64位存储格式是透明的，因此整个过程就像是只存在32位的整数一样。但这个转换过程也导致了一个严重的副效应，即在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理</p>
<p>  默认情况下，ECMAScript 中的所有整数都是有符号整数</p>
</li>
<li><p>布尔操作符(<code>!,&amp;&amp;,||</code>)<br>  非操作符对于非布尔值会先将其转换为布尔值在计算。</p>
<p>  与、或操作符，对于非布尔值，可以理解为先将其转为布尔值在计算，但是返回值仍旧是原值而不是转换后的布尔值。如<code>null &amp;&amp; 1</code>可以理解为<code>false &amp;&amp; true</code>。由于短路效应，第一个操作数是false那么就直接将第一个操作数返回，即返回null。再比如<code>NaN || obj</code>可以理解为<code>false || true</code>，短路效应要到表达式的值就是第二个操作数的值，即obj。</p>
</li>
<li><p>乘性操作符(<code>*,/,%</code>)<br>  在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用Number()转型函数将其转换为数值。也就是说，空字符串将被当作0，布尔值true将被当作1。</p>
<p>  注意<code>0 * Infinity = NaN</code>， <code>Infinity / Infinity = NaN</code>， <code>0 / 0 = NaN</code>， <code>Infinity % 有限大的数值 = NaN</code>， <code>有限大的数值 % 0= NaN</code>， <code>Infinity % Infinity = NaN</code></p>
</li>
<li><p>加性操作符(<code>+,-</code>)<br>  <code>+</code> 如果有操作数是字符串会拼接字符串。拼接时其他类型调用toString()方法</p>
<p>  注意<code>Infinity + (-Infinity) = NaN</code>， <code>Infinity -Infinity = NaN</code>， <code>-Infinity -(-Infinity) = NaN</code></p>
<p>  减法，如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN；如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。</p>
</li>
<li><p>关系操作符(<code>&gt;,&lt;,&gt;=,&lt;=</code>)<br>  对于字符串实际比较的是两个字符串中对应位置的每个字符的字符编码值</p>
<p>  如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。</p>
</li>
<li><p>相等操作符(<code>===,!==,==,!=</code>)<br>  <code>==,!=</code> 比较规则</p>
<ul>
<li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；</li>
<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较； 这两个操作符在进行比较时则要遵循下列规则。</li>
<li>null和undefined是相等的。</li>
<li>要比较相等性之前，不能将null和undefined转换成其他任何值。</li>
<li>如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN。</li>
<li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。</li>
</ul>
</li>
<li>条件操作符(<code>boolean_expression?true_value:false_value</code>)</li>
<li>逗号操作符(<code>,</code>)</li>
<li>赋值操作符(<code>=以及*=、+=等复合赋值运算符</code>)</li>
</ul>
<h2 id="ES6中的-">ES6中的<code>...</code></h2><p>rest参数可以在函数参数和解构时使用，<code>...</code>后面的变量是一个数组，可以将一个序列存入这个数组。</p>
<p>扩展操作符可以看作rest参数的逆操作，可以将一个数组转变为一个序列，可以在函数调用和解构时使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">...a</span>)</span>&#123;&#125;</span><br><span class="line">foo(...[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]);</span><br><span class="line"><span class="keyword">var</span> [...a] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>]; <span class="comment">// a = [1,2,4]</span></span><br><span class="line"><span class="keyword">var</span> [a] = [...[<span class="number">1</span>,<span class="number">2</span>]]; <span class="comment">// a = 1</span></span><br></pre></td></tr></table></figure>
<h2 id="解构赋值">解构赋值</h2><p>ECMAScript6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; <span class="comment">// a即为1，b为2，c为3</span></span><br><span class="line"><span class="keyword">var</span> [,,third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];<span class="comment">//third为"baz"</span></span><br><span class="line"><span class="keyword">var</span> [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; <span class="comment">//head为1，tail为[2,3,4]</span></span><br><span class="line"><span class="keyword">var</span> [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];<span class="comment">// x = 1</span></span><br><span class="line"><span class="keyword">var</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>]; <span class="comment">//x = null</span></span><br></pre></td></tr></table></figure>
<p>实际赋值操作符右边只要是实现了Iterable接口的对象就行，所以Set、Map、Generator函数的返回值都可以。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>().add(<span class="string">'a'</span>).add(<span class="string">'b'</span>);</span><br><span class="line"><span class="keyword">var</span> [a, b] = set; <span class="comment">//a = "a",b = "b"</span></span><br></pre></td></tr></table></figure></p>
<p>解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; bar, foo &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;<span class="comment">//bar = "bbb", foo = "aaa"</span></span><br><span class="line"><span class="keyword">var</span> &#123; baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;; <span class="comment">//baz = undefined</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">"Hello"</span>,</span><br><span class="line">    &#123; y: <span class="string">"World"</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> &#123; p: [x, &#123; y &#125;] &#125; = obj; <span class="comment">//x = "Hello", y = "World"</span></span><br><span class="line"><span class="comment">//默认值生效的条件是，对象的属性值严格等于undefined。</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;x: <span class="literal">undefined</span>&#125;; <span class="comment">//x = 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;x: <span class="literal">null</span>&#125;; <span class="comment">//x = null</span></span><br></pre></td></tr></table></figure></p>
<p>如果左边变量名和右边属性名不一致<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123; foo: baz &#125; = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;; <span class="comment">//baz = "aaa"</span></span><br></pre></td></tr></table></figure></p>
<p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">var</span> x;</span><br><span class="line">&#123;x&#125; = &#123;x:<span class="number">1</span>&#125;; <span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line">(&#123;x&#125; = &#123;x:<span class="number">1</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; log, sin, cos &#125; = <span class="built_in">Math</span>;</span><br></pre></td></tr></table></figure></p>
<p>函数参数也可以使用解构。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span>(<span class="params">&#123;x = 0, y = 0&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line">move(&#123;x: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line">move(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line">move(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure></p>
<p>解构的主要应用</p>
<p>1）交换变量的值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure></p>
<p>2）从函数返回多个值<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a, b, c] = example(); <span class="comment">//a = 1, b = 2, c = 3</span></span><br></pre></td></tr></table></figure></p>
<p>3）函数参数的定义<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">&#123;x, y, z&#125;</span>) </span>&#123; ... &#125;</span><br><span class="line">f(&#123;x:<span class="number">1</span>, y:<span class="number">2</span>, z:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<p>4）提取JSON数据<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  data: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; id, data: number &#125; = jsonData;</span><br><span class="line"><span class="built_in">console</span>.log(id, number) <span class="comment">// 42, [867, 5309]</span></span><br></pre></td></tr></table></figure></p>
<p>5）函数参数的默认值<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = function (url, &#123;</span><br><span class="line">  async = true,</span><br><span class="line">  beforeSend = function () &#123;&#125;,</span><br><span class="line">  cache = true,</span><br><span class="line">  // ... more config</span><br><span class="line">&#125;) &#123;</span><br><span class="line">  // ... do stuff</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>6）遍历Map结构<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">    .set(<span class="string">'first'</span>, <span class="string">'hello'</span>)</span><br><span class="line">    .set(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123; <span class="comment">// ...  &#125;</span></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,value] <span class="keyword">of</span> map) &#123; <span class="comment">// ...  &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>7）输入模块的指定方法<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure></p>
<h1 id="语句">语句</h1><p>ECMAScript 中的语句以一个分号结尾;如果省略分号,则由解析器确定语句的结尾，为了避免自动插入都好改变代码行为，最好加上分号。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="comment">//直接返回了</span></span><br><span class="line"> &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>if, do-while,while,for,label,break,continue,switch和Java没有太大差别。</p>
<p>switch语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串”10”不等于数值10）。</p>
<p>首先，可以在switch语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个case的值不一定是常量，可以是变量，甚至是表达式。</p>
<h2 id="for-in">for-in</h2><p>for-in 语句是一种精准的迭代语句,可以用来枚举对象的属性（包括原型链上的属性）。对于数组则是遍历下标</p>
<h2 id="with">with</h2><p>由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span>(location)&#123;</span><br><span class="line">    <span class="keyword">var</span> qs = search.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">var</span> hostName = hostname;</span><br><span class="line">    <span class="keyword">var</span> url = href;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span><br><span class="line">使用with 语句关联了location 对象。这意味着在with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location对象中是否有同名的属性。如果发现了同名属性，则以location对象属性的值作为变量的值。 严格模式下不允许使用with语句，否则将视为语法错误</span><br><span class="line"></span><br><span class="line">## for-of</span><br><span class="line">实现了Iterable接口的对象都可以用于for-of循环。for-of循环可以使用的范围包括数组、Set和Map结构及其entries,values,keys方法返回的对象、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、Generator函数返回的对象，以及字符串。</span><br><span class="line"></span><br><span class="line">并不是所有类似数组的对象都具有iterator接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。</span><br><span class="line">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="keyword">let</span> arrayLike = &#123; length: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span> &#125;;</span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike);</span><br></pre></td></tr></table></figure></p>
<p>通过for-of遍历对象，一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(someObject)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key + <span class="string">": "</span> + someObject[key]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一个方法是使用Generator函数将对象重新包装一下。</p>
<h1 id="函数">函数</h1><p>ECMAScript中最有意思的可能是函数了，函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。<strong>由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定</strong>。</p>
<p>创建一个函数，在创建Funciton类型实例的同时还会创建一个原型对象，函数变量的prototype属性指向该原型对象。</p>
<h2 id="函数声明和表达式">函数声明和表达式</h2><p>函数通常是使用函数声明语法定义的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是使用函数表达式定义函数的方式，和上面效果是一样的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>需要注意的下面这样声明函数，add只能在函数内部使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>最后一种定义函数的方式是使用Function构造函数。Function构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>); <span class="comment">// 不推荐，因为这种语法会导致解析两次代码(第一次是解析常规 ECMAScript 代码,第二次是解析传入构造函数中的字符串)</span></span><br></pre></td></tr></table></figure></p>
<p>在函数名后加圆括号就是调用函数，不加就只是一个函数指针。所以也可以像下面这样定义一个函数就直接调用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>匿名函数被认为是表达式；因此为了可调用性，它们首先会被执行。</p>
<p>有一些其他的调用函数表达式的方法，比如下面的两种方式语法不同，但是效果一模一样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 另外两种方式</span></span><br><span class="line">+<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;();</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;());</span><br></pre></td></tr></table></figure>
<p>这种立即执行的匿名函数可以用来解决只有一个全局作用域导致的常见错误是命名冲突。</p>
<h2 id="没有重载">没有重载</h2><p>将函数名想象为指针，也有助于理解为什么 ECMAScript中没有函数重载的概念。在创建第二个同名函数时,实际上覆盖了引用第一个函数的函数名变量。</p>
<h2 id="作为值的函数">作为值的函数</h2><p>因为 ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回</p>
<h2 id="arguments">arguments</h2><p>函数内部的arguments是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数，但是arguments存储的参数和形式参数存储的变量空间是独立的。arguments 对象为其内部属性以及函数形式参数创建 getter 和 setter 方法。因此，改变形参的值会影响到 arguments 对象的值，反之亦然。严格模式下不允许创建这些getter和setter，所以两者值互不影响。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line"><span class="pi">    'use strict'</span>;</span><br><span class="line">    num1 = <span class="number">11</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="this">this</h2><p>函数内部的另一个特殊对象是 this ,其行为与 Java 中的 this 大致类似。this引用的是执行函数的环境对象（当在网页的全局作用域中调用函数时，this对象引用的就是window）。</p>
<p>全局范围内使用this，它指向全局对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span> <span class="comment">//浏览器里就是window</span></span><br><span class="line">foo() <span class="comment">//这种函数调用中的this也是全局对象，如果在严格模式下将是undefined</span></span><br><span class="line">test.foo(); <span class="comment">//this指向test对象</span></span><br><span class="line"><span class="keyword">new</span> foo();  <span class="comment">//this指向新创建的对象</span></span><br></pre></td></tr></table></figure></p>
<p>还可以显示设置this<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> bar = &#123;&#125;;</span><br><span class="line"><span class="comment">//在foo 函数内 this 被设置成了 bar。</span></span><br><span class="line">foo.apply(bar, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]); <span class="comment">// 数组将会被扩展，如下所示</span></span><br><span class="line">foo.call(bar, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// 传递到foo的参数是：a = 1, b = 2, c = 3</span></span><br></pre></td></tr></table></figure></p>
<p>常见误解<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; <span class="comment">//this将是全局对象，严格模式是undefined&#125;</span></span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>很容易认为test方法中的this是Foo，但是并不是，这里test符合的是函数调用的情况，this将是全局对象，严格模式是undefined</p>
<p>为什么内部函数（test）没有取得其包含作用域(或外部作用域)的 this 对象呢? 每个函数在被调用时都会自动取得两个特殊变量: this 和 arguments 。内部函数在搜索这两个变量时,只会搜索到其活动对象（当前函数test的作用域）为止,因此永远不可能直接访问外部函数中的这两个变量。不过,可以把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里。像下面这样使用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Foo.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>) </span>&#123; <span class="comment">//that&#125;</span></span><br><span class="line">    test();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>另一个例子，test 就像一个普通的函数被调用；因此，函数内的 this 将不再被指向到 someObject 对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> test = someObject.methodTest;</span><br><span class="line">test();</span><br></pre></td></tr></table></figure></p>
<p>虽然 this 的晚绑定特性似乎并不友好，但这确实是基于原型继承赖以生存的土壤。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Foo.prototype.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Bar</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Bar.prototype = Foo.prototype;</span><br><span class="line"><span class="keyword">new</span> Bar().method();</span><br></pre></td></tr></table></figure>
<p>当 method 被调用时，this 将会指向 Bar 的实例对象。</p>
<h2 id="返回值">返回值</h2><p>没有return，或者return不带任何返回值，都会返回undefined值。</p>
<h2 id="默认参数">默认参数</h2><p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<p>定义了默认值的参数，必须是函数的尾部参数，其后不能再有其他无默认值的参数。</p>
<p>甚至还可以设置双重默认值。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fetch(url, &#123; method = 'GET' &#125; = &#123;&#125;)&#123;</span><br><span class="line">  console.log(method);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，调用函数fetch时，如果不含第二个参数，则默认值为一个空对象；如果包含第二个参数，则它的method属性默认值为GET。</p>
<p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p>
<p>注意，参数默认值所处的作用域，不是全局作用域，而是函数作用域。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line">foo(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<h2 id="rest参数">rest参数</h2><p>rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<p>函数的length属性，不包括rest参数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">a, ...b</span>) </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<h2 id="扩展运算符">扩展运算符</h2><p>将一个数组（只要实现了Iterable接口的对象即可）转为用逗号分隔的参数序列，该运算符主要用于函数调用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br></pre></td></tr></table></figure></p>
<h2 id="箭头函数">箭头函数</h2><p>ES6允许使用“箭头”（=&gt;）定义函数（和Java8中lambda表达式有点类似）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line">(param1, param2, paramN) =&gt; &#123; statements &#125;</span><br><span class="line">(param1, param2, paramN) =&gt; expression <span class="comment">// equivalent to:  =&gt; &#123; return expression; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只有一个参数可以省略圆括号</span></span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; expression</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有参数，则需要一个圆括号</span></span><br><span class="line">() =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果返回一个对象，必须在对象外面加上括号。</span></span><br><span class="line">params =&gt; (&#123;foo: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持Rest参数</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line"><span class="comment">// 支持变量解构</span></span><br><span class="line">(&#123;param1, param2&#125;) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></p>
<p>箭头函数的一个用处是简化回调函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(x =&gt; x * x);</span><br></pre></td></tr></table></figure></p>
<p>箭头函数有几个使用注意点。</p>
<ul>
<li>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。</li>
<li>不可以使用yield命令，因此箭头函数不能用作Generator函数。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length: <span class="number">1</span>,</span><br><span class="line">  doSomeThing()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(x =&gt; x*<span class="keyword">this</span>.length));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.doSomeThing();<span class="comment">//[1,2,3]</span></span><br></pre></td></tr></table></figure>
<p>如果不是使用箭头函数，得到结果是不一样的，如下例，下面this就是window<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  length:<span class="number">1</span>,</span><br><span class="line">  doSomeThing()&#123;</span><br><span class="line">    <span class="built_in">console</span>.log([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.length * x;</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">obj.doSomeThing();<span class="comment">//[0,0,0]</span></span><br></pre></td></tr></table></figure></p>
<p>箭头函数还有可以嵌套</p>
<h2 id="Generator_函数">Generator 函数</h2><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>
<p>Generator函数是一个普通函数，但是有几个特征。一是，function命令与函数名之间有一个星号；二是，可以像调用普通函数一样调用Generator函数，但是返回的结果并不是函数返回值，而是一个实现了Iterable和Iterator接口的对象（该对象的Symbol.iterator方法返回其自身）；三是，函数体内部使用yield语句，每调用Generator函数返回值的next方法，就会到达下一个yield语句，同时将yield语句后面的表达式求值后作为返回结果的value属性（yield语句在英语里的意思就是“产出”）；四是，函数体内也可以有<code>yield*</code>，其后面须是一个Iterable对象；五是，Generator函数返回值的next方法可以有参数，参数将作为函数体内上一个yield语句的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">123</span>+<span class="number">234</span>;</span><br><span class="line">  <span class="keyword">yield</span> x;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> it = gen();</span><br><span class="line">it[<span class="built_in">Symbol</span>.iterator]() === it <span class="comment">// true</span></span><br><span class="line">it.next();</span><br><span class="line">it.next(<span class="string">'a'</span>);</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure>
<p>一个稍复杂的例子，取出嵌套数组的所有成员<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是二叉树的构造函数，三个参数分别是左树、当前节点和右树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params">left, label, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.left = left;</span><br><span class="line">  <span class="keyword">this</span>.label = label;</span><br><span class="line">  <span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是中序（inorder）遍历函数。</span></span><br><span class="line"><span class="comment">// 函数体内采用递归算法，所以左树和右树要用yield*遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inorder</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t) &#123;</span><br><span class="line">    <span class="keyword">yield</span>* inorder(t.left);</span><br><span class="line">    <span class="keyword">yield</span> t.label;</span><br><span class="line">    <span class="keyword">yield</span>* inorder(t.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 下面生成二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否为叶节点</span></span><br><span class="line">  <span class="keyword">if</span> (array.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> Tree(<span class="literal">null</span>, array[<span class="number">0</span>], <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Tree(make(array[<span class="number">0</span>]), array[<span class="number">1</span>], make(array[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tree = make([[[<span class="string">'a'</span>], <span class="string">'b'</span>, [<span class="string">'c'</span>]], <span class="string">'d'</span>, [[<span class="string">'e'</span>], <span class="string">'f'</span>, [<span class="string">'g'</span>]]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二叉树</span></span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> node <span class="keyword">of</span> inorder(tree)) &#123;</span><br><span class="line">  result.push(node);</span><br><span class="line">&#125;</span><br><span class="line">result <span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f', 'g']</span></span><br></pre></td></tr></table></figure></p>
<p>Generator函数还有一个特点，它可以在函数体外通过返回的Iterator对象的throw方法抛出错误，然后在函数体内捕获。</p>
<p>一个对象的属性可以是Generator函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123; * gen()&#123;&#125; &#125;;</span><br><span class="line"><span class="keyword">var</span> obj = &#123; gen: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;&#125; &#125;;</span><br></pre></td></tr></table></figure></p>
<h2 id="尾调用优化">尾调用优化</h2><p>尾调用（Tail Call）是函数式编程的一个重要概念，就是指某个函数的最后一步是调用另一个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面是尾调用，下面三种情况都不是尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后一种情况等同于下面的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>) </span>&#123;<span class="comment">//函数m和n都属于尾调用</span></span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<p>“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span>(<span class="params">b</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的函数不会进行尾调用优化，因为内层函数inner用到了，外层函数addOne的内部变量one。</p>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。</p>
<h2 id="作用域">作用域</h2><p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p>
<p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的一个执行环境。根据 ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value1 &lt; value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (value1 &gt; value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = compare(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure></p>
<p>当调用 compare() 时,会创建一个包含 arguments 、 value1 和 value2 的活动对象。全局执行环境的变量对象(包含 result和 compare )在 compare() 执行环境的作用域链中则处于第二位。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+----------------------+</span><br><span class="line">|<span class="string">     compare          </span>|</span><br><span class="line">|<span class="string">  execution context   </span>|<span class="string">&lt;-------------------------------------------------+</span><br><span class="line">+----------------------+    +------------+      +----------------------+  </span>|</span><br><span class="line">|<span class="string">(scope chain) </span>|<span class="string">      -</span>|<span class="string">---&gt;</span>|<span class="string">scope chain </span>|<span class="string">  +--&gt;</span>|<span class="string">global variable object</span>|<span class="string">  </span>|</span><br><span class="line">+----------------------+    +------------+  |<span class="string">   +----------------------+  </span>|</span><br><span class="line">                            |<span class="string">1     </span>|<span class="string">    -</span>|<span class="string">--+   </span>|<span class="string">   compare </span>|<span class="string">         -</span>|<span class="string">--+</span><br><span class="line">                            +------------+      +----------------------+</span><br><span class="line">                            </span>|<span class="string">0     </span>|<span class="string">    -</span>|<span class="string">--+   </span>|<span class="string">   result  </span>|<span class="string"> undefined</span>|</span><br><span class="line">                            +------------+  |<span class="string">   +----------------------+</span><br><span class="line">                                            </span>|</span><br><span class="line">                                            |<span class="string">   +----------------------+</span><br><span class="line">                                            +--&gt;</span>|<span class="string">    compare()         </span>|</span><br><span class="line">                                                |<span class="string">  activation object   </span>|</span><br><span class="line">                                                +----------------------+</span><br><span class="line">                                                |<span class="string"> arguments </span>|<span class="string">  [5,10]  </span>|</span><br><span class="line">                                                +----------------------+</span><br><span class="line">                                                |<span class="string">   value1  </span>|<span class="string">  5       </span>|</span><br><span class="line">                                                +----------------------+</span><br><span class="line">                                                |<span class="string">   value2  </span>|<span class="string">  10      </span>|</span><br><span class="line">                                                +----------------------+</span><br></pre></td></tr></table></figure>
<p>每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在,而像compare() 函数这样的局部环境的变量对象,则只在函数执行的过程中存在。在创建 compare() 函数时,会创建一个预先包含全局变量对象的作用域链,这个作用域链被保存在内部的 [[Scope]] 属性中。当调用 compare() 函数时,会为函数创建一个执行环境,然后通过复制函数的 [[Scope]] 属性中的对象构建起执行环境的作用域链。此后,又有一个活动对象(在此作为变量对象使用)被创建并被推入执行环境作用域链的前端。对于这个例子中 compare() 函数的执行环境而言,其作用域链中包含两个变量对象:本地活动对象和全局变量对象。显然,作用域链本质上是一个指向变量对象的指针列表,它只引用但不实际包含变量对象。</p>
<p>无论什么时候在函数中访问一个变量时,就会从作用域链中搜索具有相应名字的变量。一般来讲,当函数执行完毕后,局部活动对象就会被销毁,内存中仅保存全局作用域(全局执行环境的变量对象)。但是,下面要讲的闭包的情况又有所不同。</p>
<h2 id="闭包">闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式,就是在一个函数内部创建另一个函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> name;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f = fn(<span class="string">"Howie"</span>);</span><br><span class="line">f();</span><br><span class="line">f = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure></p>
<p>即使这个内部函数被返回了,而且是在其他地方被调用了,但它仍然可以访问外部函数的变量 name。之所以还能够访问这个变量,是因为内部函数的作用域链中包含fn() 的作用域。</p>
<p>前面讲的有关如何创建作用域链以及作用域链有什么作用的细节,对彻底理解闭包至关重要。当某个函数被调用时,会创建一个执行环境(execution context)及相应的作用域链。然后,使用 arguments 和其他命名参数的值来初始化函数的活动对象(activation object)。但在作用域链中,外部函数的活动对象始终处于第二位,外部函数的外部函数的活动对象处于第三位,……直至作为作用域链终点的全局执行环境。</p>
<p>fn(“Howie”) 返回后其活动对象并没有被销毁，因为匿名函数（即被返回的f函数）的作用域链中有对其的引用。通过将 f设置为等于 null解除该函数的引用,就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁,其他作用域(除了全局作用域)也都可以安全地销毁了。</p>
<p>过度使用闭包可能会导致内存占用过多，只在绝对必要时使用闭包。</p>
<p>作用域链的这种配置机制引出了一个值得注意的副作用,即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象,而不是某个特殊的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组中每个函数都只会返回10，而不是0到9。i在createFunctions()的活动变量中，而每个匿名函数的作用域链第二个位置就是createFunctions()的活动变量，当createFunctions()返回后，i的值为10，此时每个函数都引用着保存变量 i 的同一个变量对象,所以在每个函数内部 i 的值都是 10。通过创建另一个匿名函数强制让闭包的行为符合预期</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6中我们还可以使用let关键字声明i，这样i仅在for循环中有效，可以得到同样预期的结果。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createFunctions</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        result[i] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="模块">模块</h1><p>ES6中模块功能由三个命令构成：export，import和module。export命令用于用户自定义模块，规定对外接口；import命令用于导入其他模块提供的功能，同时创造命名空间（namespace），防止函数名冲突；module用于整体输入其它模块的提供的功能。</p>
<p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;name, year&#125;;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name <span class="keyword">as</span> nickName, year&#125; <span class="keyword">from</span> <span class="string">'profile'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(nickName);</span><br></pre></td></tr></table></figure>
<p>import花括号里面的变量名必须与导出的变量名相同，可以通过as起别名。下面是另一个示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; from <span class="string">'./someModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br></pre></td></tr></table></figure></p>
<p>如上，如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。最后再看一个示例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> pi = <span class="number">3.1415926</span>;</span><br><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"><span class="keyword">export</span> * from <span class="string">'circle'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">module</span> math from <span class="string">"circleplus"</span>; <span class="comment">//整体导入相当于 import * as math from "circleplus";</span></span><br><span class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">"circleplus"</span>; <span class="comment">//导入circleplus中导出的默认方法</span></span><br><span class="line"><span class="built_in">console</span>.log(exp(math.e));</span><br></pre></td></tr></table></figure></p>
<p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export deault</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。</p>
<h1 id="错误处理">错误处理</h1><p>ECMA-262 定义了下列 7 种错误类型: Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError。可以通过继承这些类型自定义错误类型。</p>
<p>内置的Error对象具有两个标准属性name和message</p>
<ul>
<li><strong>name</strong>：错误名称</li>
<li><strong>message</strong>：错误提示信息</li>
<li><strong>stack</strong>：错误的堆栈（非标准属性，但是大多数平台支持）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x='</span> + x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x='</span> + x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码说明，即使有return语句在前，finally代码块依然会得到执行，且在其执行完毕后，并不影响return语句要返回的值。</p>
<p>必须要给 throw 操作符指定一个值,这个值是什么类型,没有要求。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">throw</span> &#123; name: <span class="string">"JavaScript"</span>&#125;;</span><br></pre></td></tr></table></figure></p>
<p>任何没有通过 try-catch 处理的错误都会触发 window 对象的 error 事件。</p>
<h1 id="垃圾回收">垃圾回收</h1><p>JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。</p>
<p>另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。IE中的COM对象的垃圾收集机制采用的就是引用计数策略，只要在IE中涉及COM对象，就会存在循环引用的问题</p>
<h1 id="面向对象编程">面向对象编程</h1><h2 id="对象">对象</h2><p>ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数</p>
<h3 id="属性类型">属性类型</h3><p>ECMAScript 中有两种属性:数据属性和访问器属性。</p>
<ol>
<li>数据属性<br> 数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>
<li>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>
<li>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为undefined。</li>
</ul>
</li>
<li>访问器属性<br> 访问器属性不包含数据值；它们包含一对儿getter和setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li>
<li>[[Get]]：在读取属性时调用的函数。默认值为undefined。</li>
<li>[[Set]]：在写入属性时调用的函数。默认值为undefined。</li>
</ul>
</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperties(book, &#123;</span><br><span class="line">  _year: &#123;</span><br><span class="line">    value: <span class="number">2004</span></span><br><span class="line">  &#125;,</span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">newValue</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._year = newValue;</span><br><span class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>使用 ECMAScript 5的 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get 和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(book, <span class="string">"_year"</span>);</span><br><span class="line">alert(descriptor.value); <span class="comment">//2004</span></span><br></pre></td></tr></table></figure>
<h3 id="对象使用和属性">对象使用和属性</h3><p>一种方式是使用对象字面量表示法。属性名可以是字符串也可以是Symbol类型的数据（后者必须使用方括号包含）<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name : <span class="string">'Howie'</span>,</span><br><span class="line">  age : <span class="number">26</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>另一种方法是通过构造函数<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'Howie'</span>;</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">26</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure></p>
<p>构造函数一般首字母大写，如果构造函数没有参数，使用new时后面的括号也可以省略。</p>
<p>ES6中可以简写<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nickname = <span class="built_in">Symbol</span>.for(<span class="string">'nickname'</span>);</span><br><span class="line"><span class="keyword">var</span> type = <span class="string">'cat'</span>;</span><br><span class="line"><span class="keyword">var</span> animal = &#123; [nickname]:<span class="string">'mimi'</span>, type ,<span class="string">'come from'</span>:<span class="string">'shan xi'</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>访问属性<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">animal[nickname]</span><br><span class="line">animal.type</span><br><span class="line">animal[<span class="string">'type'</span>]</span><br><span class="line">animal[<span class="string">'come from'</span>]</span><br></pre></td></tr></table></figure></p>
<p>从上例可以看出属性名不是一个有效的变量名（比如属性名中包含空格，或者属性名是 JS 的关键词）</p>
<p>有很多变通方法可以让数字的字面值看起来像对象。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2.</span>toString();<span class="comment">//出错</span></span><br><span class="line"><span class="number">2.</span>.toString(); <span class="comment">// 第二个点号可以正常解析</span></span><br><span class="line"><span class="number">2</span> .toString(); <span class="comment">// 注意点号前面的空格</span></span><br><span class="line">(<span class="number">2</span>).toString(); <span class="comment">// 2先被计算</span></span><br></pre></td></tr></table></figure></p>
<h3 id="原型">原型</h3><p>JavaScript中每个函数都是Function类型的实例，每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个函数的原型对象，而这个对象的用途是包含可以由特定类型的<strong>所有实例共享的属性和方法</strong>。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中。</p>
<p>默认情况下，每个原型对象都有一个constructor属性，这个属性指向 prototype 属性所在实例，也就是构造函数。创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。每个对象都有[[Prototype]]属性（内部属性），虽然在脚本中没有标准的方式访问[[Prototype]]，但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性<code>__proto__</code>，通过它可以访问[[Prototype]]；这个属性指向了构造函数的原型对象，JavaScript中通过递归原型链来查找对象属性，同一个构造函数创建的对象都可以访问到其原型中的属性constructor。除了通过instanceof外也可以通过person.constructor === Person来判断是否是Person类型，但是instanceof更加可靠，因为prototype对象完全可以被覆盖，其属性constructor也就不一定是Person了。</p>
<p>ECMAScript 5增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。</p>
<p>每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。</p>
<p>虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。<code>person1.name = &quot;Greg&quot;;</code>将会覆盖原型中的name属性。</p>
<p>使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不要忘了它是从Object继承来的）只在给定属性存在于对象实例中时，才会返回true。</p>
<p>有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。<code>&quot;name&quot; in person</code>为true</p>
<p>在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为 false 的属性）的实例属性也会在 for-in 循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外。</p>
<p>要取得对象上所有可枚举的实例属性，可以使用ECMAScript 5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.keys(Person.prototype); <span class="comment">//["name","age","jbo","sayName"]</span></span><br><span class="line"><span class="keyword">var</span> keys = <span class="built_in">Object</span>.getOwnPropertyNames(Person.prototype); <span class="comment">//["constructor","name","age","jbo","sayName"]</span></span><br></pre></td></tr></table></figure>
<h3 id="创建对象">创建对象</h3><p>工厂模式、寄生构造函数模式、稳妥构造函数模式都是构造函数（工厂模式中就是普通函数）内部创建一个对象然后返回，通常返回的对象和构造函数没有什么联系。后两者使用new创建对象，工厂模式是直接函数调用。第三种没有公共属性，而且也不引用this的对象。</p>
<p>组合使用构造函数模式和原型模式结合了两者的优点，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。动态原型模式则在此基础上通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="comment">//方法</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="keyword">this</span>.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">    Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要在每个实例共享的属性应该在原型上定义，如方法，如果在this对象上定义，那么每个实例的相同函数名的函数实例实际是不同的，这样就会浪费空间。</p>
<h3 id="class">class</h3><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">  constructor(name, age, job)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName()&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> friend = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。</p>
<p>如果对比前面的组合使用构造函数模式和原型模式，可以发现前面的Person构造函数对应现在Person类的构造方法constructor，前面Person原型上定义的sayName方法现在是类的内部方法。</p>
<p>一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<p>与函数一样，Class也可以使用表达式的形式定义。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Me只能在类内部使用</p>
<p>Class不存在变量提升<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>与ES5一样，在Class内部可以使用get和set关键字，定义访问器属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  get prop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  set prop(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="comment">// 'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="comment">// TypeError: undefined is not a function</span></span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span><br><span class="line">父类的静态方法，可以被子类继承。</span><br><span class="line"></span><br><span class="line">ES6为new命令引入了一个`</span><span class="keyword">new</span>.target<span class="string">`属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，`</span><span class="keyword">new</span>.target<span class="string">`会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</span><br><span class="line"></span><br><span class="line">需要注意的是，子类继承父类时，`</span><span class="keyword">new</span>.target<span class="string">`会返回子类。</span><br><span class="line"></span><br><span class="line">利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</span><br><span class="line">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'本类不能实例化'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="string">``</span><span class="string">`javascript</span><br><span class="line">### 共享变量</span><br><span class="line">在构造函数原型上定义的属性可以被所有实例共享。</span><br><span class="line"></span><br><span class="line">### 静态变量</span><br><span class="line">ES6加入了static关键字。</span><br><span class="line"></span><br><span class="line">构造函数原型链上定义的变量或属性只能通过构造函数访问，也可以当做是静态的。</span><br><span class="line"></span><br><span class="line">### 私有变量</span><br><span class="line">严格来讲,JavaScript 中没有私有成员的概念;所有对象属性都是公有的。不过,倒是有一个私有变量的概念。任何在函数中定义的变量,都可以认为是私有变量,因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。</span><br><span class="line"></span><br><span class="line">我们把有权访问私有变量和私有函数的公有方法称为特权方法(privileged method)。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法</span><br><span class="line">`</span><span class="string">``</span>javascript</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="静态私有变量">静态私有变量</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    MyObject = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//公有/特权方法</span></span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>注意,这个模式在定义构造函数时并没有使用函数声明,而是使用了函数表达式。函数声明只能创建局部函数,但那并不是我们想要的。出于同样的原因,我们也没有在声明 MyObject 时使用 var 关键字。但也要知道,在严格模式下给未经声明的变量赋值会导致错误。</p>
<h3 id="模块模式">模块模式</h3><p>模块模式通过为单例添加私有变量和特权方法能够使其得到增强<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权/公有方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicProperty: <span class="literal">true</span>,</span><br><span class="line">        publicMethod : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<h3 id="增强的模块模式">增强的模块模式</h3><p>有人进一步改进了模块模式,即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例,同时还必须添加某些属性和(或)方法对其加以增强的情况。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">    <span class="comment">//添加特权/公有属性和方法</span></span><br><span class="line">    object.publicProperty = <span class="literal">true</span>;</span><br><span class="line">    object.publicMethod = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回这个对象</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<h2 id="继承">继承</h2><p>JavaScript 不包含传统的类继承模型，而是使用 prototype 原型模型。</p>
<h3 id="原型链">原型链</h3><p>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</p>
<p><img src="http://fh-1.qiniudn.com/jsobj.jpg" alt="JavaScript Object Layout" title="JavaScript Object Layout"></p>
<p>上面这张图将原型链关系描绘地非常清晰</p>
<h3 id="继承方法">继承方法</h3><p>组合继承(combination inheritance) ,有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承,而通过借用构造函数来实现对实例属性的继承。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承属性</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//第二次调用 SuperType()</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">///第一次调用 SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType(<span class="string">"Nicholas"</span>, <span class="number">29</span>);</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName(); <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge(); <span class="comment">//29</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType(<span class="string">"Greg"</span>, <span class="number">27</span>);</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName(); <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge(); <span class="comment">//27</span></span><br></pre></td></tr></table></figure></p>
<p>如果知识用原型链继承，那么像colors这样的引用类型会被子类的所有实例共享，一个实例更改colors，所有都会更改，这不是我们想要的，而结合借用构造函数的继承方法，在构造函数内调用父类的构造方法，通过使用 apply() 和 call() 方法也可以在(将来)新创建的对象上执行构造函数，则解决了所有子类实例共享colors的问题。</p>
<p>组合继承是 JavaScript 最常用的继承模式;不过,它也有自己的不足。组合继承最大的问题就是无论什么情况下,都会调用两次超类型构造函数:一次是在创建子类型原型的时候,另一次是在子类型构造函数内部。没错,子类型最终会包含超类型对象的全部实例属性,但我们不得不在调用子类型构造函数时重写这些属性。</p>
<p>在第一次调用 SuperType 构造函数时, SubType.prototype 会得到两个属性: name 和 colors ;它们都是 SuperType 的实例属性,只不过现在位于 SubType 的原型中。当调用 SubType 构造函数时,又会调用一次 SuperType 构造函数,这一次又在新对象上创建了实例属性 name 和 colors 。</p>
<p>寄生组合式继承,即通过借用构造函数来继承属性,通过原型链的混成形式来继承方法。其背后的基本思路是:不必为了指定子类型的原型而调用超类型的构造函数,我们所需要的无非就是超类型原型的一个副本而已。本质上,就是使用寄生式继承来继承超类型的原型,然后再将结果指定给子类型的原型。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数内部,第一步是创建超类型原型的一个副本。第二步是为创建的副本添加 constructor 属性,从而弥补因重写原型而失去的默认的 constructor 属性。最后一步,将新创建的对象(即副本)赋值给子类型的原型。</p>
<p>ECMAScript 5 新增 Object.create() 方法。这个方法接收两个参数:一个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下,Object.create() 与 object() 方法的行为相同<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>YUI 的 YAHOO.lang.extend() 方法采用了寄生组合继承</p>
<h3 id="extends">extends</h3><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span></span>&#123;</span><br><span class="line">  constructor(name)&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword">extends</span> <span class="title">SuperType</span></span>&#123;</span><br><span class="line">  constructor(name, age)&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  sayAge()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">    <span class="keyword">super</span>.sayName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<p>对比借用构造函数继承，实质是先创建子类的实例对象this，然后再将父类的属性添加到this上面（<code>Parent.apply(this)</code>）。ES6的继承机制则不同，实质是先创建父类的实例对象this（所以必须先调用super方法），然后再用子类的属性修改this。</p>
<p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p>
<p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。</p>
<p>大部分浏览器实现中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>
<ol>
<li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</li>
<li>子类prototype属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的prototype属性。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SubType.__proto__ === SuperType <span class="comment">// true</span></span><br><span class="line">SubType.prototype.__proto__ === SuperType.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>下面，讨论三种特殊情况。</p>
<p>第一种特殊情况，子类继承Object类。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">Object</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>第二种特殊情况，不存在任何继承。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>第三种特殊情况，子类继承null。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">null</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="literal">undefined</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>Object.getPrototypeOf方法可以用来从子类上获取父类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(SubType) === SuperType <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构，比如<code>Array()</code>。以前，这些原生构造函数是无法继承的，即不能自己定义一个Array的子类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</span><br><span class="line">  constructor: &#123;</span><br><span class="line">    value: MyArray,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</span><br><span class="line">colors.length  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">0</span>;</span><br><span class="line">colors[<span class="number">0</span>]  <span class="comment">// "red"</span></span><br></pre></td></tr></table></figure>
<p>之所以会发生这种情况，是因为原生构造函数无法外部获取，通过<code>Array.apply()</code>或者分配给原型对象都不行。ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的属性无法获取，导致无法继承原生的构造函数。</p>
<p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> MyArray();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.length <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<h1 id="原生类型">原生类型</h1><h2 id="Object">Object</h2><p>JavaScript语言的所有对象都是由Object衍生的对象；所有对象都继承了Object.prototype的方法和属性，尽管它们可能被覆盖。</p>
<p>构建方法的参数为空，null或undefined将返回一个空对象，参数为String，Number,Boolean类型相当于使用其对应包装类型创建对象。对于其它类型的对象会返回原对象。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object.assign(target, …sources)</td>
<td>把任意多个的源对象所拥有的自身可枚举属性拷贝给目标对象，然后返回目标对象。</td>
</tr>
<tr>
<td>Object.create(proto, [ propertiesObject ])</td>
<td>创建具有指定原型并可选择包含指定属性的对象。</td>
</tr>
<tr>
<td>Object.defineProperties(obj, props)</td>
<td>将一个或多个属性添加到对象，和/或修改现有属性的特性，并返回该对象。</td>
</tr>
<tr>
<td>Object.defineProperty(obj, prop, descriptor)</td>
<td>将属性添加到对象，或修改现有属性的特性，并返回该对象。</td>
</tr>
<tr>
<td>Object.freeze(obj)</td>
<td>冻结对象是指那些不能添加新的属性，不能修改已有属性的值，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性的对象。也就是说，这个对象永远是不可变的。该方法返回被冻结的对象。</td>
</tr>
<tr>
<td>Object.getOwnPropertyDescriptor(obj, prop)</td>
<td>返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）</td>
</tr>
<tr>
<td>Object.getOwnPropertyNames(obj)</td>
<td>返回一个由指定对象的所有自身属性的属性名（包括不可枚举属性）组成的数组。</td>
</tr>
<tr>
<td>Object.getOwnPropertySymbols(obj)</td>
<td>返回一个数组，该数组包含了指定对象自身的（非继承的）所有 symbol 属性键。</td>
</tr>
<tr>
<td>Object.getPrototypeOf(object)</td>
<td>返回指定对象的原型（也就是该对象内部属性[[Prototype]]的值）。</td>
</tr>
<tr>
<td>Object.is(value1, value2)</td>
<td>返回一个值，该值指示两个值是否相同。它与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身</td>
</tr>
<tr>
<td>Object.isExtensible(obj)</td>
<td>返回指示是否可将新属性添加到对象的值。</td>
</tr>
<tr>
<td>Object.isFrozen(obj)</td>
<td>判断一个对象是否被冻结（frozen）</td>
</tr>
<tr>
<td>Object.isSealed(obj)</td>
<td>判断一个对象是否是密封的（sealed）</td>
</tr>
<tr>
<td>Object.keys(obj)</td>
<td>返回一个由给定对象的所有可枚举自身属性的属性名组成的数组，数组中属性名的排列顺序和使用for-in循环遍历该对象时返回的顺序一致（两者的主要区别是 for-in 还会遍历出一个对象从其原型链上继承到的可枚举属性）。</td>
</tr>
<tr>
<td>Object.preventExtensions(obj)</td>
<td>让一个对象变的不可扩展，也就是永远不能再添加新的属性</td>
</tr>
<tr>
<td>Object.seal(obj)</td>
<td>可以让一个对象密封，并返回被密封后的对象。密封对象是指那些不能添加新的属性，不能删除已有属性，以及不能修改已有属性的可枚举性、可配置性、可写性，但可能可以修改已有属性的值的对象。</td>
</tr>
<tr>
<td>Object.setPrototypeOf(object, prototype)</td>
<td>设置一个对象的原型(既对象的[[Prototype]]内部属性)。</td>
</tr>
</tbody>
</table>
<p>Object原型属性</p>
<ul>
<li>Object.prototype.constructor： 返回一个指向创建了该对象原型的函数引用</li>
<li>Object.prototype.<strong>proto</strong>：非标准，一个对象的<strong>proto</strong> 属性和自己的内部属性[[Prototype]]指向一个相同的值 (通常称这个值为原型),原型的值可以是一个对象值也可以是null(比如说Object.prototype.<strong>proto</strong>的值就是null)</li>
</ul>
<p>Object实例方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>obj.hasOwnProperty(prop)</td>
<td>用来判断某个对象是否含有指定的自身属性</td>
</tr>
<tr>
<td>prototype.isPrototypeOf(obj)</td>
<td>测试一个对象是否存在于另一个对象的原型链上</td>
</tr>
<tr>
<td>obj.propertyIsEnumerable(prop)</td>
<td>返回一个布尔值，表明指定的属性名是否是当前对象可枚举的自身属性</td>
</tr>
<tr>
<td>obj.toLocaleString();</td>
<td>返回一个该对象的字符串表示。该方法主要用于被本地化相关对象覆盖。</td>
</tr>
<tr>
<td>obj.toString()</td>
<td>返回一个代表该对象的字符串。</td>
</tr>
<tr>
<td>obj.valueOf()</td>
<td>返回一个对象的值，默认情况下返回对象本身。</td>
</tr>
</tbody>
</table>
<h2 id="Array">Array</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>();</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(size);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(...items);</span><br></pre></td></tr></table></figure>
<p>如果只有一个参数并且是数值，那么这个参数将用于指定数组大小，否则创建包含这个参数的一个数组。</p>
<p>Array的函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Array.from(arrayLike[, mapFn[, thisArg]])</td>
<td>将一个类数组对象或可迭代对象转换成真实的数组。</td>
</tr>
<tr>
<td>Array.isArray(value)</td>
<td>返回一个布尔值，该值指示对象是否为数组。</td>
</tr>
<tr>
<td>Array.of(…items)</td>
<td>将它的任意多个参数放在一个数组里并返回。</td>
</tr>
</tbody>
</table>
<p>Array 实例的属性</p>
<ul>
<li>length： 数组长度</li>
</ul>
<p>Array 实例的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>concat(…arguments)</td>
<td>将传入的数组或非数组值与原数组合并,组成一个新的数组并返回.</td>
</tr>
<tr>
<td>copyWithin(target, start[, end])</td>
<td>复制数组从start位置到end位置的元素到target，end默认是数组长度</td>
</tr>
<tr>
<td>entries()</td>
<td>返回包含数组的键/值对的迭代器</td>
</tr>
<tr>
<td>every(callbackfn[, thisArg])</td>
<td>测试数组的所有元素是否都通过了指定函数的测试</td>
</tr>
<tr>
<td>fill(value[, start[, end]])</td>
<td>将一个数组中指定区间的所有元素的值, 都替换成或者说填充成为某个固定的值 区间是[start,end)，start默认0，end默认数组长度</td>
</tr>
<tr>
<td>filter(callbackfn[, thisArg])</td>
<td>利用所有通过指定函数测试的元素创建一个新的数组，并返回</td>
</tr>
<tr>
<td>find(predicate[, thisArg])</td>
<td>返回数组中满足测试条件的一个元素，如果没有满足条件的元素，则返回undefined</td>
</tr>
<tr>
<td>findIndex(predicate[, thisArg])</td>
<td>用来查找数组中某指定元素的索引, 如果找不到指定的元素, 则返回 -1</td>
</tr>
<tr>
<td>forEach(callbackfn[, thisArg])</td>
<td>让数组的每一项都执行一次给定的函数</td>
</tr>
<tr>
<td>indexOf(searchElement[, fromIndex])</td>
<td>返回根据给定元素找到的第一个索引值，否则返回-1</td>
</tr>
<tr>
<td>keys()</td>
<td>返回包含数组的索引值的迭代器</td>
</tr>
<tr>
<td>lastIndexOf(searchElement[, fromIndex])</td>
<td>返回指定元素（也即有效的 JavaScript 值或变量）在数组中的最后一个的索引，如果不存在则返回 -1。从数组的后面向前查找，从 fromIndex 处开始</td>
</tr>
<tr>
<td>map(callbackfn[, thisArg])</td>
<td>返回一个由原数组中的每个元素调用一个指定方法后的返回值组成的新数组</td>
</tr>
<tr>
<td>pop()</td>
<td>从数组中移除最后一个元素并将该元素返回</td>
</tr>
<tr>
<td>push(…items)</td>
<td>添加一个或多个元素到数组的末尾，并返回数组新的长度（length 属性值）</td>
</tr>
<tr>
<td>reduce(callbackfn[, initialValue])</td>
<td>通过对数组中的所有元素（从左到右）调用定义的回调函数来累积单个结果。 回调函数的返回值是累积的结果，并且作为对回调函数的下一个调用中的参数提供</td>
</tr>
<tr>
<td>reduceRight(callbackfn[, initialValue])</td>
<td>通过对数组中的所有元素调用定义的回调函数来按降序顺序（从右到左）累积单个结果。 回调函数的返回值是累积的结果，并且作为对回调函数的下一个调用中的参数提供</td>
</tr>
<tr>
<td>reverse()</td>
<td>颠倒数组中元素的顺序</td>
</tr>
<tr>
<td>shift()</td>
<td>从数组中移除第一个元素并将返回该元素</td>
</tr>
<tr>
<td>slice(start, end)</td>
<td>把数组中一部分的浅复制（shallow copy）存入一个新的数组对象中，并返回这个新的数组</td>
</tr>
<tr>
<td>some(callbackfn[, thisArg])</td>
<td>测试数组中的某些元素是否通过了指定函数的测试</td>
</tr>
<tr>
<td>sort(comparefn)</td>
<td>对数组的元素做原地的排序，并返回这个数组。 sort 可能不是稳定的</td>
</tr>
<tr>
<td>splice(start, deleteCount, …items)</td>
<td>用新元素替换旧元素，以此修改数组的内容</td>
</tr>
<tr>
<td>toLocaleString([reserved1[, reserved2]])</td>
<td>返回一个字符串表示数组中的元素。数组中的元素将使用各自的 toLocaleString 方法转成字符串，这些字符串将使用一个特定语言环境的字符串（例如一个逗号 “,”）隔开</td>
</tr>
<tr>
<td>toString()</td>
<td>返回一个字符串，表示指定的数组及其元素</td>
</tr>
<tr>
<td>unshift(…items)</td>
<td>在数组的开头添加一个或者多个元素，并返回数组新的 length 值</td>
</tr>
<tr>
<td>values()</td>
<td>返回一个新的包含数组中每个索引的取值的 Array Iterator （数组迭代）对象</td>
</tr>
<tr>
<td><a href="">@@iterator</a></td>
<td>返回迭代器</td>
</tr>
</tbody>
</table>
<h2 id="Date">Date</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(dateVal)</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(year, month, date[, hours[, minutes[, seconds[,ms]]]])</span><br></pre></td></tr></table></figure>
<p>Date 函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Date.now()</td>
<td>返回 1970 年 1 月 1日与当前日期和时间之间的毫秒数。</td>
</tr>
<tr>
<td>Date.parse(string)</td>
<td>分析一个包含日期的字符串，并返回该日期与 1970 年 1 月 1 日午夜之间相差的毫秒数。</td>
</tr>
<tr>
<td>Date.UTC(year, month, date[, hours[, minutes[, seconds[,ms]]]])</td>
<td>返回协调通用时间 (UTC)（或 GMT）1970 年 1 月 1 日午夜与所提供的日期之间相差的毫秒数。</td>
</tr>
</tbody>
</table>
<p>Date实例方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getTime()</td>
<td>返回表示日期的毫秒数;与 valueOf() 方法返回的值相同</td>
</tr>
<tr>
<td>setTime(ms)</td>
<td>以毫秒数设置日期,会改变整个日期</td>
</tr>
<tr>
<td>getFullYear()</td>
<td>取得4位数的年份(如2007而非仅07)</td>
</tr>
<tr>
<td>getUTCFullYear()</td>
<td>返回UTC日期的4位数年份</td>
</tr>
<tr>
<td>setFullYear(year)</td>
<td>设置日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</td>
</tr>
<tr>
<td>setUTCFullYear(year)</td>
<td>设置UTC日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</td>
</tr>
<tr>
<td>getMonth()</td>
<td>返回日期中的月份,其中0表示一月,11表示十二月</td>
</tr>
<tr>
<td>getUTCMonth()</td>
<td>返回UTC日期中的月份,其中0表示一月,11表示十二月</td>
</tr>
<tr>
<td>setMonth(month)</td>
<td>设置日期的月份。传入的月份值必须大于0,超过11则增加年份</td>
</tr>
<tr>
<td>setUTCMonth(month)</td>
<td>设置UTC日期的月份。传入的月份值必须大于0,超过11则增加年份</td>
</tr>
<tr>
<td>getDate()</td>
<td>返回日期月份中的天数(1到31)</td>
</tr>
<tr>
<td>getUTCDate()</td>
<td>返回UTC日期月份中的天数(1到31)</td>
</tr>
<tr>
<td>setDate(date)</td>
<td>设置日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份</td>
</tr>
<tr>
<td>setUTCDate(date)</td>
<td>设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份</td>
</tr>
<tr>
<td>getDay()</td>
<td>返回日期中星期的星期几(其中0表示星期日,6表示星期六)</td>
</tr>
<tr>
<td>getUTCDay()</td>
<td>返回UTC日期中星期的星期几(其中0表示星期日,6表示星期六)</td>
</tr>
<tr>
<td>getHours()</td>
<td>返回日期中的小时数(0到23)</td>
</tr>
<tr>
<td>getUTCHours()</td>
<td>返回UTC日期中的小时数(0到23)</td>
</tr>
<tr>
<td>setHours(hours)</td>
<td>设置日期中的小时数。传入的值超过了23则增加月份中的天数</td>
</tr>
<tr>
<td>setUTCHours(hours)</td>
<td>设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>返回日期中的分钟数(0到59)</td>
</tr>
<tr>
<td>getUTCMinutes()</td>
<td>返回UTC日期中的分钟数(0到59)</td>
</tr>
<tr>
<td>setMinutes(minutes)</td>
<td>设置日期中的分钟数。传入的值超过59则增加小时数</td>
</tr>
<tr>
<td>setUTCMinutes(minutes)</td>
<td>设置UTC日期中的分钟数。传入的值超过59则增加小时数</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>返回日期中的秒数(0到59)</td>
</tr>
<tr>
<td>getUTCSeconds()</td>
<td>返回UTC日期中的秒数(0到59)</td>
</tr>
<tr>
<td>setSeconds(seconds)</td>
<td>设置日期中的秒数。传入的值超过了59会增加分钟数</td>
</tr>
<tr>
<td>setUTCSeconds(seconds)</td>
<td>设置UTC日期中的秒数。传入的值超过了59会增加分钟数</td>
</tr>
<tr>
<td>getMilliseconds()</td>
<td>返回日期中的毫秒数</td>
</tr>
<tr>
<td>getUTCMilliseconds()</td>
<td>返回UTC日期中的毫秒数</td>
</tr>
<tr>
<td>setMilliseconds(ms)</td>
<td>设置日期中的毫秒数</td>
</tr>
<tr>
<td>setUTCMilliseconds(ms)</td>
<td>设置UTC日期中的毫秒数</td>
</tr>
<tr>
<td>getTimezoneOffset()</td>
<td>返回本地时间与UTC时间相差的分钟数。例如,美国东部标准时间返回300。在某地进入夏令时的情况下,这个值会有所变化</td>
</tr>
<tr>
<td>toDateString()</td>
<td>以特定于实现的格式显示星期几、月、日和年；</td>
</tr>
<tr>
<td>toTimeString()</td>
<td>以特定于实现的格式显示时、分、秒和时区；</td>
</tr>
<tr>
<td>toLocaleDateString()</td>
<td>以特定于地区的格式显示星期几、月、日和年；</td>
</tr>
<tr>
<td>toLocaleTimeString()</td>
<td>以特定于实现的格式显示时、分、秒；</td>
</tr>
<tr>
<td>toUTCString()</td>
<td>以特定于实现的格式完整的UTC日期。</td>
</tr>
<tr>
<td>toJSON()</td>
<td>调用 toJSON() 返回一个 JSON 格式字符串 (使用 toISOString) ，表示该日期对象的值。默认情况下，这个方法常用于 JSON 序列化时序列化日期对象</td>
</tr>
</tbody>
</table>
<h2 id="RegExp">RegExp</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(pattern[, flags])</span><br><span class="line">/pattern/[flags]</span><br></pre></td></tr></table></figure>
<p>使用构造函数，pattern可以是字符串，ES6中也可以是正则字面量，如果是正则字面量第二个参数会覆盖字面量中的标志。构造函数如果第一个是字符串需要注意所有元字符需要双重转义（<code>\\</code>字符串中就是<code>\\\\</code>）</p>
<p>模式中使用的所有元字符都必须转义。正则表达式中的元字符包括： <code>( [ { \ ^ $ | ) ? * + .]}</code></p>
<p>正则表达式的匹配模式支持下列 5 个标志，后两个是ES6新增。</p>
<ul>
<li>g :表示全局(global)模式,即模式将被应用于所有字符串,而非在发现第一个匹配项时立即停止;</li>
<li>i :表示不区分大小写(case-insensitive)模式,即在确定匹配项时忽略模式与字符串的大小写;</li>
<li>m :表示多行(multiline)模式,即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。</li>
<li>u :表示“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</li>
<li>y :表示“粘连”（sticky）模式。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。如果同时使用g修饰符和y修饰符，则y修饰符覆盖g修饰符。</li>
</ul>
<p>RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。</p>
<ul>
<li>global：布尔值，表示是否设置了g标志。</li>
<li>ignoreCase：布尔值，表示是否设置了i标志。</li>
<li>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</li>
<li>multiline：布尔值，表示是否设置了m标志。</li>
<li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。<br>ES6新增属性</li>
<li>sticky:布尔值，表示是否设置了y标志。</li>
<li>flags: 字符串，表示正则表达式的标志</li>
</ul>
<p>RegExp的实例方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>exec(str)</td>
<td>为指定的一段字符串执行搜索匹配操作。它的返回值是一个数组或者 null。返回的数组虽然是Array 的实例，但包含两个额外的属性：index 和input。其中，index 表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串</td>
</tr>
<tr>
<td>test(str)</td>
<td>执行一个检索，用来查看正则表达式与指定的字符串是否匹配。返回 true 或 false</td>
</tr>
</tbody>
</table>
<p>RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关</p>
<p>正则表达式的valueOf()方法返回正则表达式本身。</p>
<p>RegExp 构造函数属性分别有一个长属性名和一个短属性名（Opera是例外，它不支持短属性名）。下表列出了RegExp构造函数的属性。</p>
<table>
<thead>
<tr>
<th>长属性名</th>
<th>短属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td>$_</td>
<td>最近一次要匹配的字符串。Opera未实现此属性</td>
</tr>
<tr>
<td>lastMatch</td>
<td>$&amp;</td>
<td>最近一次的匹配项。Opera未实现此属性</td>
</tr>
<tr>
<td>lastParen</td>
<td>$+</td>
<td>最近一次匹配的捕获组。Opera未实现此属性</td>
</tr>
<tr>
<td>leftContext</td>
<td>$`</td>
<td>input字符串中lastMatch之前的文本</td>
</tr>
<tr>
<td>multiline</td>
<td>$*</td>
<td>布尔值,表示是否所有表达式都使用多行模式。IE和Opera未实现此属性</td>
</tr>
<tr>
<td>rightContext</td>
<td>$’</td>
<td>Input字符串中lastMatch之后的文本</td>
</tr>
</tbody>
</table>
<h2 id="Function">Function</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Function</span>(p1, p2, … , pn, body)</span><br></pre></td></tr></table></figure>
<p>JavaScript中所有函数都是Function类型的实例。</p>
<p>Function实例属性</p>
<ul>
<li>name： 函数名</li>
<li>length： 函数参数的个数</li>
<li>prototype： 函数原型</li>
</ul>
<p>Function实例方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>apply(thisArg, argArray)</td>
<td>指定 this 值和参数（参数以数组或类数组对象的形式存在）的情况下调用某个函数。 和call方法的区别是call方法接受的是一个参数列表</td>
</tr>
<tr>
<td>bind(thisArg, …args)</td>
<td>创建一个新函数，称为绑定函数，当调用这个绑定函数时，绑定函数会以创建它时传入 bind()方法的第一个参数作为 this，传入 bind() 方法的第二个以及以后的参数加上绑定函数运行时本身的参数按照顺序作为原函数的参数来调用原函数</td>
</tr>
<tr>
<td>call(thisArg, …args)</td>
<td>在使用一个指定的this值和若干个指定的参数值的前提下调用某个函数或方法</td>
</tr>
</tbody>
</table>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">list</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> list1 = list(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<h2 id="Boolean">Boolean</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Boolean</span>([value])</span><br></pre></td></tr></table></figure>
<p>基本类型与引用类型的布尔值还有两个区别。首先，typeof操作符对基本类型返回”boolean”，而对引用类型返回”object”。其次，由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false。</p>
<h2 id="Number-1">Number</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Number</span>([value])</span><br></pre></td></tr></table></figure>
<p>Number属性</p>
<ul>
<li>Number.MAX_VALUE 能表示的最大正数。最大的负数是 -MAX_VALUE。</li>
<li>Number.MIN_VALUE 能表示的最小正数 — 即，最接近 0 的正数 (实际上不会变成 0)。最小的负数是 -MIN_VALUE。</li>
<li>Number.MAX_SAFE_INTEGER 能表示的最大整数。(2^53−1).</li>
<li>Number.MIN_SAFE_INTEGER 能表示的最小整数。 (−(2^53−1))</li>
<li>Number.NaN 特殊的“非数字”值。</li>
<li>Number.NEGATIVE_INFINITY 特殊的负无穷大值，在溢出时返回。</li>
<li>Number.POSITIVE_INFINITY 特殊的正无穷大值，在溢出时返回。</li>
</ul>
<p>Number函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Number.isFinite(number)</td>
<td>返回一个布尔值，该值指示值是否为有限数。</td>
</tr>
<tr>
<td>Number.isInteger(number)</td>
<td>返回一个布尔值，该值指示值是否为整数。</td>
</tr>
<tr>
<td>Number.isNaN(number)</td>
<td>返回一个布尔值，该值指示某个值是否为保留值 NaN（非数字）。</td>
</tr>
<tr>
<td>Number.isSafeInteger(number)</td>
<td>返回一个布尔值，该值指示值是否可在 JavaScript 中安全表示。</td>
</tr>
<tr>
<td>Number.parseFloat(string)</td>
<td>解析一个字符串并返回一个浮点数</td>
</tr>
<tr>
<td>Number.parseInt(string, radix)</td>
<td>解析一个字符串并返回一个整数，第二参数指定进制</td>
</tr>
</tbody>
</table>
<p>Number实例方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>toExponential(fractionDigits)</td>
<td>返回一个字符串，其中包含一个以指数记数法表示的数字。</td>
</tr>
<tr>
<td>toFixed(fractionDigits)</td>
<td>返回一个字符串，它表示定点表示法中的一个数字。</td>
</tr>
<tr>
<td>toLocaleString([reserved1[, reserved2]])</td>
<td>返回基于当前区域设置转换为字符串的对象。</td>
</tr>
<tr>
<td>toPrecision(precision)</td>
<td>返回一个字符串，其中包含一个以指数或定点表示法表示且具有指定位数的数字。</td>
</tr>
<tr>
<td>toString(radix)</td>
<td>返回对象的字符串表示形式。可以指定进制</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回指定对象的基元值。</td>
</tr>
</tbody>
</table>
<h2 id="String">String</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">String</span>(value);</span><br></pre></td></tr></table></figure>
<p>ES6提供了对Unicode辅助平面码点的支持</p>
<p>String 函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>String.fromCharCode(…codeUnits)</td>
<td>根据指定的一或多个 Unicode 字符编码来返回一个字符串。</td>
</tr>
<tr>
<td>String.fromCodePoint(…codePoints)</td>
<td>可以识别码点大于0xFFFF（辅助平面）的字符，弥补了String.fromCharCode方法的不足</td>
</tr>
<tr>
<td>String.raw(template, …substitutions)</td>
<td>模板字符串的标签函数，它的作用类似于 Python 中的字符串前缀 r 和 C# 中的字符串前缀 @，是用来获取一个模板字符串的原始字面量值的</td>
</tr>
</tbody>
</table>
<p>String 实例的方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>charAt(pos)</td>
<td>返回指定索引处的字符。</td>
</tr>
<tr>
<td>charCodeAt(pos)</td>
<td>返回指定字符的 Unicode 编码。但是不支持辅助平面的码点</td>
</tr>
<tr>
<td>codePointAt(pos)</td>
<td>返回一个 Unicode UTF-16 字符的码点。辅助平面的码点</td>
</tr>
<tr>
<td>concat(…args)</td>
<td>返回由提供的两个字符串串联而成的字符串。</td>
</tr>
<tr>
<td>endsWith(searchString[,endPosition])</td>
<td>返回一个布尔值，该值指示字符串或子字符串是否以传入字符串结尾。</td>
</tr>
<tr>
<td>includes(searchString[, position])</td>
<td>返回一个布尔值，该值指示传入字符串是否包含在字符串对象中。</td>
</tr>
<tr>
<td>indexOf(searchString[, position])</td>
<td>返回字符串内第一次出现子字符串的字符位置。</td>
</tr>
<tr>
<td>lastIndexOf(searchString[, position])</td>
<td>返回字符串内子字符串的最后一个匹配项。</td>
</tr>
<tr>
<td>localeCompare(that[, reserved1[, reserved2]])</td>
<td>返回一个值，该值指示两个字符串在当前区域设置中是否相等。</td>
</tr>
<tr>
<td>match(regexp)</td>
<td>通过使用提供的正则表达式对象来搜索字符串并以数组形式返回结果。</td>
</tr>
<tr>
<td>normalize([form])</td>
<td>按照指定的一种 Unicode 正规形式将当前字符串正规化。四种 Unicode 正规形式 “NFC”, “NFD”, “NFKC”, 以及 “NFKD” 其中的一个, 默认值为 “NFC”</td>
</tr>
<tr>
<td>repeat(count)</td>
<td>返回一个新的字符串对象，它的值等于重复了指定次数的原始字符串。</td>
</tr>
<tr>
<td>replace(searchValue, replaceValue)</td>
<td>使用正则表达式替换字符串中的文本并返回结果。</td>
</tr>
<tr>
<td>search(regexp)</td>
<td>返回正则表达式搜索中第一个子字符串匹配项的位置。</td>
</tr>
<tr>
<td>slice(start, end)</td>
<td>返回字符串的片段。</td>
</tr>
<tr>
<td>split(separator, limit)</td>
<td>返回一个字符串拆分为若干子字符串时所产生的字符串数组。</td>
</tr>
<tr>
<td>startsWith(searchString[, position])</td>
<td>返回一个布尔值，该值指示字符串或子字符串是否以传入字符串开头。</td>
</tr>
<tr>
<td>substr(start, end)</td>
<td>返回一个从指定位置开始且具有指定长度的子字符串。</td>
</tr>
<tr>
<td>substring(start, end)</td>
<td>返回 String 对象中指定位置处的子字符串。</td>
</tr>
<tr>
<td>toLocaleLowerCase([reserved1[, reserved2]])</td>
<td>返回一个字符串，其中所有字母字符都转换为小写形式，并将考虑主机环境的当前区域设置。</td>
</tr>
<tr>
<td>toLocaleUpperCase([reserved1[, reserved2]])</td>
<td>返回一个字符串，其中所有字母字符都转换为大写形式，并将考虑主机环境的当前区域设置。</td>
</tr>
<tr>
<td>toLowerCase()</td>
<td>返回一个字符串，其中所有字母字符都转换为小写形式。</td>
</tr>
<tr>
<td>toString()</td>
<td>返回字符串。</td>
</tr>
<tr>
<td>toUpperCase()</td>
<td>返回一个字符串，其中所有字母字符都转换为大写形式。</td>
</tr>
<tr>
<td>trim()</td>
<td>返回已移除前导空格、尾随空格和行终止符的字符串。</td>
</tr>
<tr>
<td>valueOf()</td>
<td>返回字符串</td>
</tr>
<tr>
<td><a href="">@@iterator</a></td>
<td>返回迭代器</td>
</tr>
</tbody>
</table>
<p>ECMAScript还提供了三个基于子字符串创建新字符串的方法：slice()、substr()和substring()。这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而 substr() 的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与concat()方法一样，slice()、substr()和 substring()也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。</p>
<p>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，substring()方法会把所有负值参数都转换为0</p>
<h2 id="Global">Global</h2><p>Global对象可以说是ECMAScript中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。诸如 isNaN() 、 isFinite() 、 parseInt() 以及 parseFloat() ,实际上全都是 Global 对象的方法。</p>
<ul>
<li><p>URI 编码方法<br>  对象的 encodeURI()和 encodeURIComponent()方法可以对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。 其中，encodeURI()主要用于整个URI（例如，<code>http://www.wrox.com/illegal value.htm</code>），而 encodeURIComponent()主要用于对URI中的某一段（例如前面URI中的illegal value.htm）进行编码。它们的主要区别在于，encodeURI()不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。</p>
<p>  一般来说，我们使用 encodeURIComponent()方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI进行编码。</p>
<p>  与 encodeURI()和 encodeURIComponent()方法对应的两个方法分别是 decodeURI()和decodeURIComponent()</p>
</li>
<li><p>eval()方法<br>  eval()方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串。看例子： eval(“alert(‘hi’)”); 这行代码的作用等价于代码： alert(“hi”);</p>
<p>  当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过 eval() 执行的代码可以引用在包<br>含环境中定义的变量 <code>var msg = &quot;hello world&quot;; eval(&quot;alert(msg)&quot;);</code></p>
<p>  在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。 严格模式下，在外部访问不到eval()中创建的任何变量或函数，在严格模式下,为 eval 赋值也会导致错误</p>
</li>
<li><p>Global 对象的属性<br>  特殊的值undefined、NaN以及Infinity都是Global对象的属性。此外，所有原生引用类型的构造函数，像Object和Function，也都是Global对象的属性。下表列出了Global对象的所有属性。</p>
</li>
</ul>
<p>isFinite(number)，isNaN(number)，parseFloat(string)，parseInt(string , radix)这几个函数功能和Number的类似</p>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>特殊值 undefined</td>
</tr>
<tr>
<td>NaN</td>
<td>特殊值 NaN</td>
</tr>
<tr>
<td>Infinity</td>
<td>特殊值 Infinity</td>
</tr>
<tr>
<td>Date</td>
<td>构造函数 Date</td>
</tr>
<tr>
<td>RegExp</td>
<td>构造函数 RegExp</td>
</tr>
<tr>
<td>Error</td>
<td>构造函数 Error</td>
</tr>
<tr>
<td>Object</td>
<td>构造函数 Object</td>
</tr>
<tr>
<td>Array</td>
<td>构造函数 Array</td>
</tr>
<tr>
<td>Function</td>
<td>构造函数 Function</td>
</tr>
<tr>
<td>Boolean</td>
<td>构造函数 Boolean</td>
</tr>
<tr>
<td>String</td>
<td>构造函数 String</td>
</tr>
<tr>
<td>Number</td>
<td>构造函数 Number</td>
</tr>
<tr>
<td>EvalError</td>
<td>构造函数 EvalError</td>
</tr>
<tr>
<td>RangeError</td>
<td>构造函数 RangeError</td>
</tr>
<tr>
<td>ReferenceError</td>
<td>构造函数 ReferenceError</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>构造函数 SyntaxError</td>
</tr>
<tr>
<td>TypeError</td>
<td>构造函数 TypeError</td>
</tr>
<tr>
<td>URIError</td>
<td>构造函数 URIError</td>
</tr>
</tbody>
</table>
<p>ECMAScript 5明确禁止给undefined、NaN和Infinity赋值，这样做即使在非严格模式下也会导致错误。</p>
<h2 id="Math">Math</h2><ul>
<li>Math 对象的属性</li>
</ul>
<table>
<thead>
<tr>
<th>属 性</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.E</td>
<td>自然对数的底数，即常量e的值</td>
</tr>
<tr>
<td>Math.LN10</td>
<td>10的自然对数</td>
</tr>
<tr>
<td>Math.LN2</td>
<td>2的自然对数</td>
</tr>
<tr>
<td>Math.LOG2E</td>
<td>以2为底e的对数</td>
</tr>
<tr>
<td>Math.LOG10E</td>
<td>以10为底e的对数</td>
</tr>
<tr>
<td>Math.PI</td>
<td>π的值</td>
</tr>
<tr>
<td>Math.SQRT1_2</td>
<td>1/2的平方根（即2的平方根的倒数）</td>
</tr>
<tr>
<td>Math.SQRT2</td>
<td>2的平方根</td>
</tr>
</tbody>
</table>
<ul>
<li><p>min() 和 max() 方法<br>  这两个方法都可以接收任意多个数值参数，要查找数组中的最大值可以使用apply方法。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.min(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values);</span><br></pre></td></tr></table></figure>
</li>
<li><p>舍入方法</p>
<ul>
<li>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；</li>
<li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；</li>
<li>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</li>
</ul>
</li>
<li><p>random() 方法<br>  Math.random() 方法返回大于等于 0 小于 1 的一个随机数。套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。 <code>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</code></p>
</li>
<li><p>其他方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方 法</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.abs(num)</td>
<td>返回num 的绝对值</td>
</tr>
<tr>
<td>Math.exp(num)</td>
<td>返回Math.E 的num 次幂</td>
</tr>
<tr>
<td>Math.log(num)</td>
<td>返回num 的自然对数</td>
</tr>
<tr>
<td>Math.pow(num,power)</td>
<td>返回num 的power 次幂</td>
</tr>
<tr>
<td>Math.sqrt(num)</td>
<td>返回num 的平方根</td>
</tr>
<tr>
<td>Math.acos(x)</td>
<td>返回x 的反余弦值</td>
</tr>
<tr>
<td>Math.asin(x)</td>
<td>返回x 的反正弦值</td>
</tr>
<tr>
<td>Math.atan(x)</td>
<td>返回x 的反正切值</td>
</tr>
<tr>
<td>Math.atan2(y,x)</td>
<td>返回y/x 的反正切值</td>
</tr>
<tr>
<td>Math.cos(x)</td>
<td>返回x 的余弦值</td>
</tr>
<tr>
<td>Math.sin(x)</td>
<td>返回x 的正弦值</td>
</tr>
<tr>
<td>Math.tan(x)</td>
<td>返回x 的正切值</td>
</tr>
</tbody>
</table>
<ul>
<li>ES6新增方法</li>
</ul>
<table>
<thead>
<tr>
<th>方 法</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.trunc(num)</td>
<td>去除一个数的小数部分，返回整数部分，对于空值和无法截取整数的值，返回NaN</td>
</tr>
<tr>
<td>Math.sign(num)</td>
<td>判断一个数到底是正数、负数、还是零。参数为正数，返回+1； 参数为负数，返回-1； 参数为0，返回0； 参数为-0，返回-0; 其他值，返回NaN。</td>
</tr>
<tr>
<td>Math.cbrt(num)</td>
<td>计算一个数的立方根</td>
</tr>
<tr>
<td>Math.clz32(num)</td>
<td>返回一个数的32位无符号整数二进制形式表示有多少个前导0。对于小数，只考虑整数部分，对于其他值，先转为数值，再计算</td>
</tr>
<tr>
<td>Math.imul(num1,num2)</td>
<td>回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。多数情况和`(a * b)</td>
<td>0`效果相同，但JavaScript对于超过2的53次方的值无法精确表示，该方法可以得到正确值</td>
</tr>
<tr>
<td>Math.fround(num)</td>
<td>Math.fround方法返回一个数的单精度浮点数形式。对于整数来说，Math.fround方法返回结果不会有任何不同，区别主要是那些无法用64个二进制位精确表示的小数。这时，Math.fround方法会返回最接近这个小数的单精度浮点数。</td>
</tr>
<tr>
<td>Math.hypot()</td>
<td>返回所有参数的平方和的平方根，如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN</td>
</tr>
<tr>
<td>Math.expm1()</td>
<td>返回Math.exp(x) - 1</td>
</tr>
<tr>
<td>Math.log1p()</td>
<td>返回1 + x的自然对数。如果x小于-1，返回NaN</td>
</tr>
<tr>
<td>Math.log10()</td>
<td>返回以10为底的x的对数。如果x小于0，则返回NaN</td>
</tr>
<tr>
<td>Math.log2()</td>
<td>返回以2为底的x的对数。如果x小于0，则返回NaN</td>
</tr>
<tr>
<td>Math.sinh(x)</td>
<td>返回x的双曲正弦（hyperbolic sine）</td>
</tr>
<tr>
<td>Math.cosh(x)</td>
<td>返回x的双曲余弦（hyperbolic cosine）</td>
</tr>
<tr>
<td>Math.tanh(x)</td>
<td>返回x的双曲正切（hyperbolic tangent）</td>
</tr>
<tr>
<td>Math.asinh(x)</td>
<td>返回x的反双曲正弦（inverse hyperbolic sine）</td>
</tr>
<tr>
<td>Math.acosh(x)</td>
<td>返回x的反双曲余弦（inverse hyperbolic cosine）</td>
</tr>
<tr>
<td>Math.atanh(x)</td>
<td>返回x的反双曲正切（inverse hyperbolic tangent）</td>
</tr>
</tbody>
</table>
<h2 id="Map">Map</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Map</span>([iterable])</span><br></pre></td></tr></table></figure>
<p>Map对象属性：size，映射中的元素数</p>
<p>Map对象方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>clear()</td>
<td>清除所有成员，没有返回值。</td>
</tr>
<tr>
<td>delete(key)</td>
<td>删除某个键，返回true。如果删除失败，返回false。</td>
</tr>
<tr>
<td>forEach(callbackfn[, thisArg])</td>
<td>对映射中的每个元素执行指定操作。</td>
</tr>
<tr>
<td>get(key)</td>
<td>读取key对应的键值，如果找不到key，返回undefined。</td>
</tr>
<tr>
<td>has(key)</td>
<td>返回一个布尔值，表示某个键是否在Map数据结构中。</td>
</tr>
<tr>
<td>set(key,value)</td>
<td>设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。</td>
</tr>
<tr>
<td>entries()</td>
<td>返回所有成员的Iterator对象。</td>
</tr>
<tr>
<td>keys()</td>
<td>返回键名的Iterator对象。</td>
</tr>
<tr>
<td>values()</td>
<td>返回键值的Iterator对象。</td>
</tr>
</tbody>
</table>
<h2 id="WeakMap">WeakMap</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">WeakMap</span>([iterable])</span><br></pre></td></tr></table></figure>
<p>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受原始类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</p>
<p>WeakMap的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap自动移除对应的键值对。典型应用是，一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</p>
<p>WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>
<h2 id="Set">Set</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Set</span>([iterable])</span><br></pre></td></tr></table></figure>
<p>Set 实例属性size，返回元素个数</p>
<p>Set 实例方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>clear()</td>
<td>清除所有成员，没有返回值。</td>
</tr>
<tr>
<td>delete(value)</td>
<td>删除某个键，返回true。如果删除失败，返回false。</td>
</tr>
<tr>
<td>forEach(callbackfn[, thisArg])</td>
<td>对映射中的每个元素执行指定操作。</td>
</tr>
<tr>
<td>has(value)</td>
<td>返回一个布尔值，表示某个键是否在Set数据结构中。</td>
</tr>
<tr>
<td>add(value)</td>
<td>设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。</td>
</tr>
<tr>
<td>entries()</td>
<td>返回所有成员的Iterator对象。</td>
</tr>
<tr>
<td>keys()</td>
<td>返回键名的Iterator对象。</td>
</tr>
<tr>
<td>values()</td>
<td>返回键值的Iterator对象。</td>
</tr>
</tbody>
</table>
<p>entries，keys，values三个方法返回一样。</p>
<p>数组、Map、Set实例都有entries，keys，values这三个方法，都返回一个迭代器，实现了Iterable和Iterator接口。且其<code>Symbol.iterator</code>方法的返回值就是其本身</p>
<h2 id="WeakSet">WeakSet</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">WeakSet</span>([iterable])</span><br></pre></td></tr></table></figure>
<p>WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。</p>
<p>首先，WeakSet的成员只能是对象，而不能是其他类型的值。</p>
<p>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p>
<p>实例只有add，delete，has三个方法。</p>
<h2 id="Proxy">Proxy</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Proxy</span>(target, handler)</span><br></pre></td></tr></table></figure>
<p>Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，<code>new Proxy()</code>表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>
<p>Proxy.revocable(target, handler)</p>
<table>
<thead>
<tr>
<th>处理程序方法（陷阱）语法</th>
<th>用法示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>apply: function(target, thisArg, args)</td>
<td>函数调用陷阱。</td>
</tr>
<tr>
<td>construct: function(target, args)</td>
<td>构造函数陷阱。</td>
</tr>
<tr>
<td>defineProperty: function(target, propertyName, descriptor)</td>
<td>Object.defineProperty 函数 (JavaScript) 陷阱。</td>
</tr>
<tr>
<td>deleteProperty: function(target, propertyName)</td>
<td>delete 语句的陷阱。</td>
</tr>
<tr>
<td>enumerate: function(target)</td>
<td>for…in 语句、Object.getOwnPropertySymbols、Object.keys 函数和 JSON.stringify 的陷阱。</td>
</tr>
<tr>
<td>get: function(target, propertyName, receiver)</td>
<td>任何 getter 属性的陷阱。</td>
</tr>
<tr>
<td>getOwnPropertyDescriptor: function(target, propertyName)</td>
<td>Object.getOwnPropertyDescriptor 函数 (JavaScript) 的陷阱。</td>
</tr>
<tr>
<td>getPrototypeOf: function(target)</td>
<td>Object.getPrototypeOf 函数 (JavaScript) 的陷阱。</td>
</tr>
<tr>
<td>has: function(target, propertyName)</td>
<td>in 运算符、hasOwnProperty 方法 (Object) (JavaScript) 和其他方法的陷阱。</td>
</tr>
<tr>
<td>isExtensible: function(target)</td>
<td>Object.isExtensible 函数 (JavaScript) 的陷阱。</td>
</tr>
<tr>
<td>ownKeys: function(target)</td>
<td>Object.getOwnPropertyNames 函数 (JavaScript) 的陷阱。</td>
</tr>
<tr>
<td>preventExtensions: function(target)</td>
<td>Object.preventExtensions 函数 (JavaScript) 的陷阱。</td>
</tr>
<tr>
<td>set: function(target, propertyName, value, receiver)</td>
<td>任何 setter 属性的陷阱。</td>
</tr>
<tr>
<td>setPrototypeOf: function(target, prototype)</td>
<td>Object.setPrototypeOf 的陷阱。</td>
</tr>
</tbody>
</table>
<h2 id="Reflect">Reflect</h2><p>Reflect 方法通常与Proxy一起使用，因为后者允许你委托默认行为而无需在代码中实现该默认行为。</p>
<p>Reflect 提供与每个代理陷阱具有相同名称的静态方法</p>
<p>Reflect函数清单如下。</p>
<ul>
<li>Reflect.getOwnPropertyDescriptor(target,name)</li>
<li>Reflect.defineProperty(target,name,desc)</li>
<li>Reflect.getOwnPropertyNames(target)</li>
<li>Reflect.getPrototypeOf(target) 读取对象的<code>__proto__</code>属性，等同于<code>Object.getPrototypeOf(obj)</code>。</li>
<li>Reflect.setPrototypeOf(obj, newProto) 设置对象的<code>__proto__</code>属性，注意，Object对象没有对应这个方法的方法。</li>
<li>Reflect.deleteProperty(target,name) 等同于<code>delete obj[name]</code>。</li>
<li>Reflect.enumerate(target)</li>
<li>Reflect.freeze(target)</li>
<li>Reflect.seal(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.isFrozen(target)</li>
<li>Reflect.isSealed(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.has(target,name) 等同于<code>name in obj</code>。</li>
<li>Reflect.hasOwn(target,name)</li>
<li>Reflect.keys(target)</li>
<li>Reflect.get(target,name,receiver) 查找并返回target对象的name属性，如果没有该属性，则返回undefined。如果name属性部署了读取函数，则读取函数的this绑定receiver。</li>
<li>Reflect.set(target,name,value,receiver) 设置target对象的name属性等于value。如果name属性设置了赋值函数，则赋值函数的this绑定receiver。</li>
<li>Reflect.apply(target,thisArg,args) 等同于<code>Function.prototype.apply.call(fun,thisArg,args)</code>。一般来说，如果要绑定一个函数的this对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的apply方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用Reflect对象可以简化这种操作。</li>
<li>Reflect.construct(target,args) 等同于<code>new target(...args)</code>，这提供了一种不使用new，来调用构造函数的方法。</li>
</ul>
<h2 id="Promise">Promise</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123; ... &#125;);</span><br></pre></td></tr></table></figure>
<p>Promise必须完成（返回一个值）或者必须被拒绝（返回一个原因）。Promise完成或被拒绝时（无论哪一个先发生），Promise 对象的 then 方法都会运行。如果承诺成功完成，则将运行 then 方法的履行处理程序函数。如果承诺被拒绝，则将运行 then 方法（或 catch 方法）的错误处理程序函数。</p>
<p>Promise对象有以下两个特点。</p>
<ol>
<li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ol>
<p>Promise函数</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>Promise.all(iterable)</td>
<td>返回一个promise，该promise会在iterable参数内的所有promise都被解决后被解决。如果传入的可迭代数组中某项不是一个promise，该项会被用Promise.resolve转换为一个promise。如果任一传入的promise被拒绝了，all Promise立刻带着该promise的拒绝原因进入拒绝(rejected)状态，不再理会其它传入的promise是否被解决。</td>
</tr>
<tr>
<td>Promise.race(iterable)</td>
<td>返回一个promise，这个promise在iterable中的任意一个promise被解决或拒绝后，立刻以相同的解决值被解决或以相同的拒绝原因被拒绝。</td>
</tr>
<tr>
<td>Promise.reject(reason)</td>
<td>返回一个用reason拒绝的Promise</td>
</tr>
<tr>
<td>Promise.resolve(x)</td>
<td>返回一个以给定值resolve掉的Promise对象。但如果这个值是thenable的（就是说带有then方法），返回的promise会“追随”这个thenable的对象，接收它的最终状态（指resolved/rejected/pendding/settled）；否则这个被返回的promise对象会以这个值被fulfilled</td>
</tr>
</tbody>
</table>
<p>Promise对象方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>then(onFulfilled, onRejected)</td>
<td>返回一个Promise。它有两个参数，分别为Promise在 success 和 failure 情况下的回调函数</td>
</tr>
<tr>
<td>catch(onRejected)</td>
<td>只处理Promise被拒绝的情况，并返回一个Promise。该方法的行为和调用Promise.prototype.then(undefined, onRejected)相同</td>
</tr>
</tbody>
</table>
<h1 id="异步编程">异步编程</h1><p>异步编程对JavaScript语言很重要。JavaScript只有一个线程，如果没有异步编程，性能堪忧。</p>
<p>ES6之前，异步编程的方法，大概有下面四种。</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
<h2 id="异步基本概念">异步基本概念</h2><p>所谓”异步”，简单说就好比把一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<h2 id="回调函数">回调函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，readFile函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p>
<h2 id="Promise-1">Promise</h2><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(fileA, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  fs.readFile(fileB, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面回调函数会有多重嵌套，Promise允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> readFile = <span class="built_in">require</span>(<span class="string">'fs-readfile-promise'</span>);</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> readFile(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(data.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span>(<span class="params">err</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。</p>
<p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<p>Thunkify模块和co模块可以自动执行Generator函数</p>
<p>基于Promise对象的自动执行<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>然后，手动执行上面的Generator函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">g.next().value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">  g.next(data).value.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    g.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p>
<h2 id="async函数">async函数</h2><p>async函数现在是ES7的一个提案。上面例子写成 async 函数，就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一比较就会发现，async函数就是将Generator函数的星号（<code>*</code>）替换成async，将yield替换成await，仅此而已。</p>
<p>参考：</p>
<p><a href="http://bonsaiden.github.io/JavaScript-Garden/zh/" target="_blank" rel="external">JavaScript秘密花园</a></p>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript 总结，涉及变量，数据类型，操作符，语句，函数，模块，错误处理，垃圾回收，面向对象编程，原生类型，异步编程；声明提升，typeof，对象的类定义，undefined & null，类型转换，Symbol，Number，模板字符串，标签模板，ES6中的`...`，解构赋值，for-in，with，for-of，函数声明和表达式，arguments，this，函数返回值，默认参数，rest参数，扩展运算符，箭头函数，Generator函数，尾调用优化，作用域，闭包，对象，继承，Object，Array，Date，RegExp，Function，Boolean，Number，String，Global，Math，Map，WeakMap，Set，WeakSet，Proxy，Reflect，Promise，回调函数，async函数；属性类型，对象使用和属性，原型，创建对象，class，共享变量，静态变量，私有变量，静态私有变量，模块模式，增强的模块模式，原型链，继承方法，extends]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://howiefh.github.io/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://howiefh.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 面向对象程序设计、函数表达式和异步编程]]></title>
    <link href="http://howiefh.github.io/2015/08/28/javascript-oop-function-expression-and-async/"/>
    <id>http://howiefh.github.io/2015/08/28/javascript-oop-function-expression-and-async/</id>
    <published>2015-08-28T04:23:08.000Z</published>
    <updated>2015-09-01T03:35:47.000Z</updated>
    <content type="html"><![CDATA[<p><a href="2015/08/28/javascript-grammar/">JavaScript 基本语法</a>，<a href="2015/08/28/javascript-reference-type/">JavaScript 引用类型</a>，<a href="2015/08/28/javascript-oop-function-expression-and-async/">JavaScript 面向对象程序设计、函数表达式和异步编程</a>三篇笔记是对《JavaScript 高级程序设计》和 <a href="https://github.com/ruanyf/es6tutorial/tree/5a5f9d8d492d0f925cbb6e09b10ebed9d2078d40" target="_blank" rel="external">《ECMAScript 6入门》</a>两本书的总结整理。</p>
<h1 id="面向对象程序设计">面向对象程序设计</h1><p>ECMA-262把对象定义为：“无序属性的集合，其属性可以包含基本值、对象或者函数。”严格来讲，这就相当于说对象是一组没有特定顺序的值。对象的每个属性或方法都有一个名字，而每个名字都映射到一个值。正因为这样（以及其他将要讨论的原因），我们可以把ECMAScript的对象想象成散列表：无非就是一组名值对，其中值可以是数据或函数</p>
<a id="more"></a>
<h2 id="属性类型">属性类型</h2><p>ECMAScript 中有两种属性:数据属性和访问器属性。</p>
<ol>
<li><p>数据属性<br> 数据属性包含一个数据值的位置。在这个位置可以读取和写入值。数据属性有4个描述其行为的特性。</p>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为访问器属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>
<li>[[Writable]]：表示能否修改属性的值。像前面例子中那样直接在对象上定义的属性，它们的这个特性默认值为true。</li>
<li><p>[[Value]]：包含这个属性的数据值。读取属性值的时候，从这个位置读；写入属性值的时候，把新值保存在这个位置。这个特性的默认值为undefined。</p>
<p>像例子中那样直接在对象上定义的属性,它们的 [[Configurable]] 、 [[Enumerable]] 和 [[Writable]] 特性都被设置为 true ,而 [[Value]] 特性被设置为”Nicholas”。例如: <code>var person = { name: &quot;Nicholas&quot; };</code></p>
<p>要修改属性默认的特性，必须使用ECMAScript 5的Object.defineProperty()方法。这个方法接收三个参数：属性所在的对象、属性的名字和一个描述符对象。其中，描述符（descriptor）对象的属性必须是：configurable、enumerable、writable 和 value。设置其中的一或多个值，可以修改对应的特性值。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">person</span> = &#123;&#125;;</span><br><span class="line">Object.defineProperty(<span class="keyword">person</span>, <span class="string">"name"</span>, &#123;</span><br><span class="line">  writable: false,</span><br><span class="line">  value: <span class="string">"Nicholas"</span></span><br><span class="line">&#125;);</span><br><span class="line">alert(<span class="keyword">person</span>.name); //<span class="string">"Nicholas"</span></span><br><span class="line"><span class="keyword">person</span>.name = <span class="string">"Greg"</span>;</span><br><span class="line">alert(<span class="keyword">person</span>.name); //<span class="string">"Nicholas"</span></span><br></pre></td></tr></table></figure>
<p>name属性的值是不可修改的，如果尝试为它指定新值，则在非严格模式下，赋值操作将被忽略；在严格模式下，赋值操作将会导致抛出错误。</p>
<p>把configurable设置为false，表示不能从对象中删除属性。如果对这个属性调用delete，则在非严格模式下什么也不会发生，而在严格模式下会导致错误。而且,一旦把属性定义为不可配置的,就不能再把它变回可配置了。此时,再调用 Object.defineProperty() 方法修改除 writable 之外的特性</p>
<p>可以多次调用Object.defineProperty()方法修改同一个属性，但在把configurable特性设置为false之后就会有限制了。 在调用Object.defineProperty()方法时，如果不指定，configurable、enumerable和writable特性的默认值都是false。</p>
</li>
</ul>
</li>
<li><p>访问器属性<br> 访问器属性不包含数据值；它们包含一对儿getter和setter函数（不过，这两个函数都不是必需的）。在读取访问器属性时，会调用 getter函数，这个函数负责返回有效的值；在写入访问器属性时，会调用setter函数并传入新值，这个函数负责决定如何处理数据。访问器属性有如下4个特性。</p>
<ul>
<li>[[Configurable]]：表示能否通过 delete 删除属性从而重新定义属性，能否修改属性的特性，或者能否把属性修改为数据属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li>
<li>[[Enumerable]]：表示能否通过 for-in 循环返回属性。对于直接在对象上定义的属性，这个特性的默认值为true。</li>
<li>[[Get]]：在读取属性时调用的函数。默认值为undefined。</li>
<li><p>[[Set]]：在写入属性时调用的函数。默认值为undefined。</p>
<p>访问器属性不能直接定义，必须使用Object.defineProperty()来定义。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">  _year: <span class="number">2004</span>,</span><br><span class="line">  edition: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line">Object.defineProperty(book, <span class="string">"year"</span>, &#123;</span><br><span class="line">  <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(newValue)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">      <span class="keyword">this</span>._year = newValue;</span><br><span class="line">      <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition); <span class="comment">//2</span></span><br></pre></td></tr></table></figure>
<p><code>_year</code>前面的下划线是一种常用的记号，用于表示只能通过对象方法访问的属性。</p>
<p>不一定非要同时指定getter和setter。只指定getter意味着属性是不能写，尝试写入属性会被忽略。在严格模式下，尝试写入只指定了getter函数的属性会抛出错误。类似地，只指定setter函数的属性也不能读，否则在非严格模式下会返回undefined，而在严格模式下会抛出错误。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">book.__defineGetter__("year", function()&#123;</span></span><br><span class="line">  return this._year;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="title">book.__defineSetter__("year", function(newValue)&#123;</span></span><br><span class="line">  if (newValue &gt; 2004) &#123;</span><br><span class="line">    this._year = newValue;</span><br><span class="line">    this.edition += newValue - 2004;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>支持ECMAScript 5的这个方法的浏览器有IE9+（IE8只是部分实现）、Firefox 4+、Safari 5+、Opera 12+和Chrome。在这个方法之前，要创建访问器属性，一般都使用两个非标准的方法：<strong>defineGetter</strong>()和<strong>defineSetter</strong>()。<br>在不支持 Object.defineProperty() 方法的浏览器中不能修改 [[Configurable]] 和 [[Enumerable]] 。</p>
</li>
</ul>
</li>
</ol>
<h2 id="定义多个属性">定义多个属性</h2><p>由于为对象定义多个属性的可能性很大，ECMAScript 5又定义了一个Object.defineProperties()方法。利用这个方法可以通过描述符一次定义多个属性。这个方法接收两个对象参数：第一个对象是要添加和修改其属性的对象，第二个对象的属性与第一个对象中要添加或修改的属性一一对应。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Object.defineProperties(book, &#123;</span><br><span class="line">  _year: &#123;</span><br><span class="line">    value: <span class="number">2004</span></span><br><span class="line">  &#125;,</span><br><span class="line">  edition: &#123;</span><br><span class="line">    value: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  year: &#123;</span><br><span class="line">    <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>: <span class="function"><span class="keyword">function</span><span class="params">(newValue)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2004</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>._year = newValue;</span><br><span class="line">        <span class="keyword">this</span>.edition += newValue - <span class="number">2004</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h2 id="读取属性的特性">读取属性的特性</h2><p>使用 ECMAScript 5的 Object.getOwnPropertyDescriptor()方法，可以取得给定属性的描述符。这个方法接收两个参数：属性所在的对象和要读取其描述符的属性名称。返回值是一个对象，如果是访问器属性，这个对象的属性有configurable、enumerable、get 和set；如果是数据属性，这个对象的属性有configurable、enumerable、writable和value</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var descriptor = Object.getOwnPropertyDescriptor<span class="params">(book, <span class="string">"_year"</span>)</span>;</span><br><span class="line">alert<span class="params">(descriptor.value)</span>; <span class="comment">//2004</span></span><br><span class="line">alert<span class="params">(descriptor.configurable)</span>; <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h2 id="创建对象">创建对象</h2><h3 id="工厂模式">工厂模式</h3><p>用函数来封装以特定接口创建对象的细节<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure></p>
<p>函数createPerson()能够根据接受的参数来构建一个包含所有必要信息的Person对象。可以无数次地调用这个函数，而每次它都会返回一个包含三个属性一个方法的对象。工厂模式虽然解决了创建多个相似对象的问题，但却没有解决对象识别的问题（即怎样知道一个对象的类型）。</p>
<h3 id="构造函数模式">构造函数模式</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">Person</span>(name, age, job)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;</span><br><span class="line">  this.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">var person1 = new <span class="keyword">Person</span>(<span class="string">"Nicholas"</span>, 29, <span class="string">"Software Engineer"</span>);</span><br><span class="line">var person2 = new <span class="keyword">Person</span>(<span class="string">"Greg"</span>, 27, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure>
<p>在这个例子中，Person()函数取代了 createPerson()函数。我们注意到，Person()中的代码除了与createPerson()中相同的部分外，还存在以下不同之处：</p>
<ul>
<li>没有显式地创建对象；</li>
<li>直接将属性和方法赋给了this对象；</li>
<li>没有return语句。</li>
</ul>
<p>此外，还应该注意到函数名Person使用的是大写字母P。按照惯例，构造函数始终都应该以一个大写字母开头，而非构造函数则应该以一个小写字母开头。这个做法借鉴自其他OO语言，主要是为了区别于ECMAScript中的其他函数；本质上它和其它函数没有区别的，任何函数通过new调用就会被当做构造函数。 要创建 Person 的新实例，必须使用 new 操作符。以这种方式调用构造函数实际上会经历以下 4个步骤： (1) 创建一个新对象； (2) 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）； (3) 执行构造函数中的代码（为这个新对象添加属性）； (4) 返回新对象。</p>
<ol>
<li><p>将构造函数当作函数<br> 构造函数本身就是一个普通的函数，所以我们不使用new关键字，可以看下调用Person会有什么结果</p>
 <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 作为普通函数调用，由于构造函数没有返回值，所以p将是undefined</span><br><span class="line">var p = <span class="keyword">Person</span>(<span class="string">"Greg"</span>, 27, <span class="string">"Doctor"</span>); // 在全局作用域中调用一个函数时, this 对象总是指向 Global 对象，这里就是添加到 window</span><br><span class="line">window.sayName(); //<span class="string">"Greg"</span></span><br><span class="line">sayName(); //<span class="string">"Greg"</span></span><br><span class="line">// 在另一个对象的作用域中调用</span><br><span class="line">var o = new Object();</span><br><span class="line"><span class="keyword">Person</span>.call(o, <span class="string">"Kristen"</span>, 25, <span class="string">"Nurse"</span>);</span><br><span class="line">o.sayName(); //<span class="string">"Kristen"</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>构造函数的问题<br> 上面的声明函数等价于<code>this.sayName = new Function(&quot;alert(this.name)&quot;);</code></p>
<p> 使用构造函数的主要问题，就是每个方法都要在每个实例上重新创建一遍。在前面的例子中，person1和person2都有一个名为sayName()的方法，但那两个方法不是同一个Function的实例。可以通过将函数声明在全局作用域，通过<code>this.sayName = sayName</code>赋值，但在全局作用域添加函数不是一种好的做法。这个问题可以通过原型模式解决</p>
</li>
</ol>
<h3 id="原型模式">原型模式</h3><p>我们创建的每个函数都有一个 prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么 prototype 就是通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中定义对象实例的信息，而是可以将这些信息直接添加到原型对象中</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">Person</span>()&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">Person</span>.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="keyword">Person</span>.prototype.age = 29;</span><br><span class="line"><span class="keyword">Person</span>.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line"><span class="keyword">Person</span>.prototype.sayName = function()&#123;</span><br><span class="line">  alert(this.name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>理解原型对象<br> JavaScript中函数都是Function类型的实例，把Person当做一个指针，它指向一个Function类型的对象，每个Function实例都有prototype属性，其指向一个函数的原型对象，通过Person.prototype就可以访问到这个对象。默认情况下，每个原型对象都有一个constructor属性，这个属性指向 prototype 属性所在函数也就是Person。创建了自定义的构造函数之后，其原型对象默认只会取得constructor属性；至于其他方法，则都是从Object继承而来的。每个对象都有[[Prototype]]属性（内部属性），虽然在脚本中没有标准的方式访问[[Prototype]]，但 Firefox、Safari 和 Chrome 在每个对象上都支持一个属性<code>__proto__</code>；而在其他实现中，这个属性对脚本则是完全不可见的。这个属性指向了构造函数的原型对象，也就是Person.prototype指向的对象。JavaScript中通过递归原型链来查找对象属性，因此person1和person2可以访问到其原型Person.prototype中的属性constructor。除了通过instanceof外也可以通过person1.constructor === Person来判断是否是Person类型，但是instanceof更加可靠，因为prototype对象完全可以被覆盖，其属性constructor也就不一定是Person了。</p>
 <figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+ <span class="variable">&lt;------------------------------+</span><br><span class="line">|      Person       |                                |</span><br><span class="line">+-------------------+                                |</span><br><span class="line">|prototype|        -|--+--&gt;</span>+----------------------+  |<span class="string"></span><br><span class="line">+-------------------+  </span>|<span class="string">   </span>|<span class="string">     Person prototype </span>|<span class="string">  </span>|</span><br><span class="line">                       |<span class="string">   +----------------------+  </span>|</span><br><span class="line">+--------------------+ |<span class="string">   </span>|<span class="string">constructor</span>|<span class="string">         -</span>|<span class="string">--+</span><br><span class="line"></span>|<span class="string">      person1       </span>|<span class="string"> </span>|<span class="string">   +----------------------+</span><br><span class="line">+--------------------+ </span>|<span class="string">   </span>|<span class="string">name       </span>|<span class="string">"Nicholas"</span>|</span><br><span class="line">|<span class="string">[[Prototype]]</span>|<span class="string">     -</span>|<span class="string">-+   +----------------------+</span><br><span class="line">+--------------------+ </span>|<span class="string">   </span>|<span class="string">age        </span>|<span class="string">     29   </span>|</span><br><span class="line">                       |<span class="string">   +----------------------+</span><br><span class="line">+--------------------+ </span>|<span class="string">   </span>|<span class="string">job        </span>|<span class="string">"Soft...."</span>|</span><br><span class="line">|<span class="string">      person2       </span>|<span class="string"> </span>|<span class="string">   +----------------------+</span><br><span class="line">+--------------------+ </span>|<span class="string">   </span>|<span class="string">sayName    </span>|<span class="string">(function)</span>|</span><br><span class="line">|<span class="string">[[Prototype]]</span>|<span class="string">     -</span>|<span class="string">-+   +----------------------+</span><br><span class="line">+--------------------+</span></span><br></pre></td></tr></table></figure>
<p> 虽然在所有实现中都无法访问到[[Prototype]]，但可以通过 isPrototypeOf()方法来确定对象之间是否存在这种关系。从本质上讲，如果[[Prototype]]指向调用 isPrototypeOf()方法的对象（Person.prototype），那么这个方法就返回true</p>
<p> ECMAScript 5增加了一个新方法，叫 Object.getPrototypeOf()，在所有支持的实现中，这个方法返回[[Prototype]]的值。</p>
<p> 每当代码读取某个对象的某个属性时，都会执行一次搜索，目标是具有给定名字的属性。搜索首先从对象实例本身开始。如果在实例中找到了具有给定名字的属性，则返回该属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。如果在原型对象中找到了这个属性，则返回该属性的值。</p>
<p> 虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。如果我们在实例中添加了一个属性，而该属性与实例原型中的一个属性同名，那我们就在实例中创建该属性，该属性将会屏蔽原型中的那个属性。<code>person1.name = &quot;Greg&quot;;</code>将会覆盖原型中的name属性。</p>
<p> 不过，使用delete操作符则可以完全删除实例属性，从而让我们能够重新访问原型中的属性</p>
<p> 使用hasOwnProperty()方法可以检测一个属性是存在于实例中，还是存在于原型中。这个方法（不要忘了它是从Object继承来的）只在给定属性存在于对象实例中时，才会返回true。<code>person1.hasOwnProperty(&quot;name&quot;);person2.hasOwnProperty(&quot;name&quot;);</code>第一个返回true，第二个返回false</p>
<p> ECMAScript 5 的 Object.getOwnPropertyDescriptor() 方法只能用于实例属性,要取得原型属性的描述符,必须直接在原型对象上调用 Object.getOwnPropertyDescriptor() 方法。</p>
</li>
<li><p>原型与 in 操作符<br> 有两种方式使用in操作符：单独使用和在for-in循环中使用。在单独使用时，in操作符会在通过对象能够访问给定属性时返回true，无论该属性存在于实例中还是原型中。<code>&quot;name&quot; in person1</code>为true</p>
<p> 在使用 for-in 循环时，返回的是所有能够通过对象访问的、可枚举的（enumerated）属性，其中既包括存在于实例中的属性，也包括存在于原型中的属性。屏蔽了原型中不可枚举属性（即将[[Enumerable]]标记为 false 的属性）的实例属性也会在 for-in 循环中返回，因为根据规定，所有开发人员定义的属性都是可枚举的——只有在IE8及更早版本中例外。</p>
<p> 要取得对象上所有可枚举的实例属性，可以使用ECMAScript 5的Object.keys()方法。这个方法接收一个对象作为参数，返回一个包含所有可枚举属性的字符串数组。</p>
<p> 为减少不必要的输入，也为了从视觉上更好地封装原型的功能，更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象，如下面的例子所示。</p>
 <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var keys = Object.keys(<span class="keyword">Person</span>.prototype); //<span class="comment">["name","age","jbo","sayName"]</span></span><br><span class="line">var keys = Object.getOwnPropertyNames(<span class="keyword">Person</span>.prototype); //<span class="comment">["constructor","name","age","jbo","sayName"]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>更简单的原型语法<br> 如果你想要得到所有实例属性，无论它是否可枚举，都可以使用Object.getOwnPropertyNames()方法。</p>
 <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">Person</span>()&#123; &#125;</span><br><span class="line"><span class="keyword">Person</span>.prototype = &#123;</span><br><span class="line">    name : <span class="string">"Nicholas"</span>,</span><br><span class="line">    age : 29,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName : function () &#123; alert(this.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 这时constructor 属性不再指向 Person 了。前面曾经介绍过，每创建一个函数，就会同时创建它的 prototype 对象，这个对象也会自动获得 constructor 属性。而我们在这里使用的语法，本质上完全重写了默认的 prototype 对象，因此 constructor 属性也就变成了新对象的constructor属性（指向Object构造函数），不再指向Person函数。如果constructor的值真的很重要，可以像下面这样特意将它设置回适当的值。</p>
 <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">Person</span>()&#123; &#125;</span><br><span class="line"><span class="keyword">Person</span>.prototype = &#123;</span><br><span class="line">    constructor : <span class="keyword">Person</span>,</span><br><span class="line">    name : <span class="string">"Nicholas"</span>,</span><br><span class="line">    age : 29,</span><br><span class="line">    job: <span class="string">"Software Engineer"</span>,</span><br><span class="line">    sayName : function () &#123; alert(this.name); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p> 注意，以这种方式重设 constructor 属性会导致它的[[Enumerable]]特性被设置为 true。默认情况下，原生的constructor属性是不可枚举的，因此如果你使用兼容ECMAScript 5的JavaScript引擎，可以试一试Object.defineProperty()。</p>
</li>
<li><p>原型的动态性<br> 由于在原型中查找值的过程是一次搜索,因此我们对原型对象所做的任何修改都能够立即从实例上反映出来——即使是先创建了实例后修改原型也照样如此。</p>
 <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var friend = new <span class="keyword">Person</span>();</span><br><span class="line"><span class="keyword">Person</span>.prototype.sayHi = function()&#123;</span><br><span class="line">  alert(<span class="string">"hi"</span>);</span><br><span class="line">&#125;;</span><br><span class="line">friend.sayHi(); //<span class="string">"hi"</span>(没有问题!)</span><br></pre></td></tr></table></figure>
<p> 其原因可以归结为实例与原型之间的松散连接关系。当我们调用person.sayHi()时，首先会在实例中搜索名为 sayHi 的属性，在没找到的情况下，会继续搜索原型。因为实例与原型之间的连接只不过是一个指针，而非一个副本，因此就可以在原型中找到新的 sayHi 属性并返回保存在那里的函数。</p>
<p> 尽管可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果是重写整个原型对象，那么情况就不一样了。我们知道，调用构造函数时会为实例添加一个指向最初原型的[[Prototype]]指针，而把原型修改为另外一个对象就等于切断了构造函数与最初原型之间的联系。请记住：实例中的指针仅指向原型，而不指向构造函数</p>
</li>
<li><p>原生对象的原型<br> 通过原生对象的原型，不仅可以取得所有默认方法的引用，而且也可以定义新方法。可以像修改自定义对象的原型一样修改原生对象的原型，因此可以随时添加方法。但是不推荐这么做。</p>
</li>
<li>原型对象的问题<br> 原型中所有属性是被很多实例共享的，这种共享对于函数非常合适。对于那些包含基本值的属性倒也说得过去，毕竟（如前面的例子所示），通过在实例上添加一个同名属性，可以隐藏原型中的对应属性。然而，对于包含引用类型值的属性来说，问题就比较突出了。</li>
</ol>
<h3 id="组合使用构造函数模式和原型模式">组合使用构造函数模式和原型模式</h3><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。结果，每个实例都会有自己的一份实例属性的副本，但同时又共享着对方法的引用，最大限度地节省了内存。另外，这种混成模式还支持向构造函数传递参数；可谓是集两种模式之长。这是用来定义引用类型的一种默认模式。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">Person</span>(name, age, job)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">Person</span>.prototype = &#123;</span><br><span class="line">  constructor : <span class="keyword">Person</span>,</span><br><span class="line">  sayName : function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="动态原型模式">动态原型模式</h3><p>有其他 OO 语言经验的开发人员在看到独立的构造函数和原型时,很可能会感到非常困惑。动态原型模式正是致力于解决这个问题的一个方案，它把所有信息都封装在了构造函数中，而通过在构造函数中初始化原型（仅在必要的情况下），又保持了同时使用构造函数和原型的优点。换句话说，可以通过检查某个应该存在的方法是否有效，来决定是否需要初始化原型。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">Person</span>(name, age, job)&#123;</span><br><span class="line">  this.name = name;</span><br><span class="line">  this.age = age;</span><br><span class="line">  this.job = job;</span><br><span class="line">  //方法</span><br><span class="line">  if (typeof this.sayName != <span class="string">"function"</span>)&#123;</span><br><span class="line">    <span class="keyword">Person</span>.prototype.sayName = function()&#123;</span><br><span class="line">      alert(this.name);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>if中这段代码只会在初次调用构造函数时才会执行。</p>
<p>使用动态原型模式时,不能使用对象字面量重写原型。前面已经解释过了,如果在已经创建了实例的情况下重写原型,那么就会切断现有实例与新原型之间的联系。</p>
<h3 id="寄生构造函数模式">寄生构造函数模式</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">Person</span>(name, age, job)&#123;</span><br><span class="line">  var o = new Object();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = function()&#123;</span><br><span class="line">    alert(this.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new <span class="keyword">Person</span>(<span class="string">"Nicholas"</span>, 29, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure>
<p>除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式跟工厂模式其实是一模一样的。构造函数在不返回值的情况下，默认会返回新对象实例。添加return可以重写调用构造函数时返回的值。</p>
<p>关于寄生构造函数模式，有一点需要说明：首先，返回的对象与构造函数或者与构造函数的原型属性之间没有关系；也就是说，构造函数返回的对象与在构造函数外部创建的对象没有什么不同。为此，不能依赖instanceof操作符来确定对象类型。由于存在上述问题，我们建议在可以使用其他模式的情况下，不要使用这种模式。</p>
<h3 id="稳妥构造函数模式">稳妥构造函数模式</h3><p>稳妥对象，指的是没有公共属性，而且其方法也不引用this的对象。稳妥对象最适合在一些安全的环境中（这些环境中会禁止使用this和new），或者在防止数据被其他应用程序（如Mashup程序）改动时使用。稳妥构造函数遵循与寄生构造函数类似的模式，但有两点不同：一是新创建对象的实例方法不引用this；二是不使用new 操作符调用构造函数<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">Person</span>(name, age, job)&#123;</span><br><span class="line">  var o = new Object();</span><br><span class="line">  //可以在这里定义私有变量和函数</span><br><span class="line">  o.sayName = function()&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;;</span><br><span class="line">  return o;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new <span class="keyword">Person</span>(<span class="string">"Nicholas"</span>, 29, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure></p>
<p>除了调用 sayName() 方法外,没有别的方式可以访问其数据成员。</p>
<p>与寄生构造函数模式类似，使用稳妥构造函数模式创建的对象与构造函数之间也没有什么关系，因此instanceof操作符对这种对象也没有意义。</p>
<h3 id="Class">Class</h3><p>ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class <span class="keyword">Person</span>&#123;</span><br><span class="line">  constructor(name, age, job)&#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">    this.age = age;</span><br><span class="line">    this.job = job;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName()&#123;</span><br><span class="line">    alert(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var friend = new <span class="keyword">Person</span>(<span class="string">"Nicholas"</span>, 29, <span class="string">"Software Engineer"</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。</p>
<p>如果对比前面的组合使用构造函数模式和原型模式，可以发现前面的Person构造函数对应现在Person类的构造方法constructor，前面Person原型上定义的sayName方法现在是类的内部方法。</p>
<p>ES6的类，完全可以看作构造函数的另一种写法。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof <span class="keyword">Person</span> // <span class="string">"function"</span></span><br></pre></td></tr></table></figure></p>
<p>prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Person</span>.prototype.constructor === <span class="keyword">Person</span>// true</span><br></pre></td></tr></table></figure></p>
<p>另外，类的内部所有定义的方法，都是不可枚举的（enumerable）。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(<span class="keyword">Person</span>.prototype)</span><br><span class="line">// <span class="comment">[]</span></span><br><span class="line">Object.getOwnPropertyNames(<span class="keyword">Person</span>.prototype)</span><br><span class="line">// <span class="comment">["constructor","sayName"]</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，sayName方法是Person类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。</p>
<h4 id="constructor方法">constructor方法</h4><p>constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。</p>
<p>constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Foo() <span class="keyword">instanceof</span> Foo <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。</p>
<h4 id="实例对象">实例对象</h4><p>生成实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。</p>
<p>与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。</p>
<p>与ES5一样，类的所有实例共享一个原型对象。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">friend.__proto__ === <span class="keyword">Person</span>.prototype  //true</span><br></pre></td></tr></table></figure>
<h4 id="name属性">name属性</h4><p>由于本质上，ES6的Class只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Person</span>.name</span><br></pre></td></tr></table></figure></p>
<h4 id="class_表达式">class 表达式</h4><p>与函数一样，Class也可以使用表达式的形式定义。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> <span class="title">Me</span> </span>&#123;</span><br><span class="line">  getClassName() &#123;</span><br><span class="line">    <span class="keyword">return</span> Me.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。如果Class内部没用到的话，可以省略Me，也就是可以写成下面的形式。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> MyClass = <span class="class"><span class="keyword">class</span> </span>&#123; <span class="comment">/* ... */</span> &#125;;</span><br></pre></td></tr></table></figure></p>
<p>采用Class表达式，可以写出立即执行的Class。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">person</span> = new class &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayName() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;(<span class="string">"张三"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">person</span>.sayName(); // <span class="string">"张三"</span></span><br></pre></td></tr></table></figure>
<h4 id="不存在变量提升">不存在变量提升</h4><p>Class不存在变量提升（hoist），这一点与ES5完全不同。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Foo(); <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把变量声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let <span class="type">Foo</span> = <span class="class"><span class="keyword">class</span> &#123;</span>&#125;;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="严格模式">严格模式</h4><p>类和模块的内部，默认就是严格模式，所以不需要使用<code>use strict</code>指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。</p>
<h4 id="class的取值函数（getter）和存值函数（setter）">class的取值函数（getter）和存值函数（setter）</h4><p>与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> MyClass &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>() </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">get</span> prop() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'getter'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">set</span> prop(value) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'setter: '</span>+value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> inst = <span class="keyword">new</span> MyClass();</span><br><span class="line"></span><br><span class="line">inst.prop = <span class="number">123</span>;</span><br><span class="line"><span class="comment">// setter: 123</span></span><br><span class="line"></span><br><span class="line">inst.prop</span><br><span class="line"><span class="comment">// 'getter'</span></span><br></pre></td></tr></table></figure>
<p>存值函数和取值函数是设置在属性的descriptor对象上的。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> CustomHTMLElement &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(element) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.element = element;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> html() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.element.innerHTML;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span> html(value) &#123;</span><br><span class="line">    <span class="keyword">this</span>.element.innerHTML = value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(</span><br><span class="line">  CustomHTMLElement.prototype, <span class="string">"html"</span>);</span><br><span class="line"><span class="string">"get"</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br><span class="line"><span class="string">"set"</span> <span class="keyword">in</span> descriptor  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。</p>
<p>下面的例子针对所有属性，设置存值函数和取值函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Jedi &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(options = </span>&#123;&#125;) &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">set</span>(key, val) &#123;</span><br><span class="line">    <span class="keyword">this</span>[key] = val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span>(key) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>[key];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Jedi实例所有属性的存取，都会通过存值函数和取值函数。</p>
<h4 id="Class的Generator方法">Class的Generator方法</h4><p>如果某个方法之前加上星号（*），就表示该方法是一个Generator函数。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Foo &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(...args) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.args = args;</span><br><span class="line">  &#125;</span><br><span class="line">  * [Symbol.iterator]() &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> arg of <span class="keyword">this</span>.args) &#123;</span><br><span class="line">      <span class="keyword">yield</span> arg;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x of <span class="keyword">new</span> Foo(<span class="string">'hello'</span>, <span class="string">'world'</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个Generator函数。Symbol.iterator方法返回一个Foo类的默认Iterator对象，for…of循环会自动调用这个方法。</p>
<h4 id="Class的静态方法">Class的静态方法</h4><p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Foo.classMethod() <span class="regexp">//</span> <span class="string">'hello'</span></span><br><span class="line"></span><br><span class="line"><span class="reserved">var</span> foo = <span class="keyword">new</span> Foo();</span><br><span class="line">foo.classMethod()</span><br><span class="line"><span class="regexp">//</span> <span class="attribute">TypeError</span>: <span class="literal">undefined</span> <span class="keyword">is</span> <span class="keyword">not</span> a <span class="reserved">function</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（<code>Foo.classMethod()</code>），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。</p>
<p>父类的静态方法，可以被子类继承。</p>
<p>静态方法也是可以从super对象上调用的。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="symbol">'hell</span>o';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bar</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Foo</span> &#123;</span></span><br><span class="line">  static classMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.classMethod() + ', too';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Bar</span>.classMethod();</span><br></pre></td></tr></table></figure>
<h4 id="new-target属性">new.target属性</h4><p>new是从构造函数生成实例的命令。ES6为new命令引入了一个<code>new.target</code>属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，<code>new.target</code>会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function <span class="keyword">Person</span>(name) &#123;</span><br><span class="line">  if (new.target !== undefined) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw new Error('必须使用new生成实例');</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 另一种写法</span><br><span class="line">function <span class="keyword">Person</span>(name) &#123;</span><br><span class="line">  if (new.target === <span class="keyword">Person</span>) &#123;</span><br><span class="line">    this.name = name;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    throw new Error('必须使用new生成实例');</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var <span class="keyword">person</span> = new <span class="keyword">Person</span>('张三'); // 正确</span><br><span class="line">var notAPerson = <span class="keyword">Person</span>.call(<span class="keyword">person</span>, '张三');  // 报错</span><br></pre></td></tr></table></figure>
<p>上面代码确保构造函数只能通过new命令调用。</p>
<p>Class内部调用<code>new.target</code>，返回当前Class。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Rectangle &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(length, width) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="keyword">this</span>.length = length;</span><br><span class="line">    <span class="keyword">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>); <span class="comment">// 输出 true</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，子类继承父类时，<code>new.target</code>会返回子类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Rectangle &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(length, width) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target === Rectangle);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Square extends Rectangle &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(length) </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(length, length);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> Square(<span class="number">3</span>); <span class="comment">// 输出 false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>new.target</code>会返回子类。</p>
<p>利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Shape &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.target === Shape) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'本类不能实例化'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Rectangle extends Shape &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(length, width) </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> x = <span class="keyword">new</span> Shape();  <span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">var</span> y = <span class="keyword">new</span> Rectangle(<span class="number">3</span>, <span class="number">4</span>);  <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Shape类不能被实例化，只能用于继承。</p>
<p>注意，在函数外部，使用<code>new.target</code>会报错。</p>
<h4 id="Mixin模式的实现">Mixin模式的实现</h4><p>Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">mix</span><span class="params">(<span class="rest_arg">...mixins</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">Mix</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (let mixin of mixins) &#123;</span><br><span class="line">    copyProperties(Mix, mixin);</span><br><span class="line">    copyProperties(Mix.prototype, mixin.prototype);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> Mix;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">copyProperties</span><span class="params">(target, source)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (let key of Reflect.ownKeys(source)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ( key !== <span class="string">"constructor"</span></span><br><span class="line">      &amp;&amp; key !== <span class="string">"prototype"</span></span><br><span class="line">      &amp;&amp; key !== <span class="string">"name"</span></span><br><span class="line">    ) &#123;</span><br><span class="line">      let desc = Object.getOwnPropertyDescriptor(source, key);</span><br><span class="line">      Object.defineProperty(target, key, desc);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DistributedEdit</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">mix</span>(</span><span class="type">Loggable</span>, <span class="type">Serializable</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="继承">继承</h2><p>ECMAScript只支持实现继承，而且其实现继承主要是依靠原型链来实现的。</p>
<h3 id="原型链">原型链</h3><p>其基本思想是利用原型让一个引用类型继承另一个引用类型的属性和方法。简单回顾一下构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。那么，假如我们让原型对象等于另一个类型的实例，结果会怎么样呢？显然，此时的原型对象将包含一个指向另一个原型的指针，相应地，另一个原型中也包含着一个指向另一个构造函数的指针。假如另一个原型又是另一个类型的实例，那么上述关系依然成立，如此层层递进，就构成了实例与原型的链条。这就是所谓原型链的基本概念。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//inherit from SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperValue());   <span class="comment">//true</span></span><br><span class="line"></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> <span class="built_in">Object</span>);      <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SuperType);   <span class="comment">//true</span></span><br><span class="line">alert(instance <span class="keyword">instanceof</span> SubType);     <span class="comment">//true</span></span><br><span class="line">alert(<span class="built_in">Object</span>.prototype.isPrototypeOf(instance));    <span class="comment">//true</span></span><br><span class="line">alert(SuperType.prototype.isPrototypeOf(instance)); <span class="comment">//true</span></span><br><span class="line">alert(SubType.prototype.isPrototypeOf(instance));   <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>既然 SubType.prototype 现在是 SuperType的实例,那么 property 当然就位于该实例中了。此外,要注意 instance.constructor 现在指向的是 SuperType ,这是因为SubType 的原型指向了另一个对象—— SuperType 的原型,而这个原型对象的 constructor 属性指向的是 SuperType。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">+-------------------+</span><br><span class="line">|<span class="string">      SuperType    </span>|<span class="string"> &lt;--------------------------------+</span><br><span class="line">+-------------------+                                  </span>|</span><br><span class="line">|<span class="string">prototype</span>|<span class="string">        -</span>|<span class="string">----+&gt;+------------------------+  </span>|</span><br><span class="line">+-------------------+    |<span class="string"> </span>|<span class="string">   SuperType prototype  </span>|<span class="string">  </span>|</span><br><span class="line">                         |<span class="string"> +------------------------+  </span>|</span><br><span class="line">+--------------------+   |<span class="string"> </span>|<span class="string">constructor  </span>|<span class="string">         -</span>|<span class="string">--+</span><br><span class="line"></span>|<span class="string">      SubType       </span>|<span class="string">   </span>|<span class="string"> +------------------------+</span><br><span class="line">+--------------------+   </span>|<span class="string"> </span>|<span class="string">getSuperValue</span>|<span class="string">(function)</span>|</span><br><span class="line">|<span class="string">  prototype  </span>|<span class="string">     -</span>|<span class="string">-+ </span>|<span class="string"> +------------------------+</span><br><span class="line">+--------------------+ </span>|<span class="string"> +----------------------------+</span><br><span class="line">                       </span>|<span class="string">   +------------------------+ </span>|</span><br><span class="line">+--------------------+ |<span class="string">--&gt;</span>|<span class="string">    SubType prototype   </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string">      instance      </span>|<span class="string"> </span>|<span class="string">   +------------------------+ </span>|</span><br><span class="line">+--------------------+ |<span class="string">   </span>|<span class="string">[[Prototype]]</span>|<span class="string">         -</span>|<span class="string">-+</span><br><span class="line"></span>|<span class="string">[[Prototype]]</span>|<span class="string">     -</span>|<span class="string">-+   +------------------------+</span><br><span class="line">+--------------------+     </span>|<span class="string">property     </span>|<span class="string">  true    </span>|</span><br><span class="line">|<span class="string">subproperty  </span>|<span class="string"> false</span>|<span class="string">     +------------------------+</span><br><span class="line">+--------------------+     </span>|<span class="string">getSubValue  </span>|<span class="string">(function)</span>|</span><br><span class="line">                           +------------------------+</span><br></pre></td></tr></table></figure></p>
<p>通过实现原型链,本质上扩展了本章前面介绍的原型搜索机制。读者大概还记得,当以读取模式访问一个实例属性时,首先会在实例中搜索该属性。如果没有找到该属性,则会继续搜索实例的原型。在通过原型链实现继承的情况下,搜索过程就得以沿着原型链继续向上。就拿上面的例子来说,调用instance.getSuperValue() 会经历三个搜索步骤:1)搜索实例;2)搜索 SubType.prototype ; 3)搜索 SuperType.prototype ,最后一步才会找到该方法。在找不到属性或方法的情况下,搜索过程总是要一环一环地前行到原型链末端才会停下来。</p>
<ol>
<li>别忘记默认的原型<br> 事实上,前面例子中展示的原型链还少一环。我们知道,所有引用类型默认都继承了 Object ,而这个继承也是通过原型链实现的。大家要记住,所有函数的默认原型都是 Object 的实例,因此默认原型都会包含一个内部指针,指向 Object.prototype</li>
<li>确定原型和实例的关系<br> 第一种方式是使用 instanceof 操作符,只要用这个操作符来测试实例与原型链中出现过的构造函数,结果就会返回 true。<br> 第二种方式是使用 isPrototypeOf() 方法。同样,只要是原型链中出现过的原型,都可以说是该原型链所派生的实例的原型,因此 isPrototypeOf() 方法也会返回 true</li>
<li>谨慎地定义方法<br> 子类型有时候需要重写超类型中的某个方法,或者需要添加超类型中不存在的某个方法。但不管怎样,给原型添加方法的代码一定要放在替换原型的语句之后。 <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//继承了 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="comment">//添加新方法</span></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//重写超类型中的方法</span></span><br><span class="line">SubType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
 还有一点需要提醒读者,即在通过原型链实现继承时,不能使用对象字面量创建原型方法。因为这样做就会重写原型链</li>
<li><p>原型链的问题<br> 原型链虽然很强大,可以用它来实现继承,但它也存在一些问题。其中,最主要的问题来自包含引用类型值的原型。</p>
<p> 在通过原型来实现继承时,原型实际上会变成另一个类型的实例。于是,原先的实例属性也就顺理成章地变成了现在的原型属性了。这些继承的属性会被子类实例共享。</p>
 <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承了 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green,black"</span></span><br></pre></td></tr></table></figure>
<p> 原型链的第二个问题是:在创建子类型的实例时,不能向超类型的构造函数中传递参数。基于这两点原因实践中很少单独使用原型链</p>
</li>
</ol>
<h3 id="借用构造函数">借用构造函数</h3><p>在解决原型中包含引用类型值所带来问题的过程中,开发人员开始使用一种叫做借用构造函数(constructor stealing)的技术(有时候也叫做伪造对象或经典继承)。这种技术的基本思想相当简单,即在子类型构造函数的内部调用超类型构造函数。别忘了,函数只不过是在特定环境中执行代码的对象,因此通过使用 apply() 和 call() 方法也可以在(将来)新创建的对象上执行构造函数</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="comment">//继承了 SuperType 同时还传递了参数</span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);</span><br><span class="line">  <span class="keyword">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> instance1 = <span class="keyword">new</span> SubType();</span><br><span class="line">instance1.colors.push(<span class="string">"black"</span>);</span><br><span class="line">alert(instance1.colors); <span class="comment">//"red,blue,green,black"</span></span><br><span class="line"><span class="keyword">var</span> instance2 = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance2.colors); <span class="comment">//"red,blue,green"</span></span><br><span class="line">alert(instance2.name);</span><br><span class="line">alert(instance2.age);</span><br></pre></td></tr></table></figure>
<ol>
<li>传递参数<br> 这种方法解决了原型链的两个主要的问题，为了确保SuperType 构造函数不会重写子类型的属性,可以在调用超类型构造函数后,再添加应该在子类型中定义的属性。</li>
<li>借用构造函数的问题<br> 如果仅仅是借用构造函数,那么也将无法避免构造函数模式存在的问题——方法都在构造函数中定义,因此函数复用就无从谈起了。而且,在超类型的原型中定义的方法,对子类型而言也是不可见的,结果所有类型都只能使用构造函数模式。考虑到这些问题,借用构造函数的技术也是很少单独使用的。</li>
</ol>
<h3 id="组合继承">组合继承</h3><p>组合继承(combination inheritance) ,有时候也叫做伪经典继承,指的是将原型链和借用构造函数的技术组合到一块,从而发挥二者之长的一种继承模式。其背后的思路是使用原型链实现对原型属性和方法的继承,而通过借用构造函数来实现对实例属性的继承。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span>&#123;</span></span><br><span class="line">  this.name = name;</span><br><span class="line">  this.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">  alert<span class="params">(this.name)</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span>&#123;</span></span><br><span class="line">  <span class="comment">//继承属性</span></span><br><span class="line">  SuperType.call<span class="params">(this, name)</span>;</span><br><span class="line">  this.age = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//继承方法</span></span><br><span class="line">SubType.prototype = new SuperType<span class="params">()</span>;</span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">  alert<span class="params">(this.age)</span>;</span><br><span class="line">&#125;;</span><br><span class="line">var instance1 = new SubType<span class="params">(<span class="string">"Nicholas"</span>, <span class="number">29</span>)</span>;</span><br><span class="line">instance1.colors.push<span class="params">(<span class="string">"black"</span>)</span>;</span><br><span class="line">alert<span class="params">(instance1.colors)</span>; <span class="comment">//"red,blue,green,black"</span></span><br><span class="line">instance1.sayName<span class="params">()</span>; <span class="comment">//"Nicholas";</span></span><br><span class="line">instance1.sayAge<span class="params">()</span>; <span class="comment">//29</span></span><br><span class="line">var instance2 = new SubType<span class="params">(<span class="string">"Greg"</span>, <span class="number">27</span>)</span>;</span><br><span class="line">alert<span class="params">(instance2.colors)</span>; <span class="comment">//"red,blue,green"</span></span><br><span class="line">instance2.sayName<span class="params">()</span>; <span class="comment">//"Greg";</span></span><br><span class="line">instance2.sayAge<span class="params">()</span>; <span class="comment">//27</span></span><br></pre></td></tr></table></figure></p>
<h3 id="原型式继承">原型式继承</h3><p>道格拉斯·克罗克福德在 2006 年写了一篇文章,题为 Prototypal Inheritance in JavaScript (JavaScript 中的原型式继承)。在这篇文章中,他介绍了一种实现继承的方法,这种方法并没有使用严格意义上的构造函数。他的想法是借助原型可以基于已有的对象创建新对象,同时还不必因此创建自定义类型。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span><span class="params">(o)</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在 object() 函数内部,先创建了一个临时性的构造函数,然后将传入的对象作为这个构造函数的原型,最后返回了这个临时类型的一个新实例。从本质上讲, object() 对传入其中的对象执行了一次浅复制。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">person</span> = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  friends: <span class="comment">["Shelby", "Court", "Van"]</span></span><br><span class="line">&#125;;</span><br><span class="line">//var anotherPerson = object(<span class="keyword">person</span>);</span><br><span class="line">var anotherPerson = Object.create(<span class="keyword">person</span>);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line">//var yetAnotherPerson = object(<span class="keyword">person</span>);</span><br><span class="line">var yetAnotherPerson = Object.create(<span class="keyword">person</span>);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line">alert(<span class="keyword">person</span>.friends); //<span class="string">"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure>
<p>原型式继承,要求你必须有一个对象可以作为另一个对象的基础。通过object()函数返回的对象实际上是person的副本，它们共享这引用类型属性。</p>
<p>ECMAScript 5 通过新增 Object.create() 方法规范化了原型式继承。这个方法接收两个参数:一个用作新对象原型的对象和(可选的)一个为新对象定义额外属性的对象。在传入一个参数的情况下,Object.create() 与 object() 方法的行为相同</p>
<p>Object.create() 方法的第二个参数与 Object.defineProperties() 方法的第二个参数格式相同:每个属性都是通过自己的描述符定义的。以这种方式指定的任何属性都会覆盖原型对象上的同名属性。</p>
<p>在没有必要兴师动众地创建构造函数,而只想让一个对象与另一个对象保持类似的情况下,原型式继承是完全可以胜任的。不过别忘了,包含引用类型值的属性始终都会共享相应的值,就像使用原型模式一样。</p>
<h3 id="寄生式继承">寄生式继承</h3><p>寄生式(parasitic)继承是与原型式继承紧密相关的一种思路,并且同样也是由克罗克福德推而广之的。寄生式继承的思路与寄生构造函数和工厂模式类似,即创建一个仅用于封装继承过程的函数,该函数在内部以某种方式来增强对象,最后再像真地是它做了所有工作一样返回对象。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span><span class="params">(original)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">clone</span> = object(original); <span class="comment">//通过调用函数创建一个新对象</span></span><br><span class="line">  <span class="keyword">clone</span>.sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;  <span class="comment">//以某种方式来增强这个对象</span></span><br><span class="line">    alert(<span class="string">"hi"</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">clone</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在主要考虑对象而不是自定义类型和构造函数的情况下,寄生式继承也是一种有用的模式。前面示范继承模式时使用的 object() 函数不是必需的;任何能够返回新对象的函数都适用于此模式。</p>
<p>使用寄生式继承来为对象添加函数,会由于不能做到函数复用而降低效率;这一点与构造函数模式类似。</p>
<h3 id="寄生组合式继承">寄生组合式继承</h3><p>组合继承是 JavaScript 最常用的继承模式;不过,它也有自己的不足。组合继承最大的问题就是无论什么情况下,都会调用两次超类型构造函数:一次是在创建子类型原型的时候,另一次是在子类型构造函数内部。没错,子类型最终会包含超类型对象的全部实例属性,但我们不得不在调用子类型构造函数时重写这些属性。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span></span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name); <span class="comment">//第二次调用 SuperType()</span></span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType(); <span class="comment">//第一次调用 SuperType()</span></span><br><span class="line">SubType.prototype.constructor = SubType;</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在第一次调用 SuperType 构造函数时, SubType.prototype 会得到两个属性: name 和 colors ;它们都是 SuperType 的实例属性,只不过现在位于 SubType 的原型中。当调用 SubType 构造函数时,又会调用一次 SuperType 构造函数,这一次又在新对象上创建了实例属性 name 和 colors 。</p>
<p>所谓寄生组合式继承,即通过借用构造函数来继承属性,通过原型链的混成形式来继承方法。其背后的基本思路是:不必为了指定子类型的原型而调用超类型的构造函数,我们所需要的无非就是超类型原型的一个副本而已。本质上,就是使用寄生式继承来继承超类型的原型,然后再将结果指定给子类型的原型。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span><span class="params">(subType, superType)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在函数内部,第一步是创建超类型原型的一个副本。第二步是为创建的副本添加 constructor 属性,从而弥补因重写原型而失去的默认的 constructor 属性。最后一步,将新创建的对象(即副本)赋值给子类型的原型。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span><span class="params">(name)</span></span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span><span class="params">(name, age)</span></span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>YUI 的 YAHOO.lang.extend() 方法采用了寄生组合继承</p>
<h3 id="Class的继承">Class的继承</h3><h4 id="基本用法">基本用法</h4><p>Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SuperType&#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(name)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> SubType extends SuperType&#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(name, age)</span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">  &#125;</span><br><span class="line">  sayAge()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.age);</span><br><span class="line">    <span class="keyword">super</span>.sayName();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SubType类通过extends关键字，继承了SuperType类的所有属性和方法，并且扩展了属性和方法。super关键字，它指代父类的实例（即父类的this对象）。</p>
<p>子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span> &#123;</span> <span class="comment">/* ... */</span> &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SuperType</span> &#123;</span></span><br><span class="line">  constructor() &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let cp = <span class="keyword">new</span> <span class="type">SubType</span>(); <span class="comment">// ReferenceError</span></span><br></pre></td></tr></table></figure>
<p>对比前面的借用构造函数继承，实质是先创建子类的实例对象this，然后再将父类的属性添加到this上面（<code>Parent.apply(this)</code>）。ES6的继承机制则不同，实质是先创建父类的实例对象this（所以必须先调用super方法），然后再用子类的属性修改this。</p>
<p>如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="constructor"><span class="keyword">constructor</span>(...args) </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(...args);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> SuperType&#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(name)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line">  sayName()&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> SubType extends SuperType&#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(name, age)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.age = age; <span class="comment">// ReferenceError</span></span><br><span class="line">    <span class="keyword">super</span>(name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">let</span> st = <span class="keyword">new</span> SubType(<span class="string">"Howie"</span>, <span class="number">26</span>);</span><br><span class="line">st <span class="keyword">instanceof</span> SubType <span class="regexp">//</span> <span class="literal">true</span></span><br><span class="line">st <span class="keyword">instanceof</span> SuperType <span class="regexp">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，实例对象st同时是SubType和SuperType两个类的实例，这与ES5的行为完全一致。</p>
<h4 id="类的prototype属性和__proto__属性">类的prototype属性和<code>__proto__</code>属性</h4><p>大部分浏览器实现中，每一个对象都有<code>__proto__</code>属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和<code>__proto__</code>属性，因此同时存在两条继承链。</p>
<ol>
<li>子类的<code>__proto__</code>属性，表示构造函数的继承，总是指向父类。</li>
<li>子类prototype属性的<code>__proto__</code>属性，表示方法的继承，总是指向父类的prototype属性。</li>
</ol>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SubType.<span class="variable">__proto__ =</span>== SuperType // <span class="constant">true</span></span><br><span class="line">SubType.prototype.<span class="variable">__proto__ =</span>== SuperType.prototype // <span class="constant">true</span></span><br></pre></td></tr></table></figure>
<p>这样的结果是因为，类的继承是按照下面的模式实现的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperType</span> </span>&#123; &#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// B的实例继承A的实例</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(SubType.prototype, SuperType.prototype);</span><br><span class="line"></span><br><span class="line"><span class="comment">// B继承A的静态属性</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(SubType, SuperType);</span><br><span class="line"><span class="comment">//而setPrototypeOf实现如下</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf = <span class="function"><span class="keyword">function</span> (<span class="params">obj, proto</span>) </span>&#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两条继承链，可以这样理解：作为一个对象，子类的原型（<code>__proto__</code>属性）是父类；作为一个构造函数，子类的原型（prototype属性）是父类的实例。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SubType.<span class="keyword">prototype</span> = new SuperType();</span><br><span class="line"><span class="regexp">//</span> 等同于</span><br><span class="line">SubType.<span class="keyword">prototype</span>.__proto_<span class="number">_</span> = SuperType.<span class="keyword">prototype</span>;</span><br></pre></td></tr></table></figure>
<h4 id="Extends_的继承目标">Extends 的继承目标</h4><p>extends关键字后面可以跟多种类型的值。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SuperType</span>&#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的SuperType，只要是一个有prototype属性的函数，就能被SubType继承。由于函数都有prototype属性，因此SuperType可以是任意函数。</p>
<p>下面，讨论三种特殊情况。</p>
<p>第一种特殊情况，子类继承Object类。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Object</span> &#123;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">A</span>.__proto__ === <span class="type">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="type">A</span>.prototype.__proto__ === <span class="type">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。</p>
<p>第二种特殊情况，不存在任何继承。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">A.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line">A.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承<code>Funciton.prototype</code>。但是，A调用后返回一个空对象（即Object实例），所以<code>A.prototype.__proto__</code>指向构造函数（Object）的prototype属性。</p>
<p>第三种特殊情况，子类继承null。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">null</span> &#123;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">A</span>.__proto__ === <span class="type">Function</span>.prototype <span class="comment">// true</span></span><br><span class="line"><span class="type">A</span>.prototype.__proto__ === undefined <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承<code>Funciton.prototype</code>。但是，A调用后返回的对象不继承任何方法，所以它的<code>__proto__</code>指向<code>Function.prototype</code>，即实质上执行了下面的代码。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> A extends <span class="literal">null</span> &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>() </span>&#123; <span class="keyword">return</span> <span class="built_in">Object</span>.create(<span class="literal">null</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Object-getPrototypeOf()">Object.getPrototypeOf()</h4><p>Object.getPrototypeOf方法可以用来从子类上获取父类。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.getPrototypeOf(SubType) === SuperType <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因此，可以使用这个方法判断，一个类是否继承了另一个类。</p>
<h4 id="super关键字">super关键字</h4><p>上面讲过，在子类中，super关键字代表父类实例。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SubType</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SuperType</span> &#123;</span></span><br><span class="line">  get m() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._p * <span class="keyword">super</span>._p;</span><br><span class="line">  &#125;</span><br><span class="line">  set m() &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">Error</span>('该属性只读');</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，子类通过super关键字，调用父类的实例。</p>
<p>由于，对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="built_in">toString</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"MyObject: "</span> + <span class="keyword">super</span>.<span class="built_in">toString</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.<span class="built_in">toString</span>(); <span class="comment">// MyObject: [object Object]</span></span><br></pre></td></tr></table></figure>
<h4 id="实例的__proto__属性">实例的<code>__proto__</code>属性</h4><p>子类实例的<code>__proto__</code>属性的<code>__proto__</code>属性，指向父类实例的<code>__proto__</code>属性。也就是说，子类的原型的原型，是父类的原型。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">s1 =</span> new SuperType(<span class="string">"Howie"</span>);</span><br><span class="line"><span class="keyword">let</span> <span class="variable">s2 =</span> new SubType(<span class="string">"Howie"</span>, <span class="number">26</span>);</span><br><span class="line"></span><br><span class="line">s2.<span class="variable">__proto__ =</span>== s1.__proto // <span class="constant">false</span></span><br><span class="line">s2.__proto__.<span class="variable">__proto__ =</span>== s1.__proto__ // <span class="constant">true</span></span><br></pre></td></tr></table></figure>
<p>因此，通过子类实例的<code>__proto__.__proto__</code>属性，可以修改父类实例的行为。</p>
<h3 id="原生构造函数的继承">原生构造函数的继承</h3><p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构，比如<code>Array()</code>。以前，这些原生构造函数是无法继承的，即不能自己定义一个Array的子类。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyArray</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">Array</span>.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MyArray.prototype = <span class="built_in">Object</span>.create(<span class="built_in">Array</span>.prototype, &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>: </span>&#123;</span><br><span class="line">    value: MyArray,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> MyArray();</span><br><span class="line">colors[<span class="number">0</span>] = <span class="string">"red"</span>;</span><br><span class="line">colors.length  <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">colors.length = <span class="number">0</span>;</span><br><span class="line">colors[<span class="number">0</span>]  <span class="comment">// "red"</span></span><br></pre></td></tr></table></figure>
<p>之所以会发生这种情况，是因为原生构造函数无法外部获取，通过<code>Array.apply()</code>或者分配给原型对象都不行。ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的属性无法获取，导致无法继承原生的构造函数。</p>
<p>ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Array</span> &#123;</span></span><br><span class="line">  constructor(...args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(...args);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="type">MyArray</span>();</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">12</span>;</span><br><span class="line">arr.length <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">arr.length = <span class="number">0</span>;</span><br><span class="line">arr[<span class="number">0</span>] <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。</p>
<p>上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VersionedArray</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Array</span> &#123;</span></span><br><span class="line">  constructor() &#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.history = [[]];</span><br><span class="line">  &#125;</span><br><span class="line">  commit() &#123;</span><br><span class="line">    <span class="keyword">this</span>.history.push(<span class="keyword">this</span>.slice());</span><br><span class="line">  &#125;</span><br><span class="line">  revert() &#123;</span><br><span class="line">    <span class="keyword">this</span>.splice(<span class="number">0</span>, <span class="keyword">this</span>.length, <span class="keyword">this</span>.history[<span class="keyword">this</span>.history.length - <span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，VersionedArray结构会通过commit方法，将自己的上一个版本存入history属性，然后通过revert方法，可以撤销当前版本，回到上一个版本。除此之外，VersionedArray依然是一个数组，所有原生的数组方法都可以在它上面调用。</p>
<p>下面是一个自定义Error子类的例子。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> ExtendableError extends <span class="built_in">Error</span> &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(message) </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    <span class="keyword">this</span>.message = message;</span><br><span class="line">    <span class="keyword">this</span>.stack = (<span class="keyword">new</span> <span class="built_in">Error</span>()).stack;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="keyword">this</span>.constructor.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> MyError extends ExtendableError &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(m) </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(m);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> myerror = <span class="keyword">new</span> MyError(<span class="string">'ll'</span>);</span><br><span class="line">myerror.message <span class="comment">// "ll"</span></span><br><span class="line">myerror <span class="keyword">instanceof</span> <span class="built_in">Error</span> <span class="comment">// true</span></span><br><span class="line">myerror.name <span class="comment">// "MyError"</span></span><br><span class="line">myerror.stack</span><br><span class="line"><span class="comment">// Error</span></span><br><span class="line"><span class="comment">//     at MyError.ExtendableError</span></span><br><span class="line"><span class="comment">//     ...</span></span><br></pre></td></tr></table></figure>
<h1 id="函数表达式">函数表达式</h1><p>之前已经讲过函数声明和函数表达式区别了。</p>
<p>Firefox、Safari、Chrome 和 Opera 都给函数定义了一个非标准的 name 属性（ES6已经正式加入name属性）,通过这个属性可以访问到给函数指定的名字。这个属性的值永远等于跟在 function 关键字后面的标识符。</p>
<p>关于函数声明,它的一个重要特征就是函数声明提升(function declaration hoisting) ,意思是在执行代码之前会先读取函数声明。这就意味着可以把函数声明放在调用它的语句后面。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sayHi<span class="params">()</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayHi</span><span class="params">()</span>&#123;</span></span><br><span class="line">  alert<span class="params">(<span class="string">"Hi!"</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数表达式创建的函数叫做匿名函数(anonymous function),因为 function 关键字后面没有标识符。(匿名函数有时候也叫拉姆达函数)匿名函数的 name 属性是空字符串。</p>
<p>理解函数提升的关键,就是理解函数声明与函数表达式之间的区别。例如,执行以下代码的结果可能会让人意想不到。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不要这样做!</span></span><br><span class="line"><span class="keyword">if</span><span class="params">(condition)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span><span class="params">()</span>&#123;</span></span><br><span class="line">    alert<span class="params">(<span class="string">"Hi!"</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span><span class="params">()</span>&#123;</span></span><br><span class="line">    alert<span class="params">(<span class="string">"Yo!"</span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实际上,这在 ECMAScript 中属于无效语法,JavaScript 引擎会尝试修正错误,将其转换为合理的状态。但问题是浏览器尝试修正错误的做法并不一致。大多数浏览器会返回第二个声明,忽略condition ;Firefox 会在 condition 为 true 时返回第一个声明。因此这种使用方式很危险,不应该出现在你的代码中。不过,如果是使用函数表达式,那就没有什么问题了。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以这样做</span></span><br><span class="line">var sayHi;</span><br><span class="line"><span class="keyword">if</span><span class="params">(condition)</span>&#123;</span><br><span class="line">  sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">    alert<span class="params">(<span class="string">"Hi!"</span>)</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  sayHi = <span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line">    alert<span class="params">(<span class="string">"Yo!"</span>)</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="递归">递归</h2><p>之前说过可以递归时可以使用arguments.callee，但在严格模式下,不能通过脚本访问 arguments.callee ,访问这个属性会导致错误。不过,可以使用命名函数表达式来达成相同的结果。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factorial = (function f(<span class="built_in">num</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">num</span> &lt;= <span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">num</span> * f(<span class="built_in">num</span>-<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p>以上代码创建了一个名为 f() 的命名函数表达式,然后将它赋值给变量 factorial 。即便把函数赋值给了另一个变量,函数的名字 f 仍然有效,所以递归调用照样能正确完成。这种方式在严格模式和非严格模式下都行得通</p>
<h2 id="闭包">闭包</h2><p>闭包是指有权访问另一个函数作用域中的变量的函数。创建闭包的常见方式,就是在一个函数内部创建另一个函数</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createComparisonFunction(propertyName) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="keyword">object</span><span class="number">1</span>, <span class="keyword">object</span><span class="number">2</span>)&#123;</span><br><span class="line">        var <span class="keyword">value</span><span class="number">1</span> = <span class="keyword">object</span><span class="number">1</span>[propertyName];</span><br><span class="line">        var <span class="keyword">value</span><span class="number">2</span> = <span class="keyword">object</span><span class="number">2</span>[propertyName];</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &lt; <span class="keyword">value</span><span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &gt; <span class="keyword">value</span><span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即使这个内部函数被返回了,而且是在其他地方被调用了,但它仍然可以访问外部函数的变量 propertyName。之所以还能够访问这个变量,是因为内部函数的作用域链中包含createComparisonFunction() 的作用域。</p>
<p>前面讲的有关如何创建作用域链以及作用域链有什么作用的细节,对彻底理解闭包至关重要。当某个函数被调用时,会创建一个执行环境(execution context)及相应的作用域链。然后,使用 arguments 和其他命名参数的值来初始化函数的活动对象(activation object)。但在作用域链中,外部函数的活动对象始终处于第二位,外部函数的外部函数的活动对象处于第三位,……直至作为作用域链终点的全局执行环境。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &lt; <span class="keyword">value</span><span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &gt; <span class="keyword">value</span><span class="number">2</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var result = compare(<span class="number">5</span>, <span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>当调用 compare() 时,会创建一个包含 arguments 、 value1 和 value2 的活动对象。全局执行环境的变量对象(包含 result和 compare )在 compare() 执行环境的作用域链中则处于第二位。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">+----------------------+</span><br><span class="line">|<span class="string">     compare          </span>|</span><br><span class="line">|<span class="string">  execution context   </span>|<span class="string">&lt;-------------------------------------------------+</span><br><span class="line">+----------------------+    +------------+      +----------------------+  </span>|</span><br><span class="line">|<span class="string">(scope chain) </span>|<span class="string">      -</span>|<span class="string">---&gt;</span>|<span class="string">scope chain </span>|<span class="string">  +--&gt;</span>|<span class="string">global variable object</span>|<span class="string">  </span>|</span><br><span class="line">+----------------------+    +------------+  |<span class="string">   +----------------------+  </span>|</span><br><span class="line">                            |<span class="string">1     </span>|<span class="string">    -</span>|<span class="string">--+   </span>|<span class="string">   compare </span>|<span class="string">         -</span>|<span class="string">--+</span><br><span class="line">                            +------------+      +----------------------+</span><br><span class="line">                            </span>|<span class="string">0     </span>|<span class="string">    -</span>|<span class="string">--+   </span>|<span class="string">   result  </span>|<span class="string"> undefined</span>|</span><br><span class="line">                            +------------+  |<span class="string">   +----------------------+</span><br><span class="line">                                            </span>|</span><br><span class="line">                                            |<span class="string">   +----------------------+</span><br><span class="line">                                            +--&gt;</span>|<span class="string">    compare()         </span>|</span><br><span class="line">                                                |<span class="string">  activation object   </span>|</span><br><span class="line">                                                +----------------------+</span><br><span class="line">                                                |<span class="string"> arguments </span>|<span class="string">  [5,10]  </span>|</span><br><span class="line">                                                +----------------------+</span><br><span class="line">                                                |<span class="string">   value1  </span>|<span class="string">  5       </span>|</span><br><span class="line">                                                +----------------------+</span><br><span class="line">                                                |<span class="string">   value2  </span>|<span class="string">  10      </span>|</span><br><span class="line">                                                +----------------------+</span><br></pre></td></tr></table></figure>
<p>后台的每个执行环境都有一个表示变量的对象——变量对象。全局环境的变量对象始终存在,而像compare() 函数这样的局部环境的变量对象,则只在函数执行的过程中存在。在创建 compare() 函数时,会创建一个预先包含全局变量对象的作用域链,这个作用域链被保存在内部的 [[Scope]] 属性中。当调用 compare() 函数时,会为函数创建一个执行环境,然后通过复制函数的 [[Scope]] 属性中的对象构建起执行环境的作用域链。此后,又有一个活动对象(在此作为变量对象使用)被创建并被推入执行环境作用域链的前端。对于这个例子中 compare() 函数的执行环境而言,其作用域链中包含两个变量对象:本地活动对象和全局变量对象。显然,作用域链本质上是一个指向变量对象的指针列表,它只引用但不实际包含变量对象。</p>
<p>无论什么时候在函数中访问一个变量时,就会从作用域链中搜索具有相应名字的变量。一般来讲,当函数执行完毕后,局部活动对象就会被销毁,内存中仅保存全局作用域(全局执行环境的变量对象)。但是,闭包的情况又有所不同。</p>
<p>在另一个函数内部定义的函数会将外部函数的活动对象添加到它的作用域链中。因此,在 createComparisonFunction() 函数内部定义的匿名函数的作用域链中,实际上将会包含外部函数 createComparisonFunction() 的活动对象。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建函数</span><br><span class="line"><span class="keyword">var</span> compareNames = createComparisonFunction(<span class="string">"name"</span>);</span><br><span class="line">//调用函数</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = compareNames(&#123; name: <span class="string">"Nicholas"</span> &#125;, &#123; name: <span class="string">"Greg"</span> &#125;);</span><br><span class="line">//解除对匿名函数的引用(以便释放内存)</span><br><span class="line">compareNames = null;</span><br></pre></td></tr></table></figure>
<p>createComparisonFunction(“name”) 返回后其活动对象并没有被销毁，因为匿名函数（即被返回的比较函数）的作用域链中有对其的引用。通过将 compareNames 设置为等于 null解除该函数的引用,就等于通知垃圾回收例程将其清除。随着匿名函数的作用域链被销毁,其他作用域(除了全局作用域)也都可以安全地销毁了。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">+----------------------+</span><br><span class="line">|<span class="string">  anonymous function  </span>|</span><br><span class="line">|<span class="string">  execution context   </span>|</span><br><span class="line">+----------------------+ +------------+</span><br><span class="line">|<span class="string">(scope chain) </span>|<span class="string">      -</span>|<span class="string">&gt;</span>|<span class="string"> scope chain</span>|</span><br><span class="line">+----------------------+ +------------+</span><br><span class="line">                         |<span class="string">2     </span>|<span class="string">    -</span>|<span class="string">--&gt;全局变量对象</span><br><span class="line">                         +------------+</span><br><span class="line">                         </span>|<span class="string">1     </span>|<span class="string">    -</span>|<span class="string">--&gt;createComparisonFunction()的活动对象</span><br><span class="line">                         +------------+</span><br><span class="line">                         </span>|<span class="string">0     </span>|<span class="string">    -</span>|<span class="string">--&gt;闭包的活动对象</span><br><span class="line">                         +------------+</span></span><br></pre></td></tr></table></figure>
<p>过度使用闭包可能会导致内存占用过多，只在绝对必要时使用闭包。</p>
<h3 id="闭包与变量">闭包与变量</h3><p>作用域链的这种配置机制引出了一个值得注意的副作用,即闭包只能取得包含函数中任何变量的最后一个值。别忘了闭包所保存的是整个变量对象,而不是某个特殊的变量。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="literal">result</span>[i] = function()&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>数组中每个函数都只会返回10，而不是0到9。i在createFunctions()的活动变量中，而每个匿名函数的作用域链第二个位置就是createFunctions()的活动变量，当createFunctions()返回后，i的值为10，此时每个函数都引用着保存变量 i 的同一个变量对象,所以在每个函数内部 i 的值都是 10。通过创建另一个匿名函数强制让闭包的行为符合预期</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="literal">result</span>[i] = function(num)&#123;</span><br><span class="line">            <span class="keyword">return</span> function()&#123;</span><br><span class="line">                <span class="keyword">return</span> num;</span><br><span class="line">            &#125;;</span><br><span class="line">        &#125;(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们没有直接把闭包赋值给数组,而是定义了一个匿名函数,并将立即执行该匿名函数的结果赋给数组。这里的匿名函数有一个参数 num ,也就是最终的函数要返回的值。每个函数都有自己num变量的一个副本。</p>
<p>ECMASctipt6中你可以直接使用let声明i，这样i仅在for循环中有效，可以得到同样预期的结果。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function createFunctions()&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">result</span> = new <span class="type">Array</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; <span class="number">10</span>; i++)&#123;</span><br><span class="line">        <span class="literal">result</span>[i] = function()&#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="关于_this_对象">关于 this 对象</h3><p>在闭包中使用 this 对象也可能会导致一些问题。我们知道, this 对象是在运行时基于函数的执行环境绑定的:在全局函数中, this 等于 window ,而当函数被作为某个对象的方法调用时, this 等于那个对象。不过,匿名函数的执行环境具有全局性,因此其 this 对象通常指向 window。当然,在通过 call() 或 apply() 改变函数执行环境的情况下, this 就会指向其他对象。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    key : <span class="string">"My Object"</span>,</span><br><span class="line">    getKeyFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getKeyFunc()()); <span class="comment">//"The Window"(在非严格模式下)</span></span><br></pre></td></tr></table></figure>
<p>为什么匿名函数没有取得其包含作用域(或外部作用域)的 this 对象呢? 前面曾经提到过,每个函数在被调用时都会自动取得两个特殊变量: this 和 arguments 。内部函数在搜索这两个变量时,只会搜索到其活动对象为止,因此永远不可能直接访问外部函数中的这两个变量。不过,可以把外部作用域中的 this 对象保存在一个闭包能够访问到的变量里。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    key : <span class="string">"My Object"</span>,</span><br><span class="line">    getKeyFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.key;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getKeyFunc()()); <span class="comment">//"The Window"(在非严格模式下)</span></span><br></pre></td></tr></table></figure></p>
<p>arguments 也存在同样的问题。如果想访问作用域中的 arguments 对象,必须将对该对象的引用保存到另一个闭包能够访问的变量中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">"The Window"</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="class"><span class="keyword">object</span> =</span> &#123;</span><br><span class="line">    name : <span class="string">"My Object"</span>,</span><br><span class="line">    getName: function()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">object</span>.<span class="title">getName</span>(</span>); <span class="comment">//"My Object"</span></span><br><span class="line">(<span class="class"><span class="keyword">object</span>.<span class="title">getName</span>)(</span>); <span class="comment">//"My Object"</span></span><br><span class="line">(<span class="class"><span class="keyword">object</span>.<span class="title">getName</span> =</span> <span class="class"><span class="keyword">object</span>.<span class="title">getName</span>)(</span>); <span class="comment">//"The Window",在非严格模式下</span></span><br></pre></td></tr></table></figure>
<h3 id="内存泄露">内存泄露</h3><p>由于 IE9 之前的版本对 JScript 对象和 COM 对象使用引用计数器来回收垃圾。而闭包中存在对外部函数的活动对象的引用，有可能导致对象不能被正常回收。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(element.id);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于匿名函数保存了一个对 assignHandler() 的活动对象的引用,因此就会导致无法减少 element 的引用数。只要匿名函数存在, element 的引用数至少也是 1,因此它所占用的内存就永远不会被回收。不过,这个问题可以通过稍微改写一下代码来解决<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">assignHandler</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> element = <span class="built_in">document</span>.getElementById(<span class="string">"someElement"</span>);</span><br><span class="line">    <span class="keyword">var</span> id = element.id;<span class="comment">//通过把 element.id 的一个副本保存在一个变量中,并且在闭包中引用该变量消除了循环引用</span></span><br><span class="line">    element.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(id);</span><br><span class="line">    &#125;;</span><br><span class="line">    element = <span class="literal">null</span>;<span class="comment">//解除对 DOM 对象的引用,顺利地减少其引用数,确保正常回收其占用的内存</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="模仿块级作用域">模仿块级作用域</h2><p>如前所述,JavaScript 没有块级作用域的概念。</p>
<p>用作块级作用域(通常称为私有作用域)的匿名函数的语法如下所示。<br><figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">function</span><span class="list">()</span><span class="collection">&#123;</span><br><span class="line">//这里是块级作用域</span><br><span class="line">&#125;</span>)</span><span class="list">()</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>以上代码定义并立即调用了一个匿名函数。将函数声明包含在一对圆括号中,表示它实际上是一个函数表达式。而紧随其后的另一对圆括号会立即调用这个函数。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span><span class="params">()</span>&#123;</span></span><br><span class="line"><span class="comment">//这里是块级作用域</span></span><br><span class="line">&#125;<span class="params">()</span>; <span class="comment">//出错!</span></span><br></pre></td></tr></table></figure>
<p>这段代码会导致语法错误,是因为 JavaScript 将 function 关键字当作一个函数声明的开始,而函数声明后面不能跟圆括号。然而,函数表达式的后面可以跟圆括号。要将函数声明转换成函数表达式,只要给它加上一对圆括号即可。在下面的情况下可以不加圆括号。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="function"><span class="keyword">function</span><span class="params">(i)</span></span>&#123;<span class="keyword">return</span> i;&#125;(<span class="number">1</span>);</span><br></pre></td></tr></table></figure></p>
<p>这种技术经常在全局作用域中被用在函数外部,从而限制向全局作用域中添加过多的变量和函数。一般来说,我们都应该尽量少向全局作用域中添加变量和函数。在一个由很多开发人员共同参与的大型应用程序中,过多的全局变量和函数很容易导致命名冲突。而通过创建私有作用域,每个开发人员既可以使用自己的变量,又不必担心搞乱全局作用域。</p>
<p>这种做法可以减少闭包占用的内存问题,因为没有指向匿名函数的引用。只要函数执行完毕,就可以立即销毁其作用域链了。</p>
<p>ECMASctipt6中支持块级作用域，所以ES6中可以不再使用上面的执行匿名函数（IIFE）。</p>
<h2 id="私有变量">私有变量</h2><p>严格来讲,JavaScript 中没有私有成员的概念;所有对象属性都是公有的。不过,倒是有一个私有变量的概念。任何在函数中定义的变量,都可以认为是私有变量,因为不能在函数的外部访问这些变量。私有变量包括函数的参数、局部变量和在函数内部定义的其他函数。</p>
<p>我们把有权访问私有变量和私有函数的公有方法称为特权方法(privileged method)。有两种在对象上创建特权方法的方式。第一种是在构造函数中定义特权方法<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">MyObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权方法</span></span><br><span class="line">    <span class="keyword">this</span>.publicMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span></span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>创建 MyObject 的实例后,除了使用 publicMethod() 这一个途径外,没有任何办法可以直接访问 privateVariable 和 privateFunction() 。</p>
<p>在构造函数中定义特权方法也有一个缺点,那就是你必须使用构造函数模式来达到这个目的。</p>
<h3 id="静态私有变量">静态私有变量</h3><p>通过在私有作用域中定义私有变量或函数,同样也可以创建特权方法</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造函数</span></span><br><span class="line">    MyObject = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//公有/特权方法</span></span><br><span class="line">    MyObject.prototype.publicMethod = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>注意,这个模式在定义构造函数时并没有使用函数声明,而是使用了函数表达式。函数声明只能创建局部函数,但那并不是我们想要的。出于同样的原因,我们也没有在声明 MyObject 时使用 var 关键字。但也要知道,在严格模式下给未经声明的变量赋值会导致错误。</p>
<h3 id="模块模式">模块模式</h3><p>前面的模式是用于为自定义类型创建私有变量和特权方法的。而道格拉斯所说的模块模式(module pattern)则是为单例创建私有变量和特权方法。所谓单例(singleton),指的就是只有一个实例的对象。按照惯例,JavaScript 是以对象字面量的方式来创建单例对象的。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = &#123;</span><br><span class="line">    name : value,</span><br><span class="line">    <span class="keyword">method</span> : function () &#123;</span><br><span class="line">    //这里是方法的代码</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>模块模式通过为单例添加私有变量和特权方法能够使其得到增强<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//特权/公有方法和属性</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        publicProperty: <span class="literal">true</span>,</span><br><span class="line">        publicMethod : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            privateVariable++;</span><br><span class="line">            <span class="keyword">return</span> privateFunction();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<h3 id="增强的模块模式">增强的模块模式</h3><p>有人进一步改进了模块模式,即在返回对象之前加入对其增强的代码。这种增强的模块模式适合那些单例必须是某种类型的实例,同时还必须添加某些属性和(或)方法对其加以增强的情况。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> singleton = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">var</span> privateVariable = <span class="number">10</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">privateFunction</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建对象</span></span><br><span class="line">    <span class="keyword">var</span> object = <span class="keyword">new</span> CustomType();</span><br><span class="line">    <span class="comment">//添加特权/公有属性和方法</span></span><br><span class="line">    object.publicProperty = <span class="literal">true</span>;</span><br><span class="line">    object.publicMethod = <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        privateVariable++;</span><br><span class="line">        <span class="keyword">return</span> privateFunction();</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">//返回这个对象</span></span><br><span class="line">    <span class="keyword">return</span> object;</span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure></p>
<h1 id="异步操作">异步操作</h1><p>异步编程对JavaScript语言很重要。JavaScript只有一个线程，如果没有异步编程，根本没法用，非卡死不可。</p>
<p>ES6诞生以前，异步编程的方法，大概有下面四种。</p>
<ul>
<li>回调函数</li>
<li>事件监听</li>
<li>发布/订阅</li>
<li>Promise 对象</li>
</ul>
<p>ES6将JavaScript异步编程带入了一个全新的阶段。</p>
<h2 id="异步基本概念">异步基本概念</h2><p>所谓”异步”，简单说就好比把一个任务分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。</p>
<p>比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。</p>
<p>相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。</p>
<h2 id="回调函数">回调函数</h2><p>JavaScript语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。它的英语名字callback，直译过来就是”重新调用”。</p>
<p>读取文件进行处理，是这样写的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(<span class="string">'/etc/passwd'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">err, data</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (err) <span class="keyword">throw</span> err;</span><br><span class="line">  <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，readFile函数的第二个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了<code>/etc/passwd</code>这个文件以后，回调函数才会执行。</p>
<p>一个有趣的问题是，为什么Node.js约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？原因是执行分成两段，在这两段之间抛出的错误，程序无法捕捉，只能当作参数，传入第二段。</p>
<h2 id="Promise">Promise</h2><p>回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fs.readFile(fileA, <span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> </span>&#123;</span><br><span class="line">  fs.readFile(fileB, <span class="function"><span class="keyword">function</span> <span class="params">(err, data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>不难想象，如果依次读取多个文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。这种情况就称为“回调函数噩梦”（callback hell）。</p>
<p>Promise就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的横向加载，改成纵向加载。采用Promise，连续读取多个文件，写法如下。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var readFile = require(<span class="string">'fs-readfile-promise'</span>);</span><br><span class="line"></span><br><span class="line">readFile(fileA)</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="type">data</span>.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> readFile(fileB);</span><br><span class="line">&#125;)</span><br><span class="line">.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="type">data</span>.toString());</span><br><span class="line">&#125;)</span><br><span class="line">.catch(<span class="function"><span class="keyword">function</span><span class="params">(err)</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，使用了fs-readfile-promise模块，它的作用就是返回一个Promise版本的readFile函数。Promise提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。</p>
<p>可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。</p>
<p>Promise 的最大问题是代码冗余，原来的任务被Promise 包装了一下，不管什么操作，一眼看去都是一堆 then，原来的语义变得很不清楚。</p>
<h2 id="Generator函数">Generator函数</h2><h3 id="协程">协程</h3><p>传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。</p>
<p>协程的运行流程大致如下。</p>
<ul>
<li>协程A开始执行。</li>
<li>协程A执行到一半，进入暂停，执行权转移到协程B。</li>
<li>（一段时间后）协程B交还执行权。</li>
<li>协程A恢复执行。</li>
</ul>
<p>上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。</p>
<p>举例来说，读取文件的协程写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">asnycJob</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">  <span class="keyword">var</span> f = <span class="keyword">yield</span> readFile(fileA);</span><br><span class="line">  <span class="comment">// ...其他代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。</p>
<p>协程遇到 yield 命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。</p>
<h3 id="Generator函数的概念">Generator函数的概念</h3><p>Generator函数是协程在ES6的实现，最大特点就是可以交出函数的执行权（即暂停执行）。</p>
<p>整个Generator函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator函数的执行方法如下。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* <span class="keyword">gen</span>(x)&#123;</span><br><span class="line">  <span class="keyword">var</span> y = yield x + 2;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">g</span> = <span class="keyword">gen</span>(1);</span><br><span class="line"><span class="keyword">g</span>.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="keyword">g</span>.next() <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>Generator函数和普通函数最大不同就是会返回一个Iterator对象，调用该对象的next方法，会分阶段执行Generator函数，这种阶段由yield关键字划分。上例第一个next就是执行到第一个yield出现的位置。next 方法返回IteratorResult对象，含有value和done两个属性。前者是yield语句后面的值，后者表示Generator函数是否执行完毕。</p>
<h3 id="Generator函数的数据交换和错误处理">Generator函数的数据交换和错误处理</h3><p>Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。</p>
<p>next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function* <span class="keyword">gen</span>(x)&#123;</span><br><span class="line">  <span class="keyword">var</span> y = yield x + 2;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">g</span> = <span class="keyword">gen</span>(1);</span><br><span class="line"><span class="keyword">g</span>.next() <span class="comment">// &#123; value: 3, done: false &#125;</span></span><br><span class="line"><span class="keyword">g</span>.next(2) <span class="comment">// &#123; value: 2, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个next方法的value属性，返回表达式<code>x + 2</code>的值（3）。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变量y的值）。</p>
<p>Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> y = <span class="keyword">yield</span> x + <span class="number">2</span>;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen(<span class="number">1</span>);</span><br><span class="line">g.next();</span><br><span class="line">g.throw（<span class="string">'出错了'</span>）;</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>
<p>上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try …catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。</p>
<h3 id="异步任务的封装">异步任务的封装</h3><p>下面看看如何使用 Generator 函数，执行一个真实的异步任务。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fetch = require('node-fetch');</span><br><span class="line"></span><br><span class="line">function* gen()&#123;</span><br><span class="line">  <span class="keyword">var</span> url = 'https://api.github.com/users/github';</span><br><span class="line">  <span class="keyword">var</span> <span class="literal">result</span> = <span class="keyword">yield</span> fetch(url);</span><br><span class="line">  console.log(<span class="literal">result</span>.bio);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。</p>
<p>执行这段代码的方法如下。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = g.next();</span><br><span class="line"></span><br><span class="line"><span class="literal">result</span>.value.then(function(data)&#123;</span><br><span class="line">  <span class="keyword">return</span> data.json();</span><br><span class="line">&#125;).then(function(data)&#123;</span><br><span class="line">  g.next(data);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，首先执行Generator函数，获取Iterator对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。</p>
<p>可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。</p>
<h3 id="Thunk函数">Thunk函数</h3><h4 id="参数的求值策略">参数的求值策略</h4><p>Thunk函数早在上个世纪60年代就诞生了。</p>
<p>那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = 1;</span><br><span class="line"></span><br><span class="line">function <span class="literal">f</span>(<span class="keyword">m</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">m</span> * 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="literal">f</span>(x + 5)</span><br></pre></td></tr></table></figure>
<p>上面代码先定义函数f，然后向它传入表达式<code>x + 5</code>。这个表达式应该何时求值？</p>
<p>一种意见是”传值调用”（call by value），即在进入函数体之前，就计算<code>x + 5</code>的值（等于6），再将这个值传入函数f 。C语言就采用这种策略。</p>
<p>另一种意见是”传名调用”（call by name），即直接将表达式<code>x + 5</code>传入函数体，只在用到它的时候求值。Hskell语言采用这种策略。</p>
<p>传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。</p>
<h4 id="Thunk函数的含义">Thunk函数的含义</h4><p>编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(m)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> m * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(x + <span class="number">5</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> thunk = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(thunk)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> thunk() * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数f的参数<code>x + 5</code>被一个函数替换了。凡是用到原参数的地方，对<code>Thunk</code>函数求值即可。</p>
<p>这就是Thunk函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。</p>
<h4 id="JavaScript语言的Thunk函数">JavaScript语言的Thunk函数</h4><p>JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常版本的readFile（多参数版本）</span></span><br><span class="line">fs.readFile(fileName, <span class="keyword">callback</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Thunk版本的readFile（单参数版本）</span></span><br><span class="line"><span class="keyword">var</span> readFileThunk = Thunk(fileName);</span><br><span class="line">readFileThunk(<span class="keyword">callback</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span> <span class="params">(fileName)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(callback)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fs.readFile(fileName, <span class="keyword">callback</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。</p>
<p>任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Thunk = <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">callback</span>)</span>&#123;</span><br><span class="line">      args.push(callback);</span><br><span class="line">      <span class="keyword">return</span> fn.apply(<span class="keyword">this</span>, args);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>使用上面的转换器，生成<code>fs.readFile</code>的Thunk函数。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var readFileThunk = Thunk<span class="list">(<span class="keyword">fs</span>.readFile)</span><span class="comment">;</span></span><br><span class="line">readFileThunk<span class="list">(<span class="keyword">fileA</span>)</span><span class="list">(<span class="keyword">callback</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="Thunkify模块">Thunkify模块</h4><p>生产环境的转换器，建议使用Thunkify模块。</p>
<p>安装。<br><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">install</span> thunkify</span><br></pre></td></tr></table></figure></p>
<p>使用方式。<br><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> thunkify = <span class="keyword">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="keyword">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">read</span> = thunkify(fs.readFile);</span><br><span class="line"><span class="keyword">read</span>(<span class="string">'package.json'</span>)(<span class="function"><span class="keyword">function</span><span class="params">(err, str)</span><span class="comment">&#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;</span>);</span></span><br></pre></td></tr></table></figure></p>
<p>Thunkify的源码与前面那个简单的转换器非常像。主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f(a, b, callback)&#123;</span><br><span class="line">  <span class="built_in">var</span> <span class="keyword">sum</span> <span class="subst">=</span> a <span class="subst">+</span> b;</span><br><span class="line">  callback(<span class="keyword">sum</span>);</span><br><span class="line">  callback(<span class="keyword">sum</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">var</span> <span class="literal">ft</span> <span class="subst">=</span> thunkify(f);</span><br><span class="line"><span class="literal">ft</span>(<span class="number">1</span>, <span class="number">2</span>)(console<span class="built_in">.</span><span class="keyword">log</span>); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>由于thunkify只允许回调函数执行一次，所以只输出一行结果。</p>
<h4 id="Generator_函数的流程管理">Generator 函数的流程管理</h4><p>你可能会问， Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，Thunk函数现在可以用于Generator函数的自动流程管理。</p>
<p>以读取文件为例。下面的Generator函数封装了两个异步操作。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"><span class="keyword">var</span> thunkify = <span class="built_in">require</span>(<span class="string">'thunkify'</span>);</span><br><span class="line"><span class="keyword">var</span> readFile = thunkify(fs.readFile);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> r1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r1.toString());</span><br><span class="line">  <span class="keyword">var</span> r2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(r2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，yield命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。</p>
<p>这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行上面这个Generator函数。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">g</span> = <span class="keyword">gen</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> r1 = <span class="keyword">g</span>.next();</span><br><span class="line">r1.value(function(<span class="keyword">err</span>, data)&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">err</span>) throw <span class="keyword">err</span>;</span><br><span class="line">  <span class="keyword">var</span> r2 = <span class="keyword">g</span>.next(data);</span><br><span class="line">  r2.value(function(<span class="keyword">err</span>, data)&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">err</span>) throw <span class="keyword">err</span>;</span><br><span class="line">    <span class="keyword">g</span>.next(data);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。</p>
<h4 id="Thunk函数的自动流程管理">Thunk函数的自动流程管理</h4><p>Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function run(fn) &#123;</span><br><span class="line">  <span class="keyword">var</span> gen = fn();</span><br><span class="line"></span><br><span class="line">  function next(err, data) &#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">result</span> = gen.next(data);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">result</span>.done) <span class="keyword">return</span>;</span><br><span class="line">    <span class="literal">result</span>.value(next);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p>上面代码的run函数，就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done 属性），如果没结束，就将next函数再传入Thunk函数（result.value属性），否则就直接退出。前面的gen函数可以有更多读取文件操作，只要执行run函数，这些操作就会自动完成。</p>
<p>有了这个执行器，执行Generator函数方便多了。不管有多少个异步操作，直接传入run函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在yield命令后面的必须是Thunk函数。</p>
<p>Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。</p>
<h3 id="co模块">co模块</h3><h4 id="基本用法-1">基本用法</h4><p><a href="https://github.com/tj/co" target="_blank" rel="external">co模块</a>是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。</p>
<p>co模块可以让你不用编写Generator函数的执行器。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var co = require<span class="list">(<span class="quoted">'co</span>')</span><span class="comment">;</span></span><br><span class="line">co<span class="list">(<span class="keyword">gen</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，gen函数是前面定义的，Generator函数只要传入co函数，就会自动执行。</p>
<p>co函数返回一个Promise对象，因此可以用then方法添加回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">co(gen).then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Generator 函数执行完成'</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码中，等到Generator函数执行结束，就会输出一行提示。</p>
<h4 id="co模块的原理">co模块的原理</h4><p>为什么co可以自动执行Generator函数？</p>
<p>前面说过，Generator就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
<p>两种方法可以做到这一点。</p>
<ol>
<li>回调函数。将异步操作包装成Thunk函数，在回调函数里面交回执行权。</li>
<li>Promise 对象。将异步操作包装成Promise对象，用then方法交回执行权。</li>
</ol>
<p>co模块其实就是将两种自动执行器（Thunk函数和Promise对象），包装成一个模块。使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象。</p>
<p>已经介绍了基于Thunk函数的自动执行器。下面来看，基于Promise对象的自动执行器。这是理解co模块必须的。</p>
<h4 id="基于Promise对象的自动执行">基于Promise对象的自动执行</h4><p>还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个Promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>然后，手动执行上面的Generator函数。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var g = gen();</span><br><span class="line"></span><br><span class="line">g.next().<span class="keyword">value</span>.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">  g.next(<span class="type">data</span>).<span class="keyword">value</span>.<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">    g.next(<span class="type">data</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function run(gen)&#123;</span><br><span class="line">  <span class="keyword">var</span> g = gen();</span><br><span class="line"></span><br><span class="line">  function next(data)&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="literal">result</span> = g.next(data);</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">result</span>.done) <span class="keyword">return</span> <span class="literal">result</span>.value;</span><br><span class="line">    <span class="literal">result</span>.value.then(function(data)&#123;</span><br><span class="line">      next(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  next();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(gen);</span><br></pre></td></tr></table></figure>
<p>上面代码中，只要Generator函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。</p>
<p>co就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。增加了一些类型检查的操作。</p>
<h4 id="处理并发的异步操作">处理并发的异步操作</h4><p>co支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。</p>
<p>这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> [</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="built_in">Promise</span>.resolve(<span class="number">2</span>)</span><br><span class="line">  ];</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象的写法</span></span><br><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> res = <span class="keyword">yield</span> &#123;</span><br><span class="line">    <span class="number">1</span>: <span class="built_in">Promise</span>.resolve(<span class="number">1</span>),</span><br><span class="line">    <span class="number">2</span>: <span class="built_in">Promise</span>.resolve(<span class="number">2</span>),</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">console</span>.log(res);</span><br><span class="line">&#125;).catch(onerror);</span><br></pre></td></tr></table></figure>
<p>下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">co(<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> values = [n1, n2, n3];</span><br><span class="line">  <span class="keyword">yield</span> values.map(somethingAsync);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">somethingAsync</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// do something async</span></span><br><span class="line">  <span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码允许并发三个somethingAsync异步操作，等到它们全部完成，才会进行下一步。</p>
<h2 id="async函数">async函数</h2><h3 id="含义">含义</h3><p>async 函数是什么？一句话，async函数就是Generator函数的语法糖。</p>
<p>前文有一个Generator函数，依次读取两个文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> readFile = <span class="function"><span class="keyword">function</span> (<span class="params">fileName</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    fs.readFile(fileName, <span class="function"><span class="keyword">function</span>(<span class="params">error, data</span>)</span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (error) reject(error);</span><br><span class="line">      resolve(data);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">yield</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>写成 async 函数，就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> asyncReadFile = <span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f1 = <span class="keyword">await</span> readFile(<span class="string">'/etc/fstab'</span>);</span><br><span class="line">  <span class="keyword">var</span> f2 = <span class="keyword">await</span> readFile(<span class="string">'/etc/shells'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(f1.toString());</span><br><span class="line">  <span class="built_in">console</span>.log(f2.toString());</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>一比较就会发现，async函数就是将Generator函数的星号（*）替换成async，将yield替换成await，仅此而已。</p>
<p>async 函数对 Generator 函数的改进，体现在以下三点。</p>
<ol>
<li>内置执行器。Generator函数的执行必须靠执行器，所以才有了co模块，而async 函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 <code>var result = asyncReadFile();</code></li>
<li>更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await 表示紧跟在后面的表达式需要等待结果。</li>
<li>更广的适用性。 co模块约定，yield命令后面只能是Thunk函数或Promise对象，而async函数的await命令后面，可以跟Promise对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。</li>
</ol>
<h3 id="async函数的实现">async函数的实现</h3><p>async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的 async 函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。</p>
<p>下面给出 spawn 函数的实现，基本就是前文自动执行器的翻版。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = genF();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> next = nextF();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(v); &#125;);</span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>async 函数是非常新的语法功能，新到都不属于 ES6，而是属于 ES7。目前，它仍处于提案阶段，但是转码器 Babel 和 regenerator 都已经支持，转码后就能使用。</p>
<h3 id="async_函数的用法">async 函数的用法</h3><p>同Generator函数一样，async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。</p>
<p>下面是一个例子。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">async function getStockPriceByName(name) &#123;</span><br><span class="line">  <span class="keyword">var</span> symbol = await getStockSymbol(name);</span><br><span class="line">  <span class="keyword">var</span> stockPrice = await getStockPrice(symbol);</span><br><span class="line">  <span class="keyword">return</span> stockPrice;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getStockPriceByName('goog').then(function (<span class="literal">result</span>)&#123;</span><br><span class="line">  console.log(<span class="literal">result</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。</p>
<p>下面的例子，指定多少毫秒后输出一个值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">timeout</span>(<span class="params">ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>((resolve, reject) =&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">asyncPrint</span>(<span class="params">value, ms</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> timeout(ms);</span><br><span class="line">  <span class="built_in">console</span>.log(value)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">asyncPrint(<span class="string">'hello world'</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<h3 id="注意点">注意点</h3><p>await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try…catch代码块中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">await</span> somethingThatReturnsAPromise();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 另一种写法</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">myFunction</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">await</span> somethingThatReturnsAPromise().catch(<span class="function"><span class="keyword">function</span> (<span class="params">err</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>await命令只能用在async函数之中，如果用在普通函数，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  docs.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可能得到错误结果</span></span><br><span class="line">  docs.forEach(<span class="keyword">async</span> <span class="function"><span class="keyword">function</span> (<span class="params">doc</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码可能不会正常工作，原因是这时三个<code>db.post</code>操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span>(<span class="params">db</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> doc <span class="keyword">of</span> docs) &#123;</span><br><span class="line">    <span class="keyword">await</span> db.post(doc);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果确实希望多个请求并发执行，可以使用 Promise.all 方法。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">async <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span><span class="params">(db)</span> &#123;</span></span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="built_in">let</span> promises = docs.map<span class="params">(<span class="params">(doc)</span> =&gt; db.post<span class="params">(doc)</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> results = await Promise.all<span class="params">(promises)</span>;</span><br><span class="line">  console.<span class="built_in">log</span><span class="params">(results)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者使用下面的写法</span></span><br><span class="line"></span><br><span class="line">async <span class="function"><span class="keyword">function</span> <span class="title">dbFuc</span><span class="params">(db)</span> &#123;</span></span><br><span class="line">  <span class="built_in">let</span> docs = [&#123;&#125;, &#123;&#125;, &#123;&#125;];</span><br><span class="line">  <span class="built_in">let</span> promises = docs.map<span class="params">(<span class="params">(doc)</span> =&gt; db.post<span class="params">(doc)</span>)</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">let</span> results = [];</span><br><span class="line">  <span class="keyword">for</span> <span class="params">(let promise of promises)</span> &#123;</span><br><span class="line">    results.push<span class="params">(await promise)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  console.<span class="built_in">log</span><span class="params">(results)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6将await增加为保留字。使用这个词作为标识符，在ES5是合法的，在ES6将抛出SyntaxError。</p>
<h3 id="与Promise、Generator的比较">与Promise、Generator的比较</h3><p>我们通过一个例子，来看Async函数与Promise、Generator函数的区别。</p>
<p>假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。</p>
<p>首先是Promise的写法。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsPromise</span><span class="params">(elem, animations)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 变量ret用来保存上一个动画的返回值</span></span><br><span class="line">  <span class="keyword">var</span> ret = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个空的Promise</span></span><br><span class="line">  <span class="keyword">var</span> p = Promise.resolve();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用then方法，添加所有动画</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> anim <span class="keyword">in</span> animations) &#123;</span><br><span class="line">    p = p.then(<span class="function"><span class="keyword">function</span><span class="params">(val)</span> </span>&#123;</span><br><span class="line">      ret = val;</span><br><span class="line">      <span class="keyword">return</span> anim(elem);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 返回一个部署了错误捕捉机制的Promise</span></span><br><span class="line">  <span class="keyword">return</span> p.<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;).then(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>虽然Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来。</p>
<p>接着是Generator函数的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsGenerator</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> spawn(<span class="function"><span class="keyword">function</span>*(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ret = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">        ret = <span class="keyword">yield</span> anim(elem);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">      <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">    &#125;</span><br><span class="line">      <span class="keyword">return</span> ret;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码使用Generator函数遍历了每个动画，语义比Promise写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行Generator函数，上面代码的spawn函数就是自动执行器，它返回一个Promise对象，而且必须保证yield语句后面的表达式，必须返回一个Promise。</p>
<p>最后是Async函数的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">chainAnimationsAsync</span>(<span class="params">elem, animations</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> ret = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> anim <span class="keyword">of</span> animations) &#123;</span><br><span class="line">      ret = <span class="keyword">await</span> anim(elem);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">    <span class="comment">/* 忽略错误，继续执行 */</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。</p>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript 面向对象程序设计、函数表达式和异步编程，创建对象，继承，递归，闭包，块级作用域，私有变量，回调函数，Promise，Generator函数，async函数]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://howiefh.github.io/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://howiefh.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 引用类型]]></title>
    <link href="http://howiefh.github.io/2015/08/28/javascript-reference-type/"/>
    <id>http://howiefh.github.io/2015/08/28/javascript-reference-type/</id>
    <published>2015-08-28T04:18:03.000Z</published>
    <updated>2015-09-01T02:47:11.000Z</updated>
    <content type="html"><![CDATA[<p><a href="2015/08/28/javascript-grammar/">JavaScript 基本语法</a>，<a href="2015/08/28/javascript-reference-type/">JavaScript 引用类型</a>，<a href="2015/08/28/javascript-oop-function-expression-and-async/">JavaScript 面向对象程序设计、函数表达式和异步编程</a>三篇笔记是对《JavaScript 高级程序设计》和 <a href="https://github.com/ruanyf/es6tutorial/tree/5a5f9d8d492d0f925cbb6e09b10ebed9d2078d40" target="_blank" rel="external">《ECMAScript 6入门》</a>两本书的总结整理。</p>
<h1 id="引用类型">引用类型</h1><p>引用类型是一种数据结构，用于将数据和功能组织在一起。它也常被称为类，但这种称呼并不妥当。尽管 ECMAScript从技术上讲是一门面向对象的语言，但它不具备传统的面向对象语言所支持的类和接口等基本结构。引用类型有时候也被称为对象定义，因为它们描述的是一类对象所具有的属性和方法。</p>
<a id="more"></a>
<h2 id="Object类型">Object类型</h2><p>创建Object实例有两种方式，第一种是使用new操作符后跟Object构造函数，如下所示：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">person</span> = new Object();</span><br><span class="line"><span class="keyword">person</span>.name = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="keyword">person</span>.age = 29;</span><br></pre></td></tr></table></figure></p>
<p>新对象是使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只不过该函数是出于创建新对象的目的而定义的。</p>
<p>另一种方式是使用对象字面量表示法。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">person</span> = &#123;</span><br><span class="line">  name : 'Nicholas',</span><br><span class="line">  age : 9</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在最后一个属性后面添加逗号，会在IE7及更早版本和Opera中导致错误。 在使用对象字面量语法时，属性名也可以使用字符串</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">person</span> = &#123;</span><br><span class="line">  'name' : 'Nicholas',</span><br><span class="line">  'age' : 9,</span><br><span class="line">  5 : true</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这里5会被转换为字符串。</p>
<p>使用对象字面量语法时，如果留空其花括号，则可以定义只包含默认属性和方法的对象</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">person</span> = &#123;&#125;; //与 new Object()相同</span><br><span class="line"><span class="keyword">person</span>.name = <span class="string">"Nicholas"</span>;</span><br><span class="line"><span class="keyword">person</span>.age = 29;</span><br></pre></td></tr></table></figure>
<p>开发人员更青睐对象字面量语法，因为这种语法要求的代码量少，而且能够给人封装数据的感觉。实际上，对象字面量也是向函数传递大量可选参数的首选方式。最好的做法是对那些必需值使用命名参数，而使用对象字面量来封装多个可选参数。</p>
<p>在通过对象字面量定义对象时，实际上不会调用Object构造函数</p>
<p>ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = 'world';</span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  v,</span><br><span class="line">  <span class="keyword">method</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> '<span class="type">Hello</span>!';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种写法用于函数的返回值，将会非常方便。</p>
<p>在 JavaScript也可以使用方括号表示法来访问对象的属性。在使用方括号语法时，应该将要访问的属性以字符串的形式放在方括号中。方括号语法的主要优点是可以通过变量来访问属性，例如：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var propertyName = <span class="string">"name"</span>;</span><br><span class="line">alert(<span class="keyword">person</span><span class="comment">[propertyName]</span>); //<span class="string">"Nicholas"</span></span><br></pre></td></tr></table></figure></p>
<p>如果属性名中包含会导致语法错误的字符，或者属性名使用的是关键字或保留字，也可以使用方括号表示法。例如： <code>person[&quot;first name&quot;] = &quot;Nicholas&quot;;</code></p>
<p>除非必须使用方括号，否则建议使用点表示法。</p>
<p>ES6允许字面量定义对象时，把表达式放在方括号内作为属性名。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">var</span> <span class="atom">lastWord</span> = <span class="string">'last word'</span>;</span><br><span class="line"></span><br><span class="line"><span class="atom">var</span> <span class="atom">a</span> = &#123;</span><br><span class="line">  <span class="string">'first word'</span>: <span class="string">'hello'</span>,</span><br><span class="line">  [<span class="atom">lastWord</span>]: <span class="string">'world'</span>,</span><br><span class="line">  [<span class="string">'h'</span>+<span class="string">'ello'</span>]() &#123;</span><br><span class="line">    <span class="atom">return</span> <span class="string">'hi'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="atom">a</span>[<span class="string">'first word'</span>] // <span class="string">"hello"</span></span><br><span class="line"><span class="atom">a</span>[<span class="atom">lastWord</span>] // <span class="string">"world"</span></span><br><span class="line"><span class="atom">a</span>[<span class="string">'last word'</span>] // <span class="string">"world"</span></span><br><span class="line"><span class="atom">a</span>.<span class="atom">hello</span>(); //<span class="atom">hi</span></span><br></pre></td></tr></table></figure>
<p>函数的name属性，返回函数名。ES6为对象方法也添加了name属性。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">person</span> = &#123;</span><br><span class="line">  sayName: function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;,</span><br><span class="line">  get firstName() &#123;</span><br><span class="line">    return <span class="string">"Nicholas"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">person</span>.sayName.name   // <span class="string">"sayName"</span></span><br><span class="line"><span class="keyword">person</span>.firstName.name // <span class="string">"get firstName"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，方法的name属性返回函数名（即方法名）。如果使用了取值函数，则会在方法名前加上get。如果是存值函数，方法名的前面会加上set。</p>
<p>有两种特殊情况：bind方法创造的函数，name属性返回“bound”加上原函数的名字；Function构造函数创造的函数，name属性返回“anonymous”。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(new <span class="function"><span class="keyword">Function</span><span class="params">()</span></span>).<span class="keyword">name</span> // <span class="string">"anonymous"</span></span><br><span class="line">var doSomething = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line">doSomething.<span class="keyword">bind</span>().<span class="keyword">name</span> // <span class="string">"bound doSomething"</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Object.is()</strong>用来比较两个值是否严格相等。它与严格比较运算符（===）的行为基本一致，不同之处只有两个：一是+0不等于-0，二是NaN等于自身。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === -<span class="number">0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, -<span class="number">0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>Object.assign方法</strong>用来将源对象（source）的所有可枚举属性，复制到目标对象（target）。它至少需要两个对象作为参数，第一个参数是目标对象，后面的参数都是源对象。只要有一个参数不是对象，就会抛出TypeError错误。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> target</span> = &#123; a: <span class="number">1</span> &#125;;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> source1</span> = &#123; b: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> source2</span> = &#123; c: <span class="number">3</span> &#125;;</span><br><span class="line">Object.assign(target, source1, source2);</span><br><span class="line">target <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<p>assign方法有很多用处。</p>
<p><strong>1）为对象添加属性</strong><br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Point &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(x, y) </span>&#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>2）为对象添加方法</strong><br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Object</span><span class="class">.assign</span>(SomeClass.prototype, &#123;</span><br><span class="line">  <span class="tag">someMethod</span>(arg1, arg2) &#123; ··· &#125;,</span><br><span class="line">  <span class="function">anotherMethod</span>() &#123; ··· &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<p><strong>3）克隆对象</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(&#123;&#125;, origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>4）合并多个对象</strong></p>
<p>将多个对象合并到某个对象。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">const</span> merge =</span><br><span class="line">  <span class="function"><span class="params">(target, ...sources)</span> =&gt;</span> Object.assign(target, ...sources);</span><br></pre></td></tr></table></figure></p>
<p><strong>5）为属性指定默认值</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> DEFAULTS = &#123;</span><br><span class="line">  logLevel: <span class="number">0</span>,</span><br><span class="line">  outputFormat: <span class="string">'html'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">processContent</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//用户自定义参数options和默认配置会合并</span></span><br><span class="line">  <span class="keyword">let</span> options = <span class="built_in">Object</span>.assign(&#123;&#125;, DEFAULTS, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><code>__proto__属性</code> ，用来读取或设置当前对象的prototype对象。该属性一度被正式写入ES6草案，但后来又被移除。目前，所有浏览器（包括IE11）都部署了这个属性。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  __proto__: someOtherObj,</span><br><span class="line">  <span class="keyword">method</span>: function() &#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// es5的写法</span><br><span class="line"><span class="keyword">var</span> obj = <span class="type">Object</span>.create(someOtherObj);</span><br><span class="line">obj.<span class="keyword">method</span> = function() &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>Object.setPrototypeOf()</strong>方法的作用与<code>__proto__</code>相同，用来设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure>
<p><strong>Object.getPrototypeOf()</strong>方法与setPrototypeOf方法配套，用于读取一个对象的prototype对象。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Object</span><span class="class">.getPrototypeOf</span>(<span class="tag">obj</span>);</span><br></pre></td></tr></table></figure>
<p>注意，Object.observe和Object.unobserve这两个方法不属于ES6，而是属于ES7的一部分。不过，Chrome浏览器从33版起就已经支持。</p>
<p><strong>Object.observe</strong>方法用来监听对象（以及数组）的变化。一旦监听对象发生变化，就会触发回调函数。</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">user</span> = <span class="keyword">&#123;</span><span class="keyword">&#125;</span>;</span><br><span class="line"><span class="constant">Object</span>.observe(<span class="keyword">user</span>, <span class="keyword">function(changes)&#123;</span></span><br><span class="line">  <span class="literal">changes</span>.<span class="keyword">forEach(function(change) &#123;</span></span><br><span class="line">    <span class="keyword">user</span>.fullName = <span class="keyword">user</span>.firstName+<span class="string">" "</span>+<span class="keyword">user</span>.lastName;</span><br><span class="line">  <span class="keyword">&#125;</span>);</span><br><span class="line"><span class="keyword">&#125;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">user</span>.firstName = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">user</span>.lastName = <span class="string">'Jackson'</span>;</span><br><span class="line"><span class="keyword">user</span>.fullName // <span class="string">'Michael Jackson'</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Object.observer方法监听user对象。一旦该对象发生变化，就自动生成fullName属性。</p>
<p>一般情况下，Object.observe方法接受两个参数，第一个参数是监听的对象，第二个函数是一个回调函数。一旦监听对象发生变化（比如新增或删除一个属性），就会触发这个回调函数。很明显，利用这个方法可以做很多事情，比如自动更新DOM。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> div = $(<span class="string">"#foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.observe(user, <span class="function"><span class="keyword">function</span>(<span class="params">changes</span>)</span>&#123;</span><br><span class="line">  changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">change</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> fullName = user.firstName+<span class="string">" "</span>+user.lastName;</span><br><span class="line">    div.text(fullName);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，只要user对象发生变化，就会自动更新DOM。如果配合jQuery的change方法，就可以实现数据对象与DOM对象的双向自动绑定。</p>
<p>回调函数的changes参数是一个数组，代表对象发生的变化。下面是一个更完整的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">observer</span>(<span class="params">changes</span>)</span>&#123;</span><br><span class="line">  changes.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">change</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'发生变动的属性：'</span> + change.name);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'变动前的值：'</span> + change.oldValue);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'变动后的值：'</span> + change.object[change.name]);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'变动类型：'</span> + change.type);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.observe(o, observer);</span><br></pre></td></tr></table></figure>
<p>参照上面代码，Object.observe方法指定的回调函数，接受一个数组（changes）作为参数。该数组的成员与对象的变化一一对应，也就是说，对象发生多少个变化，该数组就有多少个成员。每个成员是一个对象（change），它的name属性表示发生变化源对象的属性名，oldValue属性表示发生变化前的值，object属性指向变动后的源对象，type属性表示变化的种类。基本上，change对象是下面的样子。</p>
<p>Object.observe方法目前共支持监听六种变化。</p>
<ul>
<li>add：添加属性</li>
<li>update：属性值的变化</li>
<li>delete：删除属性</li>
<li>setPrototype：设置原型</li>
<li>reconfigure：属性的attributes对象发生变化</li>
<li>preventExtensions：对象被禁止扩展（当一个对象变得不可扩展时，也就不必再监听了）</li>
</ul>
<p>Object.observe方法还可以接受第三个参数，用来指定监听的事件种类。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Object</span><span class="class">.observe</span>(<span class="tag">o</span>, <span class="tag">observer</span>, <span class="attr_selector">['delete']</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码表示，只在发生delete事件时，才会调用回调函数。</p>
<p><strong>Object.unobserve</strong>方法用来取消监听。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Object</span><span class="class">.unobserve</span>(<span class="tag">o</span>, <span class="tag">observer</span>);</span><br></pre></td></tr></table></figure>
<p>目前，ES7有一个<a href="https://github.com/sebmarkbage/ecmascript-rest-spread" target="_blank" rel="external">提案</a>，将rest参数/扩展运算符（…）引入对象。Babel转码器已经支持这项功能。</p>
<p><strong>1）Rest参数</strong></p>
<p>Rest参数用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let &#123; x, y, ...z &#125; = &#123; <span class="string">x:</span> <span class="number">1</span>, <span class="string">y:</span> <span class="number">2</span>, <span class="string">a:</span> <span class="number">3</span>, <span class="string">b:</span> <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量z是Rest参数所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们和它们的值拷贝过来。</p>
<p>注意，Rest参数的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么Rest参数拷贝的是这个值的引用，而不是这个值的副本。</p>
<p>另外，Rest参数不会拷贝继承自原型对象的属性。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let <span class="preprocessor">o1</span> = &#123; a: <span class="number">1</span> &#125;;</span><br><span class="line">let <span class="preprocessor">o2</span> = &#123; b: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="preprocessor">o2</span>.__proto__ = <span class="preprocessor">o1</span>;</span><br><span class="line">let <span class="preprocessor">o3</span> = &#123; ...<span class="preprocessor">o2</span> &#125;;</span><br><span class="line"><span class="preprocessor">o3</span> <span class="comment">// &#123; b: 2 &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象o3是o2的复制，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。</p>
<p><strong>2）扩展运算符</strong></p>
<p>扩展运算符用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z <span class="subst">=</span> &#123; a: <span class="number">3</span>, b: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n <span class="subst">=</span> &#123; <span class="attribute">...</span>z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure>
<p>这等同于使用<code>Object.assign</code>方法。</p>
<p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并不会抛出错误，因为x属性只是被定义，但没执行</span></span><br><span class="line"><span class="keyword">let</span> aWithXGetter = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  <span class="function"><span class="keyword">get</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function">throws new <span class="title">Error</span>(<span class="params"><span class="string">'not thrown yet'</span></span>)</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会抛出错误，因为x属性被执行了</span></span><br><span class="line"><span class="keyword">let</span> runtimeError = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  ...&#123;</span><br><span class="line">    <span class="function"><span class="keyword">get</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="function">throws new <span class="title">Error</span>(<span class="params"><span class="string">'thrown now'</span></span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果扩展运算符的参数是null或undefined，这个两个值会被忽略，不会报错。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyObject <span class="subst">=</span> &#123; <span class="attribute">...</span><span class="built_in">null</span>, <span class="attribute">...</span>undefined &#125;; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure>
<h2 id="Array_类型">Array 类型</h2><p>ECMAScript 数组的每一项可以保存任何类型的数据</p>
<p>创建数组的基本方式有两种。第一种是使用 Array 构造函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure></p>
<p>如果预先知道数组要保存的项目数量，也可以给构造函数传递该数量，而该数量会自动变成length属性的值。例如，下面的代码将创建length值为20的数组。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">20</span>);</span><br></pre></td></tr></table></figure></p>
<p>也可以向Array构造函数传递数组中应该包含的项。以下代码创建了一个包含3个字符串值的数组：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>);</span><br></pre></td></tr></table></figure></p>
<p>当然，给构造函数传递一个值也可以创建数组。但这时候问题就复杂一点了，因为如果传递的是数值，则会按照该数值创建包含给定项数的数组；而如果传递的是其他类型的参数，则会创建包含那个值的只有一项的数组。下面就两个例子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含3 项的数组</span></span><br><span class="line"><span class="keyword">var</span> names = <span class="keyword">new</span> <span class="built_in">Array</span>(<span class="string">"Greg"</span>); <span class="comment">// 创建一个包含1 项，即字符串"Greg"的数组</span></span><br></pre></td></tr></table></figure></p>
<p>另外,在使用 Array 构造函数时也可以省略 new 操作符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> colors = <span class="built_in">Array</span>(<span class="number">3</span>); <span class="comment">// 创建一个包含3 项的数组</span></span><br><span class="line"><span class="keyword">var</span> names = <span class="built_in">Array</span>(<span class="string">"Greg"</span>); <span class="comment">// 创建一个包含1 项，即字符串"Greg"的数组</span></span><br></pre></td></tr></table></figure></p>
<p>创建数组的第二种基本方式是使用数组字面量表示法。数组字面量由一对包含数组项的方括号表示，多个数组项之间以逗号隔开，如下所示：<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]<span class="comment">; // 创建一个包含3 个字符串的数组</span></span><br><span class="line">var names = []<span class="comment">; // 创建一个空数组</span></span><br><span class="line">var values = [<span class="number">1</span>,<span class="number">2</span>,]<span class="comment">; // 不要这样！这样会创建一个包含2 或3 项的数组，对于IE早期版本(&lt;=8)这里将会是三项，最后一项是undefined，下面同理</span></span><br><span class="line">var options = [,,,,,]<span class="comment">; // 不要这样！这样会创建一个包含5 或6 项的数组</span></span><br></pre></td></tr></table></figure></p>
<p>ECMAScript数组的大小是可以动态调整的，即可以随着数据的添加自动增长以容纳新增数据。</p>
<p>与对象一样，在使用数组字面量表示法时，也不会调用Array构造函数</p>
<p>数组的length属性很有特点——它不是只读的。因此，通过设置这个属性，可以从数组的末尾移除项或向数组中添加新项。请看下面的例子：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> colors</span> = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>]; <span class="comment">// 创建一个包含3 个字符串的数组</span></span><br><span class="line">colors.length = <span class="number">2</span>;</span><br><span class="line">alert(colors[<span class="number">2</span>]); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p>当把一个值放在超出当前数组大小的位置上时,数组就会重新计算其长度值,即长度值<br>等于最后一项的索引加 1:<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> colors</span> = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">colors[<span class="number">99</span>] = <span class="string">"black"</span>;</span><br><span class="line">alert(colors.length); <span class="comment">// 100</span></span><br></pre></td></tr></table></figure></p>
<p>位置3到位置98实际上都是不存在的，所以访问它们都将返回undefined。</p>
<p>数组最多可以包含4 294 967 295个项，这几乎已经能够满足任何编程需求了。如果想添加的项数超过这个上限值，就会发生异常。而创建一个初始大小与这个上限值接近的数组，则可能会导致运行时间超长的脚本错误。</p>
<h3 id="检测数组">检测数组</h3><p>instanceof 操作符的问题在于,它假定只有一个全局执行环境。如果网页中包含多个框架,那实际上就存在两个以上不同的全局执行环境,从而存在两个以上不同版本的 Array 构造函数。如果你从一个框架向另一个框架传入一个数组,那么传入的数组与在第二个框架中原生创建的数组分别具有各自不同的构造函数。</p>
<p>ECMAScript 5新增了Array.isArray()方法。这个方法的目的是最终确定某个值到底是不是数组，而不管它是在哪个全局执行环境中创建的</p>
<h3 id="转换方法">转换方法</h3><p>数组的toString()方法会返回由数组中每个值的字符串形式拼接而成的一个以逗号分隔的字符串。为了创建这个字符串会调用数组每一项的 toString() 方法。toLocaleString()与toString()有些类似，只不过是调用每项的toLocaleString()。而调用 valueOf()返回的还是数组。</p>
<p>如果使用 join() 方法,则可以使用不同的分隔符来构建这个字符串。 join() 方法只接收一个参数,即用作分隔符的字符串,然后返回包含所有数组项的字符串。如果不给 join() 方法传入任何值,或者给它传入 undefined ,则使用逗号作为分隔符。IE7 及更早版本会错误的使用字符串 “undefined” 作为分隔符。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var colors = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>];</span><br><span class="line">alert<span class="params">(colors.join<span class="params">()</span>)</span>; <span class="comment">//red,green,blue</span></span><br><span class="line">alert<span class="params">(colors.join<span class="params">(<span class="string">"||"</span>)</span>)</span>; <span class="comment">//red||green||blue</span></span><br></pre></td></tr></table></figure>
<p>如果数组中的某一项的值是 null 或者 undefined，那么该值在 join()、toLocaleString()、toString() 和 valueOf() 方法返回的结果中以空字符串表示。</p>
<h3 id="栈方法">栈方法</h3><p>ECMAScript为数组专门提供了push()和pop()方法，以便实现类似栈的行为。这两个方法会改变length的值<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> colors</span> = new Array();<span class="comment">// 创建一个数组</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> count</span> = colors.push(<span class="string">"red"</span>, <span class="string">"green"</span>); <span class="comment">// 推入两项</span></span><br><span class="line">alert(count); <span class="comment">//2</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> item</span> = colors.pop();<span class="comment">// 取得最后一项</span></span><br><span class="line">alert(item); <span class="comment">//"black"</span></span><br><span class="line">alert(colors.length); <span class="comment">//1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="队列方法">队列方法</h3><p>shift() 能够移除数组中的第一个项并返回该项,同时将数组长度减 1。结合使用 shift() 和 push() 方法,可以像使用队列一样使用数组。</p>
<p>unshift()与shift()的用途相反：它能在数组前端添加任意个项并返回新数组的长度。因此，同时使用unshift()和pop()方法，可以从相反的方向来模拟队列，即在数组的前端添加项，从数组末端移除项</p>
<h3 id="重排序方法">重排序方法</h3><p>数组中已经存在两个可以直接用来重排序的方法：reverse()和 sort()</p>
<p>sort()方法会调用每个数组项的 toString()转型方法，然后比较得到的字符串，以确定如何排序。即使数组中的每一项都是数值，sort()方法比较的也是字符串</p>
<p>sort()方法可以接收一个比较函数作为参数，以便我们指定哪个值位于哪个值的前面。比较函数接收两个参数，如果第一个参数应该位于第二个之前则返回一个负数，如果两个参数相等则返回0，如果第一个参数应该位于第二个之后则返回一个正数</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &lt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">value</span><span class="number">1</span> &gt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var values = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>];</span><br><span class="line">values.sort(compare);</span><br><span class="line">alert(values); <span class="comment">//0,1,5,10,15</span></span><br><span class="line">values.sort();</span><br><span class="line">alert(values); <span class="comment">//0,1,10,15,5</span></span><br></pre></td></tr></table></figure>
<p>对于数值类型或者其 valueOf() 方法会返回数值类型的对象类型,可以使用一个更简单的比较函数。这个函数只要用第二个值减第一个值即可。正数减负数可能溢出<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> compare(<span class="keyword">value</span><span class="number">1</span>, <span class="keyword">value</span><span class="number">2</span>)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">value</span><span class="number">2</span> - <span class="keyword">value</span><span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="操作方法">操作方法</h3><p>concat()方法可以基于当前数组中的所有项创建一个新数组。具体来说，这个方法会先创建当前数组一个副本，然后将接收到的参数添加到这个副本的末尾，最后返回新构建的数组。在没有给concat()方法传递参数的情况下，它只是复制当前数组并返回副本。</p>
<p>slice()能够基于当前数组中的一或多个项创建一个新数组。slice()方法可以接受一或两个参数，即要返回项的起始和结束位置。在只有一个参数的情况下, slice() 方法返回从该参数指定位置开始到当前数组末尾的所有项。如果有两个参数,该方法返回起始和结束位置之间的项——但不包括结束位置的项。注意, slice() 方法不会影响原始数组。注意, slice() 方法不会影响原始数组。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> colors</span> = [<span class="string">"red"</span>, <span class="string">"green"</span>, <span class="string">"blue"</span>, <span class="string">"yellow"</span>, <span class="string">"purple"</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> colors2</span> = colors.slice(<span class="number">1</span>);</span><br><span class="line"><span class="variable"><span class="keyword">var</span> colors3</span> = colors.slice(<span class="number">1</span>,<span class="number">4</span>);</span><br><span class="line">alert(colors2); <span class="comment">//green,blue,yellow,purple</span></span><br><span class="line">alert(colors3); <span class="comment">//green,blue,yellow</span></span><br></pre></td></tr></table></figure>
<p>如果slice()方法的参数中有一个负数，则用数组长度加上该数来确定相应的位置。例如，在一个包含5项的数组上调用slice(-2,-1)与调用slice(3,4)得到的结果相同。如果结束位置小于起始位置，则返回空数组。</p>
<p>splice()方法，这个方法恐怕要算是最强大的数组方法了，它有很多种用法。splice()的主要用途是向数组的中部插入项，但使用这种方法的方式则有如下3种。</p>
<ul>
<li>删除：可以删除任意数量的项，只需指定 2 个参数：要删除的第一项的位置和要删除的项数。例如，splice(0,2)会删除数组中的前两项。</li>
<li>插入：可以向指定位置插入任意数量的项，只需提供3个参数：起始位置、0（要删除的项数）和要插入的项。如果要插入多个项，可以再传入第四、第五，以至任意多个项。例如，splice(2,0,”red”,”green”)会从当前数组的位置2开始插入字符串”red”和”green”。</li>
<li>替换：可以向指定位置插入任意数量的项，且同时删除任意数量的项，只需指定 3 个参数：起始位置、要删除的项数和要插入的任意数量的项。插入的项数不必与删除的项数相等。例如，splice (2,1,”red”,”green”)会删除当前数组位置 2 的项，然后再从位置 2 开始插入字符串”red”和”green”。</li>
</ul>
<p>splice()方法始终都会返回一个数组，该数组中包含从原始数组中删除的项（如果没有删除任何项，则返回一个空数组）。</p>
<h3 id="位置方法">位置方法</h3><p>ECMAScript 5为数组实例添加了两个位置方法：indexOf()和lastIndexOf()。这两个方法都接收两个参数：要查找的项和（可选的）表示查找起点位置的索引。其中，indexOf()方法从数组的开头（位置0）开始向后查找，lastIndexOf()方法则从数组的末尾开始向前查找。</p>
<p>这两个方法都返回要查找的项在数组中的位置，或者在没找到的情况下返回-1。在比较第一个参数与数组中的每一项时，会使用全等操作符；也就是说，要求查找的项必须严格相等（就像使用===一样）。</p>
<h3 id="迭代方法">迭代方法</h3><p>ECMAScript 5为数组定义了5个迭代方法。每个方法都接收两个参数：要在每一项上运行的函数和（可选的）运行该函数的作用域对象——影响 this 的值。传入这些方法中的函数会接收三个参数：数组项的值、该项在数组中的位置和数组对象本身。根据使用的方法不同，这个函数执行后的返回值可能会也可能不会影响方法的返回值。以下是这5个迭代方法的作用。</p>
<ul>
<li>every()：对数组中的每一项运行给定函数，如果该函数对每一项都返回true，则返回 true。</li>
<li>filter()：对数组中的每一项运行给定函数，返回该函数会返回true的项组成的数组。</li>
<li>forEach()：对数组中的每一项运行给定函数。这个方法没有返回值。</li>
<li>map()：对数组中的每一项运行给定函数，返回每次函数调用的结果组成的数组。</li>
<li>some()：对数组中的每一项运行给定函数，如果该函数对任一项返回true，则返回true。</li>
</ul>
<p>以上方法都不会修改数组中的包含的值。</p>
<h3 id="归并方法">归并方法</h3><p>ECMAScript 5还新增了两个归并数组的方法：reduce()和 reduceRight()。这两个方法都会迭代数组的所有项，然后构建一个最终返回的值。其中，reduce()方法从数组的第一项开始，逐个遍历到最后。而reduceRight()则从数组的最后一项开始，向前遍历到第一项。</p>
<p>这两个方法都接收两个参数：一个在每一项上调用的函数和（可选的）作为归并基础的初始值。传给 reduce()和 reduceRight()的函数接收 4个参数：前一个值、当前值、项的索引和数组对象。这个函数返回的任何值都会作为第一个参数自动传给下一项。第一次迭代发生在数组的第二项上，因此第一个参数是数组的第一项，第二个参数就是数组的第二项。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br><span class="line"><span class="keyword">var</span> sum = values.reduce(<span class="function"><span class="keyword">function</span><span class="params">(prev, cur, <span class="keyword">index</span>, <span class="keyword">array</span>)</span><span class="comment">&#123;</span><br><span class="line">  return prev + cur;</span><br><span class="line">&#125;</span>);</span></span><br><span class="line">alert(sum); <span class="comment">//15</span></span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>第一次执行回调函数, prev 是 1, cur 是 2。第二次, prev 是 3(1 加 2 的结果), cur 是 3(数组的第三项)。这个过程会持续到把数组中的每一项都访问一遍,最后返回结果。</p>
<h3 id="ES6_新增方法">ES6 新增方法</h3><ul>
<li><p>Array.from()<br>  用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）</p>
<p>  Array.from方法可以将函数的arguments对象，转为数组。</p>
<p>  任何有length属性的对象，都可以通过Array.from方法转为数组。</p>
<p>  Array.from()还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理。<code>Array.from(arrayLike, x =&gt; x * x);</code>等同于<code>Array.from(arrayLike).map(x =&gt; x * x);</code></p>
<p>  Array.from()的一个应用是，将字符串转为数组，然后返回字符串的长度。这样可以避免JavaScript将大于\uFFFF的Unicode字符，算作两个字符的bug。</p>
</li>
<li>Array.of()<br>  用于将一组值，转换为数组。这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。<code>Array(3) // [undefined, undefined, undefined]</code></li>
<li><p>数组实例的find()和findIndex()<br>  数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。<code>var found = [1, 4, -5, 10].find((n) =&gt; n &lt; 0);</code></p>
<p>  find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>  数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<p>  这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p>
</li>
<li>数组实例的fill()<br>  使用给定值，填充一个数组。fill()还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</li>
<li><p>数组实例的entries()，keys()和values()<br>  ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个既实现了Iterable又实现了Iterator接口的对象，且该对象<code>Symbol.iterator</code>方法返回其自身，可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
  <figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="reserved">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="ES7_将加入的方法">ES7 将加入的方法</h3><ul>
<li>数组实例的includes()<br>  返回一个布尔值，表示某个数组是否包含给定的值。该方法属于ES7。该方法的第二个参数表示搜索的起始位置，默认为0。</li>
<li><p>Array.observe()，Array.unobserve()<br>  这两个方法用于监听（取消监听）数组的变化，指定回调函数。</p>
<p>  它们的用法与Object.observe和Object.unobserve方法完全一致，也属于ES7的一部分，唯一的区别是，对象可监听的变化一共有六种，而数组只有四种：add、update、delete、splice（数组的length属性发生变化）</p>
</li>
</ul>
<p>此外ES7将加入数组推导（array comprehension），以提供简洁写法，允许直接通过现有数组生成新数组。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> a1</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> a2</span> = [<span class="keyword">for</span> (i of a1) i * <span class="number">2</span>];</span><br><span class="line">a2 <span class="comment">// [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码表示，通过for…of结构，数组a2直接在a1的基础上生成。</p>
<p>注意，数组推导中，for…of结构总是写在最前面，返回的表达式写在最后面。</p>
<p>for…of后面还可以附加if语句，用来设定循环的限制条件。</p>
<p>需要注意的是，数组推导的方括号构成了一个单独的作用域，在这个方括号中声明的变量类似于使用let语句声明的变量。</p>
<h2 id="Date_类型">Date 类型</h2><p>ECMAScript 中的 Date 类型是在早期 Java 中的 java.util.Date 类基础上构建的。</p>
<p>在调用Date 构造函数而不传递参数的情况下，新创建的对象自动获得当前日期和时间。如果想根据特定的日期和时间创建日期对象,必须传入表示该日期的毫秒数(即从 UTC 时间 1970 年 1 月 1 日午夜起至该日期止经过的毫秒数)。为了简化这一计算过程,ECMAScript 提供了两个方法: Date.parse()和 Date.UTC() 。</p>
<p>Date.parse()方法接收一个表示日期的字符串参数，然后尝试根据这个字符串返回相应日期的毫秒数。ECMA-262没有定义Date.parse()应该支持哪种日期格式，因此这个方法的行为因实现而异，而且通常是因地区而异。</p>
<p>如果传入Date.parse()方法的字符串不能表示日期，那么它会返回NaN。实际上，如果直接将表示日期的字符串传递给Date构造函数，也会在后台调用Date.parse()</p>
<p>Date.UTC()方法同样也返回表示日期的毫秒数，但它与 Date.parse()在构建值时使用不同的信息。Date.UTC()的参数分别是年份、基于 0的月份（一月是 0，二月是 1，以此类推）、月中的哪一天（1到 31）、小时数（0到 23）、分钟、秒以及毫秒数。在这些参数中，只有前两个参数（年和月）是必需的。如果没有提供月中的天数，则假设天数为 1；如果省略其他参数，则统统假设为 0。</p>
<p>Date 构造函数会模仿 Date.parse()和 Date.UTC()，但模仿后者有一点明显不同：日期和时间都基于本地时区而非GMT来创建。不过，Date 构造函数接收的参数仍然与Date.UTC()相同。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> y2k1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.UTC(<span class="number">2000</span>, <span class="number">0</span>));</span><br><span class="line"><span class="keyword">var</span> y2k2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="number">2000</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">var</span> someDate1 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="built_in">Date</span>.parse(<span class="string">"May 25, 2004"</span>));</span><br><span class="line"><span class="keyword">var</span> someDate2 = <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">"May 25, 2004"</span>);</span><br></pre></td></tr></table></figure>
<p>ECMAScript 5添加了Data.now()方法，返回表示调用这个方法时的日期和时间的毫秒数。这个方法简化了使用Data对象分析代码的工作。</p>
<p>使用+操作符把Data对象转换成数值，也可以达到同样的目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//取得开始时间 和Date.now()等效</span></span><br><span class="line"><span class="keyword">var</span> start = +<span class="keyword">new</span> <span class="built_in">Date</span>();</span><br></pre></td></tr></table></figure>
<h3 id="继承的方法">继承的方法</h3><p>Date类型的toLocaleString()方法会按照与浏览器设置的地区相适应的格式返回日期和时间。这大致意味着时间格式中会包含AM或PM，但不会包含时区信息（当然，具体的格式会因浏览器而异）。而toString()方法则通常返回带有时区信息的日期和时间，其中时间一般以军用时间（即小时的范围是0到23）表示。</p>
<p>至于Date类型的valueOf()方法，则根本不返回字符串，而是返回日期的毫秒表示。</p>
<h3 id="日期格式化方法">日期格式化方法</h3><p>Date类型还有一些专门用于将日期格式化为字符串的方法，这些方法如下。</p>
<ul>
<li>toDateString()——以特定于实现的格式显示星期几、月、日和年；</li>
<li>toTimeString()——以特定于实现的格式显示时、分、秒和时区；</li>
<li>toLocaleDateString()——以特定于地区的格式显示星期几、月、日和年；</li>
<li>toLocaleTimeString()——以特定于实现的格式显示时、分、秒；</li>
<li>toUTCString()——以特定于实现的格式完整的UTC日期。</li>
</ul>
<p>与toLocaleString()和toString()方法一样，以上这些字符串格式方法的输出也是因浏览器而异的，因此没有哪一个方法能够用来在用户界面中显示一致的日期信息。</p>
<p>除了前面介绍的方法之外,还有一个名叫 toGMTString() 的方法,这是一个与toUTCString() 等价的方法,其存在目的在于确保向后兼容。不过,ECMAScript 推荐现在编写的代码一律使用 toUTCString() 方法。</p>
<h3 id="日期/时间组件方法">日期/时间组件方法</h3><p>剩下还未介绍的Date类型的方法（如下表所示），都是直接取得和设置日期值中特定部分的方法了。需要注意的是，UTC日期指的是在没有时区偏差的情况下（将日期转换为GMT时间）的日期值。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>getTime()</td>
<td>返回表示日期的毫秒数;与 valueOf() 方法返回的值相同</td>
</tr>
<tr>
<td>setTime( 毫秒 )</td>
<td>以毫秒数设置日期,会改变整个日期</td>
</tr>
<tr>
<td>getFullYear()</td>
<td>取得4位数的年份(如2007而非仅07)</td>
</tr>
<tr>
<td>getUTCFullYear()</td>
<td>返回UTC日期的4位数年份</td>
</tr>
<tr>
<td>setFullYear( 年 )</td>
<td>设置日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</td>
</tr>
<tr>
<td>setUTCFullYear( 年 )</td>
<td>设置UTC日期的年份。传入的年份值必须是4位数字(如2007而非仅07)</td>
</tr>
<tr>
<td>getMonth()</td>
<td>返回日期中的月份,其中0表示一月,11表示十二月</td>
</tr>
<tr>
<td>getUTCMonth()</td>
<td>返回UTC日期中的月份,其中0表示一月,11表示十二月</td>
</tr>
<tr>
<td>setMonth( 月 )</td>
<td>设置日期的月份。传入的月份值必须大于0,超过11则增加年份</td>
</tr>
<tr>
<td>setUTCMonth( 月 )</td>
<td>设置UTC日期的月份。传入的月份值必须大于0,超过11则增加年份</td>
</tr>
<tr>
<td>getDate()</td>
<td>返回日期月份中的天数(1到31)</td>
</tr>
<tr>
<td>getUTCDate()</td>
<td>返回UTC日期月份中的天数(1到31)</td>
</tr>
<tr>
<td>setDate( 日 )</td>
<td>设置日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份</td>
</tr>
<tr>
<td>setUTCDate( 日 )</td>
<td>设置UTC日期月份中的天数。如果传入的值超过了该月中应有的天数,则增加月份</td>
</tr>
<tr>
<td>getDay()</td>
<td>返回日期中星期的星期几(其中0表示星期日,6表示星期六)</td>
</tr>
<tr>
<td>getUTCDay()</td>
<td>返回UTC日期中星期的星期几(其中0表示星期日,6表示星期六)</td>
</tr>
<tr>
<td>getHours()</td>
<td>返回日期中的小时数(0到23)</td>
</tr>
<tr>
<td>getUTCHours()</td>
<td>返回UTC日期中的小时数(0到23)</td>
</tr>
<tr>
<td>setHours( 时 )</td>
<td>设置日期中的小时数。传入的值超过了23则增加月份中的天数</td>
</tr>
<tr>
<td>setUTCHours( 时 )</td>
<td>设置UTC日期中的小时数。传入的值超过了23则增加月份中的天数</td>
</tr>
<tr>
<td>getMinutes()</td>
<td>返回日期中的分钟数(0到59)</td>
</tr>
<tr>
<td>getUTCMinutes()</td>
<td>返回UTC日期中的分钟数(0到59)</td>
</tr>
<tr>
<td>setMinutes( 分 )</td>
<td>设置日期中的分钟数。传入的值超过59则增加小时数</td>
</tr>
<tr>
<td>setUTCMinutes( 分 )</td>
<td>设置UTC日期中的分钟数。传入的值超过59则增加小时数</td>
</tr>
<tr>
<td>getSeconds()</td>
<td>返回日期中的秒数(0到59)</td>
</tr>
<tr>
<td>getUTCSeconds()</td>
<td>返回UTC日期中的秒数(0到59)</td>
</tr>
<tr>
<td>setSeconds( 秒 )</td>
<td>设置日期中的秒数。传入的值超过了59会增加分钟数</td>
</tr>
<tr>
<td>setUTCSeconds( 秒 )</td>
<td>设置UTC日期中的秒数。传入的值超过了59会增加分钟数</td>
</tr>
<tr>
<td>getMilliseconds()</td>
<td>返回日期中的毫秒数</td>
</tr>
<tr>
<td>getUTCMilliseconds()</td>
<td>返回UTC日期中的毫秒数</td>
</tr>
<tr>
<td>setMilliseconds( 毫秒 )</td>
<td>设置日期中的毫秒数</td>
</tr>
<tr>
<td>setUTCMilliseconds( 毫秒 )</td>
<td>设置UTC日期中的毫秒数</td>
</tr>
<tr>
<td>getTimezoneOffset()</td>
<td>返回本地时间与UTC时间相差的分钟数。例如,美国东部标准时间返回300。在某地进入夏令时的情况下,这个值会有所变化</td>
</tr>
</tbody>
</table>
<h2 id="RegExp_类型">RegExp 类型</h2><p>使用下面类似 Perl 的语法,就可以创建一个正则表达式。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> expression = <span class="regexp">/ pattern /</span> flags ;</span><br></pre></td></tr></table></figure></p>
<p>其中的模式(pattern)部分可以是任何简单或复杂的正则表达式,可以包含字符类、限定符、分组、向前查找以及反向引用。每个正则表达式都可带有一或多个标志(flags),用以标明正则表达式的行为。正则表达式的匹配模式支持下列 3 个标志。</p>
<ul>
<li>g :表示全局(global)模式,即模式将被应用于所有字符串,而非在发现第一个匹配项时立即停止;</li>
<li>i :表示不区分大小写(case-insensitive)模式,即在确定匹配项时忽略模式与字符串的大小写;</li>
<li>m :表示多行(multiline)模式,即在到达一行文本末尾时还会继续查找下一行中是否存在与模式匹配的项。<br>ES6中新增两个标志</li>
<li>u :表示“Unicode模式”，用来正确处理大于\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。</li>
<li>y :表示“粘连”（sticky）模式。y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">"𠮷"</span>;</span><br><span class="line"><span class="comment">//如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</span></span><br><span class="line"><span class="regexp">/^.$/</span>.test(s) <span class="comment">// false</span></span><br><span class="line"><span class="regexp">/^.$/u</span>.test(s) <span class="comment">// true</span></span><br><span class="line"><span class="comment">//如果不加u修饰符，正则表达式无法识别\u&#123;61&#125;这种表示法，只会认为这匹配61个连续的u。</span></span><br><span class="line"><span class="regexp">/\u&#123;61&#125;/u</span>.test(<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="regexp">/\u&#123;20BB7&#125;/u</span>.test(<span class="string">'𠮷'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">//使用u修饰符后，所有量词都会正确识别大于码点大于0xFFFF的Unicode字符。</span></span><br><span class="line"><span class="regexp">/𠮷&#123;2&#125;/</span>.test(<span class="string">'𠮷𠮷'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="regexp">/𠮷&#123;2&#125;/u</span>.test(<span class="string">'𠮷𠮷'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">//u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。\S是预定义模式</span></span><br><span class="line"><span class="regexp">/^\S$/</span>.test(<span class="string">'𠮷'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="regexp">/^\S$/u</span>.test(<span class="string">'𠮷'</span>) <span class="comment">// true</span></span><br><span class="line"><span class="comment">//有些Unicode字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。</span></span><br><span class="line"><span class="regexp">/[a-z]/i</span>.test(<span class="string">'\u212A'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="regexp">/[a-z]/iu</span>.test(<span class="string">'\u212A'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>y修饰符号隐含了头部匹配的标志<code>ˆ</code>。y修饰符的设计本意，就是让头部匹配的标志ˆ在全局匹配中都有效。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> s</span> = <span class="string">"aaa_aa_a"</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> r1</span> = /a+/g;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> r2</span> = /a+/y;</span><br><span class="line">r1.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line">r2.exec(s) <span class="comment">// ["aaa"]</span></span><br><span class="line">r1.exec(s) <span class="comment">// ["aa"]</span></span><br><span class="line"><span class="comment">//和g一样都是从_aa_a开始，但是y标志要求必须以a开头，所以返回null</span></span><br><span class="line">r2.exec(s) <span class="comment">// null</span></span><br></pre></td></tr></table></figure></p>
<p>如果同时使用g修饰符和y修饰符，则y修饰符覆盖g修饰符。</p>
<p>模式中使用的所有元字符都必须转义。正则表达式中的元字符包括： <code>( [ { \ ^ $ | ) ? * + .]}</code></p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> 匹配所有以<span class="string">"at"</span>结尾的 <span class="number">3</span> 个字符的组合,不区分大小写</span><br><span class="line"><span class="reserved">var</span> pattern3 = <span class="regexp">/.at/gi</span>;</span><br><span class="line"><span class="regexp">//</span> 匹配所有<span class="string">".at"</span>,不区分大小写</span><br><span class="line"><span class="reserved">var</span> pattern4 = <span class="regexp">/\.at/gi</span>;</span><br></pre></td></tr></table></figure>
<p>这些例子都是以字面量形式来定义的正则表达式。另一种创建正则表达式的方式是使用RegExp 构造函数,它接收两个参数:一个是要匹配的字符串模式,另一个是可选的标志字符串。可以使用字面量定义的任何表达式,都可以使用构造函数来定义,如下面的例子所示。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配第一个"bat"或"cat",不区分大小写</span></span><br><span class="line"><span class="keyword">var</span> pattern1 = <span class="regexp">/[bc]at/i</span>;</span><br><span class="line"><span class="comment">// 与 pattern1 相同,只不过是使用构造函数创建的</span></span><br><span class="line"><span class="keyword">var</span> pattern2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"[bc]at"</span>, <span class="string">"i"</span>);</span><br></pre></td></tr></table></figure></p>
<p>要注意的是，传递给RegExp构造函数的两个参数都是字符串（ES5不能把正则表达式字面量传递给RegExp构造函数，ES6支持传递正则表达式字面量，如果同时有第二个标识参数，将覆盖字面量中的标识）。由于RegExp构造函数的模式参数是字符串，所以在某些情况下要对字符进行双重转义。所有元字符都必须双重转义，那些已经转义过的字符也是如此，例如<code>\n</code>（字符<code>\</code>在字符串中通常被转义为<code>\\</code>，而在正则表达式字符串中就会变成<code>\\\\</code>）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6中</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">'i'</span>).flags; <span class="comment">//"i"</span></span><br></pre></td></tr></table></figure></p>
<p>使用正则表达式字面量和使用 RegExp 构造函数创建的正则表达式不一样。在ECMAScript 3中，正则表达式字面量始终会共享同一个RegExp实例，而使用构造函数创建的每一个新RegExp实例都是一个新实例。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> re = null, i;</span><br><span class="line"><span class="keyword">for</span> (i=0; i &lt; 10; i++)&#123;</span><br><span class="line">  re = /<span class="keyword">cat</span>/<span class="keyword">g</span>;</span><br><span class="line">  re.<span class="keyword">test</span>(<span class="string">"catastrophe"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>循环中,即使是循环体中指定的,但实际上只为 /cat/ 创建了一个 RegExp 实例。由于实例属性(下一节介绍实例属性)不会重置,所以在循环中再次调用 test() 方法会失败。这是因为第一次调用 test() 找到了 “cat” ,但第二次调用是从索引为 3 的字符(上一次匹配的末尾)开始的,所以就找不到它了。由于会测试到字符串末尾,所以下一次再调用 test() 就又从开头开始了。</p>
<p>ECMAScript 5明确规定，使用正则表达式字面量必须像直接调用RegExp构造函数一样，每次都创建新的RegExp实例</p>
<h3 id="RegExp_实例属性">RegExp 实例属性</h3><p>RegExp的每个实例都具有下列属性，通过这些属性可以取得有关模式的各种信息。</p>
<ul>
<li>global：布尔值，表示是否设置了g标志。</li>
<li>ignoreCase：布尔值，表示是否设置了i标志。</li>
<li>lastIndex：整数，表示开始搜索下一个匹配项的字符位置，从0算起。</li>
<li>multiline：布尔值，表示是否设置了m标志。</li>
<li>source：正则表达式的字符串表示，按照字面量形式而非传入构造函数中的字符串模式返回。<br>ES6新增属性</li>
<li>sticky:布尔值，表示是否设置了y标志。</li>
<li>flags: 字符串，表示正则表达式的标志</li>
</ul>
<p>通过这些属性可以获知一个正则表达式的各方面信息，但却没有多大用处，因为这些信息全都包含在模式声明中。</p>
<h3 id="RegExp_实例方法">RegExp 实例方法</h3><p>RegExp对象的主要方法是exec()，该方法是专门为捕获组而设计的。exec()接受一个参数，即要应用模式的字符串，然后返回包含第一个匹配项信息的数组；或者在没有匹配项的情况下返回null。返回的数组虽然是Array 的实例，但包含两个额外的属性：index 和input。其中，index 表示匹配项在字符串中的位置，而 input 表示应用正则表达式的字符串。在数组中，第一项是与整个模式匹配的字符串，其他项是与模式中的捕获组匹配的字符串（如果模式中没有捕获组，则该数组只包含一项）。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">text</span> = <span class="string">"mom and dad and baby"</span>;</span><br><span class="line">var pattern = /mom<span class="params">( and dad<span class="params">( and baby)</span>?)</span>?/gi;</span><br><span class="line">var matches = pattern.exec<span class="params">(text)</span>;</span><br><span class="line">alert<span class="params">(matches.index)</span>; <span class="comment">// 0</span></span><br><span class="line">alert<span class="params">(matches.input)</span>; <span class="comment">// "mom and dad and baby"</span></span><br><span class="line">alert<span class="params">(matches[<span class="number">0</span>])</span>; <span class="comment">// "mom and dad and baby"</span></span><br><span class="line">alert<span class="params">(matches[<span class="number">1</span>])</span>; <span class="comment">// " and dad and baby"</span></span><br><span class="line">alert<span class="params">(matches[<span class="number">2</span>])</span>; <span class="comment">// " and baby"</span></span><br></pre></td></tr></table></figure>
<p>对于 exec()方法而言，即使在模式中设置了全局标志（g），它每次也只会返回一个匹配项。在不设置全局标志的情况下，在同一个字符串上多次调用 exec()将始终返回第一个匹配项的信息。而在设置全局标志的情况下，每次调用exec()则都会在字符串中继续查找新匹配项</p>
<p>IE 的 JavaScript 实现在 lastIndex 属性上存在偏差，即使在非全局模式下，lastIndex属性每次也会变化。</p>
<p>正则表达式的第二个方法是 test()，它接受一个字符串参数。在模式与该参数匹配的情况下返回true；否则，返回 false。在只想知道目标字符串与某个模式是否匹配，但不需要知道其文本内容的情况下，使用这个方法非常方便</p>
<p>RegExp实例继承的toLocaleString()和toString()方法都会返回正则表达式的字面量，与创建正则表达式的方式无关</p>
<p>正则表达式的valueOf()方法返回正则表达式本身。</p>
<h3 id="RegExp_构造函数属性">RegExp 构造函数属性</h3><p>RegExp 构造函数属性分别有一个长属性名和一个短属性名（Opera是例外，它不支持短属性名）。下表列出了RegExp构造函数的属性。</p>
<table>
<thead>
<tr>
<th>长属性名</th>
<th>短属性名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>input</td>
<td>$_</td>
<td>最近一次要匹配的字符串。Opera未实现此属性</td>
</tr>
<tr>
<td>lastMatch</td>
<td>$&amp;</td>
<td>最近一次的匹配项。Opera未实现此属性</td>
</tr>
<tr>
<td>lastParen</td>
<td>$+</td>
<td>最近一次匹配的捕获组。Opera未实现此属性</td>
</tr>
<tr>
<td>leftContext</td>
<td>$`</td>
<td>input字符串中lastMatch之前的文本</td>
</tr>
<tr>
<td>multiline</td>
<td>$*</td>
<td>布尔值,表示是否所有表达式都使用多行模式。IE和Opera未实现此属性</td>
</tr>
<tr>
<td>rightContext</td>
<td>$’</td>
<td>Input字符串中lastMatch之后的文本</td>
</tr>
</tbody>
</table>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">text</span> = <span class="string">"this has been a short summer"</span>;</span><br><span class="line">var pattern = /<span class="params">(.)</span>hort/g;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="params">(pattern.test<span class="params">(text)</span>)</span>&#123;</span><br><span class="line">  alert<span class="params">(RegExp.input)</span>; <span class="comment">// this has been a short summer</span></span><br><span class="line">  alert<span class="params">(RegExp.leftContext)</span>; <span class="comment">// this has been a</span></span><br><span class="line">  alert<span class="params">(RegExp.rightContext)</span>; <span class="comment">// summer</span></span><br><span class="line">  alert<span class="params">(RegExp.lastMatch)</span>; <span class="comment">// short</span></span><br><span class="line">  alert<span class="params">(RegExp.lastParen)</span>; <span class="comment">// s</span></span><br><span class="line">  alert<span class="params">(RegExp.multiline)</span>; <span class="comment">// false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RegExp构造函数的各个属性返回了下列值：</p>
<ul>
<li>input属性返回了原始字符串；</li>
<li>leftContext属性返回了单词short之前的字符串，而rightContext属性则返回了short之后的字符串；</li>
<li>lastMatch属性返回最近一次与整个正则表达式匹配的字符串，即short；</li>
<li>lastParen 属性返回最近一次匹配的捕获组,即例子中的s</li>
</ul>
<p>由于短属性名大都不是有效的ECMAScript标识符，因此必须通过方括号语法来访问它们</p>
<p>除了上面介绍的几个属性之外，还有多达9个用于存储捕获组的构造函数属性。访问这些属性的语法是 RegExp.$1、RegExp.$2…RegExp.$9，分别用于存储第一、第二……第九个匹配的捕获组。在调用exec()或test()方法时，这些属性会被自动填充。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">text</span> = <span class="string">"this has been a short summer"</span>;</span><br><span class="line">var pattern = /<span class="params">(..)</span>or<span class="params">(.)</span>/g;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(pattern.test<span class="params">(text)</span>)</span>&#123;</span><br><span class="line">  alert<span class="params">(RegExp.$<span class="number">1</span>)</span>;</span><br><span class="line">  alert<span class="params">(RegExp.$<span class="number">2</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字符串必须转义，才能作为正则模式。有人提议作为RegExp对象的静态方法RegExp.escape()，放入ES7。该方法用于将字符串转义，但是最终这个方法没有被加入。</p>
<p>目前，该方法可以用下面的escapeRegExp函数或者垫片模块<a href="https://github.com/ljharb/regexp.escape" target="_blank" rel="external">regexp.escape</a>实现。<br><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function escapeRegExp(str) <span class="special">&#123;</span></span><br><span class="line">  return str.replace(/<span class="special">[</span><span class="command">\-</span><span class="command">\[</span><span class="command">\]</span><span class="command">\/</span><span class="command">\&#123;</span><span class="command">\&#125;</span><span class="command">\(</span><span class="command">\)</span><span class="command">\*</span><span class="command">\+</span><span class="command">\?</span><span class="command">\.</span><span class="command">\\</span><span class="command">\^</span><span class="command">\$</span><span class="command">\|</span><span class="special">]</span>/g, "<span class="command">\\</span><span class="formula">$<span class="special">&amp;</span>");</span><br><span class="line"><span class="special">&#125;</span></span><br><span class="line">let str = '/path/to/resource.html?search=query';</span><br><span class="line">escapeRegExp(str)</span><br><span class="line">// "<span class="command">\/</span>path<span class="command">\/</span>to<span class="command">\/</span>resource<span class="command">\.</span>html<span class="command">\?</span>search=query"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="模式的局限性">模式的局限性</h3><p>ECMAScript 正则表达式不支持的特性(要了解更多相关信息。</p>
<ul>
<li>匹配字符串开始和结尾的 \A 和 \Z 锚，但支持以插入符号(^)和美元符号($)来匹配字符串的开始和结尾。</li>
<li>向后查找(lookbehind),但完全支持向前查找(lookahead)<br>。</li>
<li>并集和交集类</li>
<li>原子组(atomic grouping)</li>
<li>Unicode 支持(单个字符除外,如 \uFFFF )</li>
<li>命名的捕获组，但支持编号的捕获组。</li>
<li>s (single,单行)和 x (free-spacing,无间隔)匹配模式</li>
<li>条件匹配</li>
<li>正则表达式注释</li>
</ul>
<h2 id="Function_类型">Function 类型</h2><p>说起来 ECMAScript中什么最有意思，我想那莫过于函数了——而有意思的根源，则在于函数实际上是对象。每个函数都是Function类型的实例，而且都与其他引用类型一样具有属性和方法。<strong>由于函数是对象，因此函数名实际上也是一个指向函数对象的指针，不会与某个函数绑定</strong>。</p>
<p>函数通常是使用函数声明语法定义的。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> <span class="params">(num1, num2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是使用函数表达式定义函数的方式，和上面效果是一样的。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span><span class="params">(num1, num2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在使用函数表达式定义函数时，没有必要使用函数名——通过变量sum即可以引用函数。另外，还要注意函数末尾有一个分号，就像声明其他变量时一样。</p>
<p>最后一种定义函数的方式是使用Function构造函数。Function构造函数可以接收任意数量的参数，但最后一个参数始终都被看成是函数体，而前面的参数则枚举出了新函数的参数。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum = <span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">"num1"</span>, <span class="string">"num2"</span>, <span class="string">"return num1 + num2"</span>)</span></span>; <span class="comment">// 不推荐，因为这种语法会导致解析两次代码(第一次是解析常规 ECMAScript 代码,第二次是解析传入构造函数中的字符串)</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span><span class="params">(num1, num2)</span>&#123;</span></span><br><span class="line">  return num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line">alert<span class="params">(sum<span class="params">(<span class="number">10</span>,<span class="number">10</span>)</span>)</span>; <span class="comment">//20</span></span><br><span class="line">var anotherSum = sum;</span><br><span class="line">alert<span class="params">(anotherSum<span class="params">(<span class="number">10</span>,<span class="number">10</span>)</span>)</span>; <span class="comment">//20</span></span><br></pre></td></tr></table></figure>
<p><strong>使用不带圆括号的函数名是访问函数指针，而非调用函数</strong></p>
<h3 id="没有重载">没有重载</h3><p>将函数名想象为指针，也有助于理解为什么 ECMAScript中没有函数重载的概念。在创建第二个同名函数时,实际上覆盖了引用第一个函数的函数名变量。</p>
<h3 id="函数声明与函数表达式">函数声明与函数表达式</h3><p>解析器会率先读取函数声明，并使其在执行任何代码之前可用（可以访问）；至于函数表达式，则必须等到解析器执行到它所在的代码行，才会真正被解释执行</p>
<p>在代码开始执行之前，解析器就已经通过一个名为函数声明提升（function declaration hoisting）的过程，读取并将函数声明添加到执行环境中。对代码求值时，JavaScript引擎在第一遍会声明函数并将它们放到源代码树的顶部</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">sum</span>(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="built_in">sum</span>(num1, num2)&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的例子可以正常运行，但是下面的运行时会抛出错误<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="built_in">sum</span>(<span class="number">10</span>,<span class="number">10</span>));</span><br><span class="line">var <span class="built_in">sum</span> = <span class="function"><span class="keyword">function</span><span class="params">(num1, num2)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也可以同时使用函数声明和函数表达式，例如var sum = function sum(){}。不过，这种语法在Safari中会导致错误。</p>
<h3 id="作为值的函数">作为值的函数</h3><p>因为 ECMAScript中的函数名本身就是变量，所以函数也可以作为值来使用。也就是说，不仅可以像传递参数一样把一个函数传递给另一个函数，而且可以将一个函数作为另一个函数的结果返回（将函数返回这是一种很有用的技巧）</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSomeFunction</span><span class="params">(someFunction, someArgument)</span></span>&#123; <span class="comment">//someFunction是一个函数</span></span><br><span class="line">  <span class="keyword">return</span> someFunction(someArgument);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="函数内部属性">函数内部属性</h3><p>在函数内部，有两个特殊的对象：arguments和this。arguments是一个类数组对象，包含着传入函数中的所有参数。虽然 arguments 的主要用途是保存函数参数，但这个对象还有一个名叫callee的属性，该属性是一个指针，指向拥有这个arguments对象的函数。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function factorial(<span class="built_in">num</span>)&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">num</span> &lt;=<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// return num * factorial(num - 1); 和下面效果相同，但是如果引用函数的变量名不是factorial而是var a = factorial，同时factorial被指向另一个函数，通过a调用该方法，那么这样就会有问题了</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">num</span> * arguments.callee(<span class="built_in">num</span>-<span class="number">1</span>); <span class="comment">//通过这种方法，消除了和函数名的耦合</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数内部的另一个特殊对象是 this ,其行为与 Java 和 C#中的 this 大致类似。this引用的是函数据以执行的环境对象——或者也可以说是this值（当在网页的全局作用域中调用函数时，this对象引用的就是window）。</p>
<p>一定要牢记，函数的名字仅仅是一个包含指针的变量而已。</p>
<p>ECMAScript 5也规范化了另一个函数对象的属性：caller。除了 Opera的早期版本不支持，其他浏览器都支持这个 ECMAScript 3并没有定义的属性。这个属性中保存着调用当前函数的函数的引用，如果是在全局作用域中调用当前函数，它的值为null。</p>
<p>同样，为了实现更松散的耦合，可以通过arguments.callee.caller访问调用当前函数的函数的引用</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">outer</span><span class="params">()</span>&#123;</span></span><br><span class="line">  inner<span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inner</span><span class="params">()</span>&#123;</span></span><br><span class="line">  alert<span class="params">(arguments.callee.caller)</span>;</span><br><span class="line">&#125;</span><br><span class="line">outer<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>当函数在严格模式下运行时，访问 arguments.callee 会导致错误。ECMAScript 5 还定义了arguments.caller属性，但在严格模式下访问它也会导致错误，而在非严格模式下这个属性始终是undefined。定义这个属性是为了分清arguments.caller 和函数的caller 属性。以上变化都是为了加强这门语言的安全性，这样第三方代码就不能在相同的环境里窥视其他代码了。 严格模式还有一个限制：不能为函数的caller属性赋值，否则会导致错误。</p>
<h3 id="函数属性和方法">函数属性和方法</h3><p>ECMAScript 中的函数是对象，因此函数也有属性和方法。每个函数都包含两个属性：length 和prototype。其中，length 属性表示函数希望接收的命名参数（形参）的个数</p>
<p>对于ECMAScript中的引用类型而言，prototype是保存它们所有实例方法的真正所在。换句话说，诸如toString()和valueOf()等方法实际上都保存在prototype名下，只不过是通过各自对象的实例访问罢了。在创建自定义引用类型以及实现继承时，prototype属性的作用是极为重要的（第6章将详细介绍）。在ECMAScript 5中，prototype属性是不可枚举的，因此使用for-in无法发现。</p>
<p>每个函数都包含两个非继承而来的方法：apply()和 call()。这两个方法的用途都是在特定的作用域中调用函数，实际上等于设置函数体内this对象的值。首先，apply()方法接收两个参数：一个是在其中运行函数的作用域，另一个是参数数组。其中，第二个参数可以是 Array 的实例，也可以是arguments对象</p>
<p>下例中，因为是在全局作用域中调用的,所以传入的就是 window 对象<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum1</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>); <span class="comment">// 传入 arguments 对象</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">callSum2</span>(<span class="params">num1, num2</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> sum.apply(<span class="keyword">this</span>, [num1, num2]); <span class="comment">// 传入数组</span></span><br><span class="line">&#125;</span><br><span class="line">alert(callSum1(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br><span class="line">alert(callSum2(<span class="number">10</span>,<span class="number">10</span>)); <span class="comment">//20</span></span><br></pre></td></tr></table></figure></p>
<p>在严格模式下，未指定环境对象而调用函数，则 this 值不会转型为 window。除非明确把函数添加到某个对象或者调用 apply()或 call()，否则 this 值将是undefined</p>
<p>call() 方法与 apply()方法的作用相同，它们的区别仅在于接收参数的方式不同。对于 call()方法而言，第一个参数是this值没有变化，变化的是其余参数都直接传递给函数。换句话说，在使用call()方法时,传递给函数的参数必须逐个列举出来</p>
<p>传递参数并非apply()和call()真正的用武之地；它们真正强大的地方是能够扩充函数赖以运行的作用域。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.<span class="built_in">color</span> = <span class="string">"red"</span>;</span><br><span class="line">var o = &#123; <span class="built_in">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span><span class="params">()</span>&#123;</span></span><br><span class="line">  alert<span class="params">(this.color)</span>;</span><br><span class="line">&#125;</span><br><span class="line">sayColor<span class="params">()</span>; <span class="comment">//red</span></span><br><span class="line">sayColor.call<span class="params">(this)</span>;<span class="comment">//red</span></span><br><span class="line">sayColor.call<span class="params">(window)</span>; <span class="comment">//red</span></span><br><span class="line">sayColor.call<span class="params">(o)</span>; <span class="comment">//blue</span></span><br></pre></td></tr></table></figure>
<p>使用call()（或apply()）来扩充作用域的最大好处，就是对象不需要与方法有任何耦合关系。如上sayColor方法就没有和具体对象耦合</p>
<p>ECMAScript 5还定义了一个方法：bind()。这个方法会创建一个函数的实例，其 this 值会被绑定到传给bind()函数的值</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.<span class="built_in">color</span> = <span class="string">"red"</span>;</span><br><span class="line">var o = &#123; <span class="built_in">color</span>: <span class="string">"blue"</span> &#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sayColor</span><span class="params">()</span>&#123;</span></span><br><span class="line">  alert<span class="params">(this.color)</span>;</span><br><span class="line">&#125;</span><br><span class="line">var objectSayColor = sayColor.bind<span class="params">(o)</span>;</span><br><span class="line">objectSayColor<span class="params">()</span>; <span class="comment">//blue</span></span><br></pre></td></tr></table></figure>
<p>每个函数继承的 toLocaleString()和 toString()方法始终都返回函数的代码</p>
<p>另外一个继承的valueOf()方法同样也只返回函数代码。</p>
<h3 id="默认参数">默认参数</h3><p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span><span class="params">(x, y = 'World')</span> &#123;</span></span><br><span class="line">  console.<span class="built_in">log</span><span class="params">(x, y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">log</span><span class="params">('Hello')</span> <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure></p>
<p>默认值的写法非常灵活，下面是一个为对象属性设置默认值的例子。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fetch(url, &#123; body = '', <span class="keyword">method</span> = '<span class="type">GET</span>', headers = &#123;&#125; &#125;)&#123;</span><br><span class="line">  console.log(<span class="keyword">method</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，传入函数fetch的第二个参数是一个对象，调用的时候可以为它的三个属性设置默认值。</p>
<p>甚至还可以设置双重默认值。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function fetch(url, &#123; <span class="keyword">method</span> = '<span class="type">GET</span>' &#125; = &#123;&#125;)&#123;</span><br><span class="line">  console.log(<span class="keyword">method</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，调用函数fetch时，如果不含第二个参数，则默认值为一个空对象；如果包含第二个参数，则它的method属性默认值为GET。</p>
<p>定义了默认值的参数，必须是函数的尾部参数，其后不能再有其他无默认值的参数。</p>
<p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p>
<p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(a, b, c = 5)</span></span>&#123;&#125;).length <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">function throwIfMissing() &#123;&#10;  throw new Error(&#39;Missing parameter&#39;);&#10;&#125;&#10;&#10;function foo(mustBeProvided = throwIfMissing()) &#123;&#10;  return mustBeProvided;&#10;&#125;&#10;&#10;foo()&#10;// Error: Missing parameter</span><br></pre></td></tr></table></figure></p>
<p>上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。</p>
<p>从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（即函数名之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行（即如果参数已经赋值，默认值中的函数就不会运行），这与python语言不一样。</p>
<p>另一个需要注意的地方是，参数默认值所处的作用域，不是全局作用域，而是函数作用域。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x, y = x)</span> &#123;</span></span><br><span class="line">  console.<span class="built_in">log</span><span class="params">(y)</span>;</span><br><span class="line">&#125;</span><br><span class="line">foo<span class="params">(<span class="number">2</span>)</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，参数y的默认值等于x，由于处在函数作用域，所以y等于参数x，而不是全局变量x。</p>
<p>参数默认值可以与解构赋值，联合起来使用。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(&#123;x, y = <span class="number">5</span>&#125;)</span> &#123;</span></span><br><span class="line">  console.<span class="built_in">log</span><span class="params">(x, y)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo<span class="params">(&#123;&#125;)</span> <span class="comment">// undefined, 5</span></span><br><span class="line">foo<span class="params">(&#123;x: <span class="number">1</span>&#125;)</span> <span class="comment">// 1, 5</span></span><br><span class="line">foo<span class="params">(&#123;x: <span class="number">1</span>, y: <span class="number">2</span>&#125;)</span> <span class="comment">// 1, 2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，foo函数的参数是一个对象，变量x和y用于解构赋值，y有默认值5。</p>
<h3 id="rest参数">rest参数</h3><p>ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。（和Java的变长参数类似）</p>
<p>注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<p>函数的length属性，不包括rest参数。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(a, <span class="rest_arg">...b</span>)</span> </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure></p>
<h3 id="扩展运算符">扩展运算符</h3><p>扩展运算符（spread）是三个点（…）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。该运算符主要用于函数调用。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//下面max,push 方法不接受数组</span></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line">Math.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Math.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> arr1</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> arr2</span> = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> arr1</span> = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> arr2</span> = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1.push(...arr2);</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">var</span> a</span> = [<span class="number">1</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> b</span> = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> c</span> = [<span class="number">6</span>, <span class="number">7</span>];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> d</span> = [<span class="number">0</span>, ...a, ...b, <span class="number">5</span>, ...c];</span><br></pre></td></tr></table></figure></p>
<p>上面代码其实也提供了，将一个数组拷贝进另一个数组的便捷方法。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr2 = [...arr1];</span><br></pre></td></tr></table></figure></p>
<p>扩展运算符也可以与解构赋值结合起来，用于生成数组。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const <span class="comment">[first, ...rest]</span> = <span class="comment">[1, 2, 3, 4, 5]</span>;</span><br><span class="line">const <span class="comment">[...butLast, last]</span> = <span class="comment">[1, 2, 3, 4, 5]</span>; // 报错</span><br></pre></td></tr></table></figure></p>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<p>任何类似数组的对象，都可以用扩展运算符转为真正的数组。<br><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var nodeList =<span class="function"> document.querySelectorAll(</span>'div'<span class="function">)</span>;</span><br><span class="line">var<span class="instruction"> array </span>= <span class="keyword">[</span>...node<span class="class">List];</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，querySelectorAll方法返回的是一个nodeList对象，扩展运算符可以将其转为真正的数组。</p>
<p>扩展运算符内部调用的是数据结构的Iterable接口，因此只要具有Iterable接口的对象，都可以使用扩展运算符，比如Map结构。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">map</span> <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Map</span>(<span class="preprocessor">[</span></span><br><span class="line">  <span class="preprocessor">[</span><span class="number">1</span>, <span class="string">'one'</span><span class="preprocessor">]</span><span class="markup">,</span><br><span class="line">  </span><span class="preprocessor">[</span><span class="number">2</span>, <span class="string">'two'</span><span class="preprocessor">]</span><span class="markup">,</span><br><span class="line">  </span><span class="preprocessor">[</span><span class="number">3</span>, <span class="string">'three'</span><span class="preprocessor">]</span><span class="markup">,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">let arr = </span><span class="preprocessor">[</span><span class="attribute">...</span><span class="built_in">map</span><span class="built_in">.</span>keys()<span class="preprocessor">]</span><span class="markup">; // </span><span class="preprocessor">[</span><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span><span class="preprocessor">]</span><span class="markup"></span></span><br></pre></td></tr></table></figure></p>
<p>Generator函数运行后，返回一个同时实现了Iterator和Iterable接口的对象，因此也可以使用扩展运算符。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量go是一个Generator函数，执行后返回的是一个Iterable对象，对这个对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<h2 id="基本包装类型">基本包装类型</h2><p>为了便于操作基本类型值，ECMAScript提供了3个特殊的引用类型：Boolean、Number和String。实际上，每当读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，从而让我们能够调用一些方法来操作这些数据。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var <span class="variable">i =</span> <span class="number">1</span> .<span class="built_in">toString</span>(); //注意空格，否则会被当浮点数解析，然后抛错，还可以写为(<span class="number">1</span>).<span class="built_in">toString</span>()  <span class="number">1</span>..<span class="built_in">toString</span>()</span><br></pre></td></tr></table></figure>
<p>上例中实际执行了三步：1. 创建Number类型的一个实例 2. 在实例上调用指定方法 3. 销毁这个实例</p>
<p>引用类型与基本包装类型的主要区别就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁。这意味着我们不能在运行时为基本类型值添加属性和方法<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> s1</span> = <span class="string">"some text"</span>;</span><br><span class="line">s1.color = <span class="string">"red"</span>;</span><br><span class="line">alert(s1.color); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></p>
<p>在此,第二行代码试图为字符串 s1 添加一个 color 属性。但是,当第三行代码再次访问 s1 时, 其 color 属性不见了。问题的原因就是第二行创建的 String 对象在执行第三行代码时已经被销毁了。第三行代码又创建自己的 String 对象,而该对象没有 color 属性。</p>
<p>Object构造函数也会像工厂方法一样，根据传入值的类型返回相应基本包装类型的实例。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Object</span>(<span class="string">"some text"</span>);</span><br><span class="line">alert(obj <span class="keyword">instanceof</span> <span class="built_in">String</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<p>要注意的是，使用new调用基本包装类型的构造函数，与直接调用同名的转型函数是不一样的。 例如：<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> value = <span class="string">"25"</span>;</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">number</span> = <span class="built_in">Number</span>(value); <span class="comment">//转型函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> <span class="built_in">number</span>); <span class="comment">//"number"</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="keyword">new</span> <span class="built_in">Number</span>(value); <span class="comment">//构造函数</span></span><br><span class="line">alert(<span class="keyword">typeof</span> obj); <span class="comment">//"object"</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Boolean_类型">Boolean 类型</h3><p>Boolean 对象在 ECMAScript 中的用处不大,因为它经常会造成人们的误解。所以不推荐使用。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> falseObject = new <span class="type">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">var</span> <span class="literal">result</span> = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line">alert(<span class="literal">result</span>); //这里返回的是<span class="literal">true</span> 布尔表达式中的所有对象都会被转换为<span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>基本类型与引用类型的布尔值还有两个区别。首先，typeof操作符对基本类型返回”boolean”，而对引用类型返回”object”。其次，由于Boolean对象是Boolean类型的实例，所以使用instanceof操作符测试Boolean对象会返回true，而测试基本类型的布尔值则返回false。</p>
<h3 id="Number_类型">Number 类型</h3><p>和Boolean类型类似，不推荐直接创建Number类型的实例，而应该使用基本类型。</p>
<p>toFixed()方法会按照指定的小数位返回数值的字符串表示。J如果数值本身包含的小数位比指定的还多，那么接近指定的最大小数位的值就会舍入<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="params">(<span class="params">(<span class="number">10</span>)</span>.toFixed<span class="params">(<span class="number">2</span>)</span>)</span>; <span class="comment">//"10.00"</span></span><br><span class="line">alert<span class="params">(<span class="params">(<span class="number">10.005</span>)</span>.toFixed<span class="params">(<span class="number">2</span>)</span>)</span>; <span class="comment">//"10.01"</span></span><br></pre></td></tr></table></figure></p>
<p>toFixed() 方法可以表示带有 0 到 20 个小数位的数值。但这只是标准实现的范围,有些浏览器也可能支持更多位数。</p>
<p>另外可用于格式化数值的方法是toExponential()，该方法返回以指数表示法（也称e表示法）表示的数值的字符串形式。与toFixed()一样，toExponential()也接收一个参数，而且该参数同样也是指定输出结果中的小数位数<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert<span class="params">(<span class="params">(<span class="number">10</span>)</span>.toExponential<span class="params">(<span class="number">1</span>)</span>)</span>; <span class="comment">//"1.0e+1"</span></span><br></pre></td></tr></table></figure></p>
<p>如果你想得到表示某个数值的最合适的格式,就应该使用 toPrecision() 方法。对于一个数值来说，toPrecision()方法可能会返回固定大小（fixed）格式，也可能返回指数（exponential）格式；具体规则是看哪种格式最合适。这个方法接收一个参数，即表示数值的所有数字的位数（不包括指数部分）。<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var num = <span class="number">99</span><span class="comment">;</span></span><br><span class="line">alert<span class="list">(<span class="keyword">num</span>.toPrecision<span class="list">(<span class="number">1</span>)</span>)</span><span class="comment">; //"1e+2"</span></span><br><span class="line">alert<span class="list">(<span class="keyword">num</span>.toPrecision<span class="list">(<span class="number">2</span>)</span>)</span><span class="comment">; //"99"</span></span><br><span class="line">alert<span class="list">(<span class="keyword">num</span>.toPrecision<span class="list">(<span class="number">3</span>)</span>)</span><span class="comment">; //"99.0"</span></span><br></pre></td></tr></table></figure></p>
<p>ES6提供了二进制和八进制数值的新的写法，分别用前缀0b和0o表示。<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">0b111110111 =<span class="value">== <span class="number">503</span> // <span class="keyword">true</span></span></span></span><br><span class="line"><span class="setting">0o767 =<span class="value">== <span class="number">503</span> // <span class="keyword">true</span></span></span></span><br></pre></td></tr></table></figure></p>
<p>八进制不再允许使用前缀0表示，而改为使用前缀0o。</p>
<p>ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法，用来检查无穷（infinity）和NaN这两个特殊值。它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。</p>
<p>ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</p>
<p>Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。<code>Number.isInteger(25.0) // true</code></p>
<p>JavaScript能够准确表示的整数范围在-2ˆ53 and 2ˆ53之间。ES6引入了<code>Number.MAX_SAFE_INTEGER</code>和<code>Number.MIN_SAFE_INTEGER</code>这两个常量，用来表示这个范围的上下限。Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p>
<h3 id="String_类型">String 类型</h3><p>和Java中的String有点类似，String类型的方法只是返回一个新的字符串，不会改变原字符串。</p>
<p>String类型的每个实例都有一个length属性，表示字符串中包含多个字符。应该注意的是，即使字符串中包含双字节字符（不是占一个字节的ASCII字符），每个字符也仍然算一个字符。</p>
<p>两个用于访问字符串中特定字符的方法是：charAt()和 charCodeAt()。这两个方法都接收一个参数，即基于 0 的字符位置。其中，charAt()方法以单字符字符串的形式返回给定位置的那个字符</p>
<p>如果你想得到的不是字符而是字符编码，那么就要像下面这样使用charCodeAt()了。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> stringValue</span> = <span class="string">"hello world"</span>; alert(stringValue.charCodeAt(<span class="number">1</span>)); <span class="comment">//输出"101"</span></span><br></pre></td></tr></table></figure></p>
<p>ECMAScript 5还定义了另一个访问个别字符的方法。在支持此方法的浏览器中，可以使用方括号加数字索引来访问字符串中的特定字符</p>
<p>concat()，用于将一或多个字符串拼接起来，返回拼接得到的新字符串。应用更多的还是加号操作符。</p>
<p>ECMAScript还提供了三个基于子字符串创建新字符串的方法：slice()、substr()和substring()。这三个方法都会返回被操作字符串的一个子字符串，而且也都接受一或两个参数。第一个参数指定子字符串的开始位置，第二个参数（在指定的情况下）表示子字符串到哪里结束。具体来说，slice()和substring()的第二个参数指定的是子字符串最后一个字符后面的位置。而 substr() 的第二个参数指定的则是返回的字符个数。如果没有给这些方法传递第二个参数，则将字符串的长度作为结束位置。与concat()方法一样，slice()、substr()和 substring()也不会修改字符串本身的值——它们只是返回一个基本类型的字符串值，对原始字符串没有任何影响。</p>
<p>在传递给这些方法的参数是负值的情况下，它们的行为就不尽相同了。其中，slice()方法会将传入的负值与字符串的长度相加，substr()方法将负的第一个参数加上字符串的长度，而将负的第二个参数转换为0。最后，substring()方法会把所有负值参数都转换为0<br><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var stringValue = <span class="string">"hello world"</span><span class="comment">;</span></span><br><span class="line">alert<span class="list">(<span class="keyword">stringValue</span>.slice<span class="list">(<span class="keyword">-3</span>)</span>)</span><span class="comment">; //"rld" slice(8)</span></span><br><span class="line">alert<span class="list">(<span class="keyword">stringValue</span>.substring<span class="list">(<span class="keyword">-3</span>)</span>)</span><span class="comment">; //"hello world" substring(0)</span></span><br><span class="line">alert<span class="list">(<span class="keyword">stringValue</span>.substr<span class="list">(<span class="keyword">-3</span>)</span>)</span><span class="comment">; //"rld" substr(8)</span></span><br><span class="line">alert<span class="list">(<span class="keyword">stringValue</span>.slice<span class="list">(<span class="number">3</span>, <span class="number">-4</span>)</span>)</span><span class="comment">; //"lo w" slice(3, 7)</span></span><br><span class="line">alert<span class="list">(<span class="keyword">stringValue</span>.substring<span class="list">(<span class="number">3</span>, <span class="number">-4</span>)</span>)</span><span class="comment">; //"hel" substring(3,0) 而由于这个方法会将较小的数作为开始位置,将较大的数作为结束位置, 因此最终相当于调用了 substring(0,3)</span></span><br><span class="line">alert<span class="list">(<span class="keyword">stringValue</span>.substr<span class="list">(<span class="number">3</span>, <span class="number">-4</span>)</span>)</span><span class="comment">; //""(空字符串) substr(3,0)</span></span><br></pre></td></tr></table></figure></p>
<p>有两个可以从字符串中查找子字符串的方法：indexOf()和lastIndexOf()。这两个方法都是从一个字符串中搜索给定的子字符串，然后返子字符串的位置（如果没有找到该子字符串，则返回-1）。这两个方法都可以接收可选的第二个参数，表示从字符串中的哪个位置开始搜索</p>
<p>trim()方法。这个方法会创建一个字符串的副本，删除前置及后缀的所有空格，然后返回结果。Firefox 3.5+、Safari 5+和Chrome 8+还支持非标准的trimLeft()和trimRight()方法，分别用于删除字符串开头和末尾的空格。</p>
<p>接下来我们要介绍的是一组与大小写转换有关的方法。ECMAScript 中涉及字符串大小写转换的方法有4个：toLowerCase()、toLocaleLowerCase()、toUpperCase()和toLocaleUpperCase()。</p>
<p>String类型定义了几个用于在字符串中匹配模式的方法。第一个方法就是match()，在字符串上调用这个方法，本质上与调用 RegExp 的 exec()方法相同。match()方法只接受一个参数，要么是一个正则表达式，要么是一个RegExp对象</p>
<p>另一个用于查找模式的方法是search()。这个方法的唯一参数与match()方法的参数相同：由字符串或 RegExp 对象指定的一个正则表达式。search()方法返回字符串中第一个匹配项的索引；如果没有找到匹配项，则返回-1。</p>
<p>为了简化替换子字符串的操作，ECMAScript提供了replace()方法。这个方法接受两个参数：第一个参数可以是一个 RegExp 对象或者一个字符串（这个字符串不会被转换成正则表达式），第二个参数可以是一个字符串或者一个函数。如果第一个参数是字符串，那么只会替换第一个子字符串。要想替换所有子字符串，唯一的办法就是提供一个正则表达式，而且要指定全局（g）标志</p>
<p>如果第二个参数是字符串,那么还可以使用一些特殊的字符序列,将正则表达式操作得到的值插入到结果字符串中。下表列出了ECMAScript提供的这些特殊的字符序列。</p>
<table>
<thead>
<tr>
<th>字符序列</th>
<th>替换文本</th>
</tr>
</thead>
<tbody>
<tr>
<td>$$</td>
<td>$</td>
</tr>
<tr>
<td>$&amp;</td>
<td>匹配整个模式的子字符串。与 RegExp.lastMatch 的值相同</td>
</tr>
<tr>
<td>$’</td>
<td>匹配的子字符串之前的子字符串。与 RegExp.leftContext 的值相同</td>
</tr>
<tr>
<td>$`</td>
<td>匹配的子字符串之后的子字符串。与 RegExp.rightContext 的值相同</td>
</tr>
<tr>
<td>$n</td>
<td>匹配第n个捕获组的子字符串,其中n等于0~9。例如, $1 是匹配第一个捕获组的子字符串, $2 是匹配第二个捕获组的子字符串,以此类推。如果正则表达式中没有定义捕获组,则使用空字符串</td>
</tr>
<tr>
<td>$nn</td>
<td>匹配第nn个捕获组的子字符串,其中nn等于01~99。例如, $01 是匹配第一个捕获组的子字符串, $02是匹配第二个捕获组的子字符串,以此类推。如果正则表达式中没有定义捕获组,则使用空字符串</td>
</tr>
</tbody>
</table>
<p>replace()方法的第二个参数也可以是一个函数。在只有一个匹配项（即与模式匹配的字符串）的情况下，会向这个函数传递3个参数：模式的匹配项、模式匹配项在字符串中的位置和原始字符串。在正则表达式中定义了多个捕获组的情况下，传递给函数的参数依次是模式的匹配项、第一个捕获组的匹配项、第二个捕获组的匹配项……，但最后两个参数仍然分别是模式的匹配项在字符串中的位置和原始字符串。这个函数应该返回一个字符串，表示应该被替换的匹配项使用函数作为 replace()方法的第二个参数可以实现更加精细的替换操作</p>
<p>最后一个与模式匹配有关的方法是split()，这个方法可以基于指定的分隔符将一个字符串分割成多个子字符串，并将结果放在一个数组中。分隔符可以是字符串，也可以是一个RegExp对象（这个方法不会将字符串看成正则表达式）。split()方法可以接受可选的第二个参数，用于指定数组的大小，以便确保返回的数组不会超过既定大小。</p>
<p>对 split() 中正则表达式的支持因浏览器而异。尽管对于简单的模式没有什么差别,但对于未发现匹配项以及带有捕获组的模式,匹配的行为就不大相同了。以下是几种常见的差别。</p>
<ul>
<li>IE8 及之前版本会忽略捕获组。ECMA-262 规定应该把捕获组拼接到结果数组中。IE9 能正确地在结果中包含捕获组。</li>
<li>Firefox 3.6 及之前版本在捕获组未找到匹配项时,会在结果数组中包含空字符串;ECMA-262 规定没有匹配项的捕获组在结果数组中应该用 undefined 表示。</li>
</ul>
<p>ES6将match()、replace()、search()和split()这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p>
<ul>
<li>String.prototype.match 调用 RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search 调用 RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split 调用 RegExp.prototype[Symbol.split]</li>
</ul>
<p>与操作字符串有关的最后一个方法是localeCompare()，这个方法比较两个字符串，并返回下列值中的一个：</p>
<ul>
<li>如果字符串在字母表中应该排在字符串参数之前，则返回一个负数（大多数情况下是-1，具体的值要视实现而定）；</li>
<li>如果字符串等于字符串参数，则返回0；</li>
<li>如果字符串在字母表中应该排在字符串参数之后，则返回一个正数（大多数情况下是1，具体的值同样要视实现而定）。</li>
</ul>
<p>另外，String 构造函数本身还有一个静态方法：fromCharCode()。这个方法的任务是接收一或多个字符编码，然后将它们转换成一个字符串</p>
<p>一些被浏览器扩展的方法，应该尽量不使用这些方法,因为它们创建的标记通常无法表达语义。</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>输出结果</th>
</tr>
</thead>
<tbody>
<tr>
<td>anchor(name)</td>
<td><code>&lt;a name= &quot;name&quot;&gt;string&lt;/a&gt;</code></td>
</tr>
<tr>
<td>big()</td>
<td><code>&lt;big&gt;string&lt;/big&gt;</code></td>
</tr>
<tr>
<td>bold()</td>
<td><code>&lt;b&gt;string&lt;/b&gt;</code></td>
</tr>
<tr>
<td>fixed()</td>
<td><code>&lt;tt&gt;string&lt;/tt&gt;</code></td>
</tr>
<tr>
<td>fontcolor(color)</td>
<td><code>&lt;font color=&quot;color&quot;&gt;string&lt;/font&gt;</code></td>
</tr>
<tr>
<td>fontsize(size)</td>
<td><code>&lt;font size=&quot;size&quot;&gt;string&lt;/font&gt;</code></td>
</tr>
<tr>
<td>italics()</td>
<td><code>&lt;i&gt;string&lt;/i&gt;</code></td>
</tr>
<tr>
<td>link(url)</td>
<td><code>&lt;a href=&quot;url&quot;&gt;string&lt;/a&gt;</code></td>
</tr>
<tr>
<td>small()</td>
<td><code>&lt;small&gt;string&lt;/small&gt;</code></td>
</tr>
<tr>
<td>strike()</td>
<td><code>&lt;strike&gt;string&lt;/strike&gt;</code></td>
</tr>
<tr>
<td>sub()</td>
<td><code>&lt;sub&gt;string&lt;/sub&gt;</code></td>
</tr>
<tr>
<td>sup()</td>
<td><code>&lt;sup&gt;string&lt;/sup&gt;</code></td>
</tr>
</tbody>
</table>
<p>ECMAScript6中对String进行了扩展。</p>
<p>对于Unicode字符，之前<code>\u20BB7</code>会被解析为<code>\u20BB+7</code>。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。ES6对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。<code>\u{20BB7}</code></p>
<p>ES6提供了String.fromCodePoint方法，可以识别码点大于0xFFFF（辅助平面）的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String.fromCharCode(0x20BB7);// </span><span class="string">"ஷ"</span></span><br><span class="line"><span class="keyword">String.fromCodePoint(0x20BB7);// </span><span class="string">"𠮷"</span></span><br></pre></td></tr></table></figure></p>
<p>注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。</p>
<p>ES6提供了String.codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">"𠮷a"</span>;</span><br><span class="line"></span><br><span class="line">s.codePointAt<span class="params">(<span class="number">0</span>)</span> <span class="comment">// 134071</span></span><br><span class="line">s.codePointAt<span class="params">(<span class="number">1</span>)</span> <span class="comment">// 57271</span></span><br><span class="line"></span><br><span class="line">s.charCodeAt<span class="params">(<span class="number">0</span>)</span> <span class="comment">// 55362</span></span><br><span class="line">s.charCodeAt<span class="params">(<span class="number">1</span>)</span> <span class="comment">// 57271</span></span><br><span class="line">s.charCodeAt<span class="params">(<span class="number">2</span>)</span> <span class="comment">// 97</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，汉字“𠮷”的码点是0x20BB7，UTF-16编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，而且charAt方法无法读取字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。</p>
<p>codePointAt方法的参数，是字符在字符串中的位置（从0开始）。上面代码中，JavaScript将“𠮷a”视为三个字符，codePointAt方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。</p>
<p>ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。</p>
<p>ES7提供了字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。Chrome浏览器已经支持该方法。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'𠮷'</span>.<span class="function"><span class="title">charAt</span><span class="params">(<span class="number">0</span>)</span></span> <span class="comment">// "\uD842"</span></span><br><span class="line"></span><br><span class="line"><span class="string">'abc'</span>.<span class="function"><span class="title">at</span><span class="params">(<span class="number">0</span>)</span></span> <span class="comment">// "a"</span></span><br><span class="line"><span class="string">'𠮷'</span>.<span class="function"><span class="title">at</span><span class="params">(<span class="number">0</span>)</span></span> <span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure></p>
<p>为了表示语调和重音符号，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。</p>
<p>这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。<br><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>.<span class="keyword">normalize</span>() === <span class="string">'\u004F\u030C'</span>.<span class="keyword">normalize</span>(); <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>normalize方法可以接受四个参数。</p>
<ul>
<li>NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li>
<li>NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li>
<li>NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。</li>
<li>NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li>
</ul>
<p>不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过Unicode编号区间判断。</p>
<p>传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。</p>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。</li>
</ul>
<p>这三个方法都支持第二个参数，表示开始搜索的位置。使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p>
<p>repeat()返回一个新字符串，表示将原字符串重复n次。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"hello"</span>.<span class="function"><span class="title">repeat</span><span class="params">(<span class="number">3</span>)</span></span> <span class="comment">// "hellohellohello"</span></span><br></pre></td></tr></table></figure></p>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。模板字符串中嵌入变量，需要将变量名写在<code>${}</code>之中。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line">`<span class="keyword">In</span> JavaScript '\<span class="keyword">n</span>' is a <span class="keyword">line</span>-feed.`</span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line">`<span class="keyword">In</span> JavaScript this is</span><br><span class="line"> not legal.`</span><br><span class="line">console.<span class="literal">log</span>(`string text <span class="keyword">line</span> 1</span><br><span class="line">string text <span class="keyword">line</span> 2`);</span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">"Bob"</span>, time = <span class="string">"today"</span>;</span><br><span class="line">console.<span class="literal">log</span>(`\`Hello <span class="label">$&#123;name&#125;</span>, how are you <span class="label">$&#123;time&#125;</span>?\`</span><br><span class="line">$&#123;'Mr. ' + name&#125;</span><br><span class="line">`);</span><br></pre></td></tr></table></figure>
<p>如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<p>大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。模板字符串之中还能调用函数</p>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。</p>
<p>如果模板字符串中的变量没有声明，将报错。</p>
<p>标签模板</p>
<p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。<br><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="literal">a</span> = <span class="number">5</span><span class="comment">;</span></span><br><span class="line">var b = <span class="number">10</span><span class="comment">;</span></span><br><span class="line">tag<span class="escape">`H</span>ello $&#123; <span class="literal">a</span> + b &#125; world $&#123; <span class="literal">a</span> * b &#125;<span class="escape">`;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。</p>
<p>函数tag依次会接收到多个参数。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(stringArr, value1, value2)</span></span>&#123; <span class="comment">// ...  &#125;</span></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(stringArr, <span class="rest_arg">...values</span>)</span></span>&#123; <span class="comment">// ...  &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p>tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。</p>
<p>tag函数所有参数的实际值如下。</p>
<ul>
<li>第一个参数：[‘Hello ‘, ‘ world ‘, ‘’]</li>
<li>第二个参数: 15</li>
<li>第三个参数：50</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s, v1, v2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(v1);</span><br><span class="line">  <span class="built_in">console</span>.log(v2);</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// "Hello "</span></span><br><span class="line"><span class="comment">// " world "</span></span><br><span class="line"><span class="comment">// ""</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 50</span></span><br><span class="line"><span class="comment">// "OK"</span></span><br></pre></td></tr></table></figure>
<p>“标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message =</span><br><span class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">var</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p>
<p>模板字符串本身并不能取代Mustache之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p>
<p>模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">tag</span>`First <span class="built_in">line</span>\nSecond <span class="built_in">line</span>`</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(strings)</span> &#123;</span></span><br><span class="line">  console.<span class="built_in">log</span>(strings.raw[<span class="number">0</span>]);</span><br><span class="line">  // <span class="string">"First line\\nSecond line"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是<code>[&quot;First line\nSecond line&quot;]</code>，那么strings.raw数组就是<code>[&quot;First line\\nSecond line&quot;]</code>。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw数组会将<code>\n</code>视为<code>\</code>和<code>n</code>两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p>
<p>ES6还为原生的String对象，提供了一个raw方法。String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;2+3&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// "Hi\\n5!"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// 'Hi\\u000A!'</span></span><br></pre></td></tr></table></figure>
<p>String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>
<p>String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">String</span><span class="class">.raw</span>(&#123; <span class="attribute">raw</span>: <span class="string">'test'</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>); <span class="comment">// 't0e1s2t'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="tag">String</span><span class="class">.raw</span>(&#123; <span class="attribute">raw</span>: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<h2 id="单体内置对象">单体内置对象</h2><h3 id="Global对象">Global对象</h3><p>Global（全局）对象可以说是ECMAScript中最特别的一个对象了，因为不管你从什么角度上看，这个对象都是不存在的。ECMAScript中的Global对象在某种意义上是作为一个终极的“兜底儿对象”来定义的。换句话说，不属于任何其他对象的属性和方法，最终都是它的属性和方法。事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。诸如 isNaN() 、 isFinite() 、 parseInt() 以及 parseFloat() ,实际上全都是 Global 对象的方法。</p>
<ul>
<li><p>URI 编码方法<br>  对象的 encodeURI()和 encodeURIComponent()方法可以对 URI（Uniform Resource Identifiers，通用资源标识符）进行编码，以便发送给浏览器。有效的 URI 中不能包含某些字符，例如空格。而这两个URI编码方法就可以对URI进行编码，它们用特殊的UTF-8编码替换所有无效的字符，从而让浏览器能够接受和理解。 其中，encodeURI()主要用于整个URI（例如，<code>http://www.wrox.com/illegal value.htm</code>），而 encodeURIComponent()主要用于对URI中的某一段（例如前面URI中的illegal value.htm）进行编码。它们的主要区别在于，encodeURI()不会对本身属于 URI 的特殊字符进行编码，例如冒号、正斜杠、问号和井字号；而encodeURIComponent()则会对它发现的任何非标准字符进行编码。</p>
<p>  一般来说，我们使用 encodeURIComponent()方法的时候要比使用encodeURI()更多，因为在实践中更常见的是对查询字符串参数而不是对基础 URI进行编码。</p>
<p>  与 encodeURI()和 encodeURIComponent()方法对应的两个方法分别是 decodeURI()和decodeURIComponent()</p>
</li>
<li><p>eval()方法<br>  现在，我们介绍最后一个——大概也是整个ECMAScript语言中最强大的一个方法：eval()。eval()方法就像是一个完整的ECMAScript解析器，它只接受一个参数，即要执行的ECMAScript（或JavaScript）字符串。看例子： eval(“alert(‘hi’)”); 这行代码的作用等价于代码： alert(“hi”);</p>
<p>  当解析器发现代码中调用eval()方法时，它会将传入的参数当作实际的ECMAScript语句来解析，然后把执行结果插入到原位置。通过 eval() 执行的代码可以引用在包<br>含环境中定义的变量 <code>var msg = &quot;hello world&quot;; eval(&quot;alert(msg)&quot;);</code></p>
<p>  在eval()中创建的任何变量或函数都不会被提升，因为在解析代码的时候，它们被包含在一个字符串中；它们只在eval()执行的时候创建。 严格模式下，在外部访问不到eval()中创建的任何变量或函数，在严格模式下,为 eval 赋值也会导致错误</p>
</li>
<li><p>Global 对象的属性<br>  特殊的值undefined、NaN以及Infinity都是Global对象的属性。此外，所有原生引用类型的构造函数，像Object和Function，也都是Global对象的属性。下表列出了Global对象的所有属性。</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>属性</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>undefined</td>
<td>特殊值 undefined</td>
</tr>
<tr>
<td>NaN</td>
<td>特殊值 NaN</td>
</tr>
<tr>
<td>Infinity</td>
<td>特殊值 Infinity</td>
</tr>
<tr>
<td>Date</td>
<td>构造函数 Date</td>
</tr>
<tr>
<td>RegExp</td>
<td>构造函数 RegExp</td>
</tr>
<tr>
<td>Error</td>
<td>构造函数 Error</td>
</tr>
<tr>
<td>Object</td>
<td>构造函数 Object</td>
</tr>
<tr>
<td>Array</td>
<td>构造函数 Array</td>
</tr>
<tr>
<td>Function</td>
<td>构造函数 Function</td>
</tr>
<tr>
<td>Boolean</td>
<td>构造函数 Boolean</td>
</tr>
<tr>
<td>String</td>
<td>构造函数 String</td>
</tr>
<tr>
<td>Number</td>
<td>构造函数 Number</td>
</tr>
<tr>
<td>EvalError</td>
<td>构造函数 EvalError</td>
</tr>
<tr>
<td>RangeError</td>
<td>构造函数 RangeError</td>
</tr>
<tr>
<td>ReferenceError</td>
<td>构造函数 ReferenceError</td>
</tr>
<tr>
<td>SyntaxError</td>
<td>构造函数 SyntaxError</td>
</tr>
<tr>
<td>TypeError</td>
<td>构造函数 TypeError</td>
</tr>
<tr>
<td>URIError</td>
<td>构造函数 URIError</td>
</tr>
</tbody>
</table>
<p>ECMAScript 5明确禁止给undefined、NaN和Infinity赋值，这样做即使在非严格模式下也会导致错误。</p>
<ul>
<li>window 对象<br>  ECMAScript 虽然没有指出如何直接访问 Global 对象，但 Web 浏览器都是将这个全局对象作为window对象的一部分加以实现的。因此，在全局作用域中声明的所有变量和函数，就都成为了window对象的属性。</li>
</ul>
<h3 id="Math_对象">Math 对象</h3><p>Math对象包含的属性大都是数学计算中可能会用到的一些特殊值。下表列出了这些属性。</p>
<ul>
<li>Math 对象的属性</li>
</ul>
<table>
<thead>
<tr>
<th>属 性</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.E</td>
<td>自然对数的底数，即常量e的值</td>
</tr>
<tr>
<td>Math.LN10</td>
<td>10的自然对数</td>
</tr>
<tr>
<td>Math.LN2</td>
<td>2的自然对数</td>
</tr>
<tr>
<td>Math.LOG2E</td>
<td>以2为底e的对数</td>
</tr>
<tr>
<td>Math.LOG10E</td>
<td>以10为底e的对数</td>
</tr>
<tr>
<td>Math.PI</td>
<td>π的值</td>
</tr>
<tr>
<td>Math.SQRT1_2</td>
<td>1/2的平方根（即2的平方根的倒数）</td>
</tr>
<tr>
<td>Math.SQRT2</td>
<td>2的平方根</td>
</tr>
</tbody>
</table>
<ul>
<li><p>min() 和 max() 方法<br>  这两个方法都可以接收任意多个数值参数，要查找数组中的最大值可以使用apply方法。</p>
  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.min(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>);</span><br><span class="line"><span class="keyword">var</span> values = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="built_in">Math</span>, values);</span><br></pre></td></tr></table></figure>
</li>
<li><p>舍入方法</p>
<ul>
<li>Math.ceil()执行向上舍入，即它总是将数值向上舍入为最接近的整数；</li>
<li>Math.floor()执行向下舍入，即它总是将数值向下舍入为最接近的整数；</li>
<li>Math.round()执行标准舍入，即它总是将数值四舍五入为最接近的整数</li>
</ul>
</li>
<li><p>random() 方法<br>  Math.random() 方法返回大于等于 0 小于 1 的一个随机数。套用下面的公式，就可以利用Math.random()从某个整数范围内随机选择一个值。 <code>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</code></p>
</li>
<li><p>其他方法</p>
</li>
</ul>
<table>
<thead>
<tr>
<th>方 法</th>
<th>说 明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Math.abs(num)</td>
<td>返回num 的绝对值</td>
</tr>
<tr>
<td>Math.exp(num)</td>
<td>返回Math.E 的num 次幂</td>
</tr>
<tr>
<td>Math.log(num)</td>
<td>返回num 的自然对数</td>
</tr>
<tr>
<td>Math.pow(num,power)</td>
<td>返回num 的power 次幂</td>
</tr>
<tr>
<td>Math.sqrt(num)</td>
<td>返回num 的平方根</td>
</tr>
<tr>
<td>Math.acos(x)</td>
<td>返回x 的反余弦值</td>
</tr>
<tr>
<td>Math.asin(x)</td>
<td>返回x 的反正弦值</td>
</tr>
<tr>
<td>Math.atan(x)</td>
<td>返回x 的反正切值</td>
</tr>
<tr>
<td>Math.atan2(y,x)</td>
<td>返回y/x 的反正切值</td>
</tr>
<tr>
<td>Math.cos(x)</td>
<td>返回x 的余弦值</td>
</tr>
<tr>
<td>Math.sin(x)</td>
<td>返回x 的正弦值</td>
</tr>
<tr>
<td>Math.tan(x)</td>
<td>返回x 的正切值</td>
</tr>
</tbody>
</table>
<ul>
<li><p>ES6新增方法</p>
<ul>
<li>Math.trunc(num)：去除一个数的小数部分，返回整数部分，对于空值和无法截取整数的值，返回NaN</li>
<li>Math.sign(num)：判断一个数到底是正数、负数、还是零。参数为正数，返回+1； 参数为负数，返回-1； 参数为0，返回0； 参数为-0，返回-0; 其他值，返回NaN。</li>
<li>Math.cbrt(num)：计算一个数的立方根</li>
<li>Math.clz32(num)：返回一个数的32位无符号整数二进制形式表示有多少个前导0。对于小数，只考虑整数部分，对于其他值，先转为数值，再计算</li>
<li>Math.imul(num1,num2)：回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。多数情况和<code>(a * b)|0</code>效果相同，但JavaScript对于超过2的53次方的值无法精确表示，该方法可以得到正确值</li>
<li>Math.fround(num)：Math.fround方法返回一个数的单精度浮点数形式。对于整数来说，Math.fround方法返回结果不会有任何不同，区别主要是那些无法用64个二进制位精确表示的小数。这时，Math.fround方法会返回最接近这个小数的单精度浮点数。</li>
<li>Math.hypot()：返回所有参数的平方和的平方根，如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN</li>
<li>Math.expm1()：返回Math.exp(x) - 1</li>
<li>Math.log1p()：返回1 + x的自然对数。如果x小于-1，返回NaN</li>
<li>Math.log10()：返回以10为底的x的对数。如果x小于0，则返回NaN</li>
<li>Math.log2()：返回以2为底的x的对数。如果x小于0，则返回NaN</li>
<li>Math.sinh(x)：返回x的双曲正弦（hyperbolic sine）</li>
<li>Math.cosh(x)：返回x的双曲余弦（hyperbolic cosine）</li>
<li>Math.tanh(x)：返回x的双曲正切（hyperbolic tangent）</li>
<li>Math.asinh(x)：返回x的反双曲正弦（inverse hyperbolic sine）</li>
<li>Math.acosh(x)：返回x的反双曲余弦（inverse hyperbolic cosine）</li>
<li>Math.atanh(x)：返回x的反双曲正切（inverse hyperbolic tangent）</li>
</ul>
</li>
</ul>
<h2 id="键集合类型">键集合类型</h2><h3 id="Map_类型">Map 类型</h3><h4 id="基本用法">基本用法</h4><p>JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">var</span> <span class="typedef"><span class="keyword">data</span> = <span class="container">&#123;&#125;</span>;</span></span><br><span class="line"><span class="title">var</span> element = document.getElementById(<span class="string">"myDiv"</span>);</span><br><span class="line"></span><br><span class="line"><span class="typedef"><span class="keyword">data</span>[element] = metadata;</span></span><br><span class="line"><span class="typedef"><span class="keyword">data</span>["[<span class="type">Object</span> <span class="type">HTMLDivElement</span>]"] // metadata</span></span><br></pre></td></tr></table></figure>
<p>上面代码原意是将一个DOM节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串<code>[Object HTMLDivElement]</code>。</p>
<p>为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。</p>
<p>作为构造函数，Map可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map([ [<span class="string">"name"</span>, <span class="string">"张三"</span>], [<span class="string">"title"</span>, <span class="string">"Author"</span>]]);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">size</span> <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">map</span>.has(<span class="string">"name"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"name"</span>) <span class="comment">// "张三"</span></span><br><span class="line"><span class="built_in">map</span>.has(<span class="string">"title"</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>(<span class="string">"title"</span>) <span class="comment">// "Author"</span></span><br></pre></td></tr></table></figure>
<p>如果对同一个键多次赋值，后面的值将覆盖前面的值。</p>
<p>如果读取一个未知的键，则返回undefined。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new <span class="function"><span class="title">Map</span><span class="params">()</span></span>.<span class="function"><span class="title">get</span><span class="params">(<span class="string">'asfddfsasadf'</span>)</span></span> <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>([<span class="string">'a'</span>], <span class="number">555</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">get</span>([<span class="string">'a'</span>]) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>同理，同样的值的两个实例，在Map结构中被视为两个键。<br><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">map</span> = <span class="keyword">new</span> <span class="type">Map</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> k1 = ['a'];</span><br><span class="line"><span class="keyword">var</span> k2 = ['a'];</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="keyword">set</span>(k1, <span class="number">111</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="keyword">set</span>(k2, <span class="number">222</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">map</span>.<span class="keyword">get</span>(k1) <span class="comment">// 111</span></span><br><span class="line"><span class="built_in">map</span>.<span class="keyword">get</span>(k2) <span class="comment">// 222</span></span><br></pre></td></tr></table></figure></p>
<p>由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，</p>
<p>如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。</p>
<h4 id="实例的属性和操作方法">实例的属性和操作方法</h4><p>Map结构的实例有以下属性和操作方法。</p>
<ul>
<li>size：返回成员总数。</li>
<li>set(key, value)：设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。</li>
<li>get(key)：读取key对应的键值，如果找不到key，返回undefined。</li>
<li>has(key)：返回一个布尔值，表示某个键是否在Map数据结构中。</li>
<li>delete(key)：删除某个键，返回true。如果删除失败，返回false。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
<p>set()方法返回的是Map本身，因此可以采用链式写法。</p>
<h4 id="遍历方法">遍历方法</h4><p>Map原生提供三个Iterable对象，这三个对象同样实现了Iterator接口。</p>
<ul>
<li>keys()：返回键名的Iterable对象。</li>
<li>values()：返回键值的Iterable对象。</li>
<li>entries()：返回所有成员的Iterable对象。</li>
</ul>
<p>下面是使用实例。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, <span class="keyword">value</span>] <span class="keyword">of</span> map.entries()) &#123;</span><br><span class="line">  console.log(key, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于使用map.entries()</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, <span class="keyword">value</span>] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  console.log(key, <span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码最后的那个例子，表示Map结构的Symbol.iterator属性，就是entries方法。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map[<span class="type">Symbol</span>.<span class="keyword">iterator</span>] === map.entries // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（…）。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">let</span> <span class="atom">map</span> = <span class="atom">new</span> <span class="name">Map</span>([</span><br><span class="line">  [<span class="number">1</span>, <span class="string">'one'</span>],</span><br><span class="line">  [<span class="number">2</span>, <span class="string">'two'</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="string">'three'</span>],</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">[...<span class="atom">map</span>.<span class="atom">keys</span>()]</span><br><span class="line">// [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">[...<span class="atom">map</span>.<span class="atom">values</span>()]</span><br><span class="line">// [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line">[...<span class="atom">map</span>.<span class="atom">entries</span>()]</span><br><span class="line">// [[<span class="number">1</span>,<span class="string">'one'</span>], [<span class="number">2</span>, <span class="string">'two'</span>], [<span class="number">3</span>, <span class="string">'three'</span>]]</span><br><span class="line">[...<span class="atom">map</span>]</span><br><span class="line">// [[<span class="number">1</span>,<span class="string">'one'</span>], [<span class="number">2</span>, <span class="string">'two'</span>], [<span class="number">3</span>, <span class="string">'three'</span>]]</span><br></pre></td></tr></table></figure>
<p>结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">let</span> map0 = <span class="keyword">new</span> Map()</span><br><span class="line">  .set(<span class="number">1</span>, <span class="string">'a'</span>)</span><br><span class="line">  .set(<span class="number">2</span>, <span class="string">'b'</span>)</span><br><span class="line">  .set(<span class="number">3</span>, <span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="reserved">let</span> map1 = <span class="keyword">new</span> Map(</span><br><span class="line">  [...map0].filter(<span class="function"><span class="params">([k, v])</span> =&gt;</span> k &lt; <span class="number">3</span>)</span><br><span class="line">);</span><br><span class="line"><span class="regexp">//</span> 产生Map结构 &#123;<span class="number">1</span> =&gt; <span class="string">'a'</span>, <span class="number">2</span> =&gt; <span class="string">'b'</span>&#125;</span><br><span class="line"><span class="reserved">let</span> map2 = <span class="keyword">new</span> Map(</span><br><span class="line">  [...map0].map(<span class="function"><span class="params">([k, v])</span> =&gt;</span> [k * <span class="number">2</span>, <span class="string">'_'</span> + v])</span><br><span class="line">    );</span><br><span class="line"><span class="regexp">//</span> 产生Map结构 &#123;<span class="number">2</span> =&gt; <span class="string">'_a'</span>, <span class="number">4</span> =&gt; <span class="string">'_b'</span>, <span class="number">6</span> =&gt; <span class="string">'_c'</span>&#125;</span><br></pre></td></tr></table></figure>
<p>此外，Map还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">map</span>.forEach(function(value, key, <span class="keyword">map</span>)) &#123;</span><br><span class="line">  console.<span class="keyword">log</span>(<span class="string">"Key: <span class="variable">%s</span>, Value: <span class="variable">%s</span>"</span>, key, value);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>forEach方法还可以接受第二个参数，用来绑定this。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> reporter = &#123;</span><br><span class="line">  report: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Key: %s, Value: %s"</span>, key, value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">map.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value, key, map</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.report(key, value);</span><br><span class="line">&#125;, reporter);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，forEach方法的回调函数的this，就指向reporter。</p>
<h4 id="与其他数据结构的互相转换">与其他数据结构的互相转换</h4><ol>
<li><p><strong>Map转为数组</strong></p>
<p> 前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。</p>
</li>
<li><p><strong>数组转为Map</strong></p>
<p> 将数组转入Map构造函数，就可以转为Map。</p>
</li>
<li><p><strong>Map转为对象</strong></p>
<p> 如果所有Map的键都是字符串，通过遍历，它可以转为对象。</p>
</li>
<li><p><strong>对象转为Map</strong></p>
<p>通过遍历Object.keys(obj)，调用map.set方法添加键值对</p>
</li>
<li><p><strong>Map转为JSON</strong></p>
<p> Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。JSON.stringify(strMapToObj(strMap));</p>
<p> 另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。 JSON.stringify([…map]);</p>
</li>
<li><p><strong>JSON转为Map</strong></p>
<p> JSON转为Map，正常情况下，所有键名都是字符串。JSON.parse(jsonStr)先转为对象，再把对象转为Map</p>
<p> 但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。new Map(JSON.parse(jsonStr));</p>
</li>
</ol>
<h3 id="WeakMap_类型">WeakMap 类型</h3><p>WeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受原始类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。</p>
<p>WeakMap的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap自动移除对应的键值对。典型应用是，一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</p>
<p>下面是WeakMap结构的一个例子，可以看到用法上与Map几乎一样。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> wm = <span class="keyword">new</span> WeakMap();</span><br><span class="line"><span class="keyword">var</span> element = <span class="built_in">document</span>.<span class="built_in">querySelector</span>(<span class="string">".element"</span>);</span><br><span class="line"></span><br><span class="line">wm.<span class="literal">set</span>(element, <span class="string">"Original"</span>);</span><br><span class="line">wm.<span class="literal">get</span>(element) <span class="comment">// "Original"</span></span><br><span class="line"></span><br><span class="line">element.parentNode.removeChild(element);</span><br><span class="line">element = <span class="keyword">null</span>;</span><br><span class="line">wm.<span class="literal">get</span>(element) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量wm是一个WeakMap实例，我们将一个DOM节点element作为键名，然后销毁这个节点，element对应的键就自动消失了，再引用这个键名就返回undefined。</p>
<p>WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。</p>
<p>WeakMap的另一个用处是部署私有属性。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> _counter = <span class="keyword">new</span> WeakMap();</span><br><span class="line"><span class="keyword">let</span> _action = <span class="keyword">new</span> WeakMap();</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> Countdown &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(counter, action) </span>&#123;</span><br><span class="line">    _counter.set(<span class="keyword">this</span>, counter);</span><br><span class="line">    _action.set(<span class="keyword">this</span>, action);</span><br><span class="line">  &#125;</span><br><span class="line">  dec() &#123;</span><br><span class="line">    <span class="keyword">let</span> counter = _counter.get(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (counter &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    counter--;</span><br><span class="line">    _counter.set(<span class="keyword">this</span>, counter);</span><br><span class="line">    <span class="keyword">if</span> (counter === <span class="number">0</span>) &#123;</span><br><span class="line">      _action.get(<span class="keyword">this</span>)();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> c = <span class="keyword">new</span> Countdown(<span class="number">2</span>, () =&gt; <span class="built_in">console</span>.log(<span class="string">'DONE'</span>));</span><br><span class="line"></span><br><span class="line">c.dec()</span><br><span class="line">c.dec()</span><br><span class="line"><span class="comment">// DONE</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Countdown类的两个内部属性<code>_counter</code>和<code>_action</code>，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。</p>
<h3 id="Set_类型">Set 类型</h3><h4 id="基本用法-1">基本用法</h4><p>ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">[<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">2</span>].map(x =&gt; s.add(x))</span><br><span class="line">s<span class="comment">// Set [ 2, 3, 5, 4 ]</span></span><br></pre></td></tr></table></figure>
<p>Set函数可以接受一个数组作为参数，用来初始化。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">5</span>]);</span><br><span class="line">items.size <span class="comment">// 5</span></span><br></pre></td></tr></table></figure></p>
<p>向Set加入值的时候，不会发生类型转换，所以5和“5”是两个不同的值。Set内部判断两个值是否不同，使用的算法类似于精确相等运算符（===），这意味着，两个对象总是不相等的。唯一的例外是NaN等于自身（精确相等运算符认为NaN不等于自身）。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let <span class="built_in">set</span> = <span class="keyword">new</span> Set();</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(&#123;&#125;)</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">size</span> <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">add</span>(&#123;&#125;)</span><br><span class="line"><span class="built_in">set</span>.<span class="built_in">size</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，由于两个空对象不是精确相等，所以它们被视为两个值。</p>
<h4 id="Set实例的属性和方法">Set实例的属性和方法</h4><p>Set结构的实例有以下属性。</p>
<ul>
<li>Set.prototype.constructor：构造函数，默认就是Set函数。</li>
<li>Set.prototype.size：返回Set实例的成员总数。</li>
</ul>
<p>Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。</p>
<ul>
<li>add(value)：添加某个值，返回Set结构本身。</li>
<li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li>has(value)：返回一个布尔值，表示该值是否为Set的成员。</li>
<li>clear()：清除所有成员，没有返回值。</li>
</ul>
<p>Array.from方法可以将Set结构转为数组。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var items =<span class="instruction"> new </span>Set(<span class="keyword">[</span>1, 2, 3, 4, 5]<span class="function">)</span>;</span><br><span class="line">var<span class="instruction"> array </span>=<span class="function"> Array.from(</span>items<span class="function">)</span>;</span><br></pre></td></tr></table></figure>
<p>这就提供了一种去除数组的重复元素的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dedupe</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="keyword">new</span> <span class="built_in">Set</span>(array));</span><br><span class="line">&#125;</span><br><span class="line">dedupe([<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]) <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p><strong>遍历操作</strong></p>
<p>Set结构的实例有四个遍历方法，可以用于遍历成员。</p>
<ul>
<li>keys()：返回一个键名的Iterable对象</li>
<li>values()：返回一个键值的Iterable对象</li>
<li>entries()：返回一个键值对的Iterable对象</li>
<li>forEach()：使用回调函数遍历每个成员</li>
</ul>
<p>key方法、value方法、entries方法返回的都是Iterable对象，该对象同样实现了Iterator接口。由于Set结构没有键名，只有键值（或者说键名和键值是同一个值），所以key方法和value方法的行为完全一致。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">let</span> set = <span class="keyword">new</span> Set([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"><span class="keyword">for</span> ( <span class="reserved">let</span> item <span class="keyword">of</span> set.entries() )&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item);</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//</span> [<span class="string">"red"</span>, <span class="string">"red"</span>]</span><br><span class="line"><span class="regexp">//</span> [<span class="string">"green"</span>, <span class="string">"green"</span>]</span><br><span class="line"><span class="regexp">//</span> [<span class="string">"blue"</span>, <span class="string">"blue"</span>]</span><br></pre></td></tr></table></figure>
<p>Set结构的实例默认可遍历，它的默认Symbol.iterator方法就是它的values方法。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Set</span>.prototype[<span class="type">Symbol</span>.<span class="keyword">iterator</span>] === <span class="type">Set</span>.prototype.values</span><br><span class="line">// <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>这意味着，可以省略values方法，直接用for…of循环遍历Set。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> set) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>由于扩展运算符（…）内部使用for…of循环，所以也可以用于Set结构。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">set</span> <span class="subst">=</span> <span class="literal">new</span> <span class="built_in">Set</span>(<span class="preprocessor">[</span><span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span><span class="preprocessor">]</span><span class="markup">);</span><br><span class="line">let arr = </span><span class="preprocessor">[</span><span class="attribute">...</span><span class="built_in">set</span><span class="preprocessor">]</span><span class="markup">;</span><br><span class="line">// </span><span class="preprocessor">[</span><span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span><span class="preprocessor">]</span><span class="markup"></span></span><br></pre></td></tr></table></figure>
<p>这就提供了另一种便捷的去除数组重复元素的方法。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">3</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> unique = [...<span class="keyword">new</span> Set(arr)];</span><br><span class="line"><span class="comment">// [3, 5, 2]</span></span><br></pre></td></tr></table></figure></p>
<p>而且，通过扩展运算符，数组的map和filter方法也可以用于Set了。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let <span class="literal">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="literal">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([...<span class="literal">set</span>].map(x =&gt; x * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4, 6&#125;</span></span><br><span class="line">let <span class="literal">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line"><span class="literal">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([...<span class="literal">set</span>].filter(x =&gt; (x % <span class="number">2</span>) == <span class="number">0</span>));</span><br><span class="line"><span class="comment">// 返回Set结构：&#123;2, 4&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>因此使用Set，可以很容易地实现并集（Union）和交集（Intersect）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">let</span> b = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>]);</span><br><span class="line"><span class="keyword">let</span> union = <span class="keyword">new</span> <span class="built_in">Set</span>([...a, ...b]);</span><br><span class="line"><span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="keyword">let</span> intersect = <span class="keyword">new</span> <span class="built_in">Set</span>([...a].filter(x =&gt; b.has(x)));</span><br><span class="line"><span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = <span class="keyword">new</span> Set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="keyword">set</span>.forEach((<span class="keyword">value</span>, key) =&gt; console.log(<span class="keyword">value</span> * <span class="number">2</span>) )</span><br><span class="line"><span class="comment">// 2</span></span><br><span class="line"><span class="comment">// 4</span></span><br><span class="line"><span class="comment">// 6</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，forEach方法还可以有第二个参数，表示绑定的this对象。</p>
<p>如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用Array.from方法。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">let <span class="literal">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="literal">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([...<span class="literal">set</span>].map(val =&gt; val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">let <span class="literal">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="literal">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>(Array.from(<span class="literal">set</span>, val =&gt; val * <span class="number">2</span>));</span><br><span class="line"><span class="comment">// set的值是2, 4, 6</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码提供了两种方法，直接在遍历操作中改变原来的Set结构。</p>
<h3 id="WeakSet_类型">WeakSet 类型</h3><p>WeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。</p>
<p>首先，WeakSet的成员只能是对象，而不能是其他类型的值。</p>
<p>其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ws = <span class="keyword">new</span> <span class="built_in">WeakSet</span>();</span><br><span class="line">ws.add(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used in weak set</span></span><br></pre></td></tr></table></figure>
<p>作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的对象。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = <span class="string">[[1,2], [3,4]]</span>;</span><br><span class="line">var ws = new WeakSet(a);</span><br></pre></td></tr></table></figure>
<p>上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为WeakSet构造函数的参数，a的成员会自动成为WeakSet的成员。</p>
<p>WeakSet结构有以下三个方法。</p>
<ul>
<li><strong>WeakSet.prototype.add(value)</strong>：向WeakSet实例添加一个新成员。</li>
<li><strong>WeakSet.prototype.delete(value)</strong>：清除WeakSet实例的指定成员。</li>
<li><strong>WeakSet.prototype.has(value)</strong>：返回一个布尔值，表示某个值是否在WeakSet实例之中。</li>
</ul>
<p>WeakSet没有size属性，没有办法遍历它的成员。</p>
<p>WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保存成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。</p>
<h2 id="反射类型">反射类型</h2><h3 id="Proxy">Proxy</h3><p>Proxy用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。</p>
<p>Proxy可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。（与Java中动态代理类似）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">var</span> proxy = new <span class="function"><span class="title">Proxy</span><span class="params">(target, handler)</span></span></span><br></pre></td></tr></table></figure>
<p>Proxy对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，<code>new Proxy()</code>表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> Proxy(&#123;&#125;, &#123;</span><br><span class="line">  <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">(target, property)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.time <span class="comment">// 35</span></span><br><span class="line">proxy.name <span class="comment">// 35</span></span><br><span class="line">proxy.title <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>
<p>注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。</p>
<p>一个技巧是将Proxy对象，设置到<code>object.proxy</code>属性，从而可以在object对象上调用。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var object = &#123; proxy: <span class="keyword">new</span> Proxy(<span class="keyword">target</span>, <span class="keyword">handler</span>) &#125;</span><br></pre></td></tr></table></figure>
<p>Proxy实例也可以作为其他对象的原型对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  get: <span class="function"><span class="keyword">function</span>(<span class="params">target, property</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">35</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = <span class="built_in">Object</span>.create(proxy);</span><br><span class="line">obj.time <span class="comment">// 35</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所有根据原型链，会在proxy对象上读取该属性，导致被拦截。</p>
<p>下面是Proxy支持的拦截操作一览。</p>
<p>对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。</p>
<ol>
<li><p><strong>get(target, propKey, receiver)</strong></p>
<p> 拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy[&#39;foo&#39;]</code>，返回类型不限。最后一个参数receiver可选，当target对象设置了propKey属性的get函数时，receiver对象会绑定get函数的this对象。</p>
</li>
<li><p><strong>set(target, propKey, value, receiver)</strong></p>
<p> 拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy[&#39;foo&#39;] = v</code>，返回一个布尔值。</p>
</li>
<li><p><strong>has(target, propKey)</strong></p>
<p> 拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</p>
</li>
<li><p><strong>deleteProperty(target, propKey)</strong></p>
<p> 拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</p>
</li>
<li><p><strong>enumerate(target)</strong></p>
<p> 拦截<code>for (var x in proxy)</code>，返回一个Iterable对象。</p>
</li>
<li><p><strong>hasOwn(target, propKey)</strong></p>
<p> 拦截<code>proxy.hasOwnProperty(&#39;foo&#39;)</code>，返回一个布尔值。</p>
</li>
<li><p><strong>ownKeys(target)</strong></p>
<p> 拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>，返回一个数组。该方法返回对象所有自身的属性，而<code>Object.keys()</code>仅返回对象可遍历的属性。</p>
</li>
<li><p><strong>getOwnPropertyDescriptor(target, propKey)</strong></p>
<p> 拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</p>
</li>
<li><p><strong>defineProperty(target, propKey, propDesc)</strong></p>
<p> 拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</p>
</li>
<li><p><strong>preventExtensions(target)</strong></p>
<p>拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</p>
</li>
<li><p><strong>getPrototypeOf(target)</strong></p>
<p>拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</p>
</li>
<li><p><strong>isExtensible(target)</strong></p>
<p>拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</p>
</li>
<li><p><strong>setPrototypeOf(target, proto)</strong></p>
<p>拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。</p>
</li>
</ol>
<p>如果目标对象是函数，那么还有两种额外操作可以拦截。</p>
<ol>
<li><p><strong>apply(target, object, args)</strong></p>
<p> 拦截Proxy实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</p>
</li>
<li><p><strong>construct(target, args, proxy)</strong></p>
<p> 拦截Proxy实例作为构造函数调用的操作，比如new proxy(…args)。</p>
</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//get</span></span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"张三"</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> proxy = <span class="keyword">new</span> Proxy(person, &#123;</span><br><span class="line">  <span class="keyword">get</span>: <span class="function"><span class="keyword">function</span><span class="params">(target, property)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (property <span class="keyword">in</span> target) &#123;</span><br><span class="line">      <span class="keyword">return</span> target[property];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> ReferenceError(<span class="string">"Property \""</span> + property + <span class="string">"\" does not exist."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">proxy.name <span class="comment">// "张三"</span></span><br><span class="line">proxy.age <span class="comment">// 抛出一个错误</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//apply</span></span><br><span class="line"><span class="keyword">var</span> target = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="string">'I am the target'</span>; &#125;;</span><br><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  apply: <span class="function"><span class="keyword">function</span> <span class="params">(receiver, <span class="rest_arg">...args</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'I am the proxy'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> Proxy(target, handler);</span><br><span class="line"></span><br><span class="line">p() === <span class="string">'I am the proxy'</span>; <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="Reflect">Reflect</h3><p>Reflect对象与Proxy对象一样，也是ES6为了操作对象而提供的新API。Reflect对象的设计目的有这样几个。</p>
<ol>
<li>将Object对象的一些明显属于语言层面的方法，放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。</li>
<li>修改某些Object方法的返回结果，让其变得更合理。比如，<code>Object.defineProperty(obj, name, desc)</code>在无法定义属性时，会抛出一个错误，而<code>Reflect.defineProperty(obj, name, desc)</code>则会返回false。</li>
<li>让Object操作都变成函数行为。某些Object操作是命令式，比如<code>name in obj</code>和<code>delete obj[name]</code>，而<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code>让它们变成了函数行为。</li>
<li>Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。</li>
</ol>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Proxy(target, &#123;</span><br><span class="line">  <span class="keyword">set</span>: function(target, <span class="property">name</span>, value, receiver) &#123;</span><br><span class="line">    var success = Reflect.<span class="keyword">set</span>(target,<span class="property">name</span>, value, receiver);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="command">log</span>('<span class="keyword">property</span> '+<span class="property">name</span>+' <span class="function_start"><span class="keyword">on</span></span> '+target+' <span class="keyword">set</span> <span class="keyword">to</span> '+value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="command">    return</span> success;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Reflect对象的方法清单如下。</p>
<ul>
<li>Reflect.getOwnPropertyDescriptor(target,name)</li>
<li>Reflect.defineProperty(target,name,desc)</li>
<li>Reflect.getOwnPropertyNames(target)</li>
<li>Reflect.getPrototypeOf(target) 读取对象的<code>__proto__</code>属性，等同于<code>Object.getPrototypeOf(obj)</code>。</li>
<li>Reflect.setPrototypeOf(obj, newProto) 设置对象的<code>__proto__</code>属性，注意，Object对象没有对应这个方法的方法。</li>
<li>Reflect.deleteProperty(target,name) 等同于<code>delete obj[name]</code>。</li>
<li>Reflect.enumerate(target)</li>
<li>Reflect.freeze(target)</li>
<li>Reflect.seal(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.isFrozen(target)</li>
<li>Reflect.isSealed(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.has(target,name) 等同于<code>name in obj</code>。</li>
<li>Reflect.hasOwn(target,name)</li>
<li>Reflect.keys(target)</li>
<li>Reflect.get(target,name,receiver) 查找并返回target对象的name属性，如果没有该属性，则返回undefined。如果name属性部署了读取函数，则读取函数的this绑定receiver。</li>
<li>Reflect.set(target,name,value,receiver) 设置target对象的name属性等于value。如果name属性设置了赋值函数，则赋值函数的this绑定receiver。</li>
<li>Reflect.apply(target,thisArg,args) 等同于<code>Function.prototype.apply.call(fun,thisArg,args)</code>。一般来说，如果要绑定一个函数的this对象，可以这样写<code>fn.apply(obj, args)</code>，但是如果函数定义了自己的apply方法，就只能写成<code>Function.prototype.apply.call(fn, obj, args)</code>，采用Reflect对象可以简化这种操作。</li>
<li>Reflect.construct(target,args) 等同于<code>new target(...args)</code>，这提供了一种不使用new，来调用构造函数的方法。</li>
</ul>
<p>注意，Reflect.set()、Reflect.defineProperty()、Reflect.freeze()、Reflect.seal()和Reflect.preventExtensions()返回一个布尔值，表示操作是否成功。它们对应的Object方法，失败时都会抛出错误。</p>
<h2 id="控制抽象类型">控制抽象类型</h2><h3 id="Iteration_接口">Iteration 接口</h3><p>ECMAScript 中一个接口是一组键值对属性，这些属性的键所对应的值符合特定的规范。如果一个对象提供了一个接口描述的所有属性，那么这个对象就实现了这个接口。一个接口并不是被单独的一个对象表示。可能有很多单独的对象实现符合某个接口，一个单独的对象可能实现多个接口。</p>
<p>通过统一的接口机制，可以使用for-of来遍历不同的数据结构。</p>
<h4 id="Iterable_接口">Iterable 接口</h4><p>这个接口只有一个属性，即Symbol.iterator，它是一个函数，这个函数返回一个实现了Iterator接口的对象。</p>
<p>在ES6中，有些数据结构原生实现了这个接口（比如数组），不用任何处理，就可以被for…of循环遍历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有。凡是部署了Symbol.iterator属性的数据结构，就称为实现了Iterable接口。调用这个接口，就会返回一个Iterator对象。</p>
<h4 id="Iterator_接口">Iterator 接口</h4><p>这个接口有一个属性，next，这个属性是一个函数，它返回一个实现了IteratorResult接口的对象。如果上一步调用next返回的对象的done属性已经是true了，那么之后调用next函数也要返回一个done属性为true的IteratorResult对象。这个要求并不是强制的。</p>
<p>该接口还有两个可选的属性return 和 throw。这两个属性都是方法，并且方法返回值都是IteratorResult对象。</p>
<p>done为true，即遍历结束时，如果存在return方法，value的值会被设置为return方法。这并不是强制要求的。</p>
<h4 id="IteratorResult_接口">IteratorResult 接口</h4><p>包含value和done两个属性的对象。其中，value属性是当前成员的值，如果iterator提供了return方法的花，done为true时，这个value应该是iterator的return属性的值即return函数，否则done为true时value就是undefined，这种情况下可以没有value属性；done属性是一个布尔值，表示遍历是否结束，如果不存在done，就认为done属性为false。</p>
<h4 id="实例">实例</h4><p>如果使用TypeScript的写法，可以描述如下。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="type">Iterable</span> &#123;</span><br><span class="line">  [<span class="type">Symbol</span>.<span class="keyword">iterator</span>]() : <span class="type">Iterator</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="type">Iterator</span> &#123;</span><br><span class="line">  next(value?: <span class="type">any</span>) : <span class="type">IterationResult</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="type">IterationResult</span> &#123;</span><br><span class="line">  value: <span class="type">any</span>,</span><br><span class="line">  done: boolean,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面看一个例子<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">function <span class="type">Obj</span>(value)&#123;</span><br><span class="line">  this.value = value;</span><br><span class="line">  this.next = null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">Obj</span>.prototype[<span class="type">Symbol</span>.<span class="keyword">iterator</span>] = function()&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">iterator</span> = &#123;</span><br><span class="line">    next: next,</span><br><span class="line">    <span class="keyword">return</span>: returnFn</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> current = this;</span><br><span class="line"></span><br><span class="line">  function next()&#123;</span><br><span class="line">    <span class="keyword">if</span> (current)&#123;</span><br><span class="line">      <span class="keyword">var</span> value = current.value;</span><br><span class="line">      <span class="keyword">var</span> done = current === null;</span><br><span class="line">      current = current.next;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: done,</span><br><span class="line">        value: value</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        value: <span class="keyword">iterator</span>.<span class="keyword">return</span>,</span><br><span class="line">        done: <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  function returnFn()&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      done: <span class="literal">true</span>,</span><br><span class="line">      value: '<span class="keyword">return</span>'</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">iterator</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> one = new <span class="type">Obj</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">var</span> two = new <span class="type">Obj</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">var</span> three = new <span class="type">Obj</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">one.next = two;</span><br><span class="line">two.next = three;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = one[<span class="type">Symbol</span>.<span class="keyword">iterator</span>]();</span><br><span class="line">it.next();</span><br><span class="line">it.next();</span><br><span class="line">it.next();</span><br><span class="line">it.next().value();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> a <span class="keyword">of</span> one)&#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码首先在构造函数的原型链上部署Symbol.iterator方法，调用该方法会返回遍Iterator对象，调用该对象的next方法，在返回一个值的同时，自动将内部指针移到下一个实例。</p>
<h4 id="默认实现Iterable接口的数据结构">默认实现Iterable接口的数据结构</h4><p>Iterable接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for…of循环（详见下文）。当使用for…of循环遍历某种数据结构时，该循环会自动去寻找Iterable接口。</p>
<p>ES6规定，默认的Iterator接口部署在数据结构的<code>Symbol.iterator</code>属性，或者一个数据结构只要具有<code>Symbol.iterator</code>属性，就可以认为是“可遍历的”（iterable）。也就是说，调用<code>Symbol.iterator</code>方法，就会得到当前数据结构的默认Iterator对象。<code>Symbol.iterator</code>本身是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放在方括号内。</p>
<p>在ES6中，有三类数据结构原生具备Iterable接口：数组、某些类似数组的对象、Set和Map结构。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="built_in">let</span> iter = arr[Symbol.iterator]();</span><br><span class="line"></span><br><span class="line">iter.next() // &#123; value: <span class="string">'a'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: <span class="string">'b'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: <span class="string">'c'</span>, <span class="keyword">done</span>: <span class="literal">false</span> &#125;</span><br><span class="line">iter.next() // &#123; value: undefined, <span class="keyword">done</span>: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量arr是一个数组，原生就具有Iterable接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到Iterator对象。</p>
<p>上面提到，原生就部署Iterable接口的数据结构有三类，对于这三类数据结构，for…of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的Iterable接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for…of循环遍历。</p>
<p>对象（Object）之所以没有默认部署Iterable接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历是一种线性处理，对于任何非线性的数据结构，部署Iterable接口，就等于部署一种线性转换。不过，严格地说，对象部署Iterable接口并不是很必要，因为这时对象实际上被当作Map结构使用，ES5没有Map结构，而ES6原生提供了。</p>
<p>一个对象如果要有可被for…of循环调用的Iterable接口，就必须有Symbol.iterator方法（原型链上的对象具有该方法也可）。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> RangeIterator &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>(start, stop) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.value = start;</span><br><span class="line">    <span class="keyword">this</span>.stop = stop;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  [Symbol.iterator]() &#123; <span class="keyword">return</span> <span class="keyword">this</span>; &#125;</span><br><span class="line"></span><br><span class="line">  next() &#123;</span><br><span class="line">    <span class="keyword">var</span> value = <span class="keyword">this</span>.value;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>.stop) &#123;</span><br><span class="line">      <span class="keyword">this</span>.value++;</span><br><span class="line">      <span class="keyword">return</span> &#123;done: <span class="literal">false</span>, value: value&#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;done: <span class="literal">true</span>, value: <span class="literal">undefined</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">range</span>(<span class="params">start, stop</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RangeIterator(start, stop);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> value of range(<span class="number">0</span>, <span class="number">3</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是另一个为对象添加Iterator接口的例子。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  data: [ <span class="string">'hello'</span>, <span class="string">'world'</span> ],</span><br><span class="line">  [Symbol.iterator]() &#123;</span><br><span class="line">    <span class="keyword">const</span> self = <span class="keyword">this</span>;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      next() &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; self.data.length) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123;</span><br><span class="line">            <span class="keyword">value</span>: self.data[index++],</span><br><span class="line">            done: <span class="keyword">false</span></span><br><span class="line">          &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="keyword">value</span>: undefined, done: <span class="keyword">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>对于类似数组的对象（存在数值键名和length属性），部署Iterable接口，有一个简便方法，就是<code>Symbol.iterator</code>方法直接引用数组的Iterable接口。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">NodeList</span>.prototype[<span class="type">Symbol</span>.<span class="keyword">iterator</span>] = <span class="type">Array</span>.prototype[<span class="type">Symbol</span>.<span class="keyword">iterator</span>];</span><br><span class="line">// 或者</span><br><span class="line"><span class="type">NodeList</span>.prototype[<span class="type">Symbol</span>.<span class="keyword">iterator</span>] = [][<span class="type">Symbol</span>.<span class="keyword">iterator</span>];</span><br><span class="line">[...document.querySelectorAll('<span class="keyword">div</span>')] // 可以执行了</span><br></pre></td></tr></table></figure>
<p>如果Symbol.iterator方法返回的不是Iterator对象，解释引擎将会报错。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="type">Symbol</span>.<span class="keyword">iterator</span>] = () =&gt; <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">[...obj] // <span class="type">TypeError</span>: [] <span class="keyword">is</span> <span class="keyword">not</span> a function</span><br></pre></td></tr></table></figure>
<p>有了Iterable接口，数据结构就可以用for…of循环遍历，也可以使用while循环遍历。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $<span class="keyword">iterator</span> = <span class="type">ITERABLE</span>[<span class="type">Symbol</span>.<span class="keyword">iterator</span>]();</span><br><span class="line"><span class="keyword">var</span> $<span class="literal">result</span> = $<span class="keyword">iterator</span>.next();</span><br><span class="line"><span class="keyword">while</span> (!$<span class="literal">result</span>.done) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = $<span class="literal">result</span>.value;</span><br><span class="line">  // ...</span><br><span class="line">  $<span class="literal">result</span> = $<span class="keyword">iterator</span>.next();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，ITERABLE代表某种可遍历的数据结构</p>
<h4 id="Iterable接口默认的应用场合">Iterable接口默认的应用场合</h4><p>有一些场合会默认使用Iterable接口（即调用Symbol.iterator方法），除了for…of循环，还有几个别的场合。</p>
<p><strong>解构赋值</strong></p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="keyword">set</span> = <span class="keyword">new</span> Set().<span class="built_in">add</span>(<span class="string">'a'</span>).<span class="built_in">add</span>(<span class="string">'b'</span>).<span class="built_in">add</span>(<span class="string">'c'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [<span class="keyword">x</span>,<span class="keyword">y</span>] = <span class="keyword">set</span>;</span><br><span class="line">// <span class="keyword">x</span>=<span class="string">'a'</span>; <span class="keyword">y</span>=<span class="string">'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [<span class="keyword">first</span>, ...rest] = <span class="keyword">set</span>; // <span class="keyword">first</span>=<span class="string">'a'</span>; rest=[<span class="string">'b'</span>,<span class="string">'c'</span>];</span><br></pre></td></tr></table></figure>
<p><strong>扩展运算符</strong></p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 例一</span><br><span class="line"><span class="atom">var</span> <span class="atom">str</span> = <span class="string">'hello'</span>;</span><br><span class="line">[...<span class="atom">str</span>] //  [<span class="string">'h'</span>,<span class="string">'e'</span>,<span class="string">'l'</span>,<span class="string">'l'</span>,<span class="string">'o'</span>]</span><br><span class="line"></span><br><span class="line">// 例二</span><br><span class="line"><span class="atom">let</span> <span class="atom">arr</span> = [<span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">[<span class="string">'a'</span>, ...<span class="atom">arr</span>, <span class="string">'d'</span>]</span><br><span class="line">// [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>]</span><br></pre></td></tr></table></figure>
<p>实际上，这提供了一种简便机制，可以将任何实现了Iterable接口的数据结构，转为数组。也就是说，只要某个数据结构实现了Iterable接口，就可以对它使用扩展运算符，将其转为数组。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr <span class="subst">=</span> <span class="preprocessor">[</span><span class="attribute">...</span>iterable<span class="preprocessor">]</span><span class="markup">;</span></span><br></pre></td></tr></table></figure>
<p><strong><code>yield*</code></strong></p>
<p><code>yield*</code>后面跟的是一个实现了Iterable的对象，它会调用该对象的Symbol.iterator方法。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> generator = function* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span>* [<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]; //use an iterable, <span class="keyword">is</span> looped, <span class="keyword">and</span> added <span class="keyword">as</span> yields</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">iterator</span> = generator();</span><br><span class="line"></span><br><span class="line"><span class="keyword">iterator</span>.next() // &#123; value: <span class="number">1</span>, done: <span class="literal">false</span> &#125;</span><br><span class="line"><span class="keyword">iterator</span>.next() // &#123; value: <span class="number">2</span>, done: <span class="literal">false</span> &#125;</span><br><span class="line"><span class="keyword">iterator</span>.next() // &#123; value: <span class="number">3</span>, done: <span class="literal">false</span> &#125;</span><br><span class="line"><span class="keyword">iterator</span>.next() // &#123; value: <span class="number">4</span>, done: <span class="literal">false</span> &#125;</span><br><span class="line"><span class="keyword">iterator</span>.next() // &#123; value: <span class="number">5</span>, done: <span class="literal">false</span> &#125;</span><br><span class="line"><span class="keyword">iterator</span>.next() // &#123; value: undefined, done: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>
<p><strong>其他场合</strong></p>
<p>由于数组的遍历会调用Symbol.iterator方法，所以任何接受数组作为参数的场合，其实都调用了Symbol.iterator。下面是一些例子。</p>
<ul>
<li>Array.from()</li>
<li>Map(), Set(), WeakMap(), WeakSet()（比如<code>new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])</code>）</li>
<li>Promise.all()</li>
<li>Promise.race()</li>
</ul>
<h4 id="原生具备Iterable接口的数据结构">原生具备Iterable接口的数据结构</h4><p>ES6对数组提供entries()、keys()和values()三个方法，就是返回三个Iterable对象。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">5</span>, <span class="number">7</span>];</span><br><span class="line"><span class="keyword">var</span> arrEntries = arr.entries();</span><br><span class="line"></span><br><span class="line">arrEntries.toString() // <span class="string">"[object Array Iterator]"</span></span><br><span class="line"></span><br><span class="line">arrEntries === arrEntries[<span class="type">Symbol</span>.<span class="keyword">iterator</span>]() // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，entries方法返回的是一个Iterator对象，本质上就是调用了<code>Symbol.iterator</code>方法。</p>
<p>字符串是一个类似数组的对象，也原生具有Iterable接口。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someString = <span class="string">"hi"</span>;</span><br><span class="line">typeof someString[<span class="type">Symbol</span>.<span class="keyword">iterator</span>]</span><br><span class="line">// <span class="string">"function"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">iterator</span> = someString[<span class="type">Symbol</span>.<span class="keyword">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="keyword">iterator</span>.next()  // &#123; value: <span class="string">"h"</span>, done: <span class="literal">false</span> &#125;</span><br><span class="line"><span class="keyword">iterator</span>.next()  // &#123; value: <span class="string">"i"</span>, done: <span class="literal">false</span> &#125;</span><br><span class="line"><span class="keyword">iterator</span>.next()  // &#123; value: undefined, done: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>
<p>可以覆盖原生的<code>Symbol.iterator</code>方法，达到修改Iterator对象行为的目的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">"hi"</span>);</span><br><span class="line"></span><br><span class="line">[...str] <span class="comment">// ["h", "i"]</span></span><br><span class="line"></span><br><span class="line">str[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>._first) &#123;</span><br><span class="line">        <span class="keyword">this</span>._first = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> &#123; value: <span class="string">"bye"</span>, done: <span class="literal">false</span> &#125;;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123; done: <span class="literal">true</span> &#125;;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    _first: <span class="literal">true</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...str] <span class="comment">// ["bye"]</span></span><br><span class="line">str <span class="comment">// "hi"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串str的<code>Symbol.iterator</code>方法被修改了，所以扩展运算符（…）返回的值变成了bye，而字符串本身还是hi。</p>
<h4 id="Iterable接口与Generator函数">Iterable接口与Generator函数</h4><p><code>Symbol.iterator</code>方法的最简单实现，还是使用后面要介绍的Generator函数。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> myIterable = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">myIterable[<span class="type">Symbol</span>.<span class="keyword">iterator</span>] = function* () &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line">[...myIterable] // [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line">// 或者采用下面的简洁写法</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  * [<span class="type">Symbol</span>.<span class="keyword">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">yield</span> 'hello';</span><br><span class="line">    <span class="keyword">yield</span> 'world';</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> obj) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line">// hello</span><br><span class="line">// world</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Symbol.iterator</code>方法几乎不用部署任何代码，只要用yield命令给出每一步的返回值即可。</p>
<h3 id="Promise_类型">Promise 类型</h3><h4 id="Promise的含义">Promise的含义</h4><p>Promise在JavaScript语言早有实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。</p>
<p>所谓Promise，就是一个对象，用来传递异步操作的消息。它代表了某个未来才会知道结果的事件（通常是一个异步操作），并且这个事件提供统一的API，可供进一步处理。</p>
<p>Promise对象有以下两个特点。</p>
<ol>
<li>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。</li>
</ol>
<p>有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。</p>
<p>Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</p>
<p>如果某些事件不断地反复发生，一般来说，使用stream模式是比部署Promise更好的选择。</p>
<h4 id="基本用法-2">基本用法</h4><p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p>
<p>下面代码创造了一个Promise实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... some code</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。</p>
<p>resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="transposed_variable">promise.</span><span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(value)</span> &#123;</span></span><br><span class="line">  <span class="comment">// success</span></span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span><span class="params">(value)</span> &#123;</span></span><br><span class="line">  <span class="comment">// failure</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。</p>
<p>下面是一个Promise对象的简单例子。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">function</span> timeout(ms) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Promise(<span class="function"><span class="params">(resolve)</span> =&gt;</span> &#123;</span><br><span class="line">    setTimeout(resolve, ms, <span class="string">'done'</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="reserved">var</span> to = timeout(<span class="number">8000</span>);</span><br><span class="line">to.<span class="keyword">then</span>(<span class="function"><span class="params">(value)</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="regexp">//</span>没有输出done前命令行查看to，输出后再查看，两次状态不同</span><br></pre></td></tr></table></figure>
<p>上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。</p>
<p>下面是一个用Promise对象实现的Ajax操作的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getJSON = <span class="function"><span class="keyword">function</span>(<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> client = <span class="keyword">new</span> XMLHttpRequest();</span><br><span class="line">    client.open(<span class="string">"GET"</span>, url);</span><br><span class="line">    client.onreadystatechange = handler;</span><br><span class="line">    client.responseType = <span class="string">"json"</span>;</span><br><span class="line">    client.setRequestHeader(<span class="string">"Accept"</span>, <span class="string">"application/json"</span>);</span><br><span class="line">    client.send();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">handler</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">this</span>.status === <span class="number">200</span>) &#123;</span><br><span class="line">        resolve(<span class="keyword">this</span>.response);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="keyword">this</span>.statusText));</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> promise;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">getJSON(<span class="string">"/posts.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">json</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'Contents: '</span> + json);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.error(<span class="string">'出错了'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，getJSON是对XMLHttpRequest对象的封装，用于发出一个针对JSON数据的HTTP请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。</p>
<p>如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作，比如像下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//可以在这里加resolve或reject方法，观察p1和p2的状态</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  resolve(p1);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>上面代码中，p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。</p>
<p>注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行。</p>
<h4 id="Promise-prototype-then()">Promise.prototype.then()</h4><p>then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。</p>
<p>then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(json)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> <span class="transposed_variable">json.</span>post;</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(post)</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的代码使用then方法，依次指定了两个回调函数。第一个then方法的回调函数完成以后，会将返回结果作为参数，传入第二个then方法的回调函数。</p>
<p>采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(post.commentURL);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span> <span class="title">funcA</span>(<span class="params">comments</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Resolved: "</span>, comments);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="title">funcB</span>(<span class="params">err</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">"Rejected: "</span>, err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。</p>
<h4 id="Promise-prototype-catch()">Promise.prototype.catch()</h4><p>Promise.prototype.catch方法是<code>.then(null, rejection)</code>的别名，用于指定发生错误时的回调函数。</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/posts.json"</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(posts)</span> &#123;</span></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> &#123;</span></span><br><span class="line">  <span class="comment">// 处理前一个回调函数运行时发生的错误</span></span><br><span class="line">  <span class="transposed_variable">console.</span>log(<span class="string">'发生错误！'</span>, error);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。</p>
<p>下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// Error: test</span></span><br></pre></td></tr></table></figure>
<p>如果Promise状态已经变成resolved，再抛出错误是无效的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">"ok"</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">promise</span><br><span class="line">  .then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123; <span class="built_in">console</span>.log(error) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br></pre></td></tr></table></figure></p>
<p>Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">getJSON(<span class="string">"/post/1.json"</span>).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(post)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> getJSON(<span class="transposed_variable">post.</span>commentURL);</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">(comments)</span> &#123;</span></span><br><span class="line">  <span class="comment">// some code</span></span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> &#123;</span></span><br><span class="line">  <span class="comment">// 处理前面三个Promise产生的错误</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。</p>
<p>跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'everything is great'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，someAsyncThing函数产生的Promise对象会报错，但是由于没有调用catch方法，这个错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  resolve(<span class="string">"ok"</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'test'</span>) &#125;, <span class="number">0</span>)</span><br><span class="line">&#125;);</span><br><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123; <span class="built_in">console</span>.log(value) &#125;);</span><br><span class="line"><span class="comment">// ok</span></span><br><span class="line"><span class="comment">// Uncaught Error: test</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Promise指定在下一轮“事件循环”再抛出错误，结果由于没有指定try-catch语句，就冒泡到最外层，成了未捕获的错误。</p>
<p>Node.js有一个unhandledRejection事件，专门监听未捕获的reject错误。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">process.<span class="keyword">on</span>(<span class="string">'unhandledRejection'</span>, <span class="function"><span class="keyword">function</span> <span class="params">(err, p)</span> <span class="comment">&#123;</span><br><span class="line">  console.error(err.stack)</span><br><span class="line">&#125;</span>);</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的Promise实例，它可以用来了解发生错误的环境信息。。</p>
<p>需要注意的是，catch方法返回的还是一个Promise对象，因此后面还可以接着调用then方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on</span></span><br></pre></td></tr></table></figure>
<p>catch方法之中，还能再抛出错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> someAsyncThing = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 下面一行会报错，因为x没有声明</span></span><br><span class="line">    resolve(x + <span class="number">2</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">someAsyncThing().then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为y没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'carry on'</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">someAsyncThing().<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span><span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> someOtherAsyncThing();</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> &#123;</span></span><br><span class="line">  <span class="transposed_variable">console.</span>log(<span class="string">'oh no'</span>, error);</span><br><span class="line">  <span class="comment">// 下面一行会报错，因为y没有声明</span></span><br><span class="line">  y + <span class="number">2</span>;</span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(error)</span> &#123;</span></span><br><span class="line">  <span class="transposed_variable">console.</span>log(<span class="string">'carry on'</span>, error);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// oh no [ReferenceError: x is not defined]</span></span><br><span class="line"><span class="comment">// carry on [ReferenceError: y is not defined]</span></span><br></pre></td></tr></table></figure>
<h4 id="Promise-all()">Promise.all()</h4><p>Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">var</span> p = Promise.all([<span class="literal">p1</span>,<span class="literal">p2</span>,<span class="literal">p3</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例。（Promise.all方法的参数不一定是数组，但是必须具有Iterable接口，且返回的每个成员都是Promise实例。）</p>
<p>p的状态由p1、p2、p3决定，分成两种情况。</p>
<ol>
<li>只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。</li>
<li>只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 生成一个Promise对象的数组</span></span><br><span class="line"><span class="keyword">var</span> promises = [<span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">13</span>].map(<span class="function"><span class="keyword">function</span><span class="params">(id)</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getJSON(<span class="string">"/post/"</span> + id + <span class="string">".json"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">Promise.all(promises).then(<span class="function"><span class="keyword">function</span><span class="params">(posts)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;).<span class="keyword">catch</span>(<span class="function"><span class="keyword">function</span><span class="params">(reason)</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="Promise-race()">Promise.race()</h4><p>Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="label">var</span> p = Promise.race([<span class="literal">p1</span>,<span class="literal">p2</span>,<span class="literal">p3</span>])<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的Promise实例的返回值，就传递给p的回调函数。</p>
<p>如果Promise.all方法和Promise.race方法的参数，不是Promise实例，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。</p>
<h4 id="Promise-resolve()">Promise.resolve()</h4><p>有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jsPromise = <span class="built_in">Promise</span>.resolve($.ajax(<span class="string">'/whatever.json'</span>));</span><br></pre></td></tr></table></figure>
<p>上面代码将jQuery生成deferred对象，转为一个新的Promise对象。</p>
<p>如果Promise.resolve方法的参数，不是具有then方法的对象（又称thenable对象），则返回一个新的Promise对象，且它的状态为Resolved。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve(<span class="string">'Hello'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
<p>上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。</p>
<p>Promise.resolve方法允许调用时不带参数。所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve();</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>如果Promise.resolve方法的参数是一个Promise实例，则会被原封不动地返回。</p>
<h4 id="Promise-reject()">Promise.reject()</h4><p>Promise.reject(reason)方法也会返回一个新的Promise实例，该实例的状态为rejected。Promise.reject方法的参数reason，会被传递给实例的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'出错了'</span>);</span><br><span class="line"></span><br><span class="line">p.then(<span class="literal">null</span>, <span class="function"><span class="keyword">function</span> (<span class="params">s</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 出错了</span></span><br></pre></td></tr></table></figure>
<p>上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。</p>
<h4 id="Generator函数与Promise的结合">Generator函数与Promise的结合</h4><p>使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function getFoo() &#123;</span><br><span class="line">  <span class="keyword">return</span> new <span class="type">Promise</span>(function (resolve, reject)&#123;</span><br><span class="line">    resolve('foo');</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = function*() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> foo = <span class="keyword">yield</span> getFoo();</span><br><span class="line">    console.log(foo);</span><br><span class="line">  &#125; catch (e) &#123;</span><br><span class="line">    console.log(e);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function run(generator) &#123;</span><br><span class="line">  <span class="keyword">var</span> it = generator();</span><br><span class="line"></span><br><span class="line">  function go(<span class="literal">result</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="literal">result</span>.done) <span class="keyword">return</span> <span class="literal">result</span>.value;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">result</span>.value.then(function (value) &#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.next(value));</span><br><span class="line">    &#125;, function (error) &#123;</span><br><span class="line">      <span class="keyword">return</span> go(it.throw(value));</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  go(it.next());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">run(g);</span><br></pre></td></tr></table></figure>
<h4 id="async函数">async函数</h4><p>async函数与Promise、Generator函数一样，是用来取代回调函数、解决异步操作的一种方法。它本质上是Generator函数的语法糖。async函数并不属于ES6，而是被列入了ES7，但是traceur、Babel.js、regenerator等转码器已经支持这个功能，转码后立刻就能使用。</p>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript 引用类型，Object，Array，Date，RegExp，Function，Number，Boolean，String，Global，Math，Map，Set，WeakMap，WeakSet，Proxy，Reflect，Promise，Iterator]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://howiefh.github.io/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://howiefh.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JavaScript 基本语法]]></title>
    <link href="http://howiefh.github.io/2015/08/28/javascript-grammar/"/>
    <id>http://howiefh.github.io/2015/08/28/javascript-grammar/</id>
    <published>2015-08-28T04:14:28.000Z</published>
    <updated>2015-08-30T11:50:14.000Z</updated>
    <content type="html"><![CDATA[<p><a href="2015/08/28/javascript-grammar/">JavaScript 基本语法</a>，<a href="2015/08/28/javascript-reference-type/">JavaScript 引用类型</a>，<a href="2015/08/28/javascript-oop-function-expression-and-async/">JavaScript 面向对象程序设计、函数表达式和异步编程</a>三篇笔记是对《JavaScript 高级程序设计》和 <a href="https://github.com/ruanyf/es6tutorial/tree/5a5f9d8d492d0f925cbb6e09b10ebed9d2078d40" target="_blank" rel="external">《ECMAScript 6入门》</a>两本书的总结整理。</p>
<h1 id="简介">简介</h1><p>一个完整的JavaScript实现应该由三个不同的部分组成：核心（ECMAScript）、文档对象模型（DOM）、浏览器对象模型（BOM）</p>
<p>JavaScript实现了ECMAScript，Adobe ActionScript同样也实现了ECMAScript。</p>
<a id="more"></a>
<h1 id="HTML中使用JavaScript">HTML中使用JavaScript</h1><h2 id="script元素">script元素</h2><p>使用<code>&lt;script&gt;</code>元素的方式有两种：直接在页面中嵌入 JavaScript 代码和包含外部 JavaScript文件。 在使用<code>&lt;script&gt;</code>元素嵌入 JavaScript代码时，只须为<code>&lt;script&gt;</code>指定 type 属性。</p>
<p>包含在<code>&lt;script&gt;</code>元素内部的JavaScript代码将被从上至下依次解释。就拿前面这个例子来说，解释器会解释一个函数的定义，然后将该定义保存在自己的环境当中。在解释器对<code>&lt;script&gt;</code>元素内部的所有代码求值完毕以前，页面中的其余内容都不会被浏览器加载或显示。 在使用<code>&lt;script&gt;</code>嵌入JavaScript代码时，记住不要在代码中的任何地方出现<code>&lt;/script&gt;</code>字符串。例如，浏览器在加载下面所示的代码时就会产生一个错误： <code>&lt;script type=&quot;text/javascript&quot;&gt; function sayScript(){ alert(&quot;&lt;/script&gt;&quot;); } &lt;/script&gt;</code> 因为按照解析嵌入式代码的规则，当浏览器遇到字符串<code>&lt;/script&gt;</code>时，就会认为那是结束的<code>&lt;/script&gt;</code></p>
<p>如果是在 XHTML文档中，也可以省略前面示例代码中结束的<code>&lt;/script&gt;</code>标签，例如： <code>&lt;script type=&quot;text/javascript&quot; src=&quot;example.js&quot; /&gt;</code> 但是，不能在 HTML文档使用这种语法。原因是这种语法不符合 HTML规范</p>
<p>为了避免延迟浏览器出现空白，现代Web应用程序一般都把全部JavaScript引用放在<code>&lt;body&gt;</code>元素中页面内容的后面，</p>
<p>按照惯例，外部 JavaScript文件带有.js扩展名。但这个扩展名不是必需的，因为浏览器不会检查包含 JavaScript的文件的扩展名。这样一来，使用 JSP、PHP或其他服务器端语言动态生成 JavaScript代码也就成为了可能。但是，服务器通常还是需要看扩展名决定为响应应用哪种 MIME 类型。如果不使用.js 扩展名，请确保服务器能返回正确的MIME类型。 需要注意的是，带有 src 属性的<code>&lt;script&gt;</code>元素不应该在其<code>&lt;script&gt;</code>和<code>&lt;/script&gt;</code>标签之间再包含额外的 JavaScript代码。如果包含了嵌入的代码，则只会下载并执行外部脚本文件，嵌入的代码会被忽略。</p>
<p>无论如何包含代码，只要不存在 defer 和 async 属性，浏览器都会按照<code>&lt;script&gt;</code>元素在页面中出现的先后顺序对它们依次进行解析</p>
<p>HTML 4.01为<code>&lt;script&gt;</code>标签定义了defer属性。这个属性的用途是表明脚本在执行时不会影响页面的构造。也就是说，脚本会被延迟到整个页面都解析完毕后再运行。因此，在<code>&lt;script&gt;</code>元素中设置defer</p>
<p>在现实当中，延迟脚本并不一定会按照顺序执行，也不一定会在 DOMContentLoaded 事件触发前执行，因此最好只包含一个延迟脚本。 前面提到过，defer 属性只适用于外部脚本文件。这一点在 HTML5 中已经明确规定，因此支持HTML5的实现会忽略给嵌入脚本设置的 defer 属性</p>
<p>指定async属性的目的是不让页面等待两个脚本下载和执行，从而异步加载页面其他内容。为此，建议异步脚本不要在加载期间修改DOM。 异步脚本一定会在页面的 load 事件前执行，但可能会在 DOMContentLoaded 事件触发之前或之后执行。</p>
<p>同样与defer类似，async只适用于外部脚本文件，并告诉浏览器立即下载文件。但与defer不同的是，标记为async的脚本并不保证按照指定它们的先后顺序执行。</p>
<p>保证让相同代码在 XHTML中正常运行的第二个方法，就是用一个 CData片段来包含 JavaScript代码。在XHTML（XML）中，CData片段是文档中的一个特殊区域，这个区域中可以包含不需要解析的任意格式的文本内容。</p>
<p>但由于所有浏览器都已经支持 JavaScript，因此也就没有必要再使用下面这种格式了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//<span class="comment">&lt;!--</span><br><span class="line">代码</span><br><span class="line">//--&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="嵌入代码和外部文件">嵌入代码和外部文件</h2><p>一般认为最好的做法还是尽可能使用外部文件来包含 JavaScript代码。可维护性，可缓存，适应未来</p>
<h2 id="文档模式">文档模式</h2><p>文档模式是：混杂模式（quirks mode）和标准模式（standards mode）。混杂模式会让IE的行为与（包含非标准特性的）IE5相同，而标准模式则让IE的行为更接近标准行为。虽然这两种模式主要影响CSS内容的呈现，但在某些情况下也会影响到 JavaScript的解释执行。</p>
<p>对于准标准模式，则可以通过使用过渡型（transitional）或框架集型（frameset）文档类型来触发，</p>
<p>如果在文档开始处没有发现文档类型声明，则所有浏览器都会默认开启混杂模式。但采用混杂模式不是什么值得推荐的做法，因为不同浏览器在这种模式下的行为差异非常大，如果不使用某些 hack 技术，跨浏览器的行为根本就没有一致性可言。</p>
<h2 id="noscript">noscript</h2><p>包含在<code>&lt;noscript&gt;</code>元素中的内容只有在这些情况下才会显示出来：浏览器不支持脚本；浏览器支持脚本，但脚本被禁用。</p>
<h2 id="ECMAScript_6">ECMAScript 6</h2><p>在 Chrome 地址栏中输入 chrome://flags/#enable-javascript-harmony，启用实验性 JavaScript</p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/New_in_JavaScript/ECMAScript_6_support_in_Mozilla" target="_blank" rel="external">Firefox 支持的 ECMAScript 6 特性</a></p>
<p>各个平台对ECMAScript 6的支持情况可以查看 <a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="external">https://kangax.github.io/compat-table/es6/</a></p>
<p>鉴于现在浏览器并没有完全支持ECMASctipt6，所以可以用ES6的方式编写代码，之后用<a href="https://babeljs.io/" target="_blank" rel="external">Babel</a>或谷歌的<a href="https://github.com/google/traceur-compiler" target="_blank" rel="external">Traceur</a>进行转码</p>
<p>另外node中使用可以加参数<code>--harmony</code></p>
<h1 id="基本概念">基本概念</h1><h2 id="语法">语法</h2><p>ECMAScript中的一切（变量、函数名和操作符）都区分大小写</p>
<p>标识符可以是按照下列格式规则组合起来的一或多个字符：第一个字符必须是一个字母、下划线（<code>_</code>）或一个美元符号（<code>$</code>）；其他字符可以是字母、下划线、美元符号或数字。 标识符中的字母也可以包含扩展的ASCII或Unicode字母字符（如À和Æ），但我们不推荐这样做。 按照惯例，ECMAScript标识符采用驼峰大小写格式，也就是第一个字母小写，剩下的每个单词的首字母大写</p>
<p>C风格的注释，包括单行注释和块级注释</p>
<p>ECMAScript中的语句以一个分号结尾；如果省略分号，则由解析器确定语句的结尾。最好不省略分号，省略分号，解释器会猜测在什么位置加分号，这样可能会照成与预期不同的结果。如<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> <span class="comment">//浏览器在这里加入分号，然后1+2就不会被返回了</span></span><br><span class="line">    <span class="number">1</span> + <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>要在整个脚本中启用严格模式，可以在顶部添加如下代码： “use strict”;</p>
<h2 id="变量">变量</h2><h3 id="通过var声明">通过var声明</h3><p>ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。定义变量应该使用var操作符（不使用var操作符将会定义一个全局变量，这种方式不被推荐），后面跟一个变量名。<code>var message</code>像这样只是声明一个变量，并没有初始化，它的值将是undefined。</p>
<p>变量声明具有hoisting机制，JavaScript引擎在执行的时候，会把所有变量的声明都提升到当前作用域的最前面。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v = <span class="string">"hello"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">  <span class="keyword">var</span> v = <span class="string">"world"</span>;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p>
<p>执行结果是undefined。这就是因为变量提升，上面的代码实际上会是这样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> v;</span><br><span class="line">v = <span class="string">"hello"</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//覆盖全局的v变量，并且没有初始化所以是undefined</span></span><br><span class="line">  <span class="keyword">var</span> v,f;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">  v = <span class="string">"world"</span>;</span><br><span class="line">  <span class="comment">//函数表达式不会被提升，但是函数声明会，后面还会讲</span></span><br><span class="line">  f = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>严格模式下，不能定义名为eval或arguments的变量，否则会导致语法错误。</p>
<h3 id="通过let声明">通过let声明</h3><p>ES6中还可以使用let生命变量不同的是let声明的变量只在其所在代码块内有效（意味着ES6支持块级作用域了），并且不会发生“变量提升“现象（注意引号，当进入包含let的作用域，let所声明的变量以创建但是不可以使用，读写都会抛错，直到声明语句）。let不允许在相同作用域内，重复声明同一个变量。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="list">(<span class="keyword">function</span><span class="list">()</span><span class="collection">&#123;</span><br><span class="line">  var v = <span class="string">"world"</span><span class="comment">;</span></span><br><span class="line">  if <span class="list">(<span class="keyword">true</span>)</span> <span class="collection">&#123;</span><br><span class="line">    v = 'hello';</span><br><span class="line">    let v;</span><br><span class="line">  &#125;</span></span><br><span class="line">&#125;</span>)</span><span class="list">()</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。上面的代码中if块内v通过let声明，不再受外部变量v影响，但是由于在let声明前对v赋值，所以会报错。</p>
<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称TDZ）。</p>
<p>下面两个函数中使用let重复声明变量都会报错<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="通过const声明">通过const声明</h3><p>ECMAScript6中const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。const的作用域与let命令相同：只在声明所在的块级作用域内有效；不存在“变量提升“现象，只能在声明的位置后面使用；也不可重复声明。和Java中final有点类似，不可变是指其指向的对象不可变，但是对象内部属性可以变。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line">foo.<span class="keyword">prop</span> = 123;</span><br><span class="line">foo.<span class="keyword">prop</span> <span class="comment">// 123</span></span><br><span class="line">foo = &#123;&#125; <span class="comment">// 不起作用</span></span><br></pre></td></tr></table></figure></p>
<p>如果真的想将对象冻结，应该使用Object.freeze方法。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line">foo.prop = <span class="number">123</span>; <span class="comment">// 不起作用</span></span><br></pre></td></tr></table></figure></p>
<p>除了将对象本身冻结，对象的属性也应该冻结。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> constantize = <span class="function"><span class="params">(obj)</span> =&gt;</span> &#123;</span><br><span class="line">  Object.freeze(obj);</span><br><span class="line">  Object.keys(obj).forEach( <span class="function"><span class="params">(key, value)</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>const声明的常量只在当前代码块有效。如果想设置跨模块的常量，可以采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// constants.js 模块</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> A = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> B = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> C = <span class="number">4</span>;</span><br><span class="line"><span class="comment">// test1.js 模块</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> constants <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(constants.A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(constants.B); <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// test2.js 模块</span></span><br><span class="line"><span class="keyword">import</span> &#123;A, B&#125; <span class="keyword">from</span> <span class="string">'./constants'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(A); <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">console</span>.log(B); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>ES6规定，var和function声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="regexp">//</span>这里<span class="keyword">this</span>即全局变量，在浏览器中就是<span class="built_in">window</span>，node中是<span class="built_in">global</span></span><br><span class="line"><span class="keyword">this</span>.a;</span><br><span class="line"><span class="reserved">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>.b; <span class="regexp">//</span><span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p>
<p>模块中运行的全局变量，都是当前模块的属性，而不是node顶层对象的属性。</p>
<h2 id="数据类型">数据类型</h2><p>ECMAScript中有5种简单数据类型（也称为基本数据类型）：Undefined、Null、Boolean、Number和String。还有1种复杂数据类型——Object，其本质是一组<strong>无序</strong>的名值对组成</p>
<p>ES6引入了一种新的基本数据类型Symbol，是一种特殊的、不可变的数据类型，可以作为对象属性的标识符使用。</p>
<p>现在共有七种数据类型：Undefined, Null, Boolean, String, Symbol, Number和Object.</p>
<h3 id="typeof">typeof</h3><p>typeof的返回值</p>
<ul>
<li>“undefined” 如果这个值未定义</li>
<li>“boolean” 如果这个值是布尔值</li>
<li>“string” 如果这个值是字符串</li>
<li>“number” 如果这个值是数值</li>
<li>“object” 如果这个值是对象或者null</li>
<li>“function” 如果这个值是函数</li>
<li>“symbol” 如果这个值是Symbol类型（ES6新增）</li>
</ul>
<p><strong>从技术角度讲，函数在ECMAScript中是对象</strong></p>
<p>typeof操作符的操作数可以是变量（message），也可以是数值字面量。注意，typeof是一个操作符而不是函数，因此例子中的圆括号尽管可以使用，但不是必需的。</p>
<h3 id="Undefined">Undefined</h3><p>Undefined类型只有一个值，即特殊的undefined。在使用var声明变量但未对其加以初始化时，这个变量的值就是undefined</p>
<p>对未初始化和未声明的变量执行 typeof 操作符都返回 undefined 值，但是如果直接访问未声明的变量就会报错了。</p>
<p>对于尚未声明过的变量，只能执行一项操作，即使用typeof操作符检测其数据类型，这也是typeof存在的最大意义了。</p>
<h3 id="Null">Null</h3><p>Null类型是第二个只有一个值的数据类型，这个特殊的值是 null。从逻辑角度来看，null 值表示一个空对象指针，而这也正是使用 typeof 操作符检测 null 值时会返回”object”的原因</p>
<p>实际上，undefined值是派生自null值的，<code>null == undefined</code>将会返回true。</p>
<p>如果定义的变量准备在将来用于保存对象，那么最好将该变量初始化为null而不是其他值。这样一来，只要直接检查null 值就可以知道相应的变量是否已经保存了一个对象的引用</p>
<h3 id="Boolean">Boolean</h3><p>可以对任何数据类型的值调用Boolean()函数，而且总会返回一个Boolean值，你也可以在任何数据前加<code>!!</code>使其转化为Boolean类型。</p>
<p>转换规则</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>转换为true的值</th>
<th>转换为false的值</th>
</tr>
</thead>
<tbody>
<tr>
<td>Boolean</td>
<td>true</td>
<td>false</td>
</tr>
<tr>
<td>String</td>
<td>非空字符串</td>
<td>“”</td>
</tr>
<tr>
<td>Number</td>
<td>非零数字值（包括无穷大）</td>
<td>0和NaN</td>
</tr>
<tr>
<td>Object</td>
<td>任何对象</td>
<td>null</td>
</tr>
<tr>
<td>Undefined</td>
<td>n/a（不适用）</td>
<td>undefined</td>
</tr>
</tbody>
</table>
<h3 id="Number">Number</h3><p>八进制字面量在严格模式下是无效的</p>
<p>默认情况下，ECMAScript会将那些小数点后面带有 6个零以上的浮点数值转换为以 e表示法表示的数值（例如，0.0000003会被转换成3e-7）</p>
<p>如果浮点数值本身表示的就是一个整数（如1.0），那么该值也会被转换为整数</p>
<p>永远不要测试某个特定的浮点数值。 关于浮点数值计算会产生舍入误差的问题，有一点需要明确：这是使用基于IEEE754数值的浮点计算的通病，ECMAScript并非独此一家；其他使用相同数值格式的语言也存在这个问题。</p>
<p>所谓浮点数值，就是该数值中必须包含一个小数点，并且小数点后面必须至少有一位数字。虽然小数点前面可以没有整数，但我们不推荐这种写法</p>
<p>isNaN()函数。这个函数接受一个参数，该参数可以是任何类型，而函数会帮我们确定这个参数是否“不是数值”</p>
<p>ECMAScript能够表示的最小数值保存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324；能够表示的最大数值保存在Number.MAX_VALUE中——在大多数浏览器中，这个值是1.7976931348623157e+308。如果某次计算的结果得到了一个超出JavaScript数值范围的值，那么这个数值将被自动转换成特殊的 Infinity 值</p>
<p>要想确定一个数值是不是有穷的（换句话说，是不是位于最小和最大的数值之间），可以使用 isFinite()函数</p>
<p>NaN，即非数值（Not a Number）是一个特殊的数值，这个数值用于表示一个本来要返回数值的操作数未返回数值的情况（这样就不会抛出错误了）。例如，在其他编程语言中，任何数值除以0都会导致错误，从而停止代码执行。但在ECMAScript中，任何数值除以0会返回NaN（实际上只有0除以0才会返回NaN，正数除以0返回Infinity，负数除以0返回-Infinity），因此不会影响其他代码的执行。 NaN本身有两个非同寻常的特点。首先，任何涉及 NaN 的操作（例如 NaN/10）都会返回 NaN，这个特点在多步计算中有可能导致问题。其次，NaN与任何值都不相等，包括NaN本身</p>
<p>有3个函数可以把非数值转换为数值：Number()、parseInt()和parseFloat()（可以在字符串前加<code>+</code>将其转为数字，如<code>+&#39;10&#39;</code>）。第一个函数，即转型函数 Number()可以用于任何数据类型，而另两个函数则专门用于把字符串转换成数值</p>
<p>parseInt这个函数提供第二个参数：转换时使用的基数（即多少进制）。</p>
<p>parseInt()函数在转换字符串时，更多的是看其是否符合数值模式。它会忽略字符串前面的空格，直至找到第一个非空格字符。如果第一个字符不是数字字符或者负号，parseInt()就会返回 NaN；也就是说，用 parseInt()转换空字符串会返回 NaN（Number()对空字符返回0）。如果第一个字符是数字字符，parseInt()会继续解析第二个字符，直到解析完所有后续字符或者遇到了一个非数字字符。例如，”1234blue”会被转换为1234，因为”blue”会被完全忽略。类似地，”22.5”会被转换为22，因为小数点并不是有效的数字字符。</p>
<p>除了第一个小数点有效之外，parseFloat()与 parseInt()的第二个区别在于它始终都会忽略前导的零。parseFloat()可以识别前面讨论过的所有浮点数值格式，也包括十进制整数格式。但十六进制格式的字符串则始终会被转换成0。由于parseFloat()只解析十进制值，因此它没有用第二个参数指定基数的用法。最后还要注意一点：如果字符串包含的是一个可解析为整数的数（没有小数点，或者小数点后都是零），parseFloat()会返回整数。</p>
<h3 id="String">String</h3><p>与PHP中的双引号和单引号会影响对字符串的解释方式不同，ECMAScript中的这两种语法形式没有什么区别。</p>
<p>转义字符被作为一个字符来解析</p>
<p>数值、布尔值、对象和字符串值（没错，每个字符串也都有一个toString()方法，该方法返回字符串的一个副本）都有toString()方法。但null和undefined值没有这个方法。 多数情况下，调用toString()方法不必传递参数。但是，在调用数值的toString()方法时，可以传递一个参数：输出数值的基数</p>
<p>不知道要转换的值是不是null或undefined的情况下，还可以使用转型函数String()，这个函数能够将任何类型的值转换为字符串。</p>
<p>可以使用加号<code>+</code>操作符把某个值与以空字符加在一起来转换为字符串。<br>要把某个值转换为字符串，可以使用加号操作符（3.5 节讨论）把它与一个字符串（””）加在一起。</p>
<h3 id="Symbol">Symbol</h3><p>Symbol，表示独一无二的值。对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<p>注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<p>Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<p>注意，Symbol函数的参数只是表示对当前Symbol值的描述，因此相同参数的Symbol函数的返回值是不相等的。</p>
<p>Symbol值不能与其他类型的值进行运算，会报错。但是，Symbol值可以转为字符串。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"><span class="keyword">var</span> a = <span class="string">"your symbol is "</span> + sym; <span class="comment">//报错</span></span><br><span class="line"><span class="built_in">String</span>(sym) <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.toString() <span class="comment">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure></p>
<p>对象属性名使用Symbol<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;</span><br><span class="line">  [mySymbol]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(a, mySymbol, &#123; value: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure></p>
<p>注意，Symbol值作为对象属性名时，不能用点运算符。同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  [<span class="link_label">s</span>](<span class="link_url">arg</span>) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">log</span><span class="built_in">.</span>levels <span class="subst">=</span> &#123;</span><br><span class="line">  DEBUG: Symbol(<span class="string">'debug'</span>),</span><br><span class="line">  INFO: Symbol(<span class="string">'info'</span>),</span><br><span class="line">  WARN: Symbol(<span class="string">'warn'</span>),</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">log</span>(<span class="keyword">log</span><span class="built_in">.</span>levels<span class="built_in">.</span>DEBUG, <span class="string">'debug message'</span>);</span><br><span class="line"><span class="keyword">log</span>(<span class="keyword">log</span><span class="built_in">.</span>levels<span class="built_in">.</span>INFO, <span class="string">'info message'</span>);</span><br></pre></td></tr></table></figure></p>
<p>还有一点需要注意，Symbol值作为属性名时，该属性还是公开属性，不是私有属性。</p>
<p><strong>属性名遍历</strong><br>Symbol作为属性名，该属性不会出现在for…in、for…of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有Symbol属性名。</p>
<p>Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的Symbol值。</p>
<p><strong>Symbol.for</strong>方法接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> b = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line">s1 === s2 <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">a === s2 <span class="comment">// false</span></span><br><span class="line">a === b <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的Symbol类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。由于Symbol()写法没有登记机制</p>
<p><strong>Symbol.keyFor</strong>方法返回一个已登记的Symbol类型值的key。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s1 = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>需要注意的是，<code>Symbol.for</code>为Symbol值登记的名字，是全局环境的，可以在不同的iframe或service worker中取到同一个值。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = <span class="built_in">String</span>(<span class="built_in">window</span>.location);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">iframe.contentWindow.<span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p><strong>内置的Symbol值</strong></p>
<p>除了定义自己使用的Symbol值以外，ES6还提供一些内置的Symbol值，指向语言内部使用的方法。</p>
<p><strong>对象的Symbol.hasInstance属性</strong>，指向一个内部方法。该对象使用instanceof运算符时，会调用这个方法，判断该对象是否为某个构造函数的实例。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p>
<p><strong>对象的Symbol.isConcatSpreadable属性</strong>，指向一个方法。该对象使用Array.prototype.concat()时，会调用这个方法，返回一个布尔值，表示该对象是否可以扩展成数组。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Array</span> &#123;</span></span><br><span class="line">  [<span class="type">Symbol</span>.isConcatSpreadable]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Array</span> &#123;</span></span><br><span class="line">  [<span class="type">Symbol</span>.isConcatSpreadable]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a1 = <span class="keyword">new</span> <span class="type">A1</span>();</span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">a1[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">let a2 = <span class="keyword">new</span> <span class="type">A2</span>();</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(a1).concat(a2)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></figure>
<p><strong>对象的Symbol.isRegExp属性</strong>，指向一个方法。该对象被用作正则表达式时，会调用这个方法，返回一个布尔值，表示该对象是否为一个正则对象。</p>
<p><strong>对象的Symbol.match属性</strong>，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>
<p><strong>对象的Symbol.replace属性</strong>，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。</p>
<p><strong>对象的Symbol.search属性</strong>，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。</p>
<p><strong>对象的Symbol.split属性</strong>，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。</p>
<p><strong>对象的Symbol.iterator属性</strong>，指向一个方法，即该对象进行for…of循环时，会调用这个方法，返回该对象的Iterator对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>[i] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">this</span>[i];</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myCollection = <span class="keyword">new</span> Collection();</span><br><span class="line">myCollection[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">myCollection[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> myCollection) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p><strong>对象的Symbol.toPrimitive属性</strong>，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>
<p><strong>对象的Symbol.toStringTag属性</strong>，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中object后面的那个字符串。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class Collection &#123;</span><br><span class="line">  get [<span class="link_label">Symbol.toStringTag</span>](<span class="link_url"></span>) &#123;</span><br><span class="line"><span class="code">    return 'xxx';</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var x = new Collection();</span><br><span class="line">Object.prototype.toString.call(x) // "[object xxx]"</span><br></pre></td></tr></table></figure>
<p><strong>对象的Symbol.unscopables属性</strong>，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables]</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   copyWithin: true,</span></span><br><span class="line"><span class="comment">//   entries: true,</span></span><br><span class="line"><span class="comment">//   fill: true,</span></span><br><span class="line"><span class="comment">//   find: true,</span></span><br><span class="line"><span class="comment">//   findIndex: true,</span></span><br><span class="line"><span class="comment">//   keys: true</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(<span class="built_in">Array</span>.prototype[<span class="built_in">Symbol</span>.unscopables])</span><br><span class="line"><span class="comment">// ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'keys']</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，数组有6个属性，会被with命令排除。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有unscopables时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  foo() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span><br><span class="line">  foo(); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 有unscopables时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  foo() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="keyword">get</span> [Symbol.unscopables]() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; foo: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span><br><span class="line">  foo(); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Object">Object</h3><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br></pre></td></tr></table></figure>
<p>在ECMAScript中，如果不给构造函数传递参数，则可以省略后面的那一对圆括号。</p>
<p>Object每个实例都具有下列属性和方法</p>
<ul>
<li>Constructor：保存用于创建当前对象的函数，即构造函数</li>
<li>hasOwnProperty(propertyName)：用于检查给定的属性在当前对象实例中（而不是在实例的原型中）是否存在，propertyName必须是字符串</li>
<li>isPrototypeOf(object)：用于检查传入的对象是否是另一个对象的原型</li>
<li>propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for-in语句来枚举。参数必须是字符串</li>
<li>toLocaleString()：返回对象的字符串表示，与执行环境的地区对应</li>
<li>toString()：返回对象的字符串表示</li>
<li>valueOf()：分返回对象的字符串、数值或布尔值表示。通常与toString方法返回值相同。</li>
</ul>
<p>在ECMAScript中，（就像 Java 中的 java.lang.Object 对象一样）Object 类型是所有它的实例的基础</p>
<h2 id="操作符">操作符</h2><h3 id="一元操作符(++,-,+,-)">一元操作符(<code>++,--,+,-</code>)</h3><p>ECMAScript 操作符的与众不同之处在于，它们能够适用于很多值，例如字符串、数字值、布尔值，甚至对象。不过，在应用于对象时，相应的操作符通常都会调用对象的valueOf()和（或）toString()方法，以便取得可以操作的值。</p>
<p>应用于非数值的值时，递增和递减操作符执行前，该值会被转换为数值，然后在执行递增递减。对象是先调用它们的valueOf()和（或）toString()方法，再转换得到的值。</p>
<p>在对非数值应用一元加操作符时，该操作符会像Number()转型函数一样对这个值执行转换。如<code>+&#39;10&#39; === 10 //true</code></p>
<h3 id="位操作符(~,&amp;,|,^,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;)">位操作符(<code>~,&amp;,|,^,&lt;&lt;,&gt;&gt;,&gt;&gt;&gt;</code>)</h3><p>负数同样以二进制码存储，但使用的格式是二进制补码</p>
<p>ECMAScript中的所有数值都以IEEE-754 64位格式存储，但位操作符并不直接操作64位的值。而是先将64位的值转换成32位的整数，然后执行操作，最后再将结果转换回64位。对于开发人员来说，由于64位存储格式是透明的，因此整个过程就像是只存在32位的整数一样。但这个转换过程也导致了一个严重的副效应，即在对特殊的NaN和Infinity值应用位操作时，这两个值都会被当成0来处理</p>
<p>默认情况下，ECMAScript 中的所有整数都是有符号整数</p>
<p>计算补码的过程</p>
<p>(1) 求这个数值绝对值的二进制码（例如，要求-18的二进制补码，先求18的二进制码）； (2) 求二进制反码，即将0替换为1，将1替换为0； (3) 得到的二进制反码加1</p>
<p>按位非操作的本质：操作数的负值减1</p>
<p>按位异或操作符由一个插入符号（^）表示</p>
<p>左移操作会以0来填充空位</p>
<p>有符号右移在移位过程中，原数值中也会出现空位。只不过空位出现在原数值的左侧、符号位的右侧。而此时ECMAScript会用符号位的值来填充所有空位</p>
<p>首先，无符号右移操作符由3个大于号（&gt;&gt;&gt;）表示，无符号右移是以0来填充空位，其次，无符号右移操作符会把负数的二进制码当成正数的二进制码</p>
<h3 id="布尔操作符(!,&amp;&amp;,||)">布尔操作符(<code>!,&amp;&amp;,||</code>)</h3><p>逻辑非操作符首先会将操作数转换为布尔值然后再计算。参考前面的Boolean转换表</p>
<p>同时使用两个逻辑非操作符，实际上就会模拟 Boolean()转型函数的行为。如<code>!!&#39;&#39; //false</code></p>
<p>逻辑与和逻辑或在有一个操作数不是布尔值情况下不一定返回布尔值，遵循下列规则：</p>
<ul>
<li>如果第一个操作数是对象，则返回第二个操作数</li>
<li>如果第二个操作数是对象，则只有在第一个操作数的求值结果为true的情况下才返回该对象</li>
<li>如果两个操作数都是对象，则返回第二个操作数</li>
<li>如果有一个操作数是null，则返回null</li>
<li>如果有一个操作数是NaN，则返回NaN</li>
<li>如果有一个操作数是undefined，则返回undefined</li>
</ul>
<p>逻辑或遵循规则</p>
<ul>
<li>如果第一个操作数是对象，则返回第一个操作数</li>
<li>如果第一个操作数是求值结果为false，则返回第二个操作数</li>
<li>如果两个操作数都是对象，则返回第一个操作数</li>
<li>如果两个操作数都是null，则返回null</li>
<li>如果两个操作数都是NaN，则返回NaN</li>
<li>如果两个操作数都是undefined，则返回undefined</li>
</ul>
<h3 id="乘性操作符(*,/,%)">乘性操作符(<code>*,/,%</code>)</h3><p>在操作数为非数值的情况下会执行自动的类型转换。如果参与乘性计算的某个操作数不是数值，后台会先使用Number()转型函数将其转换为数值。也就是说，空字符串将被当作0，布尔值true将被当作1。</p>
<p>乘法</p>
<ul>
<li>如果操作数都是数值，执行常规的乘法计算，即两个正数或两个负数相乘的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果乘积超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；</li>
<li>如果有一个操作数是NaN，则结果是NaN；</li>
<li>如果是Infinity与0相乘，则结果是NaN；</li>
<li>如果是Infinity与非0数值相乘，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li>
<li>如果是Infinity与Infinity相乘，则结果是Infinity；</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的 规则。</li>
</ul>
<p>除法</p>
<ul>
<li>如果操作数都是数值，执行常规的除法计算，即两个正数或两个负数相除的结果还是正数，而如果只有一个操作数有符号，那么结果就是负数。如果商超过了ECMAScript数值的表示范围，则返回Infinity或-Infinity；</li>
<li>如果有一个操作数是NaN，则结果是NaN；</li>
<li>如果是Infinity被Infinity除，则结果是NaN；</li>
<li>如果是零被零除，则结果是NaN；</li>
<li>如果是非零的有限数被零除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li>
<li>如果是Infinity被任何非零数值除，则结果是Infinity或-Infinity，取决于有符号操作数的符号；</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的 规则。</li>
</ul>
<p>求模</p>
<ul>
<li>如果操作数都是数值，执行常规的除法计算，返回除得的余数；</li>
<li>如果被除数是无穷大值而除数是有限大的数值，返回NaN；</li>
<li>如果被除数是有限大的数值而除数是零，返回NaN；</li>
<li>如果Infinity被Infinity除，返回NaN；</li>
<li>如果被除数是有限大的数值而除数是无穷大值，返回被除数；</li>
<li>如果被除数是零，返回零；</li>
<li>如果有一个操作数不是数值，则在后台调用Number()将其转换为数值，然后再应用上面的 规则。</li>
</ul>
<h3 id="加性操作符(+,-)">加性操作符(<code>+,-</code>)</h3><p>加法</p>
<ul>
<li>如果有一个操作数是NaN，则结果是NaN；</li>
<li>如果是Infinity加Infinity，则结果是Infinity；</li>
<li>如果是-Infinity加-Infinity，则结果是-Infinity；</li>
<li>如果是Infinity加-Infinity，则结果是NaN；</li>
<li>如果是+0加+0，则结果是+0；</li>
<li>如果是-0加-0，则结果是-0；</li>
<li>如果是+0加-0，则结果是+0。</li>
</ul>
<p>不过，如果有一个操作数是字符串，那么就要应用如下规则：</p>
<ul>
<li>如果两个操作数都是字符串，则将第二个操作数与第一个操作数拼接起来；</li>
<li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，然后再将两个字符串拼接 起来。 如果有一个操作数是对象、数值或布尔值，则调用它们的toString()方法取得相应的字符串值，然后再应用前面关于字符串的规则。对于undefined和null，则分别调用String()函数并取得字符串”undefined”和”null”。</li>
</ul>
<p>减法</p>
<ul>
<li>如果两个操作数都是数值，则执行常规的算术减法操作并返回结果；</li>
<li>如果有一个操作数是NaN，则结果是NaN；</li>
<li>如果是Infinity减Infinity，则结果是NaN；</li>
<li>如果是-Infinity减-Infinity，则结果是NaN；</li>
<li>如果是Infinity减-Infinity，则结果是Infinity；</li>
<li>如果是-Infinity减Infinity，则结果是-Infinity；</li>
<li>如果是+0减+0，则结果是+0；</li>
<li>如果是+0减-0，则结果是-0；</li>
<li>如果是-0减-0，则结果是+0；</li>
<li>如果有一个操作数是字符串、布尔值、null或undefined，则先在后台调用Number()函数将其转换为数值，然后再根据前面的规则执行减法计算。如果转换的结果是NaN，则减法的结果就是NaN；</li>
<li>如果有一个操作数是对象，则调用对象的valueOf()方法以取得表示该对象的数值。如果得到的值是NaN，则减法的结果就是NaN。如果对象没有valueOf()方法，则调用其toString()方法并将得到的字符串转换为数值。</li>
</ul>
<h3 id="关系操作符(&gt;,&lt;,&gt;=,&lt;=)">关系操作符(<code>&gt;,&lt;,&gt;=,&lt;=</code>)</h3><p>对于字符串实际比较的是两个字符串中对应位置的每个字符的字符编码值</p>
<ul>
<li>如果两个操作数都是数值，则执行数值比较。</li>
<li>如果两个操作数都是字符串，则比较两个字符串对应的字符编码值。</li>
<li>如果一个操作数是数值，则将另一个操作数转换为一个数值，然后执行数值比较。</li>
<li>如果一个操作数是对象，则调用这个对象的valueOf()方法，用得到的结果按照前面的规则执行比较。如果对象没有valueOf()方法，则调用toString()方法，并用得到的结果根据前面的规则执行比较。</li>
<li>如果一个操作数是布尔值，则先将其转换为数值，然后再执行比较。<br>任何操作数与NaN比较都将返回false</li>
</ul>
<p>按照常理，如果一个值不小于另一个值，则一定大于或等于那个值，然而，在与NaN进行比较时，下面两个比较操作的结果都返回了false。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> res1 = <span class="literal">NaN</span> &lt; <span class="number">3</span>  <span class="comment">//false</span></span><br><span class="line"><span class="keyword">var</span> res2 = <span class="literal">NaN</span> &gt;= <span class="number">3</span> <span class="comment">//false</span></span><br></pre></td></tr></table></figure></p>
<h3 id="相等操作符(===,!==,==,!=)">相等操作符(<code>===,!==,==,!=</code>)</h3><p>相等和不相等——先转换再比较，全等和不全等——仅比较而不转换。</p>
<p>在转换不同的数据类型时，相等和不相等操作符遵循下列基本规则：</p>
<ul>
<li>如果有一个操作数是布尔值，则在比较相等性之前先将其转换为数值——false转换为0，而true转换为1；</li>
<li>如果一个操作数是字符串，另一个操作数是数值，在比较相等性之前先将字符串转换为数值；</li>
<li>如果一个操作数是对象，另一个操作数不是，则调用对象的valueOf()方法，用得到的基本类型值按照前面的规则进行比较； 这两个操作符在进行比较时则要遵循下列规则。</li>
<li>null和undefined是相等的。</li>
<li>要比较相等性之前，不能将null和undefined转换成其他任何值。</li>
<li>如果有一个操作数是NaN，则相等操作符返回false，而不相等操作符返回true。重要提示：即使两个操作数都是NaN，相等操作符也返回false；因为按照规则，NaN不等于NaN。</li>
<li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true；否则，返回false。</li>
</ul>
<p>由于相等和不相等操作符存在类型转换问题，而为了保持代码中数据类型的完整性，推荐使用全等和不全等操作符。</p>
<h3 id="条件操作符(boolean_expression?true_value:false_value)">条件操作符(<code>boolean_expression?true_value:false_value</code>)</h3><p>和Java中一样</p>
<h3 id="逗号操作符(,)">逗号操作符(<code>,</code>)</h3><p>在用于赋值时，逗号操作符总会返回表达式中的最后一项<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">num</span> = (<span class="number">5</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">0</span>) <span class="comment">//num值为0</span></span><br></pre></td></tr></table></figure></p>
<h3 id="赋值操作符(=以及*=、+=等复合赋值运算符)">赋值操作符(<code>=以及*=、+=等复合赋值运算符</code>)</h3><p>赋值与复合赋值和其他语言无太大区别。</p>
<h3 id="解构赋值">解构赋值</h3><p>ECMAScript6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。下面是数组解构赋值的例子<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">var</span> [<span class="atom">a</span>, <span class="atom">b</span>, <span class="atom">c</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; // <span class="atom">a</span>即为<span class="number">1</span>，<span class="atom">b</span>为<span class="number">2</span>，<span class="atom">c</span>为<span class="number">3</span></span><br><span class="line"><span class="atom">let</span> [,,<span class="atom">third</span>] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];//<span class="atom">third</span>为<span class="string">"baz"</span></span><br><span class="line"><span class="atom">let</span> [<span class="atom">head</span>, ...<span class="atom">tail</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]; //<span class="atom">head</span>为<span class="number">1</span>，<span class="atom">tail</span>为[<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]，...操作符后面再说</span><br><span class="line"><span class="atom">var</span> [<span class="atom">foo</span>, [[<span class="atom">bar</span>], <span class="atom">baz</span>]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br></pre></td></tr></table></figure></p>
<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>如果解构不成功，变量的值就等于undefined。以下几种情况都属于解构不成功，foo的值都会等于undefined（下面的代码在一些环境下会抛异常）。这是因为原始类型的值，会自动转为对象，比如数值1转为new Number(1)，从而导致foo取到undefined。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> [foo]</span> = [];</span><br><span class="line"><span class="variable"><span class="keyword">var</span> [foo]</span> = <span class="number">1</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> [foo]</span> = <span class="literal">false</span>;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> [foo]</span> = NaN;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> [bar, foo]</span> = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure></p>
<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]; //<span class="variable">x =</span> <span class="number">1</span>, <span class="variable">y =</span> <span class="number">2</span></span><br><span class="line"><span class="keyword">let</span> [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];// <span class="variable">a =</span> <span class="number">1</span>, <span class="variable">b =</span> <span class="number">2</span>, <span class="variable">d =</span> <span class="number">4</span></span><br></pre></td></tr></table></figure>
<p>如果对undefined或null进行解构，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>这是因为解构只能用于数组或对象。其他原始类型的值都可以转为相应的对象，但是，undefined和null不能转为对象，因此报错。</p>
<p>解构赋值允许指定默认值。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="atom">var</span> [<span class="atom">foo</span> = <span class="atom">true</span>] = []; //<span class="atom">foo</span> = <span class="atom">true</span></span><br><span class="line">[<span class="atom">x</span>, <span class="atom">y</span>=<span class="string">'b'</span>] = [<span class="string">'a'</span>] // <span class="atom">x</span>=<span class="string">'a'</span>, <span class="atom">y</span>=<span class="string">'b'</span></span><br><span class="line">[<span class="atom">x</span>, <span class="atom">y</span>=<span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="atom">undefined</span>] // <span class="atom">x</span>=<span class="string">'a'</span>, <span class="atom">y</span>=<span class="string">'b'</span></span><br></pre></td></tr></table></figure></p>
<p>注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> [x</span> = <span class="number">1</span>] = [undefined];<span class="comment">// x = 1</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> [x</span> = <span class="number">1</span>] = [<span class="literal">null</span>]; <span class="comment">//x = null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</p>
<p>解构赋值不仅适用于var命令，也适用于let和const命令。对于Set结构（ECMAScript6新增），也可以使用数组的解构赋值。事实上，只要某种数据结构具有Iterable接口，都可以采用数组形式的解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibs</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [first, second, third, fourth, fifth, sixth] = fibs();</span><br><span class="line">sixth <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，fibs是一个Generator函数，原生具有Iterable接口。解构赋值会依次从这个接口获取值。</p>
<p>解构不仅可以用于数组，还可以用于对象。对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> &#123; bar, foo &#125;</span> = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;;<span class="comment">//bar = "bbb", foo = "aaa"</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> &#123; baz &#125;</span> = &#123; foo: <span class="string">"aaa"</span>, bar: <span class="string">"bbb"</span> &#125;; <span class="comment">//baz = undefined</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> obj</span> = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">"Hello"</span>,</span><br><span class="line">    &#123; y: <span class="string">"World"</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="variable"><span class="keyword">var</span> &#123; p</span>: [x, &#123; y &#125;] &#125; = obj; <span class="comment">//x = "Hello", y = "World"</span></span><br></pre></td></tr></table></figure></p>
<p>如果左边变量名和右边属性名不一致<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var &#123; <span class="string">foo:</span> baz &#125; = &#123; <span class="string">foo:</span> <span class="string">"aaa"</span>, <span class="string">bar:</span> <span class="string">"bbb"</span> &#125;; <span class="comment">//baz = "aaa"</span></span><br></pre></td></tr></table></figure></p>
<p>默认值生效的条件是，对象的属性值严格等于undefined。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> &#123;x</span> = <span class="number">3</span>&#125; = &#123;x: undefined&#125;; <span class="comment">//x = 3</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> &#123;x</span> = <span class="number">3</span>&#125; = &#123;x: <span class="literal">null</span>&#125;; <span class="comment">//x = null</span></span><br></pre></td></tr></table></figure></p>
<p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="variable"><span class="keyword">var</span> x;</span><br><span class="line">&#123;x&#125;</span> = &#123;x:<span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正确的写法</span></span><br><span class="line"><span class="comment">(&#123;x&#125; = &#123;x:1&#125;)</span>;</span><br></pre></td></tr></table></figure></p>
<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> &#123; <span class="built_in">log</span>, <span class="built_in">sin</span>, <span class="built_in">cos</span> &#125; = Math;</span><br></pre></td></tr></table></figure></p>
<p>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p>
<p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c, d, e] = 'hello';//<span class="variable">a =</span> <span class="string">"h"</span>, <span class="variable">b =</span> <span class="string">"e"</span>, <span class="variable">c =</span> <span class="string">"l"</span>, <span class="variable">d =</span> <span class="string">"l"</span>, <span class="variable">e =</span> <span class="string">"o"</span></span><br><span class="line"><span class="keyword">let</span> &#123;length : len&#125; = 'hello'; //<span class="variable">len =</span> <span class="number">5</span></span><br></pre></td></tr></table></figure></p>
<p>函数的参数也可以使用解构。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">([x, y])</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>函数参数的解构也可以使用默认值。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span><span class="params">(&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;)</span> &#123;</span></span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move<span class="params">(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;)</span>; <span class="comment">// [3, 8]</span></span><br><span class="line">move<span class="params">(&#123;x: <span class="number">3</span>&#125;)</span>; <span class="comment">// [3, 0]</span></span><br><span class="line">move<span class="params">(&#123;&#125;)</span>; <span class="comment">// [0, 0]</span></span><br><span class="line">move<span class="params">()</span>; <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
<p>注意，指定函数参数的默认值时，不能采用下面的写法。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">move</span><span class="params">(&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;)</span> &#123;</span></span><br><span class="line">  return [x, y];</span><br><span class="line">&#125;</span><br><span class="line">move<span class="params">(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;)</span>; <span class="comment">// [3, 8]</span></span><br><span class="line">move<span class="params">(&#123;x: <span class="number">3</span>&#125;)</span>; <span class="comment">// [3, undefined]</span></span><br><span class="line">move<span class="params">(&#123;&#125;)</span>; <span class="comment">// [undefined, undefined]</span></span><br><span class="line">move<span class="params">()</span>; <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
<p>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p>
<p>变量的解构赋值用途很多。</p>
<p>1）交换变量的值<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[x, y]</span> = <span class="comment">[y, x]</span>;</span><br></pre></td></tr></table></figure></p>
<p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
<p>2）从函数返回多个值</p>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> [a, b, c] = example();</span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure></p>
<p>3）函数参数的定义</p>
<p>解构赋值可以方便地将一组参数与变量名对应起来。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="tag">function</span> <span class="tag">f</span>([x, y, z]) &#123; ... &#125;</span><br><span class="line"><span class="tag">f</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="tag">function</span> <span class="tag">f</span>(&#123;<span class="tag">x</span>, <span class="tag">y</span>, <span class="tag">z</span>&#125;) &#123; ... &#125;</span><br><span class="line"><span class="function">f</span>(&#123;<span class="attribute">x</span>:<span class="number">1</span>, <span class="attribute">y</span>:<span class="number">2</span>, <span class="attribute">z</span>:<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<p>4）提取JSON数据</p>
<p>解构赋值对提取JSON对象中的数据，尤其有用。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  <span class="keyword">status</span>: <span class="string">"OK"</span>,</span><br><span class="line">  <span class="type">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;</span><br><span class="line">let &#123; id, <span class="keyword">status</span>, <span class="type">data</span>: <span class="keyword">number</span> &#125; = jsonData;</span><br><span class="line">console.<span class="built_in">log</span>(id, <span class="keyword">status</span>, <span class="keyword">number</span>)</span><br><span class="line">// <span class="number">42</span>, OK, [<span class="number">867</span>, <span class="number">5309</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码可以快速提取JSON数据的值。</p>
<p>5）函数参数的默认值</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> <span class="params">(url, &#123;</span><br><span class="line">  async = true,</span><br><span class="line">  beforeSend = function ()</span> </span>&#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p>
<p>6）遍历Map结构</p>
<p>任何部署了Iterable接口的对象，都可以用for…of循环遍历。Map结构原生支持Iterable接口，配合变量的解构赋值，获取键名和键值就非常方便。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (let [<span class="variable">key</span>, value] of <span class="built_in">map</span>) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="variable">key</span> + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure></p>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,<span class="keyword">value</span>] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>7）输入模块的指定方法</p>
<p>加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="语句">语句</h2><p>if, do-while,while,for,label,break,continue,switch和Java没有太大差别。</p>
<p>推崇始终使用代码块，即使要执行的只有一行代码</p>
<p>像 do-while 这种后测试循环语句最常用于循环体中的代码至少要被执行一次的情形。</p>
<p>加标签的语句一般都要与for语句等循环语句配合使用。</p>
<p>break和 continue 语句都可以与 label 语句联合使用，从而返回代码中特定的位置。这种联合使用的情况多发生在循环嵌套的情况下</p>
<p>建议如果使用label语句，一定要使用描述性的标签，同时不要嵌套过多的循环</p>
<p>switch语句在比较值时使用的是全等操作符，因此不会发生类型转换（例如，字符串”10”不等于数值10）。</p>
<p>首先，可以在switch语句中使用任何数据类型（在很多其他语言中只能使用数值），无论是字符串，还是对象都没有问题。其次，每个case的值不一定是常量，可以是变量，甚至是表达式。</p>
<h3 id="for-in">for-in</h3><p>由于 ECMAScript中不存在块级作用域（ES6已有），因此在循环内部定义的变量也可以在外部访问到</p>
<p>ECMAScript对象的属性没有顺序。因此，通过 for-in 循环输出的属性名的顺序是不可预测的</p>
<p>for-in语句是一种精准的迭代语句，可以用来枚举对象的属性。</p>
<p>建议在使用for-in循环之前，先检测确认该对象的值不是null或undefined。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="reserved">var</span> propName <span class="keyword">in</span> <span class="built_in">window</span>) &#123;</span><br><span class="line">    <span class="built_in">document</span>.write(propName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="with">with</h3><p>由于大量使用with语句会导致性能下降，同时也会给调试代码造成困难，因此在开发大型应用程序时，不建议使用with语句。</p>
<p>定义with语句的目的主要是为了简化多次编写同一个对象的工作，如下面的例子所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> qs</span> = location.search.substring(<span class="number">1</span>);</span><br><span class="line"><span class="variable"><span class="keyword">var</span> hostName</span> = location.hostname;</span><br><span class="line"><span class="variable"><span class="keyword">var</span> url</span> = location.href;</span><br></pre></td></tr></table></figure></p>
<p>上面几行代码都包含location对象。如果使用with 语句，可以把上面的代码改写成如下所示：<br><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with(location)&#123;</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> qs</span> = search.substring(<span class="number">1</span>);</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> hostName</span> = hostname;</span><br><span class="line">    <span class="variable"><span class="keyword">var</span> url</span> = href;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个重写后的例子中，使用with 语句关联了location 对象。这意味着在with 语句的代码块内部，每个变量首先被认为是一个局部变量，而如果在局部环境中找不到该变量的定义，就会查询location对象中是否有同名的属性。如果发现了同名属性，则以location对象属性的值作为变量的值。 严格模式下不允许使用with语句，否则将视为语法错误</p>
<h3 id="for-of">for-of</h3><p>ES6借鉴C++、Java、C#和Python语言，引入了for…of循环，作为遍历所有数据结构的统一的方法。一个数据结构只要部署了<code>Symbol.iterator</code>方法，就被视为具有Iterable接口，就可以用for…of循环遍历它的成员。也就是说，for…of循环内部调用的是数据结构的<code>Symbol.iterator</code>方法。</p>
<p>for…of循环可以使用的范围包括数组、Set和Map结构及其entries,values,keys方法返回的对象、某些类似数组的对象（比如arguments对象、DOM NodeList对象）、后文的Generator对象，以及字符串。</p>
<p>数组原生具备Iterable接口，for…of循环本质上就是调用<code>Symbol.iterator</code>产生的Iterator对象，可以用下面的代码证明。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = ['red', 'green', 'blue'];</span><br><span class="line"><span class="keyword">let</span> <span class="keyword">iterator</span>  = arr[<span class="type">Symbol</span>.<span class="keyword">iterator</span>]();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  console.log(v); // red green blue</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> <span class="keyword">iterator</span>) &#123;</span><br><span class="line">  console.log(v); // red green blue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript原有的for…in循环，只能获得对象的键名，不能直接获取键值。ES6提供for…of循环，允许遍历获得键值。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr = [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"d"</span>];</span><br><span class="line"><span class="keyword">for</span> <span class="params">(a in arr)</span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span><span class="params">(a)</span>; <span class="comment">// 0 1 2 3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> <span class="params">(a of arr)</span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span><span class="params">(a)</span>; <span class="comment">// a b c d</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Set和Map结构也原生具有Iterable接口，可以直接使用for…of循环。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> engines = <span class="keyword">Set</span>([<span class="string">"Gecko"</span>, <span class="string">"Trident"</span>, <span class="string">"Webkit"</span>, <span class="string">"Webkit"</span>]);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> <span class="keyword">e</span> of engines) &#123;</span><br><span class="line">  console.<span class="literal">log</span>(<span class="keyword">e</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Gecko</span></span><br><span class="line"><span class="comment">// Trident</span></span><br><span class="line"><span class="comment">// Webkit</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> es6 = new Map();</span><br><span class="line">es6.<span class="keyword">set</span>(<span class="string">"edition"</span>, 6);</span><br><span class="line">es6.<span class="keyword">set</span>(<span class="string">"committee"</span>, <span class="string">"TC39"</span>);</span><br><span class="line">es6.<span class="keyword">set</span>(<span class="string">"standard"</span>, <span class="string">"ECMA-262"</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> [name, value] of es6) &#123;</span><br><span class="line">  console.<span class="literal">log</span>(name + <span class="string">": "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// edition: 6</span></span><br><span class="line"><span class="comment">// committee: TC39</span></span><br><span class="line"><span class="comment">// standard: ECMA-262</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码演示了如何遍历Set结构和Map结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。</p>
<p>并不是所有类似数组的对象都具有iterator接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123; length: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> arrayLike) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">of</span> <span class="built_in">Array</span>.from(arrayLike)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过for-of遍历对象，一种解决方法是，使用<code>Object.keys</code>方法将对象的键名生成一个数组，然后遍历这个数组。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="variable">key</span> of <span class="keyword">Object</span>.keys(someObject)) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="variable">key</span> + <span class="string">": "</span> + someObject[<span class="variable">key</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在对象上部署iterator接口的代码，参见本章前面部分。一个方便的方法是将数组的<code>Symbol.iterator</code>属性，直接赋值给其他对象的<code>Symbol.iterator</code>属性。比如，想要让for…of循环遍历jQuery对象，只要加上下面这一行就可以了。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jQuery.prototype[<span class="type">Symbol</span>.<span class="keyword">iterator</span>] =</span><br><span class="line">  <span class="type">Array</span>.prototype[<span class="type">Symbol</span>.<span class="keyword">iterator</span>];</span><br></pre></td></tr></table></figure>
<p>另一个方法是使用Generator函数将对象重新包装一下。</p>
<p><strong>与其他遍历语法的比较</strong></p>
<p>以数组为例，JavaScript提供多种遍历语法。最原始的写法就是for循环。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; myArray.<span class="keyword">length</span>; <span class="keyword">index</span>++) &#123;</span><br><span class="line">  console.<span class="keyword">log</span>(myArray[<span class="keyword">index</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种写法比较麻烦，因此数组提供内置的forEach方法。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">myArray.forEach(<span class="function"><span class="keyword">function</span></span> (<span class="keyword">value</span>) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="keyword">value</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。</p>
<p>for…in循环可以遍历数组的键名。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="reserved">var</span> index <span class="keyword">in</span> myArray) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(myArray[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>for…in循环有几个缺点。</p>
<ol>
<li><p>数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。</p>
</li>
<li><p>for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。</p>
</li>
<li><p>某些情况下，for…in循环会以任意顺序遍历键名。</p>
</li>
</ol>
<p>总之，for…in循环主要是为遍历对象而设计的，不适用于遍历数组。</p>
<p>for…of循环相比上面几种做法，有一些显著的优点。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">value</span> <span class="keyword">of</span> myArray) &#123;</span><br><span class="line">  console.log(<span class="keyword">value</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>有着同for…in一样的简洁语法，但是没有for…in那些缺点。</li>
<li>不同用于forEach方法，它可以与break、continue和return配合使用。</li>
<li>提供了遍历所有数据结构的统一操作接口。</li>
</ul>
<h2 id="函数">函数</h2><p>严格模式对函数有一些限制：</p>
<ul>
<li>不能把函数命名为eval或arguments；</li>
<li>不能把参数命名为eval或arguments；</li>
<li>不能出现两个命名参数同名的情况。 如果发生以上情况，就会导致语法错误，代码无法执行。</li>
</ul>
<p>return语句也可以不带有任何返回值。在这种情况下，函数在停止执行后将返回undefined值。</p>
<p>即便你定义的函数只接收两个参数，在调用这个函数时也未必一定要传递两个参数。可以传递一个、三个甚至不传递参数，而解析器永远不会有什么怨言。之所以会这样，原因是ECMAScript中的参数在内部是用一个数组来表示的。函数接收到的始终都是这个数组，而不关心数组中包含哪些参数（如果有参数的话）。如果这个数组中不包含任何元素，无所谓；如果包含多个元素，也没有问题。实际上，在函数体内可以通过arguments对象来访问这个参数数组，从而获取传递给函数的每一个参数。</p>
<p>其实，arguments对象只是与数组类似（它并不是Array的实例），因为可以使用方括号语法访问它的每一个元素（即第一个元素是arguments[0]，第二个元素是arguments[1]，以此类推），使用length属性来确定传递进来多少个参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doAdd</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">arguments</span>[<span class="number">1</span>] = <span class="number">10</span>;</span><br><span class="line">    alert(<span class="built_in">arguments</span>[<span class="number">0</span>] + num2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>arguments对象为其内部属性以及函数形式参数创建getter和setter函数。因此改变形参的值会影响arguments对象的值，但是严格模式不允许创建getter和setter方法。</p>
<p>严格模式对如何使用 arguments 对象做出了一些限制。首先，像前面例子中那样的赋值会变得无效。也就是说，即使把 arguments[1]设置为 10，num2 的值仍然还是 undefined。其次，重写arguments的值会导致语法错误（代码将不会执行）。 ECMAScript中的所有参数传递的都是值，不可能通过引用传递参数。</p>
<p><strong>没有重载</strong><br>没有函数签名，真正的重载是不可能做到的。 如果在ECMAScript中定义了两个名字相同的函数，则该名字只属于后定义的函数。</p>
<h2 id="箭头函数">箭头函数</h2><h3 id="基本用法">基本用法</h3><p>ES6允许使用“箭头”（=&gt;）定义函数（和Java8中lambda表达式有点类似）<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基本用法</span></span><br><span class="line">(param1, param2, paramN) =&gt; &#123; statements &#125;</span><br><span class="line">(param1, param2, paramN) =&gt; expression <span class="comment">// equivalent to:  =&gt; &#123; return expression; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果只有一个参数可以省略圆括号</span></span><br><span class="line">singleParam =&gt; &#123; statements &#125;</span><br><span class="line">singleParam =&gt; expression</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果没有参数，则需要一个圆括号</span></span><br><span class="line">() =&gt; &#123; statements &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果返回一个对象，必须在对象外面加上括号。</span></span><br><span class="line">params =&gt; (&#123;foo: bar&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 支持Rest参数</span></span><br><span class="line">(param1, param2, ...rest) =&gt; &#123; statements &#125;</span><br><span class="line"><span class="comment">// 支持变量解构</span></span><br><span class="line">(&#123;param1, param2&#125;) =&gt; &#123; statements &#125;</span><br></pre></td></tr></table></figure></p>
<p>箭头函数的一个用处是简化回调函数。<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> <span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(x =&gt; x * x);</span><br></pre></td></tr></table></figure></p>
<h3 id="使用注意点">使用注意点</h3><p>箭头函数有几个使用注意点。</p>
<ul>
<li>函数体内的this对象，绑定定义时所在的对象，而不是使用时所在的对象。</li>
<li>不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</li>
<li>不可以使用arguments对象，该对象在函数体内不存在。</li>
<li>不可以使用yield命令，因此箭头函数不能用作Generator函数。</li>
</ul>
<p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。下面的代码是一个例子，将this对象绑定定义时所在的对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  id: <span class="string">"123456"</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">"click"</span>,</span><br><span class="line">      event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"Handling "</span> + type  + <span class="string">" for "</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码的init方法中，使用了箭头函数，这导致this绑定handler对象，否则回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</p>
<p>由于this在箭头函数中被绑定，所以不能用call()、apply()、bind()这些方法去改变this的指向。</p>
<h3 id="嵌套的箭头函数">嵌套的箭头函数</h3><p>箭头函数内部，还可以再使用箭头函数。下面是一个ES5语法的多重嵌套函数。</p>
<p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>pipeline參數是...funcs，返回值是val =&gt; funcs.reduce(<span class="function"><span class="params">(a, b)</span> =&gt;</span> b(a), val);</span><br><span class="line"><span class="regexp">//</span>addThenMult參數是val，返回值是 funcs.reduce(<span class="function"><span class="params">(a, b)</span> =&gt;</span> b(a), val);</span><br><span class="line"><span class="reserved">const</span> pipeline = <span class="function"><span class="params">(...funcs)</span> =&gt;</span></span><br><span class="line">  val =&gt; funcs.reduce(<span class="function"><span class="params">(a, b)</span> =&gt;</span> b(a), val);</span><br><span class="line"></span><br><span class="line"><span class="reserved">const</span> plus1 = a =&gt; a + <span class="number">1</span>;</span><br><span class="line"><span class="reserved">const</span> mult2 = a =&gt; a * <span class="number">2</span>;</span><br><span class="line"><span class="reserved">const</span> addThenMult = pipeline(plus1, mult2);</span><br><span class="line"></span><br><span class="line">addThenMult(<span class="number">5</span>)</span><br><span class="line"><span class="regexp">//</span> <span class="number">12</span></span><br></pre></td></tr></table></figure></p>
<p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus1 = a =&gt; a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = a =&gt; a * <span class="number">2</span>;</span><br><span class="line">mult2(plus1(<span class="number">5</span>)) <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p>
<p>箭头函数还有一个功能，就是可以很方便地改写λ演算。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// λ演算的写法</span></span><br><span class="line">fix = λf.<span class="params">(λx.f<span class="params">(λv.x<span class="params">(x)</span><span class="params">(v)</span>)</span>)</span><span class="params">(λx.f<span class="params">(λv.x<span class="params">(x)</span><span class="params">(v)</span>)</span>)</span></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line">var fix = f =&gt; <span class="params">(x =&gt; f<span class="params">(v =&gt; x<span class="params">(x)</span><span class="params">(v)</span>)</span>)</span></span><br><span class="line">               <span class="params">(x =&gt; f<span class="params">(v =&gt; x<span class="params">(x)</span><span class="params">(v)</span>)</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<h2 id="Generator_函数">Generator 函数</h2><h3 id="基本概念-1">基本概念</h3><p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p>
<p>Generator函数有多种理解角度。从语法上，首先可以把它理解成一个函数的内部状态的遍历器（也就是说，Generator函数是一个状态机）。它每调用一次，就进入下一个内部状态。Generator函数可以控制内部状态的变化，依次遍历这些状态。</p>
<p>形式上，Generator函数是一个普通函数，但是有两个特征。一是，function命令与函数名之间有一个星号；二是，函数体内部使用yield语句，定义遍历器的每个成员，即不同的内部状态（yield语句在英语里的意思就是“产出”）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">helloWorldGenerator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'hello'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'world'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">'ending'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> hw = helloWorldGenerator();</span><br></pre></td></tr></table></figure>
<p>上面代码定义了一个Generator函数helloWorldGenerator，它内部有两个yield语句“hello”和“world”，即该函数有三个状态：hello，world和return语句（结束执行）。</p>
<p>然后，Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个Iterator对象（该对象同时实现了Iterable接口，并且调用该对象的<code>Symbol.iterator</code>方法返回该对象自身）。</p>
<p>下一步，必须调用Iterator对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield命令是暂停执行的标记，而next方法可以恢复执行。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hw.<span class="function"><span class="title">next</span><span class="params">()</span></span> <span class="comment">// &#123; value: 'hello', done: false &#125;</span></span><br><span class="line">hw.<span class="function"><span class="title">next</span><span class="params">()</span></span> <span class="comment">// &#123; value: 'world', done: false &#125;</span></span><br><span class="line">hw.<span class="function"><span class="title">next</span><span class="params">()</span></span> <span class="comment">// &#123; value: 'ending', done: true &#125;</span></span><br><span class="line">hw.<span class="function"><span class="title">next</span><span class="params">()</span></span> <span class="comment">// &#123; value: undefined, done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>第三次调用，Generator函数从上次yield语句停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。第四次调用，此时Generator函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。</p>
<p>总结一下，调用Generator函数，返回一个实现了Iterator接口的对象，用来操作内部指针。以后，每次调用Iterator对象的next方法，就会返回一个实现了IteratorResult接口的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。</p>
<h3 id="yield语句">yield语句</h3><p>由于Generator函数返回的Iterator对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。</p>
<p>Iterator对象next方法的运行逻辑如下。</p>
<ol>
<li>遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li>
<li>下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。</li>
<li>如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。</li>
<li>如果该函数没有return语句，则返回的对象的value属性值为undefined。</li>
</ol>
<p>需要注意的是，yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span></span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>  <span class="number">123</span> + <span class="number">456</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，yield后面的表达式<code>123 + 456</code>，不会立即求值，只会在next方法将指针移到这一句时，才会求值。</p>
<p>yield语句与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。正常函数只能返回一个值，因为只能执行一次return；Generator函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说Generator生成了一系列的值，这也就是它的名称的来历（在英语中，generator这个词是“生成器”的意思）。</p>
<p>Generator函数可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'执行了！'</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> generator = f();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  generator.next()</span><br><span class="line">&#125;, <span class="number">2000</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个Generator函数，就变成只有调用next方法时，函数f才会执行。</p>
<p>另外需要注意，yield语句不能用在普通函数中，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">&#125;)()</span><br><span class="line"><span class="comment">// SyntaxError: Unexpected number</span></span><br></pre></td></tr></table></figure>
<p>上面代码在一个普通函数中使用yield语句，结果产生一个句法错误。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>)</span>&#123;</span><br><span class="line">  a.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">'number'</span>)&#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> flat(arr))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield语句。一种修改方法是改用for循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, [[<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]];</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> flat = <span class="function"><span class="keyword">function</span>* (<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> length = a.length;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i =<span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">    <span class="keyword">var</span> item = a[i];</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> item !== <span class="string">'number'</span>)&#123;</span><br><span class="line">      <span class="keyword">yield</span>* flat(item);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span> item;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> f <span class="keyword">of</span> flat(arr))&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1, 2, 3, 4, 5, 6</span></span><br></pre></td></tr></table></figure>
<h3 id="与Iterator的关系">与Iterator的关系</h3><p>调用Generator函数返回一个Iterator对象。这里的Iterator对象也实现了Iterable接口，Symbol.iterator方法执行后，返回自身。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function* gen()&#123;</span><br><span class="line">  // some code</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var i = gen();</span><br><span class="line"></span><br><span class="line">i[<span class="link_label">Symbol.iterator</span>](<span class="link_url"></span>) === i // true</span><br></pre></td></tr></table></figure>
<h3 id="next方法的参数">next方法的参数</h3><p>yield语句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span><span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="keyword">for</span><span class="params">(var i=<span class="number">0</span>; <span class="literal">true</span>; i++)</span> &#123;</span><br><span class="line">    var reset = yield i;</span><br><span class="line">    <span class="keyword">if</span><span class="params">(reset)</span> &#123; i = -<span class="number">1</span>; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var g = f<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">g.next<span class="params">()</span> <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br><span class="line">g.next<span class="params">()</span> <span class="comment">// &#123; value: 1, done: false &#125;</span></span><br><span class="line">g.next<span class="params">(<span class="literal">true</span>)</span> <span class="comment">// &#123; value: 0, done: false &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码先定义了一个可以无限运行的Generator函数f，如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined。当next方法带一个参数true时，当前的变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。</p>
<p>这个功能有很重要的语法意义。Generator函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在Generator函数开始运行之后，继续向函数体内部注入值。也就是说，可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p>
<p>再看一个例子。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span><span class="params">(x)</span> &#123;</span></span><br><span class="line">  var y = <span class="number">2</span> <span class="built_in">*</span> <span class="params">(yield <span class="params">(x + <span class="number">1</span>)</span>)</span>;</span><br><span class="line">  var z = yield <span class="params">(y / <span class="number">3</span>)</span>;</span><br><span class="line">  return <span class="params">(x + y + z)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var a = foo<span class="params">(<span class="number">5</span>)</span>;</span><br><span class="line"></span><br><span class="line">a.next<span class="params">()</span> <span class="comment">// Object&#123;value:6, done:false&#125;</span></span><br><span class="line">a.next<span class="params">()</span> <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br><span class="line">a.next<span class="params">()</span> <span class="comment">// Object&#123;value:NaN, done:false&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，第二次运行next方法的时候不带参数，导致y的值等于<code>2 * undefined</code>（即NaN），除以3以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于<code>5 + NaN + undefined</code>，即NaN。</p>
<p>如果向next方法提供参数，返回结果就完全不一样了。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var it = foo<span class="params">(<span class="number">5</span>)</span>;</span><br><span class="line"></span><br><span class="line">it.next<span class="params">()</span> <span class="comment">// &#123; value:6, done:false &#125;</span></span><br><span class="line">it.next<span class="params">(<span class="number">12</span>)</span> <span class="comment">// &#123; value:8, done:false &#125;</span></span><br><span class="line">it.next<span class="params">(<span class="number">13</span>)</span> <span class="comment">// &#123; value:42, done:true &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码第一次调用next方法时，返回<code>x+1</code>的值6；第二次调用next方法，将上一次yield语句的值设为12，因此y等于24，返回<code>y / 3</code>的值8；第三次调用next方法，将上一次yield语句的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。</p>
<p>注意，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。</p>
<h3 id="for…of循环">for…of循环</h3><p>for…of循环可以自动遍历Generator函数，且此时不再需要调用next方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">6</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> v <span class="keyword">of</span> foo()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码使用for…of循环，依次显示5个yield语句的值。这里需要注意，一旦next方法的返回对象的done属性为true，for…of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for…of循环之中。</p>
<p>下面是一个利用generator函数和for…of循环，实现斐波那契数列的例子。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">fibonacci</span><span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="built_in">let</span> [prev, curr] = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">  <span class="keyword">for</span> <span class="params">(;;)</span> &#123;</span><br><span class="line">    [prev, curr] = [curr, prev + curr];</span><br><span class="line">    yield curr;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> <span class="params">(let n of fibonacci<span class="params">()</span>)</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> <span class="params">(n &gt; <span class="number">1000</span>)</span> break;</span><br><span class="line">  console.<span class="built_in">log</span><span class="params">(n)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面代码可见，使用for…of语句时不需要使用next方法。</p>
<h3 id="throw方法">throw方法</h3><p>Generator函数还有一个特点，它可以在函数体外抛出错误，然后在函数体内捕获。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="string">'a'</span>) <span class="keyword">throw</span> e;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  i.throw(<span class="string">'a'</span>);</span><br><span class="line">  i.throw(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 内部捕获 a</span></span><br><span class="line"><span class="comment">// 外部捕获 b</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，迭代器i连续抛出两个错误。第一个错误被Generator函数体内的catch捕获，然后Generator函数执行完成，于是第二个错误被函数体外的catch捕获。</p>
<p>注意，上面代码的错误，是用Iterator对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">yield</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (e != <span class="string">'a'</span>) <span class="keyword">throw</span> e;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'内部捕获'</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> i = g();</span><br><span class="line">i.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'a'</span>);</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'b'</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'外部捕获'</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部捕获 [Error: a]</span></span><br></pre></td></tr></table></figure>
<p>上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续执行try语句块了。</p>
<p>如果Generator函数内部部署了try…catch代码块，那么Iterator对象的throw方法抛出的错误，不影响下一次遍历，否则遍历直接终止。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  g.throw();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  g.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br></pre></td></tr></table></figure>
<p>上面代码只输出hello就结束了，因为第二次调用next方法时，遍历器状态已经变成终止了。但是，如果使用throw命令抛出错误，不会影响遍历器状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> gen = <span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'hello'</span>);</span><br><span class="line">  <span class="keyword">yield</span> <span class="built_in">console</span>.log(<span class="string">'world'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> g = gen();</span><br><span class="line">g.next();</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  g.next();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// hello</span></span><br><span class="line"><span class="comment">// world</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都取到了正确的操作。</p>
<p>这种函数体内捕获错误的机制，大大方便了对错误的处理。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数写一个错误处理语句。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">foo<span class="list">(<span class="quoted">'a</span>', function <span class="list">(<span class="keyword">a</span>)</span> &#123;</span><br><span class="line">  if <span class="list">(<span class="keyword">a</span>.error)</span> &#123;</span><br><span class="line">    throw new Error<span class="list">(<span class="keyword">a</span>.error)</span><span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  foo<span class="list">(<span class="quoted">'b</span>', function <span class="list">(<span class="keyword">b</span>)</span> &#123;</span><br><span class="line">    if <span class="list">(<span class="keyword">b</span>.error)</span> &#123;</span><br><span class="line">      throw new Error<span class="list">(<span class="keyword">b</span>.error)</span><span class="comment">;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    foo<span class="list">(<span class="quoted">'c</span>', function <span class="list">(<span class="keyword">c</span>)</span> &#123;</span><br><span class="line">      if <span class="list">(<span class="keyword">c</span>.error)</span> &#123;</span><br><span class="line">        throw new Error<span class="list">(<span class="keyword">c</span>.error)</span><span class="comment">;</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      console.log<span class="list">(<span class="keyword">a</span>, b, c)</span><span class="comment">;</span></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>使用Generator函数可以大大简化上面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">g</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">yield</span> foo(<span class="string">'a'</span>);</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">yield</span> foo(<span class="string">'b'</span>);</span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">yield</span> foo(<span class="string">'c'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(e);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>反过来，Generator函数内抛出的错误，也可以被函数体外的catch捕获。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">var</span> y = x.toUpperCase();</span><br><span class="line">  <span class="keyword">yield</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = foo();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">// &#123; value:3, done:false &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  it.next(<span class="number">42</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，第二个next方法向函数体内传入一个参数42，数值是没有toUpperCase方法的，所以会抛出一个TypeError错误，被函数体外的catch捕获。</p>
<p>一旦Generator执行过程中抛出错误，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了。</p>
<h3 id="yield*语句"><code>yield*</code>语句</h3><p>如果yield命令后面跟的是一个Iterable对象，需要在yield命令后面加上星号，表明它返回的是一个Iterable对象。这被称为<code>yield*</code>语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> delegatedIterator = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Hello!'</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Bye!'</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> delegatingIterator = (<span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Greetings!'</span>;</span><br><span class="line">  <span class="keyword">yield</span>* delegatedIterator;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'Ok, bye.'</span>;</span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> delegatingIterator) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "Greetings!</span></span><br><span class="line"><span class="comment">// "Hello!"</span></span><br><span class="line"><span class="comment">// "Bye!"</span></span><br><span class="line"><span class="comment">// "Ok, bye."</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，delegatingIterator是代理者，delegatedIterator是被代理者。由于<code>yield* delegatedIterator</code>语句得到的值，是一个Iterable对象，所以要用星号表示。运行结果就是使用一个Iterable对象，遍历了多个Generator函数，有递归的效果。</p>
<p><code>yield*</code>语句等同于在Generator函数内部，部署一个for…of循环。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span>* iter1;</span><br><span class="line">  <span class="keyword">yield</span>* iter2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">concat</span>(<span class="params">iter1, iter2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter1) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> value <span class="keyword">of</span> iter2) &#123;</span><br><span class="line">    <span class="keyword">yield</span> value;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码说明，<code>yield*</code>不过是for…of的一种简写形式，完全可以用后者替代前者。</p>
<p>如果<code>yield*</code>后面跟着一个数组，由于数组原生支持Iterable对象，因此就会遍历数组成员。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span><span class="params">()</span>&#123;</span></span><br><span class="line">  yield<span class="built_in">*</span> [<span class="string">"a"</span>, <span class="string">"b"</span>, <span class="string">"c"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">gen<span class="params">()</span>.next<span class="params">()</span> <span class="comment">// &#123; value:"a", done:false &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是Iterable对象。</p>
<p>如果被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"foo"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">var</span> v = <span class="keyword">yield</span> *foo();</span><br><span class="line">  <span class="built_in">console</span>.log( <span class="string">"v: "</span> + v );</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = bar();</span><br><span class="line"></span><br><span class="line">it.next(); <span class="comment">//</span></span><br><span class="line">it.next(); <span class="comment">//</span></span><br><span class="line">it.next(); <span class="comment">//</span></span><br><span class="line">it.next(); <span class="comment">// "v: foo"</span></span><br><span class="line">it.next(); <span class="comment">//</span></span><br></pre></td></tr></table></figure>
<p>上面代码在第四次调用next方法的时候，屏幕上会有输出，这是因为函数foo的return语句，向函数bar提供了返回值。</p>
<p><code>yield*</code>命令可以很方便地取出嵌套数组的所有成员。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterTree</span>(<span class="params">tree</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(tree)) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; tree.length; i++) &#123;</span><br><span class="line">      <span class="keyword">yield</span>* iterTree(tree[i]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> tree;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> tree = [ <span class="string">'a'</span>, [<span class="string">'b'</span>, <span class="string">'c'</span>], [<span class="string">'d'</span>, <span class="string">'e'</span>] ];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> x <span class="keyword">of</span> iterTree(tree)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// a</span></span><br><span class="line"><span class="comment">// b</span></span><br><span class="line"><span class="comment">// c</span></span><br><span class="line"><span class="comment">// d</span></span><br><span class="line"><span class="comment">// e</span></span><br></pre></td></tr></table></figure>
<p>下面是一个稍微复杂的例子，使用<code>yield*</code>语句遍历完全二叉树。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面是二叉树的构造函数，</span></span><br><span class="line"><span class="comment">// 三个参数分别是左树、当前节点和右树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Tree</span>(<span class="params">left, label, right</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.left = left;</span><br><span class="line">  <span class="keyword">this</span>.label = label;</span><br><span class="line">  <span class="keyword">this</span>.right = right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面是中序（inorder）遍历函数。</span></span><br><span class="line"><span class="comment">// 由于返回的是一个Iterator对象，所以要用generator函数。</span></span><br><span class="line"><span class="comment">// 函数体内采用递归算法，所以左树和右树要用yield*遍历</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">inorder</span>(<span class="params">t</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (t) &#123;</span><br><span class="line">    <span class="keyword">yield</span>* inorder(t.left);</span><br><span class="line">    <span class="keyword">yield</span> t.label;</span><br><span class="line">    <span class="keyword">yield</span>* inorder(t.right);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面生成二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">make</span>(<span class="params">array</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 判断是否为叶节点</span></span><br><span class="line">  <span class="keyword">if</span> (array.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> Tree(<span class="literal">null</span>, array[<span class="number">0</span>], <span class="literal">null</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Tree(make(array[<span class="number">0</span>]), array[<span class="number">1</span>], make(array[<span class="number">2</span>]));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> tree = make([[[<span class="string">'a'</span>], <span class="string">'b'</span>, [<span class="string">'c'</span>]], <span class="string">'d'</span>, [[<span class="string">'e'</span>], <span class="string">'f'</span>, [<span class="string">'g'</span>]]]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历二叉树</span></span><br><span class="line"><span class="keyword">var</span> result = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> node <span class="keyword">of</span> inorder(tree)) &#123;</span><br><span class="line">  result.push(node);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">result</span><br><span class="line"><span class="comment">// ['a', 'b', 'c', 'd', 'e', 'f', 'g']</span></span><br></pre></td></tr></table></figure>
<h3 id="作为对象属性的Generator函数">作为对象属性的Generator函数</h3><p>如果一个对象的属性是Generator函数，可以简写成下面的形式。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">obj =</span> &#123;</span><br><span class="line">  * myGeneratorMethod() &#123;</span><br><span class="line">    ···</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个Generator函数。</p>
<p>它的完整形式如下，与上面的写法是等价的。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  myGeneratorMethod: <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ···</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<h3 id="构造函数是Generator函数">构造函数是Generator函数</h3><p>这一节讨论一种特殊情况：构造函数是Generator函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">F</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.x = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="keyword">this</span>.y = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数F是一个构造函数，又是一个Generator函数。这时，使用new命令就无法生成F的实例了，因为F返回的是一个Iterator对象。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'next'</span> <span class="keyword">in</span> (new <span class="function"><span class="title">F</span><span class="params">()</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>那么，这个时候怎么生成对象实例呢？</p>
<p>我们知道，如果构造函数调用时，没有使用new命令，那么内部的this对象，绑定当前构造函数所在的对象（比如window对象）。因此，可以生成一个空对象，使用bind方法绑定F内部的this。这样，构造函数调用以后，这个空对象就是F的实例对象了。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;&#125;;</span><br><span class="line">var f = F.bind<span class="params">(obj)</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">f.next<span class="params">()</span>;</span><br><span class="line">f.next<span class="params">()</span>;</span><br><span class="line">f.next<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span><span class="params">(obj)</span>; <span class="comment">// &#123; x: 2, y: 3 &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个Iterator对象。这个对象执行三次next方法（因为F内部有两个yield语句），完成F内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。</p>
<h3 id="Generator函数推导">Generator函数推导</h3><p>ES7在数组推导的基础上，提出了Generator函数推导（Generator comprehension）。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> generator = <span class="function"><span class="keyword">function</span>* <span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="keyword">for</span> <span class="params">(let i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span> &#123;</span><br><span class="line">    yield i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> squared = <span class="params">( for <span class="params">(n of generator<span class="params">()</span>)</span> n * n )</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="comment">// let squared = Array.from(generator()).map(n =&gt; n * n);</span></span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span><span class="params">(...squared)</span>; <span class="comment">// 0 1 4 9 16 25</span></span><br></pre></td></tr></table></figure>
<p>“推导”这种语法结构，不仅可以用于数组，ES7将其推广到了Generator函数。for…of循环会自动调用Iterator对象的next方法，将返回值的value属性作为数组的一个成员。</p>
<p>Generator函数推导是对数组结构的一种模拟，它的最大优点是惰性求值，即直到真正用到时才会求值，这样可以保证效率。请看下面的例子。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="variable">bigArray =</span> new Array(<span class="number">100000</span>);</span><br><span class="line">for (<span class="keyword">let</span> <span class="variable">i =</span> <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">  bigArray[i] = i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="variable">first =</span> bigArray.<span class="built_in">map</span>(<span class="variable">n =</span>&gt; n * n)[<span class="number">0</span>];</span><br><span class="line">console.log(first);</span><br></pre></td></tr></table></figure></p>
<p>上面例子遍历一个大数组，但是在真正遍历之前，这个数组已经生成了，占用了系统资源。如果改用Generator函数推导，就能避免这一点。下面代码只在用到时，才会生成一个大数组。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> bigGenerator = <span class="function"><span class="keyword">function</span>* <span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="keyword">for</span> <span class="params">(let i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++)</span> &#123;</span><br><span class="line">    yield i;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">let</span> squared = <span class="params">( for <span class="params">(n of bigGenerator<span class="params">()</span>)</span> n * n )</span>;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span><span class="params">(squared.next<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Generator与状态机">Generator与状态机</h3><p>Generator是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ticking = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> clock = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (ticking)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Tick!'</span>);</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Tock!'</span>);</span><br><span class="line">  ticking = !ticking;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用Generator实现，就是下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> clock = <span class="function"><span class="keyword">function</span>*(<span class="params">_</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">yield</span> _;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Tick!'</span>);</span><br><span class="line">    <span class="keyword">yield</span> _;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Tock!'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的Generator实现与ES5实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。</p>
<h3 id="Generator与协程">Generator与协程</h3><p>协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。</p>
<ol>
<li><p><strong>协程与子例程的差异</strong></p>
<p> 传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。</p>
<p> 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。</p>
</li>
<li><p><strong>协程与普通线程的差异</strong></p>
<p> 不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。</p>
<p> 由于ECMAScript是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。</p>
<p> Generator函数是ECMAScript 6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”（semi-coroutine），意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。</p>
<p> 如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。</p>
</li>
</ol>
<h3 id="应用">应用</h3><p>Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。</p>
<p><strong>异步操作的同步化表达</strong></p>
<p>Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">loadUI</span><span class="params">()</span> &#123;</span></span><br><span class="line">  showLoadingScreen<span class="params">()</span>;</span><br><span class="line">  yield loadUIDataAsynchronously<span class="params">()</span>;</span><br><span class="line">  hideLoadingScreen<span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line">var loader = loadUI<span class="params">()</span>;</span><br><span class="line"><span class="comment">// 加载UI</span></span><br><span class="line">loader.next<span class="params">()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 卸载UI</span></span><br><span class="line">loader.next<span class="params">()</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，第一次调用loadUI函数时，该函数不会执行，仅返回一个Iterator对象。下一次对该Iterator对象调用next方法，则会显示Loading界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。</p>
<p>Ajax是典型的异步操作，通过Generator函数部署Ajax操作，可以用同步的方式表达。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function* main() &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="literal">result</span> = <span class="keyword">yield</span> request(<span class="string">"http://some.url"</span>);</span><br><span class="line">  <span class="keyword">var</span> resp = <span class="type">JSON</span>.parse(<span class="literal">result</span>);</span><br><span class="line">  console.log(resp.value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function request(url) &#123;</span><br><span class="line">  makeAjaxCall(url, function(response)&#123;</span><br><span class="line">    it.next(response);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> it = main();</span><br><span class="line">it.next();</span><br></pre></td></tr></table></figure>
<p>上面代码的main函数，就是通过Ajax操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield语句构成的表达式，本身是没有值的，总是等于undefined。</p>
<p>下面是另一个例子，通过Generator函数逐行读取文本文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> file = <span class="keyword">new</span> FileReader(<span class="string">"numbers.txt"</span>);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">while</span>(!file.eof) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="built_in">parseInt</span>(file.readLine(), <span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    file.close();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码打开文本文件，使用yield语句可以手动逐行读取文件。</p>
<p><strong>控制流管理</strong></p>
<p>如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">step1<span class="list">(<span class="keyword">function</span> <span class="list">(<span class="keyword">value1</span>)</span> &#123;</span><br><span class="line">  step2<span class="list">(<span class="keyword">value1</span>, function<span class="list">(<span class="keyword">value2</span>)</span> &#123;</span><br><span class="line">    step3<span class="list">(<span class="keyword">value2</span>, function<span class="list">(<span class="keyword">value3</span>)</span> &#123;</span><br><span class="line">      step4<span class="list">(<span class="keyword">value3</span>, function<span class="list">(<span class="keyword">value4</span>)</span> &#123;</span><br><span class="line">        // Do something with value4</span><br><span class="line">      &#125;)</span><span class="comment">;</span></span><br><span class="line">    &#125;)</span><span class="comment">;</span></span><br><span class="line">  &#125;)</span><span class="comment">;</span></span><br><span class="line">&#125;)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>采用Promise改写上面的代码。</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="transposed_variable">Q.</span>fcall(step1)</span><br><span class="line">  .<span class="keyword">then</span>(step2)</span><br><span class="line">  .<span class="keyword">then</span>(step3)</span><br><span class="line">  .<span class="keyword">then</span>(step4)</span><br><span class="line">  .<span class="keyword">then</span>(<span class="function"><span class="keyword">function</span> <span class="params">(value4)</span> &#123;</span></span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125;, <span class="function"><span class="keyword">function</span> <span class="params">(error)</span> &#123;</span></span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;)</span><br><span class="line">  .done();</span><br></pre></td></tr></table></figure>
<p>上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量Promise的语法。Generator函数可以进一步改善代码运行流程。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* longRunningTask() &#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> value1 = <span class="function"><span class="keyword">yield</span> <span class="title">step1</span>(<span class="params"></span>)</span>;</span><br><span class="line">    <span class="keyword">var</span> value2 = <span class="function"><span class="keyword">yield</span> <span class="title">step2</span>(<span class="params">value1</span>)</span>;</span><br><span class="line">    <span class="keyword">var</span> value3 = <span class="function"><span class="keyword">yield</span> <span class="title">step3</span>(<span class="params">value2</span>)</span>;</span><br><span class="line">    <span class="keyword">var</span> value4 = <span class="function"><span class="keyword">yield</span> <span class="title">step4</span>(<span class="params">value3</span>)</span>;</span><br><span class="line">    <span class="comment">// Do something with value4</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="comment">// Handle any error from step1 through step4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，使用一个函数，按次序自动执行所有步骤。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">scheduler<span class="params">(longRunningTask<span class="params">()</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">scheduler</span><span class="params">(task)</span> &#123;</span></span><br><span class="line">  setTimeout<span class="params">(function<span class="params">()</span> &#123;</span><br><span class="line">    var taskObj = task.next<span class="params">(task.value)</span>;</span><br><span class="line">    // 如果Generator函数未结束，就继续调用</span><br><span class="line">    if <span class="params">(!taskObj.done)</span> &#123;</span><br><span class="line">      task.value = taskObj.value</span><br><span class="line">      scheduler<span class="params">(task)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, <span class="number">0</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，yield语句是同步运行，不是异步运行（否则就失去了取代回调函数的设计目的了）。实际操作中，一般让yield语句返回Promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Q = <span class="built_in">require</span>(<span class="string">'q'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">delay</span>(<span class="params">milliseconds</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> deferred = Q.defer();</span><br><span class="line">  setTimeout(deferred.resolve, milliseconds);</span><br><span class="line">  <span class="keyword">return</span> deferred.promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> delay(<span class="number">100</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用Promise的函数库Q，yield语句返回的就是一个Promise对象。</p>
<p>多个任务按顺序一个接一个执行时，yield语句可以按顺序排列。多个任务需要并列执行时（比如只有A任务和B任务都执行完，才能执行C任务），可以采用数组的写法。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">parallelDownloads</span><span class="params">()</span> &#123;</span></span><br><span class="line">  <span class="built_in">let</span> [text1,text2] = yield [</span><br><span class="line">    taskA<span class="params">()</span>,</span><br><span class="line">    taskB<span class="params">()</span></span><br><span class="line">  ];</span><br><span class="line">  console.<span class="built_in">log</span><span class="params">(text1, text2)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，yield语句的参数是一个数组，成员就是两个任务taskA和taskB，只有等这两个任务都完成了，才会接着执行下面的语句。</p>
<p><strong>部署Iterable接口</strong></p>
<p>利用Generator函数，可以在任意对象上部署Iterable接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">iterEntries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> keys = <span class="built_in">Object</span>.keys(obj);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i=<span class="number">0</span>; i &lt; keys.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> key = keys[i];</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> myObj = &#123; foo: <span class="number">3</span>, bar: <span class="number">7</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, value] <span class="keyword">of</span> iterEntries(myObj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(key, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// foo 3</span></span><br><span class="line"><span class="comment">// bar 7</span></span><br></pre></td></tr></table></figure>
<p>上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了Iterable接口。</p>
<p>下面是一个对数组部署Iterable接口的例子，尽管数组原生具有这个接口。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">makeSimpleGenerator</span><span class="params">(array)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> nextIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(nextIndex &lt; <span class="keyword">array</span>.length)&#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">array</span>[nextIndex++];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> gen = makeSimpleGenerator([<span class="string">'yo'</span>, <span class="string">'ya'</span>]);</span><br><span class="line"></span><br><span class="line">gen.next().value <span class="comment">// 'yo'</span></span><br><span class="line">gen.next().value <span class="comment">// 'ya'</span></span><br><span class="line">gen.next().done  <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p><strong>作为数据结构</strong></p>
<p>Generator可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> *<span class="title">doStuff</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'hello.txt'</span>);</span><br><span class="line">  <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'world.txt'</span>);</span><br><span class="line">  <span class="keyword">yield</span> fs.readFile.bind(<span class="literal">null</span>, <span class="string">'and-such.txt'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码就是依次返回三个函数，但是由于使用了Generator函数，导致可以像处理数组那样，处理这三个返回的函数。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> <span class="params">(task of doStuff<span class="params">()</span>)</span> &#123;</span><br><span class="line">  <span class="comment">// task是一个函数，可以像回调函数那样使用它</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际上，如果用ES5表达，完全可以用数组模拟Generator的这种用法。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doStuff</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    fs.readFile.bind(<span class="literal">null</span>, <span class="string">'hello.txt'</span>),</span><br><span class="line">    fs.readFile.bind(<span class="literal">null</span>, <span class="string">'world.txt'</span>),</span><br><span class="line">    fs.readFile.bind(<span class="literal">null</span>, <span class="string">'and-such.txt'</span>)</span><br><span class="line">  ];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数，可以用一模一样的for…of循环处理！两相一比较，就不难看出Generator使得数据或者操作，具备了类似数组的接口。</p>
<h2 id="尾调用优化">尾调用优化</h2><p>尾调用（Tail Call）是函数式编程的一个重要概念，就是指某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span>&#123;</span></span><br><span class="line">  return g<span class="params">(x)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面三种情况都不是尾调用</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span>&#123;</span></span><br><span class="line">  <span class="built_in">let</span> y = g<span class="params">(x)</span>;</span><br><span class="line">  return y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span>&#123;</span></span><br><span class="line">  return g<span class="params">(x)</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span>&#123;</span></span><br><span class="line">  g<span class="params">(x)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一种情况等同于下面的代码。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span> &#123;</span></span><br><span class="line">  <span class="keyword">if</span> <span class="params">(x &gt; <span class="number">0</span>)</span> &#123;</span><br><span class="line">    return m<span class="params">(x)</span></span><br><span class="line">  &#125;</span><br><span class="line">  return n<span class="params">(x)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<p>“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span><span class="params">(a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span><span class="params">(b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的函数不会进行尾调用优化，因为内层函数inner用到了，外层函数addOne的内部变量one。</p>
<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n)</span> &#123;</span></span><br><span class="line">  <span class="keyword">if</span> <span class="params">(n === <span class="number">1</span>)</span> return <span class="number">1</span>;</span><br><span class="line">  return n <span class="built_in">*</span> factorial<span class="params">(n - <span class="number">1</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial<span class="params">(<span class="number">5</span>)</span> <span class="comment">//120</span></span><br></pre></td></tr></table></figure></p>
<p>对上面的递归优化<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function tailFactorial(<span class="keyword">n</span>, <span class="keyword">total</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">n</span> === 1) <span class="keyword">return</span> <span class="keyword">total</span>;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(<span class="keyword">n</span> - 1, <span class="keyword">n</span> * <span class="keyword">total</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function factorial(<span class="keyword">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(<span class="keyword">n</span>, 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure></p>
<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function currying(fn, <span class="keyword">n</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> function (<span class="keyword">m</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(this, <span class="keyword">m</span>, <span class="keyword">n</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function tailFactorial(<span class="keyword">n</span>, <span class="keyword">total</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">n</span> === 1) <span class="keyword">return</span> <span class="keyword">total</span>;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(<span class="keyword">n</span> - 1, <span class="keyword">n</span> * <span class="keyword">total</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, 1);</span><br><span class="line"></span><br><span class="line">factorial(5) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。</p>
<p>第二种方法就简单多了，就是采用ES6的函数默认值。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function factorial(<span class="keyword">n</span>, <span class="keyword">total</span> = 1) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">n</span> === 1) <span class="keyword">return</span> <span class="keyword">total</span>;</span><br><span class="line">  <span class="keyword">return</span> factorial(<span class="keyword">n</span> - 1, <span class="keyword">n</span> * <span class="keyword">total</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(5) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure></p>
<p>递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。</p>
<h2 id="ES7可能支持函數綁定">ES7可能支持函數綁定</h2><p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。</p>
<p>函数绑定运算符是并排的两个双引号（::），双引号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<h2 id="模块">模块</h2><p>在ES6之前，社区制定了一些模块加载方案，最主要的有CommonJS和AMD两种。前者用于服务器，后者用于浏览器。ES6在语言规格的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的CommonJS和AMD规范，成为浏览器和服务器通用的模块解决方案。</p>
<p>ES6模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS和AMD模块，都只能在运行时确定这些东西。比如，CommonJS模块就是对象，输入时必须查找对象属性。ES6模块不是对象，而是通过export命令显式指定输出的代码，输入时也采用静态命令的形式。所以，ES6可以在编译时就完成模块编译，效率要比CommonJS模块高。</p>
<p>模块功能由三个命令构成：export，import和module。export命令用于用户自定义模块，规定对外接口；import命令用于输入其他模块提供的功能，同时创造命名空间（namespace），防止函数名冲突；module用于整体输入其它模块的提供的功能。</p>
<p>简单实例<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lib/math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> pi = <span class="number">3.141593</span>;</span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> math <span class="keyword">from</span> <span class="string">"lib/math"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(math.pi);</span><br></pre></td></tr></table></figure></p>
<h3 id="export命令">export命令</h3><p>ES6允许将独立的JS文件作为模块，也就是说，允许一个JavaScript脚本文件调用另一个脚本文件。该文件内部的所有变量、函数、类，外部无法获取，必须使用export关键字输出，一种输出方式是只需要在原有声明变量、函数、类语句前加export，另一种方式是在export后使用大括号指定需要输出的变量、函数、类，并且中间用逗号分隔。下面是一个JS文件，里面使用export命令输出变量。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="literal">export</span> <span class="keyword">var</span> name = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="literal">export</span> <span class="keyword">var</span> year = <span class="number">1958</span>;</span><br></pre></td></tr></table></figure>
<p>另外一种写法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// profile.js</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'Michael'</span>;</span><br><span class="line"><span class="keyword">var</span> year = <span class="number">1958</span>;</span><br><span class="line"></span><br><span class="line"><span class="literal">export</span> &#123;name, year&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。</p>
<h3 id="import命令">import命令</h3><p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块（文件）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> &#123;name, year&#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setHeader</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">  element.textContent = name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码属于另一个文件main.js，import命令就用于加载profile.js文件，并从中输入变量。import命令接受一个对象（用大括号表示），里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。</p>
<p>如果想为输入的变量重新取一个名字，import语句中要使用as关键字，将输入的变量重命名。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name <span class="keyword">as</span> nickName &#125; <span class="keyword">from</span> <span class="string">'./profile'</span>;</span><br></pre></td></tr></table></figure>
<p>ES6支持多重加载，即所加载的模块中又加载其他模块。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="type">Vehicle</span> &#125; from './<span class="type">Vehicle</span>';</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Vehicle</span> &#123;</span></span><br><span class="line">  move () &#123;</span><br><span class="line">    console.log(<span class="keyword">this</span>.name + ' is spinning wheels...')</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export &#123; <span class="type">Car</span> &#125;</span><br></pre></td></tr></table></figure>
<p>如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> &#123; es6 <span class="keyword">as</span> <span class="keyword">default</span> &#125; from <span class="string">'./someModule'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">import</span> &#123; es6 &#125; <span class="keyword">from</span> <span class="string">'./someModule'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> es6;</span><br></pre></td></tr></table></figure>
<p>上面代码中，export和import语句可以结合在一起，写成一行。但是从可读性考虑，不建议采用这种写法，应该采用标准写法。</p>
<h3 id="模块的整体输入">模块的整体输入</h3><p>下面是一个circle.js文件，它输出两个方法area和circumference。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circle.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">area</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.PI * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">circumference</span>(<span class="params">radius</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * <span class="built_in">Math</span>.PI * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，main.js文件输入circle.js模块。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">import</span> <span class="built_in">*</span> as <span class="built_in">circle</span> from '<span class="built_in">circle</span>';</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span><span class="params">(<span class="string">"圆面积："</span> + circle.area<span class="params">(<span class="number">4</span>)</span>)</span>;</span><br><span class="line">console.<span class="built_in">log</span><span class="params">(<span class="string">"圆周长："</span> + circle.circumference<span class="params">(<span class="number">14</span>)</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="module命令">module命令</h3><p>module命令可以取代import语句，达到整体输入模块的作用。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line">module <span class="keyword">circle</span> from <span class="string">'circle'</span>;</span><br><span class="line"></span><br><span class="line">console.<span class="keyword">log</span>(<span class="string">"圆面积："</span> + <span class="keyword">circle</span>.area(<span class="number">4</span>));</span><br><span class="line">console.<span class="keyword">log</span>(<span class="string">"圆周长："</span> + <span class="keyword">circle</span>.circumference(<span class="number">14</span>));</span><br></pre></td></tr></table></figure>
<p>module命令后面跟一个变量，表示输入的模块定义在该变量上。</p>
<h3 id="export_default命令">export default命令</h3><p>使用import的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。</p>
<p>为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到<code>export default</code>命令，为模块指定默认输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码是一个模块文件<code>export-default.js</code>，它的默认输出是一个函数。</p>
<p>其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// import-default.js</span></span><br><span class="line"><span class="keyword">import</span> customName <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br><span class="line">customName(); <span class="comment">// 'foo'</span></span><br></pre></td></tr></table></figure>
<p>上面代码的import命令，可以用任意名称指向<code>export-default.js</code>输出的方法。需要注意的是，这时import命令后面，不使用大括号。</p>
<p>export default命令用在非匿名函数前，也是可以的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export-default.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者写成</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'foo'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> foo;</span><br></pre></td></tr></table></figure>
<p>上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。</p>
<p>下面比较一下默认输出和正常输出。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> crc32 <span class="keyword">from</span> <span class="string">'crc32'</span>;</span><br><span class="line"><span class="comment">// 对应的输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要使用大括号</span></span><br><span class="line"><span class="keyword">import</span> &#123; crc32 &#125; <span class="keyword">from</span> <span class="string">'crc32'</span>;</span><br><span class="line"><span class="comment">// 对应的输出</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">crc32</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p><code>export default</code>命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此<code>export deault</code>命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。</p>
<p>本质上，<code>export default</code>就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// modules.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * y;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; default &#125; <span class="keyword">from</span> <span class="string">'modules'</span>;</span><br></pre></td></tr></table></figure>
<p>有了<code>export default</code>命令，输入模块时就非常直观了，以输入jQuery模块为例。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> $ <span class="keyword">from</span> <span class="string">'jquery'</span>;</span><br></pre></td></tr></table></figure>
<p>如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> customName, &#123; otherMethod &#125; <span class="keyword">from</span> <span class="string">'./export-default'</span>;</span><br></pre></td></tr></table></figure>
<p>如果要输出默认的值，只需将值跟在<code>export default</code>之后即可。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="reserved">export</span> <span class="reserved">default</span> <span class="number">42</span>;</span><br></pre></td></tr></table></figure>
<p><code>export default</code>也可以用来输出类。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MyClass.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="keyword">import</span> MyClass <span class="keyword">from</span> <span class="string">'MyClass'</span></span><br><span class="line">let o = new MyClass();</span><br></pre></td></tr></table></figure>
<h3 id="模块的继承">模块的继承</h3><p>模块之间也可以继承。</p>
<p>假设有一个circleplus模块，继承了circle模块。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line"><span class="keyword">export</span> * from <span class="string">'circle'</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> e = <span class="number">2.71828182846</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中的“export *”，表示输出circle模块的所有属性和方法，export default命令定义模块的默认方法。</p>
<p>这时，也可以将circle的属性或方法，改名后再输出。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// circleplus.js</span></span><br><span class="line">export &#123; area <span class="keyword">as</span> circleArea &#125; <span class="keyword">from</span> <span class="string">'circle'</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。</p>
<p>加载上面模块的写法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.js</span></span><br><span class="line"><span class="built_in">module</span> math from <span class="string">"circleplus"</span>;</span><br><span class="line"><span class="keyword">import</span> exp <span class="keyword">from</span> <span class="string">"circleplus"</span>;</span><br><span class="line"><span class="built_in">console</span>.log(exp(math.e));</span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>import exp</code>表示，将circleplus模块的默认方法加载为exp方法。</p>
<h3 id="ES6模块的转码">ES6模块的转码</h3><p>浏览器目前还不支持ES6模块，为了现在就能使用，可以将转为ES5的写法。</p>
<h4 id="ES6_module_transpiler">ES6 module transpiler</h4><p><a href="https://github.com/esnext/es6-module-transpiler" target="_blank" rel="external">ES6 module transpiler</a>是square公司开源的一个转码器，可以将ES6模块转为CommonJS模块或AMD模块的写法，从而在浏览器中使用。</p>
<p>首先，安装这个转玛器。</p>
<figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$ </span>npm install -g es6-<span class="class"><span class="keyword">module</span>-<span class="title">transpiler</span></span></span><br></pre></td></tr></table></figure>
<p>然后，使用<code>compile-modules convert</code>命令，将ES6模块文件转码。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ compile-modules convert file1<span class="class">.js</span> file2.js</span><br></pre></td></tr></table></figure>
<p>o参数可以指定转码后的文件名。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ compile-modules convert -o out<span class="class">.js</span> file1.js</span><br></pre></td></tr></table></figure>
<h4 id="SystemJS">SystemJS</h4><p>另一种解决方法是使用<a href="https://github.com/systemjs/systemjs" target="_blank" rel="external">SystemJS</a>。它是一个垫片库（polyfill），可以在浏览器内加载ES6模块、AMD模块和CommonJS模块，将其转为ES5格式。它在后台调用的是Google的Traceur转码器。</p>
<p>使用时，先在网页内载入system.js文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"system.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后，使用<code>System.import</code>方法加载模块文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="actionscript"></span><br><span class="line">  System.<span class="keyword">import</span>(<span class="string">'./app'</span>);</span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中的<code>./app</code>，指的是当前目录下的app.js文件。它可以是ES6模块文件，<code>System.import</code>会自动将其转码。</p>
<p>需要注意的是，<code>System.import</code>使用异步加载，返回一个Promise对象，可以针对这个对象编程。下面是一个模块文件。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app/es6-file.js:</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> q &#123;</span><br><span class="line">  <span class="constructor"><span class="keyword">constructor</span>() </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.es6 = <span class="string">'hello'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后，在网页内加载这个模块文件。</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">script</span>&gt;</span><span class="stylus"></span><br><span class="line">System.<span class="function"><span class="title">import</span><span class="params">(<span class="string">'app/es6-file'</span>)</span></span>.<span class="function"><span class="title">then</span><span class="params">(function(m)</span></span> </span></span><span class="expression">&#123;</span><br><span class="line">  <span class="variable">console.log</span>(<span class="variable">new</span> <span class="variable">m.q</span>()<span class="variable">.es</span>6); /<span class="end-block">/ hello</span></span><br><span class="line">&#125;</span><span class="xml"><span class="dns">)<span class="comment">;</span></span><br><span class="line"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="错误处理">错误处理</h2><h3 id="try-catch_语句">try-catch 语句</h3><p>ECMA-262 第 3 版引入了 try-catch 语句,作为 JavaScript 中处理异常的一种标准方式。基本的语法如下所示,显而易见,这与 Java 中的 try-catch 语句是完全相同的。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line"><span class="comment">// 可能会导致错误的代码</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(<span class="keyword">error</span>)&#123;</span><br><span class="line"><span class="comment">// 在错误发生时怎么处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>也就是说,我们应该把所有可能会抛出错误的代码都放在 try 语句块中,而把那些用于错误处理的代码放在 catch 块中。如果 try 块中的任何代码发生了错误,就会立即退出代码执行过程,然后接着执行 catch 块。此时, catch 块会接收到一个包含错误信息的对象。</p>
<p>内置使用内置的Error对象具有两个标准属性name和message</p>
<ul>
<li><strong>name</strong>：错误名称</li>
<li><strong>message</strong>：错误提示信息</li>
<li><strong>stack</strong>：错误的堆栈（非标准属性，但是大多数平台支持）</li>
</ul>
<p>使用 try-catch 最适合处理那些我们无法控制的错误。假设你在使用一个大型 JavaScript 库中的函数,该函数可能会有意无意地抛出一些错误。由于我们不能修改这个库的源代码,所以大可将对该函数的调用放在 try-catch 语句当中,万一有什么错误发生,也好恰当地处理它们。</p>
<p>在明明白白地知道自己的代码会发生错误时,再使用 try-catch 语句就不太合适了。例如,如果传递给函数的参数是字符串而非数值,就会造成函数出错,那么就应该先检查参数的类型,然后再决定如何去做。在这种情况下,不应用使用 try-catch 语句。</p>
<h3 id="finally_子句">finally 子句</h3><p>finally都是可选的，但 finally 子句一经使用,其代码无论如何都会执行。换句话说, try 语句块中的代码全部正常执行, finally 子句会执行;如果因为出错而执行了 catch 语句块, finally 子句照样还会执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'error'</span>);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x='</span> + x);</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    x = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'x='</span> + x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码说明，即使有return语句在前，finally代码块依然会得到执行，且在其执行完毕后，并不影响return语句要返回的值。</p>
<h3 id="错误类型">错误类型</h3><p>ECMA-262 定义了下列 7 种错误类型: Error,EvalError,RangeError,ReferenceError,SyntaxError,TypeError,URIError</p>
<h4 id="EvalError">EvalError</h4><p>如果没有把 eval() 当成函数调用,就会抛出EvalError错误。一些浏览器不会正确抛出这个错误。</p>
<h4 id="RangeError">RangeError</h4><p>RangeError是当一个值超出有效范围时发生的错误。主要有几种情况，一是数组长度为负数，二是Number对象的方法参数超出范围，以及函数堆栈超过最大值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(-<span class="number">1</span>);</span><br><span class="line">(<span class="number">1234</span>).toExponential(<span class="number">21</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Array</span>(<span class="built_in">Number</span>.MAX_VALUE);</span><br></pre></td></tr></table></figure>
<h4 id="ReferenceError">ReferenceError</h4><p>ReferenceError是引用一个不存在的变量时发生的错误。另一种触发场景是，将一个值分配给无法分配的对象，比如对函数的运行结果或者this赋值。</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">undefinedVar<span class="comment">;</span></span><br><span class="line">console.log() = 1<span class="comment">;</span></span><br><span class="line">this = 1<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<h4 id="SyntaxError">SyntaxError</h4><p>SyntaxError是解析代码时发生的语法错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量名错误</span></span><br><span class="line"><span class="keyword">var</span> <span class="number">1</span>a;</span><br><span class="line"><span class="comment">// 缺少括号</span></span><br><span class="line"><span class="built_in">console</span>.log <span class="string">'hello'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="TypeError">TypeError</h4><p>TypeError是变量或参数不是预期类型时发生的错误。比如，对字符串、布尔值、数值等原始类型的值使用new命令，就会抛出这种错误，因为new命令的参数应该是一个构造函数。访问不存在的方法时也会抛出该错误。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="number">123</span></span><br><span class="line"><span class="keyword">var</span> obj = &#123;&#125;;</span><br><span class="line">obj.unknownMethod()</span><br></pre></td></tr></table></figure>
<h4 id="URIError">URIError</h4><p>URIError是URI相关函数的参数不正确时抛出的错误，主要涉及encodeURI()、decodeURI()、encodeURIComponent()、decodeURIComponent()、escape()和unescape()这六个函数。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">decodeURI</span><span class="params">(<span class="string">'%2'</span>)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="抛出错误">抛出错误</h3><p>与 try-catch 语句相配的还有一个 throw 操作符,用于随时抛出自定义错误。抛出错误时,必须要给 throw 操作符指定一个值,这个值是什么类型,没有要求。下列代码都是有效的。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">12345</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"Hello world!"</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">throw</span> &#123; <span class="string">name:</span> <span class="string">"JavaScript"</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>在遇到 throw 操作符时,代码会立即停止执行。仅当有 try-catch 语句捕获到被抛出的值时,代码才会继续执行。</p>
<p>通过使用某种内置错误类型,可以更真实地模拟浏览器错误。每种错误类型的构造函数接收一个参数,即实际的错误消息。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"error"</span>);</span><br></pre></td></tr></table></figure>
<p>这行代码抛出了一个通用错误,带有一条自定义错误消息。浏览器会像处理自己生成的错误一样,来处理这行代码抛出的错误。</p>
<p>在创建自定义错误消息时最常用的错误类型是 Error 、 RangeError 、 ReferenceError 和 TypeError 。</p>
<p>另外,利用原型链还可以通过继承 Error 来创建自定义错误类型</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserError</span>(<span class="params">message</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.message = message || <span class="string">"默认信息"</span>;</span><br><span class="line">   <span class="keyword">this</span>.name = <span class="string">"UserError"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">UserError.prototype = <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">UserError.prototype.constructor = UserError;</span><br></pre></td></tr></table></figure>
<p>浏览器对待继承自 Error 的自定义错误类型,就像对待其他错误类型一样。如果要捕获自己抛出的错误并且把它与浏览器错误区别对待的话,创建自定义错误是很有用的。</p>
<p>要针对函数为什么会执行失败给出更多信息,抛出自定义错误是一种很方便的方式。应该在出现某种特定的已知错误条件,导致函数无法正常执行时抛出错误。换句话说,浏览器会在某种特定的条件下执行函数时抛出错误。</p>
<p>说到抛出错误与捕获错误,我们认为只应该捕获那些你确切地知道该如何处理的错误。捕获错误的目的在于避免浏览器以默认方式处理它们;而抛出错误的目的在于提供错误发生具体原因的消息。</p>
<h3 id="错误(_error_)事件">错误( error )事件</h3><p>任何没有通过 try-catch 处理的错误都会触发 window 对象的 error 事件。在任何 Web 浏览器中, onerror 事件处理程序都不会创建 event 对象,但它可以接收三个参数:错误消息、错误所在的 URL 和行号。多数情况下,只有错误消息有用,因为 URL 只是给出了文档的位置,而行号所指的代码行既可能出自嵌入的 JavaScript 代码,也可能出自外部的文件。</p>
<p>只要发生错误,无论是不是浏览器生成的,都会触发 error 事件,并执行这个事件处理程序。然后,浏览器默认的机制发挥作用,像往常一样显示出错误消息。像下面这样在事件处理程序中返回false ,可以阻止浏览器报告错误的默认行为。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.onerror = <span class="function"><span class="keyword">function</span>(<span class="params">message, url, line</span>)</span>&#123;</span><br><span class="line">    alert(message);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>通过返回 false ,这个函数实际上就充当了整个文档中的 try-catch 语句,可以捕获所有无代码处理的运行时错误。这个事件处理程序是避免浏览器报告错误的最后一道防线,理想情况下,只要可能就不应该使用它。只要能够适当地使用 try-catch 语句,就不会有错误交给浏览器,也就不会触发error 事件。</p>
<p>图像也支持 error 事件。只要图像的 src 特性中的 URL 不能返回可以被识别的图像格式,就会触发 error 事件。</p>
<h3 id="常见的错误类型">常见的错误类型</h3><p>错误处理的核心,是首先要知道代码里会发生什么错误。由于 JavaScript 是松散类型的,而且也不会验证函数的参数,因此错误只会在代码运行期间出现。一般来说,需要关注三种错误:</p>
<ul>
<li>类型转换错误</li>
<li>数据类型错误</li>
<li>通信错误</li>
</ul>
<p>类型转换错误发生在使用某个操作符,或者使用其他可能会自动转换值的数据类型的语言结构时。在使用相等(==)和不相等(!=)操作符,或者在 if 、 for 及 while 等流控制语句中使用非布尔值时, 最常发生类型转换错误。强烈建议使用全等操作符（===,!==）。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">if</span> (str3)&#123; <span class="comment">//绝对不要这样!!!</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">if</span> (typeof str3 == <span class="string">"string"</span>)&#123;<span class="comment">//合理的比较</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>JavaScript 是松散类型的,也就是说,在使用变量和函数参数之前,不会对它们进行比较以确保它们的数据类型正确。为了保证不会发生数据类型错误,只能依靠开发人员编写适当的数据类型检测代码。在将预料之外的值传递给函数的情况下,最容易发生数据类型错误。大体上来说,基本类型的值应该使用 typeof 来检测,而对象的值则应该使用 instanceof 来检测。</p>
<p>JavaScript 与服务器之间的任何一次通信,都有可能会产生错误。</p>
<p>第一种通信错误与格式不正确的 URL 或发送的数据有关。最常见的问题是在将数据发送给服务器之前,没有使用 encodeURIComponent() 对数据进行编码。</p>
<p>对于查询字符串,应该记住必须要使用 encodeURIComponent() 方法。为了确保这一点,有时候可以定义一个处理查询字符串的函数,例如:<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addQueryStringArg</span><span class="params">(url, name, value)</span>&#123;</span></span><br><span class="line">    <span class="keyword">if</span> <span class="params">(url.indexOf<span class="params">(<span class="string">"?"</span>)</span> == -<span class="number">1</span>)</span>&#123;</span><br><span class="line">        url += <span class="string">"?"</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        url += <span class="string">"&amp;"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    url += encodeURIComponent<span class="params">(name)</span> + <span class="string">"="</span> + encodeURIComponent<span class="params">(value)</span>;</span><br><span class="line">    return url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="区分致命错误和非致命错误">区分致命错误和非致命错误</h3><ul>
<li>非致命错误<br>  *不影响用户的主要任务;<ul>
<li>只影响页面的一部分;</li>
<li>可以恢复;</li>
<li>重复相同操作可以消除错误。</li>
</ul>
</li>
<li>致命错误<ul>
<li>应用程序根本无法继续运行;</li>
<li>错误明显影响到了用户的主要操作;</li>
<li>会导致其他连带错误。</li>
</ul>
</li>
</ul>
<h3 id="把错误记录到服务器">把错误记录到服务器</h3><p>可以把错误回写到服务器，标明来自前端。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">logError</span>(<span class="params">sev, msg</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> img = <span class="keyword">new</span> Image();</span><br><span class="line">    img.src = <span class="string">"log.php?sev="</span> + <span class="built_in">encodeURIComponent</span>(sev) + <span class="string">"&amp;msg="</span> +</span><br><span class="line">    <span class="built_in">encodeURIComponent</span>(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个 logError() 函数接收两个参数:表示严重程度的数值或字符串(视所用系统而异)及错误消息。其中,使用了 Image 对象来发送请求,这样做非常灵活,主要表现如下几方面。</p>
<ul>
<li>所有浏览器都支持 Image 对象,包括那些不支持 XMLHttpRequest 对象的浏览器。</li>
<li>可以避免跨域限制。通常都是一台服务器要负责处理多台服务器的错误,而这种情况下使用XMLHttpRequest 是不行的。</li>
<li>在记录错误的过程中出问题的概率比较低。大多数 Ajax 通信都是由 JavaScript 库提供的包装函数来处理的,如果库代码本身有问题,而你还在依赖该库记录错误,可想而知,错误消息是不可能得到记录的。</li>
</ul>
<h1 id="变量、作用域和内存问题">变量、作用域和内存问题</h1><h2 id="基本类型和引用类型的值">基本类型和引用类型的值</h2><p>引用类型的值是保存在内存中的对象。与其他语言不同，JavaScript不允许直接访问内存中的位置，也就是说不能直接操作对象的内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象（和Java类似）。为此，引用类型的值是按引用访问的</p>
<p>很多语言中，字符串以对象的形式来表示，因此被认为是引用类型的。ECMAScript放弃了这一传统。</p>
<p>ECMAScript 变量可能包含两种不同数据类型的值：基本类型值和引用类型值。基本类型值指的是简单的数据段，而引用类型值指那些可能由多个值构成的对象。</p>
<p>我们不能给基本类型的值添加属性，尽管这样做不会导致任何错误</p>
<p>ECMAScript 中所有函数的参数都是按值传递的</p>
<p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一个对象。复制操作结束后，两个变量实际上将引用同一个对象。</p>
<p>在向参数传递基本类型的值时，被传递的值会被复制给一个局部变量（即命名参数，或者用ECMAScript的概念来说，就是 arguments 对象中的一个元素）。在向参数传递引用类型的值时，会把这个值在内存中的地址复制给一个局部变量，因此这个局部变量的变化会反映在函数的外部</p>
<p>如果使用instanceof 操作符检测基本类型的值，则该操作符始终会返回false，因为基本类型不是对象。</p>
<p>如果变量的值是一个对象或null，则typeof操作符会返回”object”</p>
<p>ECMA-262规定任何在内部实现[[Call]]方法的对象都应该在应用 typeof 操作符时返回”function”。由于Safari 5及之前版本和Chrome 7及之前版本浏览器中的正则表达式也实现了这个方法，因此对正则表达式应用 typeof 会返回”function”。在IE和Firefox中，对正则表达式应用typeof会返回”object”。</p>
<h2 id="执行环境及作用域">执行环境及作用域</h2><p>标识符解析是沿着作用域链一级一级地搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级地向后回溯，直至找到标识符为止（如果找不到标识符，通常会导致错误发生）。</p>
<p>执行环境定义了变量或函数有权访问的其他数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象（variable object），环境中定义的所有变量和函数都保存在这个对象中。虽然我们编写的代码无法访问这个对象，但解析器在处理数据时会在后台使用它。 全局执行环境是最外围的一个执行环境。根据 ECMAScript实现所在的宿主环境不同，表示执行环境的对象也不一样。在Web浏览器中，全局执行环境被认为是 window 对象，因此所有全局变量和函数都是作为window对象的属性和方法创建的。某个执行环境中的所有代码执行完毕后，该环境被销毁，保存在其中的所有变量和函数定义也随之销毁（全局执行环境直到应用程序退出——例如关闭网页或浏览器——时才会被销毁）。 每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript 程序中的执行流正是由这个方便的机制控制着。 当代码在一个环境中执行时，会创建变量对象的一个作用域链（scope chain）。作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。如果这个环境是函数，则将其活动对象（activation object）作为变量对象。活动对象在最开始时只包含一个变量，即arguments对象（这个对象在全局环境中是不存在的）。作用域链中的下一个变量对象来自包含（外部）环境，而再下一个变量对象则来自下一个包含环境。这样，一直延续到全局执行环境；全局执行环境的变量对象始终都是作用域链中的最后一个对象。</p>
<p>内部环境可以通过作用域链访问所有的外部环境，但外部环境不能访问内部环境中的任何变量和函数。这些环境之间的联系是线性、有次序的。每个环境都可以向上搜索作用域链，以查询变量和函数名；但任何环境都不能通过向下搜索作用域链而进入另一个执行环境。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">changeColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">swapColors</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>作用域链中包含 swapColors-&gt;changeColor-&gt;window三个对象</p>
<h3 id="延长作用域链">延长作用域链</h3><p>当执行流进入下列任何一个语句时，作用域链就会得到加长：</p>
<ul>
<li>try-catch语句的catch块；</li>
<li>with语句。</li>
</ul>
<p>这两个语句都会在作用域链的前端添加一个变量对象。对with语句来说，会将指定的对象添加到作用域链中。对catch语句来说，会创建一个新的变量对象，其中包含的是被抛出的错误对象的声明</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">buildUrl</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> qs = <span class="string">'?debug=true'</span>;</span><br><span class="line">  <span class="keyword">with</span>(location) &#123;</span><br><span class="line">    <span class="keyword">var</span> url = href + qs;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>with 语句接收的是location 对象，因此其变量对象中就包含了location 对象的所有属性和方法，而这个变量对象被添加到了作用域链的前端</p>
<h3 id="JavaScript没有块级作用域">JavaScript没有块级作用域</h3><ul>
<li><p>声明变量<br>  在函数内部，最接近的环境就是函数的局部环境；在with语句中，最接近的环境是函数环境。如果初始化变量时没有使用var声明，该变量会自动被添加到全局环境。</p>
<p>  严格模式下，初始化未经声明的变量会导致错误。建议还是要用var声明变量，当然可以边声明边初始化。</p>
</li>
<li><p>查询标识符<br>  搜索过程从作用域链的前端开始，向上逐级查询与给定名字匹配的标识符。</p>
<p>  如果局部环境中存在着同名标识符，就不会使用位于父环境中的标识符</p>
  <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> color = <span class="string">'blue'</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getColor</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> color = <span class="string">'red'</span>;</span><br><span class="line">  <span class="keyword">return</span> color;</span><br><span class="line">&#125;</span><br><span class="line">alert(getColor());</span><br></pre></td></tr></table></figure>
<p>  位于局部变量 color 的声明之后的代码，如果不使用 window.color 都无法访问全局 color变量。</p>
</li>
</ul>
<p>ECMASctipt6中let实际上为JavaScript增加了块级作用域。另外，ES6也规定，函数本身的作用域，在其所在的块级作用域之内。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure></p>
<p>上面代码在ES5中运行，会得到“I am inside!”，但是在ES6中运行，会得到“I am outside!”。这是因为ES5存在函数提升，不管会不会进入if代码块，函数声明都会提升到当前作用域的顶部，得到执行；而ES6支持块级作用域，不管会不会进入if代码块，其内部声明的函数皆不会影响到作用域的外部。</p>
<p>需要注意的是，如果在严格模式下，函数只能在顶层作用域和函数内声明，其他情况（比如if代码块、循环代码块）的声明都会报错。</p>
<h2 id="垃圾收集">垃圾收集</h2><h3 id="标记清除">标记清除</h3><p>JavaScript 中最常用的垃圾收集方式是标记清除（mark-and-sweep）。</p>
<h3 id="引用计数">引用计数</h3><p>另一种不太常见的垃圾收集策略叫做引用计数（reference counting）。</p>
<p>IE中的COM对象的垃圾收集机制采用的就是引用计数策略，只要在IE中涉及COM对象，就会存在循环引用的问题</p>
<p>循环引用指的是对象A中包含一个指向对象B的指针，而对象B中也包含一个指向对象A的引用。即使A、B不再被使用，但是由于其引用计数不为0，并不会被释放。</p>
<p>IE9把BOM和DOM对象都转换成了真正的JavaScript对象。</p>
<h3 id="性能问题">性能问题</h3><p>垃圾收集器是周期性运行的，而且如果为变量分配的内存数量很可观，那么回收工作量也是相当大的。</p>
<h3 id="管理内存">管理内存</h3><p>一旦数据不再有用，最好通过将其值设置为 null 来释放其引用——这个做法叫做解除引用（dereferencing）。这一做法适用于大多数全局变量和全局对象的属性。局部变量会在它们离开执行环境时自动被解除引用</p>
]]></content>
    <summary type="html">
    <![CDATA[JavaScript 基本语法，ECMAScript 6，语法，变量，数据类型，操作符，语句，函数，箭头函数，Generator函数，尾调用优化，模块，错误处理，基本类型和引用类型，执行环境和作用域，垃圾回收]]>
    
    </summary>
    
      <category term="JavaScript" scheme="http://howiefh.github.io/tags/JavaScript/"/>
    
      <category term="JavaScript" scheme="http://howiefh.github.io/categories/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java Web 笔记]]></title>
    <link href="http://howiefh.github.io/2015/08/10/java-web/"/>
    <id>http://howiefh.github.io/2015/08/10/java-web/</id>
    <published>2015-08-10T02:21:47.000Z</published>
    <updated>2015-08-28T16:04:26.000Z</updated>
    <content type="html"><![CDATA[<p>这篇记录一下浏览器的请求过程，NIO，字符编码等。<br><a id="more"></a></p>
<h2 id="一次请求过程">一次请求过程</h2><ol>
<li>浏览器查找域名的 IP 地址<br> 这一步包括 DNS 具体的查找过程，会依次从浏览器缓存、系统缓存、hosts中查找，如果这个过程中有一个地方有结果，查询就结束了，否则向本地域名服务器（LDNS）发送DNS请求（UDP）；如果LDNS没有命中，LDNS直接向Root Server域名服务器请求解析，根域名服务器会返回给LDNS一个所查询的主域名服务器（gTLD Server，.com,.cn,.org等）地址；本地域名服务器再向gTLD服务器发送请求，gTLD服务器会返回此域名对应的Name Server域名服务器（就是你注册的域名服务器）的地址，Name Server会查询存储的域名、IP映射表，然后返回IP和TTL值（这个值用来指定DNS缓存时间）；最后LDNS Server缓存结果并将结果返回给用户。Name Server 也可能会有多级。<br> Linux和Windows下<code>nslookup</code>，Linux下<code>dig</code>可以跟踪DNS解析过程。<br> 如果域名对应的IP地址变了，但是本地还有缓存，会造成访问不了的问题，可以清除缓存的域名，Windows下可以<code>ipconfig /flushdns</code>，Linux下<code>/etc/init.d/nscd restart</code><br> JVM也会缓存DNS解析结果，是通过InetAddress类完成的，这个类最好是使用单例模式，否则没有缓存每次都解析会很耗时。<br> 域名解析方式<ul>
<li>A 记录，多个域名可以解析岛一个IP地址，不能将一个域名解析到多个IP。如taobao.com指定到110.75.115.70</li>
<li>MX 记录，Mail Exchange，可将摸个域名下的邮件服务器指向自己的Mail Server。</li>
<li>CNAME 记录，Canonical Name别名。如指定xxx.github.io的别名xxx.com</li>
<li>NS 记录，为某域名指定DNS域名服务器。</li>
<li>TXT 记录，为某个主机或域名设置说明，如xxx.com的TXT记录为XXX的博客</li>
</ul>
</li>
<li>浏览器根据解析得到的IP地址向 web 服务器发送一个 HTTP 请求<br> 通过DNS获取到IP后，目标IP和本机IP分别与子网掩码相与的结果相同，那么它们在一个子网，那么通过ARP协议可以查到目标主机的MAC地址，否则的话，需要通过网关转发，也就是目标MAC是网关的MAC。<br> 请求需要进行编码，生成一个HTTP数据包，依次打上TCP、IP、以太网协议的头部。其中TCP头部主要信息是本机端口和目标端口号等信息，用于标识同一个主机的不同进程，对于HTTP协议，服务器端的默认端口号是80，本机浏览器的话生成一个1024到65535之间的端口号。IP头部主要包含本地IP和目标IP等信息。以太网协议头部主要是双方的MAC地址，目标MAC可以由第一条所诉方法得到。以太网数据包的数据部分，最大长度为1500字节，所以如果IP包太大的话还要拆包，比如IP包5000字节，要分为4包，每一包都包含一个IP头部。<br> 服务器接收请求就要层层解包，对于HTTP包要进行解码，解码时如果编码不对的话就有可能乱码了。</li>
<li>服务器可能有很多，由哪台来处理请求，还需要负载均衡设备来平均分配所有用户的请求。<br> 负载均衡，即对工作任务进行平衡，分摊到多个操作单元上执行，如图片服务器，应用服务器。可分为链路负载均衡（通过DNS解析成不同IP，用户根据这个IP访问不同的服务器，由于中间没有代理，其特点是快，但是如果某台服务器挂了，可能造成用户无法访问的问题），集群负载均衡，操作系统负载均衡（通过硬中断和软中断实现）<br> 集群负载均衡又分为硬件负载均衡和软件负载均衡，前者非常贵，不嫩能够进行动态扩容，后者成本低，但需要多次代理，增加了延时。</li>
<li>请求的数据可能存储在分布式缓存或者静态文件再或者数据库中，数据库中。如果请求的数据是静态文件，如果在CDN上，那么CDN服务器又会处理这个用户的请求。如果在数据库中需要向数据库发起查询请求。<br> CDN, Content Delivery Network，一个比喻：CDN = 镜像+缓存+整体负载均衡。用户访问离他最近节点的服务器的内容。通过DNS迭代解析，会返回公司的DNS解析服务器，它又会指定DNS负载均衡器，由其决定用户访问最近的CDN节点。<br> 如果CDN节点没有资源，会去源站请求，然后缓存并返回给用户。</li>
<li>服务器返回一个 HTTP 响应，如果返回状态码304，浏览器可以直接使用之前缓存的资源。对于内容响应，浏览器需要进行响应解码，渲染显示。<br> 缓存机制<ul>
<li>Expires，指定一个时间，告诉浏览器，在此之前可以直接使用缓存而不需要请求，当然F5还是会去请求</li>
<li>Cache-control，更细致的控制缓存，比Expires优先级高。<ul>
<li>Public指示响应可被任何缓存区缓存。</li>
<li>Private指示对于单个用户的整个或部分响应消息，不能被共享缓存处理。这允许服务器仅仅描述当用户的部分响应消息，此响应消息对于其他用户的请求无效。</li>
<li>no-cache指示请求或响应消息不能缓存</li>
<li>no-store用于防止重要的信息被无意的发布。在请求消息中发送将使得请求和响应消息都不使用缓存。</li>
<li>max-age指示客户机可以接收生存期不大于指定时间（以秒为单位）的响应。</li>
<li>min-fresh指示客户机可以接收响应时间小于当前时间加上指定时间的响应。</li>
<li>max-stale指示客户机可以接收超出超时期间的响应消息。如果指定max-stale消息的值，那么客户机可以接收超出超时期指定值之内的响应消息。</li>
</ul>
</li>
<li>Last-Modified/If-Modified-Since，Last-Modified标示这个响应资源的最后修改时间。当资源过期时（使用Cache-Control标识的max-age），发现资源具有Last-Modified声明，则再次向web服务器请求时带上头 If-Modified-Since，web服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对，判断是否可以继续使用缓存资源。</li>
<li>Etag/If-None-Match，Etag/If-None-Match也要配合Cache-Control使用。Apache中，ETag的值，默认是对文件的索引节（INode），大小（Size）和最后修改时间（MTime）进行Hash后得到的。当资源过期时（使用Cache-Control标识的max-age），发现资源具有Etag声明，则再次向web服务器请求时带上头If-None-Match （Etag的值）。web服务器根据If-None-Match 决定是否使用缓存。<br>Last-Modified标注的最后修改只能精确到秒级，如果一秒内资源改变了，却还是使用之前的缓存，这时就需要Etag来控制缓存了。Last-Modified与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。<br>Ctrl+F5快捷键刷新页面，将会在头部加上<code>Pragma:no-cache</code>和<code>Cache-Control:no-cache</code>，从而获取最新的资源。</li>
</ul>
</li>
</ol>
<h2 id="NIO">NIO</h2><table>
<thead>
<tr>
<th>IO</th>
<th>NIO</th>
</tr>
</thead>
<tbody>
<tr>
<td>面向流</td>
<td>面向缓冲</td>
</tr>
<tr>
<td>阻塞IO</td>
<td>非阻塞IO</td>
</tr>
<tr>
<td>无</td>
<td>选择器</td>
</tr>
</tbody>
</table>
<p>原来的 I/O 库(在 <code>java.io.*</code>中) 与 NIO 最重要的区别是数据打包和传输的方式。原来的 I/O 以流的方式处理数据，而 NIO 以块的方式处理数据。NIO快得多</p>
<p><code>java.io.*</code> 已经以 NIO 为基础重新实现了，所以现在它可以利用 NIO 的一些特性。</p>
<p>通道 和 缓冲区 是 NIO 中的核心对象，几乎在每一个 I/O 操作中都要使用它们。</p>
<p>NIO中的三个概念Buffer，Channel 和 Selector，下面是一个示例<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">public void selector<span class="params">()</span> throws IOException &#123;</span><br><span class="line">    ByteBuffer buffer = ByteBuffer.allocate<span class="params">(<span class="number">1024</span>)</span>;</span><br><span class="line">    <span class="comment">// 1. 调用 Selector 的静态工厂创建一个选择器</span></span><br><span class="line">    Selector selector = Selector.open<span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 2. 创建一个服务端的 Channel</span></span><br><span class="line">    ServerSocketChannel ssc = ServerSocketChannel.open<span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 3. 把这个通信信道设置为非阻塞模式</span></span><br><span class="line">    ssc.configureBlocking<span class="params">(<span class="literal">false</span>)</span>;</span><br><span class="line">    <span class="comment">// 4. 绑定到一个 Socket 对象</span></span><br><span class="line">    ssc.socket<span class="params">()</span>.bind<span class="params">(new InetSocketAddress<span class="params">(<span class="number">8080</span>)</span>)</span>;</span><br><span class="line">    <span class="comment">// 5. 把这个通信信道注册到选择器上</span></span><br><span class="line">    ssc.register<span class="params">(selector, SelectionKey.OP_ACCEPT)</span>;</span><br><span class="line">    while <span class="params">(<span class="literal">true</span>)</span> &#123;</span><br><span class="line">        <span class="comment">// 6. 调用 Selector 的 selectedKeys 方法来检查已经注册在这个选择器上的所有通信信道是否有需要的事件发生，如果有某个事件发生时，将会返回所有的 SelectionKey</span></span><br><span class="line">        Set selectedKeys = selector.selectedKeys<span class="params">()</span>;</span><br><span class="line">        Iterator it = selectedKeys.iterator<span class="params">()</span>;</span><br><span class="line">        while <span class="params">(it.hasNext<span class="params">()</span>)</span> &#123;</span><br><span class="line">            SelectionKey key = <span class="params">(SelectionKey)</span> it.next<span class="params">()</span>;</span><br><span class="line">            <span class="keyword">if</span> <span class="params">(<span class="params">(key.readyOps<span class="params">()</span> &amp; SelectionKey.OP_ACCEPT)</span> == SelectionKey.OP_ACCEPT)</span> &#123;</span><br><span class="line">                <span class="comment">// 7. 通过这个对象 Channel 方法就可以取得这个通信信道对象从而可以读取通信的数据</span></span><br><span class="line">                ServerSocketChannel ssChannel = <span class="params">(ServerSocketChannel)</span> key.channel<span class="params">()</span>;</span><br><span class="line">                SocketChannel sc = ssChannel.accept<span class="params">()</span>;<span class="comment">//接受到服务端的请求</span></span><br><span class="line">                sc.configureBlocking<span class="params">(<span class="literal">false</span>)</span>;</span><br><span class="line">                sc.register<span class="params">(selector, SelectionKey.OP_READ)</span>;</span><br><span class="line">                it.remove<span class="params">()</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> <span class="params">(<span class="params">(key.readyOps<span class="params">()</span> &amp; SelectionKey.OP_READ)</span> == SelectionKey.OP_READ)</span> &#123;</span><br><span class="line">                SocketChannel sc = <span class="params">(SocketChannel)</span> key.channel<span class="params">()</span>;</span><br><span class="line">                while <span class="params">(<span class="literal">true</span>)</span> &#123;</span><br><span class="line">                    buffer.clear<span class="params">()</span>;</span><br><span class="line">                    <span class="comment">// 8. 读取的数据是 Buffer，这个 Buffer 是我们可以控制的缓冲器</span></span><br><span class="line">                    int n = sc.read<span class="params">(buffer)</span>;<span class="comment">//读取数据到buffer中，也就是向buffer写数据</span></span><br><span class="line">                    <span class="keyword">if</span> <span class="params">(n &lt;= <span class="number">0</span>)</span> &#123;</span><br><span class="line">                        break;</span><br><span class="line">                    &#125;</span><br><span class="line">                    buffer.flip<span class="params">()</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                it.remove<span class="params">()</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java NIO的通道类似流，但又有些不同：</p>
<ul>
<li>既可以从通道中读取数据，又可以写数据到通道。但流的读写通常是单向的。</li>
<li>通道可以异步地读写。</li>
<li>通道中的数据总是要先读到一个Buffer，或者总是要从一个Buffer中写入。</li>
</ul>
<p>Buffer内部实现是一个数组，但是一个缓冲区不仅仅是一个数组。缓冲区提供了对数据的结构化访问，而且还可以跟踪系统的读/写进程。每个基本类型都有对应的Buffer类。</p>
<p>为了理解Buffer的工作原理，需要熟悉它的几个属性：</p>
<ul>
<li>capacity</li>
<li>position</li>
<li>limit</li>
<li>mark</li>
</ul>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Write Mode</span><br><span class="line">+-------------------------+</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br><span class="line">+-------------------------+</span><br><span class="line">           ^             ^</span><br><span class="line">           |<span class="string">             </span>|</span><br><span class="line">        position       limit,capacity</span><br><span class="line">Read Mode</span><br><span class="line">+-------------------------+</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br><span class="line">|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|<span class="string"> </span>|</span><br><span class="line">+-------------------------+</span><br><span class="line"> ^         ^             ^</span><br><span class="line"> |<span class="string">         </span>|<span class="string">             </span>|</span><br><span class="line"> position  limit        capacity</span><br></pre></td></tr></table></figure>
<p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式，capacity的含义总是一样的。</p>
<ul>
<li><p>capacity</p>
<p>  作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”.你只能往里写capacity个byte、long，char等类型。一旦Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p>
</li>
<li><p>position</p>
<p>  当你写数据到Buffer中时，position表示当前的位置。初始的position值为0.当一个byte、long等数据写到Buffer后， position会向前移动到下一个可插入数据的Buffer单元。position最大可为capacity – 1.</p>
<p>  当读取数据时，也是从某个特定位置读。当将Buffer从写模式切换到读模式，position会被重置为0. 当从Buffer的position处读取数据时，position向前移动到下一个可读的位置。</p>
</li>
<li><p>limit</p>
<p>  在写模式下，Buffer的limit表示你最多能往Buffer里写多少数据。 写模式下，limit等于Buffer的capacity。</p>
<p>  当切换Buffer到读模式时， limit表示你最多能读到多少数据。因此，当切换Buffer到读模式时，limit会被设置成写模式下的position值。换句话说，你能读到之前写入的所有数据（limit被设置成已写数据的数量，这个值在写模式下就是position）</p>
</li>
<li><p>mark</p>
<p>  用于记录当前 position 的前一个位置或者默认是 0</p>
</li>
</ul>
<p>写数据到Buffer有两种方式：</p>
<ul>
<li>从Channel写到Buffer。<code>int bytesRead = inChannel.read(buf); //read into buffer.</code></li>
<li>通过Buffer的put()方法写到Buffer里。<code>buf.put(127);</code></li>
</ul>
<p>从Buffer中读取数据有两种方式：</p>
<ul>
<li>从Buffer读取数据到Channel。<code>int bytesWritten = inChannel.write(buf);</code></li>
<li>使用get()方法从Buffer中读取数据。<code>byte aByte = buf.get();</code></li>
</ul>
<p>Buffer中的几个方法</p>
<ul>
<li><p>allocate方法</p>
<p>  每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。<code>ByteBuffer buf = ByteBuffer.allocate(48);</code></p>
</li>
<li><p>flip()方法</p>
<p>  flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</p>
</li>
<li><p>rewind()方法</p>
<p>  Buffer.rewind()将position设回0，所以你可以重读Buffer中的所有数据。limit保持不变，仍然表示能从Buffer中读取多少个元素（byte、char等）。</p>
</li>
<li><p>clear()与compact()方法</p>
<p>  一旦读完Buffer中的数据，需要让Buffer准备好再次被写入。可以通过clear()或compact()方法来完成。</p>
<p>  如果调用的是clear()方法，position将被设回0，limit被设置成 capacity的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往Buffer里写数据。</p>
<p>  如果Buffer中有一些未读的数据，调用clear()方法，数据将“被遗忘”，意味着不再有任何标记会告诉你哪些数据被读过，哪些还没有。</p>
<p>  如果Buffer中仍有未读的数据，且后续还需要这些数据，但是此时想要先先写些数据，那么使用compact()方法。</p>
<p>  compact()方法将所有未读的数据拷贝到Buffer起始处。然后将position设到最后一个未读元素正后面。limit属性依然像clear()方法一样，设置成capacity。现在Buffer准备好写数据了，但是不会覆盖未读的数据。</p>
</li>
<li><p>mark()与reset()方法</p>
<p>  通过调用Buffer.mark()方法，可以标记Buffer中的一个特定position。之后可以通过调用Buffer.reset()方法恢复到这个position。</p>
</li>
</ul>
<p>参考: <a href="http://ifeve.com/java-nio-all/" target="_blank" rel="external">http://ifeve.com/java-nio-all/</a></p>
<h2 id="几种访问文件的方式">几种访问文件的方式</h2><ol>
<li><p>标准访问文件方式 标准访问文件方式就是当应用程序调用read()接口时，操作系统检查内核的高速缓存中有没有需要的数据，如果已经缓存了，那么就直接从缓存中返回，如果没有，从磁盘中读取，然后缓存在操作系统的缓存中。</p>
<p> 写入的方式是，用户的应用程序调用write()接口将数据从用户地址空间复制到内核地址空间的缓存中。这时对用户程序来说写操作就已经完成，至于什么时候再写到磁盘中由操作系统决定，除非显式地调用了sync同步命令。</p>
</li>
<li><p>直接I/O方式 所谓直接I/O方式就是应用程序直接访问磁盘数据，而不经过操作系统内核数据缓冲区，这样做的目的就是减少一次从内核缓冲区到用户程序缓存的数据复制。这种访问文件的方式通常是在对数据的缓存管理由应用程序实现的数据库管理系统中。如数据库管理系统中，系统明确地知道应该缓存哪些数据，应该失效哪些数捃，还可以对一些热点数据做预加载，提前将热点数据加载到内存，可以加速数据的访问效率。直接I/O也有负面影响，如果访问的数据不在应用程序缓存中，那么每次数据都会直接从磁盘加载，这种直接加载会非常缓慢。通常直接I/O与异步I/O结合使用，会得到比较好的性能。</p>
</li>
<li><p>同步访问文件方式 同步访问文件方式比较容易理解，就是数据的读取和写入都是同步操作的，它与标准访问文件方式不同的是，只有当数据被成功写到磁盘时才返回给应用程序成功标志。这种访问文件方式性能比较差，只有在一些对数据安全性要求比较高的场景中才会使用，而且通常这种操作方式的硬件都是定制的。</p>
</li>
<li><p>异步访问文件方式 异步访问文件方式就是当访问数据的线程发出请求之后，线程会接着去处理其他事情，而不是阻塞等待，当请求的数据返回后继续处理下面的操作。这种访问文件的方式可以明显地提高应用程序的效率，但是不会改变访问文件的效率。</p>
</li>
<li><p>内存映射方式 内存映射方式是指操作系统将内存中的某一块区域与磁盘中的文件关联起来，当要访问内存中一段数据时，转换为访问文件的某一段数据。这种方式的目的同样是减少数据从内核空间缓存到用户空间缓存的数据复制操作，因为这两个空间的数据是共享的。</p>
</li>
</ol>
<h2 id="序列化">序列化</h2><ul>
<li>当父类继承Serializable接口，所有子类都可以被序列化。</li>
<li>子类实现了Serializable接口，父类没有，父类中的属性不能序列化（不报错，数据会丢失），但是子类中属性仍能正确序列化。</li>
<li>如果序列化的属性是对象，这个对象也必须实现Serializable接口，否则会报错。</li>
<li>在反序列化时，如果对象的属性有修改或删减，修改的部分属性会丢失，但不会报错。</li>
<li>在反序列化时，如果seriaIVersionUID被修改，那么反序列化时会失败。</li>
</ul>
<p>序列化后很难被其它语言反序列化，所以通常用json，xml这样的结构数据。</p>
<h2 id="I/O调优">I/O调优</h2><h3 id="磁盘_I/O_优化">磁盘 I/O 优化</h3><ul>
<li><p>性能检测</p>
<p>  我们可以压力测试应用程序看系统的 I/O wait 指标是否正常，例如测试机器有 4 个 CPU，那么理想的 I/O wait 参数不应该超过 25%，如果超过 25% 的话，I/O 很可能成为应用程序的性能瓶颈。Linux 操作系统下可以通过 iostat 命令查看。</p>
<p>  通常我们在判断 I/O 性能时还会看另外一个参数就是 IOPS，每个磁盘的 IOPS 通常是在一个范围内，这和存储在磁盘的数据块的大小和访问方式也有关。但是主要是由磁盘的转速决定的，磁盘的转速越高磁盘的 IOPS 也越高。</p>
<p>  现在为了提高磁盘 I/O 的性能，通常采用一种叫 RAID 的技术，就是将不同的磁盘组合起来来提高 I/O 性能，目前有多种 RAID 技术，每种 RAID 技术对 I/O 性能提升会有不同，可以用一个 RAID 因子来代表，磁盘的读写吞吐量可以通过 iostat 命令来获取，于是我们可以计算出一个理论的 IOPS 值，计算公式如下所以：</p>
<p>  (磁盘数 <em> 每块磁盘的 IOPS)/(磁盘读的吞吐量 +RAID 因子 </em> 磁盘写的吞吐量)=IOPS</p>
</li>
<li><p>提升 I/O 性能</p>
<ul>
<li>增加缓存，减少磁盘访问次数</li>
<li>优化磁盘的管理系统，设计最优的磁盘访问策略，以及磁盘的寻址策略，这里是在底层操作系统层面考虑的。</li>
<li>设计合理的磁盘存储数据块，以及访问这些数据块的策略，这里是在应用层面考虑的。如我们可以给存放的数据设计索引，通过寻址索引来加快和减少磁盘的访问，还有可以采用异步和非阻塞的方式加快磁盘的访问效率。</li>
<li>应用合理的 RAID 策略提升磁盘 IO，每种 RAID 的区别我们可以用下表所示：</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th>磁盘阵列</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>RAID 0</td>
<td>数据被平均写到多个磁盘阵列中，写数据和读数据都是并行的，所以磁盘的 IOPS 可以提高一倍。</td>
</tr>
<tr>
<td>RAID 1</td>
<td>RAID 1 的主要作用是能够提高数据的安全性，它将一份数据分别复制到多个磁盘阵列中。并不能提升 IOPS 但是相同的数据有多个备份。通常用于对数据安全性较高的场合中。</td>
</tr>
<tr>
<td>RAID 5</td>
<td>这中设计方式是前两种的折中方式，它将数据平均写到所有磁盘阵列总数减一的磁盘中，往另外一个磁盘中写入这份数据的奇偶校验信息。如果其中一个磁盘损坏，可以通过其它磁盘的数据和这个数据的奇偶校验信息来恢复这份数据。</td>
</tr>
<tr>
<td>RAID 0+1</td>
<td>如名字一样，就是根据数据的备份情况进行分组，一份数据同时写到多个备份磁盘分组中，同时多个分组也会并行读写。</td>
</tr>
</tbody>
</table>
<h3 id="网络_I/O_优化">网络 I/O 优化</h3><p>网络 I/O 优化通常有一些基本处理原则：</p>
<ul>
<li>一个是减少网络交互的次数，如静态文件合并，多次数据库查询合并为一次。</li>
<li>减少网络传输数据量的大小，如 gzip 压缩。还有就是通过设计简单的协议，尽量通过读取协议头来获取有用的价值信息。</li>
<li>尽量减少编码，尽量直接以字节形式发送。也就是尽量提前将字符转化为字节，或者减少字符到字节的转化过程。</li>
<li>根据应用场景设计合适的交互方式，所谓的交互场景主要包括同步与异步阻塞与非阻塞方式，下面将详细介绍。</li>
</ul>
<table>
<thead>
<tr>
<th>组合方式</th>
<th>性能分析</th>
</tr>
</thead>
<tbody>
<tr>
<td>同步阻塞</td>
<td>最常用的一种用法，使用也是最简单的，但是 I/O 性能一般很差，CPU 大部分在空闲状态。</td>
</tr>
<tr>
<td>同步非阻塞</td>
<td>提升 I/O 性能的常用手段，就是将 I/O 的阻塞改成非阻塞方式，尤其在网络 I/O 是长连接，同时传输数据也不是很多的情况下，提升性能非常有效。这种方式通常能提升 I/O 性能，但是会增加 CPU 消耗，要考虑增加的 I/O 性能能不能补偿 CPU 的消耗，也就是系统的瓶颈是在 I/O 还是在 CPU 上。</td>
</tr>
<tr>
<td>异步阻塞</td>
<td>这种方式在分布式数据库中经常用到，例如在网一个分布式数据库中写一条记录，通常会有一份是同步阻塞的记录，而还有两至三份是备份记录会写到其它机器上，这些备份记录通常都是采用异步阻塞的方式写 I/O。异步阻塞对网络 I/O 能够提升效率，尤其像上面这种同时写多份相同数据的情况。</td>
</tr>
<tr>
<td>异步非阻塞</td>
<td>这种组合方式用起来比较复杂，只有在一些非常复杂的分布式情况下使用，像集群之间的消息同步机制一般用这种 I/O 组合方式。如 Cassandra 的 Gossip 通信机制就是采用异步非阻塞的方式。它适合同时要传多份相同的数据到集群中不同的机器，同时数据的传输量虽然不大，但是却非常频繁。这种网络 I/O 用这个方式性能能达到最高。</td>
</tr>
</tbody>
</table>
<h2 id="Java_io包中的设计模式">Java io包中的设计模式</h2><ul>
<li>适配器模式。InputStreamReader。目标接口是Reader。源角色是InputStream</li>
<li>装饰器模式。FilterInputStream及其子类。</li>
</ul>
<p>两者都是包装模式，区别是目的不同，前者意在转换接口，后者重在强化功能。</p>
<h2 id="编码">编码</h2><ul>
<li>ASSIC，单字节编码，共有128个字符，一字节可以容纳256个，所以其最高位为0，除去第[0,32]以及第127为控制字符，有效字符为94个。</li>
<li>ISO-8859-1，单字节编码。又称Latin-1，是对ASSIC的扩展，在一些软件或协议中是默认编码，通常如果有<code>?</code>问号这样的乱码，很可能就是由于这个编码。</li>
<li>GB2312，对于落在ASSIC范围内的编码还是使用单字节，其它双字节编码。使用二位区位编号，行为区，列为位，总计94x94个编号，区位均从1起始，一个字符用区码加位码编号，区码、位码各加32就是国标码，国标码区位各加128就是机内码，区位码区位各加0XA0就是机内码了。机内码是实际使用的编码。</li>
<li>GBK，单字节，双字节变长编码，对于ASSIC码是单字节。是对GB2312的扩展，K即扩展。UTF-16和GB开头的编码转换需要通过查表，而Unicode的几种编码之间有相应的转换规则。</li>
<li>GB18030，可能单字节、双字节、四字节编码，兼容GB2312，部分兼容GBK</li>
<li>UTF-8，1到4个字节。</li>
<li>UTF-16，两个字节或四个字节。两个字节时基本可以认为和UCS-2等同。</li>
<li>UTF-32，四个字节定长编码。可以认为和UCS-4等同。</li>
</ul>
<h3 id="Unicode">Unicode</h3><blockquote>
<p>Unicode的核心就是为每个字符提供唯一一个数字编号。Unicode provides a unique number for every character.</p>
</blockquote>
<p>后三个都是Unicode字符集中的编码。字符集和编码几乎都是一对一的，但是Unicode是个例外，Unicode只是给出了个字符集，每个字符有对应的码点（code point），比如美元<code>$</code>符号对应码点是<code>U+0024</code>，至于怎么对这个码点编码这就是UTF-X（Unicode (or UCS) Transformation Format）的事情了，这个X代表了码元（code unit）是多少位的，比如UTF-8的码元是8bits也就是一个字节，一种转换格式可以有整数个码元，比如UTF-16码元是16位，两个字节，其可以包含一个或两个码元，也就是两个或四个字节。</p>
<p>码点范围是U+0000~U+10FFFF（表示为4到6个16进制数，不足4位补零，超过4位，是多少位就还是多少位），最多用到21比特位，可以表示(1+2^4)x2^16个字符，可分为17个部分，每个部分称为平面，平面从0起始，第一个平面即是BMP（Basic Multilingual Plane 基本多语言平面，也叫Plane 0，它的码点范围是U+0000~U+FFFF），UTF-16用两个字节表示BMP平面的字符。后续的16个平面称为SP（Supplementary Planes）。显然，这些码点已经是超过U+FFFF的了，所以已经超过了16位空间的理论上限，对于这些平面内的字符，UTF-16采用了四字节编码。BMP平面从D8~DF都是空白的。其中D800–DBFF属于高代理区（High Surrogate Area），DC00–DFFF属于低代理区（Low Surrogate Area），各自的大小均为4×256=1024。2^10x2^10=2^4x2^16正好可以表示后面的16个平面，UTF-16就是使用代理对表示BMP平面外的字符的。</p>
<p>还有一个代码页的概念，配置vim编码时碰到过一个cp936的，这个就是一个代码页（code page），可以说代码页是编码的一个别名，如cp936和GBK其实就是一个东西。cp65001和UTF-8也是一个东西。Windows命令窗口可以用<code>chcp 65001</code>改变其编码。</p>
<p><strong>码点到UTF-8的转换</strong></p>
<p>以<code>你</code>字为例，其码点是<code>U+4F60</code><br><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0100 1111</span>   <span class="number">0110 0000</span>   码点的二进制形式</span><br><span class="line"><span class="number">0100 111101</span> 100000      按4+6+6分组</span><br><span class="line">1110XXXX 10XXXXXX 10XXXXXX  UTF-8三字节模板</span><br><span class="line"><span class="number">11100100 101</span><span class="number">11101 101000</span>00  替换有效编码位</span><br><span class="line">E4 BD A0</span><br></pre></td></tr></table></figure></p>
<p>UTF-8 有以下编码规则：</p>
<ul>
<li>如果一个字节，最高位（第 8 位）为 0，表示这是一个 ASSIC 字符（00 - 7F）。可见，所有 ASSIC 编码已经是 UTF-8 了。</li>
<li>如果一个字节，以 11 开头，连续的 1 的个数暗示这个字符的字节数，例如：110xxxxx 代表它是双字节 UTF-8 字符的首字节。</li>
<li>如果一个字节，以 10 开始，表示它不是首字节，需要向前查找才能得到当前字符的首字节</li>
</ul>
<p><strong>码点到UTF-16的转换</strong></p>
<ol>
<li>BMP中直接对应，无须转换；</li>
<li>增补平面SP中，则需要做相应的计算。<br> 拿到一个码点，先减去10000(16)，再除以400(16)（=1024(10)）就是所在行了，余数就是所在列了，再加上行与列所在的起始值，就得到了代理对了。<code>(16)</code>表示是16位。</li>
</ol>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Lead = <span class="params">(码点 - <span class="number">10000</span><span class="params">(<span class="number">16</span>)</span>)</span> ÷ <span class="number">400</span><span class="params">(<span class="number">16</span>)</span> + D800</span><br><span class="line">Trail = <span class="params">(码点 - <span class="number">10000</span><span class="params">(<span class="number">16</span>)</span>)</span> <span class="built_in">%</span> <span class="number">400</span><span class="params">(<span class="number">16</span>)</span> + DC00</span><br></pre></td></tr></table></figure>
<p>下面以前面的U+1D11E具体示例了代理对的（16进制）计算：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Lead =</span> (<span class="number">1</span>D11E - <span class="number">10000</span>) ÷ <span class="number">400</span> + <span class="variable">DB00 =</span> D11E ÷ <span class="number">400</span> + <span class="variable">D800 =</span> <span class="number">34</span> + <span class="variable">D800 =</span> D834</span><br><span class="line"><span class="variable">Trail =</span> (<span class="number">1</span>D11E - <span class="number">10000</span>) % <span class="number">400</span> + <span class="variable">DC00 =</span> D11E % <span class="number">400</span> + <span class="variable">DC00 =</span> <span class="number">11</span>E + <span class="variable">DC00 =</span> DD1E</span><br></pre></td></tr></table></figure>
<p><strong>码点到UTF-32无需转换，补零就行了</strong></p>
<p>记事本中可以保存Unicode编码其实就是UTF-16，默认是小端编码。另外记事本保存UTF-8默认是带BOM的。</p>
<p>提到小端编码了，顺便说说大小端编码的问题，也就是字节序的问题，涉及到的是多字节数据存储时的字节顺序问题（对于单字节数据来说，一般不需要考虑各比特位的存储顺序问题。UTF-8以字节为编码单元，没有字节序的问题。UTF-16以两个字节为编码单元，就要考虑字节序了）。大端序是指数据的高字节保存在内存的低地址中，小端序是指数据的高字节保存在内存的高地址中。按照自左向右的顺序，以左为先，把先出现的当做低地址。对于UTF-16的一个码元来说比如<code>0x597D</code>这两个字节，大端表示的话就是<code>0x597D</code>，小端表示的话是<code>0x7D59</code>。可以看出大端表示法跟我们的书写习惯是一致的，而小端的话对我们来说有点不自然，但对于电脑存储可能就比较自然了，因为它的高低字节和内存的高低地址正好就是对应的。</p>
<p>说完大小端再说说BOM，其全称是Byte Order Marker，从全称，我们就知道它是干嘛用的了，标识字节序的。它对应Unicode中的<code>U+FEFF</code>码点，对于UTF-16来说，如果开头是<code>FEFF</code>那就是大端序了，如果是<code>FFFE</code>那就是小端序。</p>
<p>关于编码更详细的内容可以看这个系列博客<a href="http://my.oschina.net/goldenshaw/blog?catalog=536953" target="_blank" rel="external">http://my.oschina.net/goldenshaw/blog?catalog=536953</a></p>
<h3 id="Java中String_的相关方法">Java中String 的相关方法</h3><p>getBytes有四个重载方法，有一个是过时的，总的说来就是两种，指定了编码的和没有指定编码的，没有指定编码，它会使用平台的缺省编码，这个平台是指JVM，如果JVM启动时没有指定编码，那么这个缺省编码也就是操作系统的缺省编码了。这个方法的作用是把字符串按指定的编码方式编码为字节数组，其实质应该就是将内存中存储的UTF-16的编码数组转换为其它编码方式的字节数组。</p>
<p>length方法，这个方法是常用的一个方法，它返回字符串的长度，这个长度不是字符的个数，而是码元的个数，在Java里也就是UTF-16的码元个数了。像charAt, substring这些方法，其参数实际也是基于码元的概念而不是字符。不过呢，大多的字符在BMP平面就能表示了，所以平时接触到的可能这个码元个数和字符个数都是对应的。</p>
<p>下面看些具体的例子</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">final String interesting = <span class="string">"hi你好"</span>;</span><br><span class="line">System.out.println<span class="params">(interesting.length<span class="params">()</span>)</span>; <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line">final byte[] utf8Bytes = interesting.getBytes<span class="params">(<span class="string">"UTF-8"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出8，每个英文字母占一个字节，每个汉字3个字节</span></span><br><span class="line">System.out.println<span class="params">(utf8Bytes.length)</span>;</span><br><span class="line"><span class="comment">//68 69 E4 BD A0 E5 A5 BD</span></span><br><span class="line">System.out.println<span class="params">(toHex<span class="params">(utf8Bytes)</span>)</span>;</span><br><span class="line">System.out.println<span class="params">(utf8Bytes.length)</span>;</span><br><span class="line">final byte[] utf16Bytes = interesting.getBytes<span class="params">(<span class="string">"UTF-16"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出10，每个字符2个字节，外加BOM两个字节</span></span><br><span class="line">System.out.println<span class="params">(utf16Bytes.length)</span>;</span><br><span class="line"><span class="comment">//输出中开头的FE FF就是传说中的BOM(Byte Order Marker用来表明大端还是小端的)了，其实就是U+FEFF码点</span></span><br><span class="line"><span class="comment">//EF BB BF 是这一码点在UTF-8下的编码，UTF-8只有大端，没有大小端之分，所以不建议保存时带BOM，对于不支持BOM的软件会带来未知问题</span></span><br><span class="line"><span class="comment">//FE FF 00 68 00 69 4F 60 59 7D</span></span><br><span class="line">System.out.println<span class="params">(toHex<span class="params">(utf16Bytes)</span>)</span>;</span><br><span class="line">final byte[] utf16beBytes = interesting.getBytes<span class="params">(<span class="string">"UTF-16BE"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出8，每个字符2个字节，UTF-16大端编码，可以看到后面输出的结果除了没有BOM标记之外和UTF-16是一样的。</span></span><br><span class="line">System.out.println<span class="params">(utf16beBytes.length)</span>;</span><br><span class="line"><span class="comment">//00 68 00 69 4F 60 59 7D</span></span><br><span class="line">System.out.println<span class="params">(toHex<span class="params">(utf16beBytes)</span>)</span>;</span><br><span class="line">final byte[] utf32Bytes = interesting.getBytes<span class="params">(<span class="string">"UTF-32"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出16，每个字符4个字节，UTF-32其实也是可以有大小端之分的</span></span><br><span class="line">System.out.println<span class="params">(utf32Bytes.length)</span>;</span><br><span class="line"><span class="comment">//00 00 00 68 00 00 00 69 00 00 4F 60 00 00 59 7D</span></span><br><span class="line">System.out.println<span class="params">(toHex<span class="params">(utf32Bytes)</span>)</span>;</span><br><span class="line">final byte[] isoBytes = interesting.getBytes<span class="params">(<span class="string">"ISO-8859-1"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出4，两个汉字超出它的表示范围，它不认识，然后就被编程`?`了</span></span><br><span class="line">System.out.println<span class="params">(isoBytes.length)</span>;</span><br><span class="line"><span class="comment">//68 69 3F 3F</span></span><br><span class="line">System.out.println<span class="params">(toHex<span class="params">(isoBytes)</span>)</span>;</span><br><span class="line">final byte[] gb2312Bytes = interesting.getBytes<span class="params">(<span class="string">"GB2312"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出6</span></span><br><span class="line">System.out.println<span class="params">(gb2312Bytes.length)</span>;</span><br><span class="line"><span class="comment">//68 69 C4 E3 BA C3</span></span><br><span class="line">System.out.println<span class="params">(toHex<span class="params">(gb2312Bytes)</span>)</span>;</span><br><span class="line">final byte[] gbkBytes = interesting.getBytes<span class="params">(<span class="string">"GBK"</span>)</span>;</span><br><span class="line"><span class="comment">// 输出6， 是对GB2312的扩展，所以这个编码一样</span></span><br><span class="line">System.out.println<span class="params">(gbkBytes.length)</span>;</span><br><span class="line"><span class="comment">// 68 69 C4 E3 BA C3</span></span><br><span class="line">System.out.println<span class="params">(toHex<span class="params">(gbkBytes)</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//s是增补平面的一个字符，UTF-16需要四个字节存，这里如果给char类型赋值，会报错，char总是两个字节的，很显然它存不下</span></span><br><span class="line"><span class="comment">// char c = '𪚥';</span></span><br><span class="line">String s = <span class="string">"𪚥"</span>;</span><br><span class="line"><span class="comment">//Returns the length of this string. The length is equal to the number of Unicode code units in the string.</span></span><br><span class="line"><span class="comment">//上面是length方法的注释，可以看到这个字符串长度，实际是码元的个数，而Java是用UTF-16存储字符串的，所以这里就是UTF-16的码元个数了，即2</span></span><br><span class="line">System.out.println<span class="params">(s.length<span class="params">()</span>)</span>; <span class="comment">//2  输出的是码元数目，也就是UTF-16码元的数目</span></span><br><span class="line"><span class="comment">//下面的两个方法其实也是针对码元的，如果是按字符算的话，s只有一个字符，下面两个方法可就都越界了，事实上它们并没有</span></span><br><span class="line">System.out.println<span class="params">(s.charAt<span class="params">(<span class="number">1</span>)</span>)</span>;</span><br><span class="line">System.out.println<span class="params">(s.substring<span class="params">(<span class="number">1</span>)</span>)</span>;</span><br><span class="line">System.out.println<span class="params">(s.equals<span class="params">(<span class="string">"\uD869\uDEA5"</span>)</span>)</span>;<span class="comment">//s的转义表示，就是UTF-16的代理对</span></span><br><span class="line">System.out.println<span class="params">(s.codePointAt<span class="params">(<span class="number">0</span>)</span> == <span class="number">0</span>x2A6A5)</span>;<span class="comment">//s码点是U+2A6A5</span></span><br><span class="line">System.out.println<span class="params">(toHex<span class="params">(s.getBytes<span class="params">(<span class="string">"utf-16be"</span>)</span>)</span>)</span>; <span class="comment">//D8 69 DE A5</span></span><br><span class="line"><span class="comment">//下面是一个组合字符，神一样的存在</span></span><br><span class="line">s = <span class="string">"ส้้้้้้้้้้้้้้้้้้้้้้้้้้้้้้้้้้้้้้"</span>;</span><br><span class="line">System.out.println<span class="params">(s.length<span class="params">()</span>)</span>; <span class="comment">//39,意味着有39个码元！但是显示的确实是一个字符</span></span><br><span class="line"><span class="comment">//0E 2A 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49 0E 49</span></span><br><span class="line">System.out.println<span class="params">(toHex<span class="params">(s.getBytes<span class="params">(<span class="string">"utf-16be"</span>)</span>)</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//两个汉字变成了三个字符，因为UTF-8对汉字编码是三字节，而GBK是两个字节，其实就是六个字节的两种组合</span></span><br><span class="line">System.out.println<span class="params">(new String<span class="params">(interesting.getBytes<span class="params">(<span class="string">"UTF-8"</span>)</span>,<span class="string">"GBK"</span>)</span>)</span>;</span><br><span class="line"><span class="comment">//两个汉字变成了六个字符，因为UTF-8对汉字编码是三字节，而ISO-8859-1是单字节编码，两个三字节被当做六个单字节来解了</span></span><br><span class="line">System.out.println<span class="params">(new String<span class="params">(interesting.getBytes<span class="params">(<span class="string">"UTF-8"</span>)</span>,<span class="string">"ISO-8859-1"</span>)</span>)</span>;</span><br><span class="line"><span class="comment">//两个汉字变成了两个'?'，因为ISO-8859-1是单字节编码，不认识的都按3F也就是'?'编码，解码时GBK也就当是问号了</span></span><br><span class="line">System.out.println<span class="params">(new String<span class="params">(interesting.getBytes<span class="params">(<span class="string">"ISO-8859-1"</span>)</span>,<span class="string">"GBK"</span>)</span>)</span>;</span><br><span class="line"><span class="comment">//两个汉字变成了四个字符，因为GBK对汉字编码是两字节，而ISO-8859-1是单字节编码，两个双字节被当做四个单字节来解了</span></span><br><span class="line">System.out.println<span class="params">(new String<span class="params">(interesting.getBytes<span class="params">(<span class="string">"GBK"</span>)</span>,<span class="string">"ISO-8859-1"</span>)</span>)</span>;</span><br><span class="line"><span class="comment">// 68 69 C4 E3 BA C3 -&gt; 68 69 3F 3F 3F 3F</span></span><br><span class="line">System.out.println<span class="params">(toHex<span class="params">(new String<span class="params">(interesting.getBytes<span class="params">(<span class="string">"GBK"</span>)</span>,<span class="string">"ISO-8859-1"</span>)</span>.getBytes<span class="params">(<span class="string">"GBK"</span>)</span>)</span>)</span>;</span><br><span class="line"><span class="comment">//两个汉字变成了四个'?'，涉及两次编解码，这里有个疑问，第一次按GBK编码再按ISO-8859-1解码，字节数没变每个字节里存储的内容没变还是68 69 C4 E3 BA C3</span></span><br><span class="line"><span class="comment">//为什么再拿GBK编码后面就变成3F了，GBK不是按照C4E3 BAC3这么分组编码的？我觉得应该跟字符串的存储有关系，getBytes这个方法其实还是从UTF-16到其它编码的一个转换过程</span></span><br><span class="line"><span class="comment">//C4 E3 BA C3 存储可能是00C4 00E3 00BA 00C3然后00C4是什么GBK没有对应的编码，然后就又3F了</span></span><br><span class="line">System.out.println<span class="params">(new String<span class="params">(new String<span class="params">(interesting.getBytes<span class="params">(<span class="string">"GBK"</span>)</span>,<span class="string">"ISO-8859-1"</span>)</span>.getBytes<span class="params">(<span class="string">"GBK"</span>)</span>,<span class="string">"GBK"</span>)</span>)</span>;</span><br><span class="line"><span class="comment">//下面这个结果就是正确的了，第二次编码时，数组的内容还是68 69 C4 E3 BA C3 再按GBK解码自然能够把C4E3 BAC3转为对应的汉字</span></span><br><span class="line">System.out.println<span class="params">(new String<span class="params">(new String<span class="params">(interesting.getBytes<span class="params">(<span class="string">"GBK"</span>)</span>,<span class="string">"ISO-8859-1"</span>)</span>.getBytes<span class="params">(<span class="string">"ISO-8859-1"</span>)</span>,<span class="string">"GBK"</span>)</span>)</span>;</span><br></pre></td></tr></table></figure>
<h3 id="Java_Web_涉及到的编码">Java Web 涉及到的编码</h3><h4 id="URL中的编码">URL中的编码</h4><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"> +-----------------URL-------------------------+</span><br><span class="line">/                      +---------URI------------\</span><br><span class="line">                      /                          \</span><br><span class="line">http://localhost:8080/examples/servlets/servlet/你好?param=你好<span class="comment">#h1</span></span><br><span class="line"> ^       ^       ^     ^            ^            ^         ^</span><br><span class="line"> |<span class="string">       </span>|<span class="string">       </span>|<span class="string">     </span>|<span class="string">            </span>|<span class="string">            </span>|<span class="string">         </span>|</span><br><span class="line">scheme domain  port context path  servlet path path info  query string</span><br></pre></td></tr></table></figure>
<p>Port 对应在 Tomcat 的 <code>&lt;Connector port=&quot;8080&quot;/&gt;</code> 中配置，而 Context Path 在 <code>&lt;Context path=&quot;/examples&quot;/&gt;</code> 中配置，Servlet Path 在 Web 应用的 web.xml 中的<code>&lt;url-pattern&gt;</code> 中配置，PathInfo 是我们请求的具体的 Servlet，QueryString 是要传递的参数</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;servlet-mapping&gt;</span></span><br><span class="line">    <span class="variable">&lt;servlet-name&gt;</span>example<span class="variable">&lt;/servlet-name&gt;</span></span><br><span class="line">    <span class="variable">&lt;url-pattern&gt;</span>/servlets/servlet/<span class="keyword">*</span><span class="variable">&lt;/url-pattern&gt;</span></span><br><span class="line"><span class="variable">&lt;/servlet-mapping&gt;</span></span><br></pre></td></tr></table></figure>
<p>tomcat服务器对URL解码使用的编码是由 <code>&lt;Connector URIEncoding=&quot;UTF-8&quot;/&gt;</code>指定的，而对于QueryString 的解码字符集要么是 Header 中 ContentType 中定义的 Charset 要么就是默认的 ISO-8859-1，要使用 ContentType 中定义的编码就要设置 connector 的 <code>&lt;Connector URIEncoding=&quot;UTF-8&quot; useBodyEncodingForURI=&quot;true&quot;/&gt;</code> 中的 useBodyEncodingForURI 设置为 true。</p>
<h4 id="Header中的编码">Header中的编码</h4><p>对 Header 中的项进行解码是在调用 request.getHeader 是进行的，如果请求的 Header 项没有解码则调用 MessageBytes 的 toString 方法，这个方法将从 byte 到 char 的转化使用的默认编码也是 ISO-8859-1，而我们也不能设置 Header 的其它解码格式，所以如果你设置 Header 中有非 ASSIC 字符解码肯定会有乱码。</p>
<p>我们在添加 Header 时也是同样的道理，不要在 Header 中传递非 ASSIC 字符，如果一定要传递的话，我们可以先将这些字符用 org.apache.catalina.util.URLEncoder 编码然后再添加到 Header 中。</p>
<h4 id="POST表单中的编码">POST表单中的编码</h4><p>POST 表单提交的参数的解码是在第一次调用 request.getParameter 发生的，POST 表单参数传递方式与 QueryString 不同，它是通过 HTTP 的 BODY 传递到服务端的。当我们在页面上点击 submit 按钮时浏览器首先将根据 ContentType 的 Charset 编码格式对表单填的参数进行编码然后提交到服务器端，在服务器端同样也是用 ContentType 中字符集进行解码。所以通过 POST 表单提交的参数一般不会出现问题，而且这个字符集编码是我们自己设置的，可以通过 request.setCharacterEncoding(charset) 来设置，这个调用一定要在第一次调用 request.getParameter前调用。</p>
<p>另外针对 multipart/form-data 类型的参数，也就是上传的文件编码同样也是使用 ContentType 定义的字符集编码，值得注意的地方是上传文件是用字节流的方式传输到服务器的本地临时目录，这个过程并没有涉及到字符编码，而真正编码是在将文件内容添加到 parameters 中，如果用这个编码不能编码时将会用默认编码 ISO-8859-1 来编码。</p>
<h4 id="HTTP_BODY_的编解码">HTTP BODY 的编解码</h4><p>当用户请求的资源已经成功获取后，这些内容将通过 Response 返回给客户端浏览器，这个过程先要经过编码再到浏览器进行解码。这个过程的编解码字符集可以通过 response.setCharacterEncoding 来设置，它将会覆盖 request.getCharacterEncoding 的值，并且通过 Header 的 Content-Type 返回客户端，浏览器接受到返回的 socket 流时将通过 Content-Type 的 charset 来解码，如果返回的 HTTP Header 中 Content-Type 没有设置 charset，那么浏览器将根据 Html 的 <code>&lt;meta HTTP-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=GBK&quot; /&gt;</code> 中的 charset 来解码。如果也没有定义的话，那么浏览器将使用默认的编码来解码。</p>
<h4 id="JS中的编码">JS中的编码</h4><p>外部引入js文件<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">script</span> <span class="attribute">src</span>=<span class="value">"static/js/all.js"</span> <span class="attribute">charset</span>=<span class="value">"gbk"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>对URL编码</p>
<ul>
<li>escape已废弃</li>
<li>encodeURI</li>
<li>encodeURIComponent 和encodeURI方法的区别是编码更加彻底，比如像<code>:</code>,<code>#</code>,<code>?</code>这种字符也会被编码。Java中的URLEncoder和URLDecoder与encodeURIComponent和decodeURIComponent是基本对应的。</li>
</ul>
<p>如果没有指定字符集，那么将使用当前页面的编码。</p>
<h4 id="其它需要编码的地方">其它需要编码的地方</h4><p>xml 文件可以通过设置头来制定编码格式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br></pre></td></tr></table></figure>
<p>Velocity 模版设置编码格式：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">services<span class="class">.VelocityService</span><span class="class">.input</span><span class="class">.encoding</span>=UTF-<span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>JSP 设置编码格式：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">%@page</span> <span class="attribute">contentType</span>=<span class="value">"text/html; charset=UTF-8"</span><span class="value">%</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>访问数据库都是通过客户端 JDBC 驱动来完成，用 JDBC 来存取数据要和数据的内置编码保持一致，可以通过设置 JDBC URL 来制定如 MySQL：url=”jdbc:mysql://localhost:3306/DB?useUnicode=true&amp;characterEncoding=GBK”。</p>
<h2 id="常见加载器类错误分析">常见加载器类错误分析</h2><ul>
<li><p>ClassNotFoundException<br>  这个异常通常发生在<strong>显式加载类</strong>的时候，例如，用如下方式调用加载一个类时就报这个错了：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">NotFoundException</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"NotFoundException"</span>);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  显式加载一个类通常有如下方式：</p>
<ul>
<li>通过类Class中的forName()方法。</li>
<li>通过类 ClassLoader 中的 loadClass()方法。</li>
<li><p>通过类 ClassLoader 中的 findSystemClass()方法。</p>
<p>出现这类错误也很好理解，就是当JVM要加载指定文件的字节码到内存时，并没有找到这个文件对应的字节码，也就是这个文件并不存在。解决的办法就是检査在当前的classpath目录下有没有指定的文件存在。如果不知道当前的classpath路径,就可以通过如下命令来获取：<code>this.getClass().getClassLoader().getResource(&quot;&quot;).toString()</code></p>
</li>
</ul>
</li>
<li><p>NoClassDefFoundError<br>  NoClassDefFoundError是另外一个经常遇到的异常，这个异常在第一次使用命令行执行Java类时很可能会碰到，如： <code>java -cp example.jar Example</code></p>
<p>  报错是因为你在命令行中没有加类的包名，正确的写法是这样的： <code>java -cp example.jar net.xulingbo.Example</code></p>
<p>  而之前同时报了NoClassDefFoundError和 ClassNotFoundException异常，原因是 Java虚拟机隐式加载了exanple.jar后显式加载Example时没有找到这个类，所以是ClassNotFoundException 引发了 NoClassDefFoundError 异常。</p>
<p>  在JVM的规范中描述了出现NoClassDefFoundError可能的情况就是使用new关键字、属性引用某个类、继承某个接口或类，以及方法的某个参数中引用了某个类，这时会触发JVM<strong>隐式加载</strong>这些类时发现这些类不存在的异常。</p>
<p>  解决这个错误的办法就是确保每个类引用的类都在当前的classpath路径下面。</p>
</li>
<li><p>UnsatisfiedLinkError<br>  这个异常倒不是很常见，但是出错的话，通常是在JVM启动的时候,如果一不小心将在JVM中的某个lib删除了,可能就会报这个错误了，代码如下：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoLibException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">nativeMethod</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"NoLib"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> NoLibException().nativeMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  这个错误通常是在解析native标识的方法时JVM找不到对应的本机库文件时出现</p>
</li>
<li><p>ClassCastException<br>  这个错误也很常见，通常在程序出现强制类型转换时出现这个错误，如下面这段代码所示：</p>
  <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CastExceptlon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map m = <span class="keyword">new</span> HashMap()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            put (<span class="string">"a"</span>，<span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        Integer islnt =(Integer)m.<span class="keyword">get</span>(<span class="string">"a"</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.print(islnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  当强制将本来不是Integer类型的字符串转成Integer类型时会报错</p>
<p>  JVM在做类型转换时会按照如下规侧进行检査：</p>
<ul>
<li>对于普通对象，对象必须是目标类的实例或目标类的子类的实例。如果目标类是接口，那么会把它当作实现了该接口的一个子类。</li>
<li><p>对于数组类型，目标类必须是数组类型或java.lang.Object 、java.lang.Cloneable或java.io.Serializable。</p>
<p>如果不满足上面的规则，JVM就会报这个错误。要避免这个错误有两种方式：</p>
</li>
<li><p>在容器类型中显式地指明这个容器所包含的对象类型，如在上面的Map中可以写为 <code>Map&lt;String，Integer&gt; m = new HashMap&lt;String，Integer&gt;()</code>。这祥上面的代码在编译阶段就会检査通过。</p>
</li>
<li>先通过instanceof检查是不是目标类型,然后再进强制类型转换。</li>
</ul>
</li>
<li><p>ExceptionInInitializerError<br>  这个错误在JVM规范中是这样定义的：</p>
<ul>
<li>如果Java虚拟机试图创建类ExceptionlnInitializerError的新实例,但是因为出现Out-Of-Memory-Error而无法创建新实倒.，那么就抛出OutOfMemoryError对象作为替代。</li>
<li><p>如果初始化器抛出一些Exception，而且Exception类不是Error或者它的某个子类，那么就会创建ExceptionlnlnitializeiError类的一个新实例，并用Exception作为参数，用这个实例代替Exception。</p>
<p>将上面的代码例子稍微改了一下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">CastExceptlon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map m = <span class="keyword">new</span> HashMap()&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            m.put (<span class="string">"a"</span>，<span class="string">"2"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        Integer islnt =(Integer)m.<span class="keyword">get</span>(<span class="string">"a"</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.print(islnt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在初始化这个类时，给静态属性m赋值时出现了异常导致抛出错误ExceptionInInitializerError.</p>
</li>
</ul>
</li>
</ul>
<h2 id="热部署">热部署</h2><p>先简单说下类加载器。</p>
<ol>
<li>JVM通过类加载器(ClassLoader)加载类。JVM中提供的三种类加载器：BootStrap类加载器，加载<code>JRE/lib</code>；ExtClassLoader，加载 JRE/lib/ext；AppClassLoader 加载classpath。</li>
<li>JVM加载采用了双亲委派机制，就是当加载一个类时，当前的ClassLoader先请求父ClassLoader，依次类推，直到父ClassLoader无法加载时，才通过当前的ClassLoader加载，这就保证了像String这样的类型肯定是由BootStrap类加载器加载的。</li>
<li>在JVM中，一个实例是通过本身的完整类名+加载它的ClassLoader实例识别的，也就是说即使同一个ClassLoader类的不同的实例加载同一个类在JVM也是不同的。</li>
<li>同一个ClassLoader是不允许多次加载一个类的，否则会报java.lang.LinkageError。JVM在加载类之前会检査请求的类是否已经被加载过来，也就是要调用flndLoadedClass()方法查看是否能够返回类实例。如果类已经加载过来，再调用loadClass()将会导致类冲突。</li>
</ol>
<p>热部署是在不重启 Java 虚拟机的前提下，能自动侦测到 class 文件的变化，更新运行时 class 的行为。JVM并不支持热部署，那么要实现热部署，就必须自定义ClassLoader，当类被修改过后，可以创建不同的ClassLoader的实例对象，然后通过这个不同的实例对象来加载同名的类。</p>
<p>不需要担心这样会使PermGen区无限增大，因为ClassLoader 也是个对象，当不再被引用时也会被回收，之后在Full GC时，由其加载的类，如果没用了，也会被收回。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ClassReloader reloader = <span class="keyword">new</span> ClassReloader(<span class="keyword">classpath</span>);</span><br><span class="line"><span class="keyword">Class</span> r = reloader.findClass(<span class="string">"HelloWorld.class"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(r.newInstance());</span><br><span class="line"></span><br><span class="line">ClassReloader reloader2 = <span class="keyword">new</span> ClassReloader(<span class="keyword">classpath</span>);</span><br><span class="line"><span class="keyword">Class</span> r2 = reloader2.findClass(<span class="string">"HelloWorld.class"</span>);</span><br><span class="line">System.out.<span class="keyword">println</span>(r2.newInstance());</span><br></pre></td></tr></table></figure>
<p>Class.forName()和ClassLoader.loadClass()区别</p>
<ul>
<li>Class.forName()：将类的.class文件加载到jvm中之外，还会对类进行解释，执行类中的static块；</li>
<li>ClassLoader.loadClass()：只干一件事情，就是将.class文件加载到jvm中，不会执行static中的内容,只有在newInstance才会去执行static块。</li>
</ul>
<p>在Tomcat中JSP就是热部署的。其实现原理也是通过创建新的类加载器实例，加载修改后的类。</p>
<p>对于WEB-INF/classes下的class文件，可以通过配置使其自动加载。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;Context <span class="variable">docBase=</span><span class="string">"xxx"</span> <span class="variable">path=</span><span class="string">"/xxx"</span> <span class="variable">reloadable=</span><span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>reloadable:如果这个属性设为true，tomcat服务器在运行状态下会监视在WEB-INF/classes和WEB-INF/lib目录下class文件的改动，如果监测到有class文件被更新的，服务器会自动重新加载Web应用。默认值是false。这个配置能干嘛，其实就是你文件变了，它重启下容器，也就重新加载类了，这个跟之前提到的热部署可能还有些出入。</p>
<p>如果搜“tomcat 热部署“，可能会搜到autoDeploy和crossContext两个属性，前者为Host属性，指示Tomcat运行时，如有新的WEB程序加入appBase指定的目录下，是否为自动布署，默认值为true。后者为Context属性，指示是否允许跨域访问，为true时，在程序内调用ServletContext.getContext()方法将返回一个虚拟主机上其它web程序的请求调度器。默认值为false，调 径用getContext()返回为null。所以这两个配置跟热部署也没多大关系了。</p>
<p>有一个工具可以实现这里说的热部署：<a href="http://zeroturnaround.com/software/jrebel" target="_blank" rel="external">JRebel</a>。这个工具需要付费使用。</p>
<h2 id="执行引擎">执行引擎</h2><p>每个Java线程就是一个执行引擎实例，那么一个JVM实例中就会同时存在多个执行引擎工作。</p>
<p>执行引擎可以是基于栈的，如Hotspot，也可以是基于寄存器的，如Dalvik。前者是为了更好地支持跨平台，很难针对不同平台设计通用基于寄存器的指令，而后者主要运用于手机等智能设备，基本基于特定的芯片的寄存器设计。</p>
<h2 id="Session与Cookie">Session与Cookie</h2><p>为什么会使用Session和Cookie？因为HTTP是无状态的。而我们服务器端又需要知道用户状态，比如说这次请求和另一次请求是不是一个用户之类的，Session和Cookie就是用来记录状态的机制。</p>
<p>Cookie在客户端存储，一般会受到浏览器的限制，比如大多数浏览器要求每个域名只能保存50个Cookie、Cookie大小不能超过4KB。并且还需要防止Cookie被盗，Cookie伪造等问题。如果Cookie很大，还会占用带宽，可以考虑压缩Cookie，比如使用gzip或deflate进行压缩，压缩后再使用BASE64编码。</p>
<p>Session保存在服务器上。当访问增多，会比较占用服务器的资源，并且还需要考虑如何在服务器之间共享Session。</p>
<p>Session和Cookie也并不是必须的，如RESTful应用在服务端不会保存状态的，它的状态由客户端去维护，像浏览器这样的客户端也可以将状态保存在本地存储中（localstorage、sessionstorage）。这样可以不用考虑像Session共享这样的问题了。</p>
<h3 id="Cookie">Cookie</h3><p>Cookie一般是由服务器端生成，通过在响应头添加<code>Set-Cookie</code>使浏览器保存Cookie（临时或持久化保存），下次请求同一网站时浏览器会在请求头携带Cookie给服务器（前提是浏览器设置为启用Cookie）。Cookie主要就是键值对，有一种比较特殊的Cookie，就是SeesionID，Tomcat中其name是JSESSIONID，根据SeesionID服务器可以找到对应的Session，进而获取保存的状态。</p>
<p>当前 Cookie 有两个版本：Version 0 和 Version 1。通过它们有两种设置响应头的标识，分别是 “Set-Cookie”和“Set-Cookie2”，后者不常用。</p>
<p>Version 0 属性项介绍</p>
<table>
<thead>
<tr>
<th>属性项</th>
<th>属性项介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME=VALUE</td>
<td>键值对，<strong>可以设置要保存的 Key/Value，注意这里的 NAME 不能和其他属性项的名字一样，否则会抛出IllegalArgumentException。Value不能是非ASSIC字符，非ASSIC字符可以使用URLEncoder进行编码</strong></td>
</tr>
<tr>
<td>Expires</td>
<td>过期时间，在设置的某个时间点后该 Cookie 就会失效，如 expires=Wednesday, 09-Nov-99 23:12:40 GMT。用Max-Age更多些</td>
</tr>
<tr>
<td>Domain</td>
<td>生成该 Cookie 的域名，<strong>Cookie不能跨域访问，如 images.google.com 不能访问 www.google.com的Cookie。但是对于二级域名，如果设置Domain=”.google.com”的话，images.google.com 也能访问 www.google.com的Cookie</strong></td>
</tr>
<tr>
<td>Path</td>
<td>该 Cookie 是在当前的哪个路径下生成的，<strong>Cookie只能在相同path下访问。如 path=/wp-admin/ 这样/wp-content/下就无法访问该Cookie。注意，path应该以<code>/</code>结束</strong></td>
</tr>
<tr>
<td>Secure</td>
<td>如果设置了这个属性，那么只会在HTTPS和SSL等安全协议时才会回传该 Cookie</td>
</tr>
</tbody>
</table>
<p>Version 1 属性项介绍</p>
<table>
<thead>
<tr>
<th>属性项</th>
<th>属性项介绍</th>
</tr>
</thead>
<tbody>
<tr>
<td>NAME=VALUE</td>
<td>与 Version 0 相同</td>
</tr>
<tr>
<td>Version</td>
<td>通过 Set-Cookie2 设置的响应头创建必须符合 RFC2965 规范，如果通过 Set-Cookie 响应头设置，默认值为 0，如果要设置为 1，则该 Cookie 要遵循 RFC 2109 规范</td>
</tr>
<tr>
<td>Comment</td>
<td>注释项，用户说明该 Cookie 有何用途</td>
</tr>
<tr>
<td>CommentURL</td>
<td>服务器为此  Cookie 提供的 URI 注释</td>
</tr>
<tr>
<td>Discard</td>
<td>是否在会话结束后丢弃该 Cookie 项，默认为 fasle</td>
</tr>
<tr>
<td>Domain</td>
<td>类似于 Version 0</td>
</tr>
<tr>
<td>Max-Age</td>
<td>最大失效时间，<strong>为正数，会被持久化，即存储到文件中，指定多少秒后失效；为负数，不被持久化，关闭浏览器后失效，0表示立即失效，可以起到删除Cookie的作用，这里需要保证 name, path和domain 是相同的</strong></td>
</tr>
<tr>
<td>Path</td>
<td>类似于 Version 0</td>
</tr>
<tr>
<td>Port</td>
<td>该 Cookie 在什么端口下可以回传服务端，如果有多个端口，以逗号隔开，如 Port=”80,81,8080”</td>
</tr>
<tr>
<td>Secure</td>
<td>类似于 Version 0</td>
</tr>
</tbody>
</table>
<p>JavaEE中对应的类是javax.servlet.http.Cookie包含name，value，secure，path，domain，comment，version属性。通过request.getCookies()获取客户端提交的所有Cookie，通过response.addCookie(Cookie cookie)向客户端设置Cookie。</p>
<p>如果我们通过浏览器查看当前网站的Cookie，可能会看到两种Cookie，一种是当前网站本身设置的 Cookie，另一种是来自在网页上嵌入广告或图片等其他域来源的 第三方 Cookie (网站可通过使用这些 Cookie 跟踪你的使用信息)。可以确定的是对于Cookie来说肯定是不允许垮域访问的。无论是通过JS还是Server端程序来说都是如此，但是通过一些技术可以，比如天猫如何能跨域获取淘宝的Cookie，一种办法就是淘宝提供接口可以获取到其下的Cookie</p>
<h3 id="Session">Session</h3><p>Session是另一种记录客户状态的机制，保存在服务器上。</p>
<p>Session存储在服务器哪里？为了获得更高的存取速度，服务器一般把Session放在内存里。也可以将其存储在数据库、文件系统、缓存中。当Servlet容器关闭时StandardManager类会把Session对象写入<code>SESSIONS.ser</code>文件中，要想持久化保存Servlet容器中的Session对象，必须通过调用Servlet容器的start和stop方法。</p>
<p>何时生成Session？调用request.getSession()方法时，如果不存在Session就会创建一个新的，用户第一次访问服务器时，访问JSP或Servlet等程序才会创建Session，只访问HTML、图片等静态资源并不会创建Session。服务器会更新Session最后访问时间。</p>
<p>何时失效？服务器会把长时间内没有活跃的Session从内存删除。这个时间就是Session的超时时间 。如果超过了超时时间没访问过服务器，Session就自动失效了。Session的超时时间为maxInactiveInterval属性，可以通过对应的getMaxInactiveInterval()获取，通过setMaxInactiveInterval(long interval)修改。Session的超时时间也可以在web.xml中修改。另外，通过调用Session的invalidate()方法可以使Session失效。</p>
<p>如何来识别特定用户？依靠Cookie，服务端会在HTTP协议中告诉客户端，需要在 Cookie 里面记录一个Session ID，以后每次请求把这个会话ID发送到服务器，我就知道你是谁了。如果客户端的浏览器禁用了 Cookie 怎么办？一般这种情况下，会使用一种叫做URL重写的技术来进行会话跟踪，即每次HTTP交互，URL后面都会被附加上一个诸如 <code>;JSESSIONID=xxxxx</code> 这样的参数，服务端据此来识别用户。</p>
<p>通过订阅服务器（如Zookeeper集群管理服务器）统一各个服务器的Session配置项，通过分布式缓存（如MemCache）存储Session，解决Session共享问题。</p>
<h3 id="表单重复提交问题">表单重复提交问题</h3><p>每次生成表单时，都生成一个隐藏表单项，其值为一个唯一的token，并且这个token存储在Session中，表单提交到服务器后，比对表单中的token和服务器Session中的token是否一致，如果一致则没有重复提交，进行后续处理，然后重新生成Session中的token。如果不一致，说明表单已经成功提交过一次了，这是重复提交。</p>
<h3 id="多终端Session统一">多终端Session统一</h3><p>一种情况是在移动设备上访问无限服务端系统和PC服务端系统，这两者之间Session的共享，这个可以通过分布式Session框架解决。另一种情况是在移动端已经登陆的前提下，PC端通过扫码登录，这种情况下二维码携带一个特定标识，标识事这个客户端通过手机端登录了。当手机扫码成功后，会在服务器端设置这个二维码对应的标识为已经登录成功，PC端通过心跳请求验证是否登陆成功。</p>
<h2 id="跨域资源共享（CORS）">跨域资源共享（CORS）</h2><p>出于安全考虑，浏览器会限制脚本中发起的跨站请求。比如，使用 XMLHttpRequest 对象发起 HTTP 请求就必须遵守同源策略（same-origin policy）。</p>
<p>简单记录下两种跨域请求</p>
<ul>
<li><p>简单请求<br>  这种跨站请求与以往浏览器发出的跨站请求并无异同。并且，如果服务器不给出适当的响应头，则不会有任何数据返回给请求方。因此，那些不允许跨站请求的网站无需为这一新的 HTTP 访问控制特性担心。这种请求具备以下两个条件：</p>
<ul>
<li>只使用 GET, HEAD 或者 POST 请求方法。如果使用 POST 向服务器端传送数据，则数据类型(Content-Type)只能是 application/x-www-form-urlencoded, multipart/form-data 或 text/plain中的一种。</li>
<li>不会使用自定义请求头（类似于 X-Modified 这种）。</li>
</ul>
</li>
<li><p>预请求（preflight request）<br>  不同于上面讨论的简单请求，“预请求”要求必须先发送一个 OPTIONS 请求给目的站点，来查明这个跨站请求对于目的站点是不是安全可接受的。这样做，是因为跨站请求可能会对目的站点的数据造成破坏。这种场景下，总比正常请求多一次请求。当请求具备以下条件，就会被当成预请求处理：</p>
<ul>
<li>请求以 GET, HEAD 或者 POST 以外的方法发起请求。或者，使用 POST，但请求数据为 application/x-www-form-urlencoded, multipart/form-data 或者 text/plain 以外的数据类型。比如说，用 POST 发送数据类型为 application/xml 或者 text/xml 的 XML 数据的请求。</li>
<li>使用自定义请求头（比如添加诸如 X-PINGOTHER）</li>
</ul>
</li>
</ul>
<p>跨域请求请求头可能带有Origin、Access-Control-Request-Method、Access-Control-Request-Headers，分别用来标识发起请求的URI，请求方法，请求头</p>
<p>响应头部可能带有Access-Control-Allow-Origin，Access-Control-Max-Age，Access-Control-Allow-Methods，Access-Control-Allow-Headers分别表示允许发起访问的URI，预请求的结果的有效期，允许的访问方法，允许的请求头</p>
<p>Tomcat 中配置CORS过滤器<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="attribute">filter</span>&gt;</span><br><span class="line">  &lt;<span class="attribute">filter</span>-name&gt;CorsFilter&lt;/<span class="attribute">filter</span>-name&gt;</span><br><span class="line">  &lt;<span class="attribute">filter</span>-class&gt;org<span class="class">.apache</span><span class="class">.catalina</span><span class="class">.filters</span><span class="class">.CorsFilter</span>&lt;/<span class="attribute">filter</span>-class&gt;</span><br><span class="line">&lt;/<span class="attribute">filter</span>&gt;</span><br><span class="line">&lt;<span class="attribute">filter</span>-mapping&gt;</span><br><span class="line">  &lt;<span class="attribute">filter</span>-name&gt;CorsFilter&lt;/<span class="attribute">filter</span>-name&gt;</span><br><span class="line">  &lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>跨域资源共享更详细的内容可以参考：<br><a href="http://www.w3.org/TR/cors/" target="_blank" rel="external">http://www.w3.org/TR/cors/</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Access_control_CORS" target="_blank" rel="external">HTTP访问控制(CORS)</a></p>
<p><a href="http://enable-cors.org/index.html" target="_blank" rel="external">不同的服务器配置CORS</a></p>
<p>从<a href="http://www.xulingbo.net/" target="_blank" rel="external">君山的博客</a>中整理了一些<a href="http://pan.baidu.com/s/1kTF39XX" target="_blank" rel="external">资料</a>。</p>
]]></content>
    <summary type="html">
    <![CDATA[Java Web; 浏览器请求过程; NIO; 字符编码; 乱码;]]>
    
    </summary>
    
      <category term="Java" scheme="http://howiefh.github.io/tags/Java/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[逻辑删除]]></title>
    <link href="http://howiefh.github.io/2015/07/25/logical-delete/"/>
    <id>http://howiefh.github.io/2015/07/25/logical-delete/</id>
    <published>2015-07-25T04:08:47.000Z</published>
    <updated>2015-08-10T02:38:33.000Z</updated>
    <content type="html"><![CDATA[<ul>
<li>物理删除，又称硬删除、真删除，即删除操作是将数据记录直接从数据库删除。</li>
<li>逻辑删除，又称软删除、假删除，通过添加删除标记或者将要删除的数据记录移动到另一张表的方式实现。好处就是对于误操作，数据被删除了，可以很方便地将数据恢复。</li>
</ul>
<a id="more"></a>
<p>流水记录可以考虑物理删除，关键业务数据逻辑删除。如果根本不考虑将来需要恢复的问题，直接删就好了。</p>
<p>逻辑删除大致又有两种可行方案：做标记；转移数据。</p>
<p>对于添加标记字段，通过更新语句直接更新一个字段就可以了。但是如果表中有unique字段，就无法再添加相同内容了，解决方案是将删除标记也列入唯一索引中，如<code>&lt;删除标记,唯一字段&gt;</code>。如果数据量大的话，删除操作又比较频繁，这种方法在查询时都要再加一个标记判断，相对效率会比较低。使用视图可以解决每个查询语句添加额外判断的问题，通过创建设定过滤条件索引对查询效率低的问题可能会有所帮助（不是所有数据库都支持过滤索引，而且使用过滤索引也会带来更新索引的代价）。</p>
<p>对于将要删除的数据移动到另一张表，可以通过<code>CREATE TABLE table_name_archive SELECT * FROM table_name WHERE 1 = 2;ALTER TABLE table_name_archive ADD PRIMARY KEY (id);ALTER TABLE table_name_archive ADD delete_date datetime NOT NULL COMMENT &#39;删除时间&#39;;</code>创建一张表结构相同的表，然后通过触发器实现数据的转移，相对来说可能这种做法效率会略差，一次删除实际上执行了两次操作，同时使用触发器可能也会加重数据库的负担。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DELIMITER $$</span><br><span class="line"></span><br><span class="line"><span class="operator"><span class="keyword">DROP</span> <span class="keyword">TRIGGER</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> table_name_trigger $$</span><br><span class="line"></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TRIGGER</span> table_name_trigger</span><br><span class="line"><span class="keyword">AFTER</span> <span class="keyword">DELETE</span> <span class="keyword">ON</span> table_name</span><br><span class="line"><span class="keyword">FOR</span> <span class="keyword">EACH</span> <span class="keyword">ROW</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> table_name_archive</span><br><span class="line">    <span class="keyword">SELECT</span> *, <span class="keyword">now</span>()</span><br><span class="line">    <span class="keyword">FROM</span> OLD;</span></span><br><span class="line"><span class="operator"><span class="keyword">END</span>;</span></span><br><span class="line">$$</span><br></pre></td></tr></table></figure>
<p>参考：</p>
<p><a href="http://weblogs.asp.net/fbouma/soft-deletes-are-bad-m-kay" target="_blank" rel="external">http://weblogs.asp.net/fbouma/soft-deletes-are-bad-m-kay</a></p>
]]></content>
    <summary type="html">
    <![CDATA[逻辑删除; 软删除; logical delete; soft delete; tombstone;]]>
    
    </summary>
    
      <category term="Database" scheme="http://howiefh.github.io/tags/Database/"/>
    
      <category term="Database" scheme="http://howiefh.github.io/categories/Database/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Vim 自动补全插件 YouCompleteMe 安装与配置]]></title>
    <link href="http://howiefh.github.io/2015/05/22/vim-install-youcompleteme-plugin/"/>
    <id>http://howiefh.github.io/2015/05/22/vim-install-youcompleteme-plugin/</id>
    <published>2015-05-22T12:31:12.000Z</published>
    <updated>2015-05-21T16:36:01.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>对于代码自动补全，之前一直使用的是Shougo/neocomplcache和Shougo/neosnippet。早就听说过YouCompleteMe的大名，一直想尝试一下YCM，但是还是拖到了现在。YCM和其它Vim插件的安装有些不同，可能需要折腾一下。之所以安装稍微会麻烦些，是因为YCM 后端调用 libclang(以获取AST,当然还有其他语言的语义分析库)、前端由 C++ 开发(以提升补全效率)、外层由 python 封装(以成为 vim 插件),它可能是安装最复杂的 vim 插件了。YCM是Client-sever架构的，Vim这部分的YCM只是很小的一个客户端，与具有大量逻辑和功能的ycmd HTTP+JSON交互。server在你开启或关闭Vim是自动开启或关闭。</p>
<p>其它自动补全的插件基本上是基于文本的，也就是说它们基本上是使用正则去猜。区别于其它Vim的自动补全插件，YCM基于语义引擎（比如C家族的libclang）提供了语义补全，是通过分析源文件，经过语法分析之后进行补全。对于C家族的语言这种基于语义的自动补全依赖于clang/llvm，其他语言 ,会调用vim设置的omnifunc来匹配，可以查看<a href="https://github.com/Valloric/YouCompleteMe#semantic-completion-for-other-languages" target="_blank" rel="external">github</a></p>
<ul>
<li>Java/Ruby <a href="http://eclim.org/" target="_blank" rel="external">eclim</a></li>
<li>Python <a href="https://github.com/davidhalter/jedi" target="_blank" rel="external">Jedi</a></li>
<li>Go <a href="https://github.com/nsf/gocode" target="_blank" rel="external">Gocode</a></li>
<li>C# <a href="https://github.com/nosami/OmniSharpServer" target="_blank" rel="external">OmniSharp</a></li>
<li>JavaScript <a href="https://github.com/marijnh/tern_for_vim" target="_blank" rel="external">Tern for Vim</a></li>
</ul>
<p>YCM不是基于前缀补全的，而是子序列，所以输入 abc 可以补全 xaybgc，它对于大小写的补全也非常智能。对于C家族的语言和Python支持跳转到定义处。此外还可以对文件路径进行补全，和ultisnips也很好结合。</p>
<a id="more"></a>
<h2 id="安装">安装</h2><h3 id="完全安装">完全安装</h3><p><strong>如果用Vundle更新YCM，yum_support_lib库API改变了，YCM会提醒你重新编译它。</strong></p>
<ol>
<li><p>确保Vim版本至少是7.3.584，并且支持python2脚本。</p>
<p> 在Vim中输入<code>:version</code>可以查看版本。如果版本已经高于7.4了，那么OK。版本是7.3。那么继续往下看，看到<code>包含版本:1-Z</code>，如果Z小于584就需要重装了。Ubuntu的话可以通过<a href="http://linuxg.net/how-to-install-vim-7-4-on-ubuntu-13-10-13-04-12-04-linux-mint-16-15-13-and-debian-sid/" target="_blank" rel="external">PPA</a>安装高版本的。否则就要从源码编译安装了。<br> 查看是否支持python2：进入vim,命令:echo has(‘python’)，输出为1,则表示支持。如果为0,则需要重新编译安装vim，在编译时添加python支持。</p>
</li>
<li><p>通过Vundle安装YCM，在你的vimrc中添加<code>Plugin &#39;Valloric/YouCompleteMe&#39;</code>，然后执行<code>:PluginInstall</code></p>
</li>
<li><p>如果不需要对C家族的语言进行语义补全支持，则跳过这一步。</p>
<p> 下载最新版的libclang。Clang是一个开源编译器，能够编译C/C++/Objective-C/Objective-C++。Clang提供的libclang库是用于驱动YCM对这些语言的语义补全支持。YCM需要版本至少为3.6的libclang，但是理论上3.2+版本也行。也可以使用系统libclang，如果确定是3.3版本或者更高。推荐下载<llvm.org>官网的<a href="http://llvm.org/releases/download.html" target="_blank" rel="external">二进制文件</a>。确保选对适合自己系统的包。</llvm.org></p>
</li>
<li><p>编译YCM需要的ycm_support_libs库。YCM的C++引擎通过这些库来获取更快的补全速度。<br> 需要cmake，如果未安装，安装之：<code>sudo apt-get install build-essential cmake</code>（也可以下载安装<a href="http://www.cmake.org/cmake/resources/software.html" target="_blank" rel="external">http://www.cmake.org/cmake/resources/software.html</a>）。确保python头文件已安装：<code>sudo apt-get install python-dev</code>。假设你已经通过Vundle装好YCM了，那么它应该位于<code>~/.vim/bundle/YouCompleteMe</code>。我们新建一个目录用来放置编译文件，并切换到此目录下<code>cd ~;mkdir ycm_build;cd ycm_build;</code><br> 下一步生成makefile，这一步很重要，有点复杂。</p>
<ul>
<li>如果不需要C族语言的语义支持，在ycm_build目录下执行：<code>cmake -G &quot;Unix Makefiles&quot; . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</code></li>
<li>如果需要C族语言的语义支持，还得分几种情况：<ul>
<li>假如你从llvm的官网下载了LLVM+Clang，然后解压到：~/ycm_temp/llvm_root_dir （该目录下有 bin, lib, include 等文件夹），然后执行：<code>cmake -G &quot;Unix Makefiles&quot; -DPATH_TO_LLVM_ROOT=~/ycm_temp/llvm_root_dir . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</code></li>
<li>如果想用系统的libclang：<code>cmake -G &quot;Unix Makefiles&quot; -DUSE_SYSTEM_LIBCLANG=ON . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</code></li>
<li>如果想用自定义的libclang：<code>cmake -G &quot;Unix Makefiles&quot; -DEXTERNAL_LIBCLANG_PATH=/path/to/libclang.so . ~/.vim/bundle/YouCompleteMe/third_party/ycmd/cpp</code>。/path/to/libclang.so这部分填入你自己的路径。<br>makefiles生成后执行：<code>make ycm_support_libs</code></li>
</ul>
</li>
</ul>
</li>
</ol>
<p>我是从llvm网站下载的二进制文件，安装的，安装过程中也没遇到什么问题。</p>
<h3 id="Ubuntu_Linux_X64_超快安装">Ubuntu Linux X64 超快安装</h3><p>最好还是完整安装，这种快速安装未必适合所有人。安装之前，同样也要确定满足以上所述的vim版本、python支持等条件。和上面一样使用Vundle安装YCM，安装CMake和python头文件。</p>
<p>编译YCM，如果需要对C-family的语义支持：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~/.<span class="keyword">vim</span>/bundle/YouCompleteMe</span><br><span class="line">./install.<span class="keyword">sh</span> --clang-completer</span><br></pre></td></tr></table></figure></p>
<p>如果不需要对C-family的语义支持：<br><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> ~/.<span class="keyword">vim</span>/bundle/YouCompleteMe</span><br><span class="line">./install.<span class="keyword">sh</span></span><br></pre></td></tr></table></figure></p>
<p>如果需要支持C#，添加 <code>--omnisharp-complete</code>。如果需要支持Go添加<code>--gocode-completer</code></p>
<h2 id="配置">配置</h2><p>YCM使用TAB键接受补全，一直按TAB则会循环所有的匹配补全项。shift+TAB则会反向循环。注意：如果使用控制台Vim（非GVim或MacVim等），控制台不会将shift+Tab传递给Vim，因此会无反应，需要重新映射按键。此外，如果同时使用ultisnaps，可能会有冲突，需要进行一些设置。可以使用Ctrl+Space来触发补全，不过会和输入法冲突，也需要设置。</p>
<p>YCM会寻找当前打开的文件的同级目录下或上级目录中的<code>ycm_extra_conf.py</code>这个文件，找到后会加载为Python模块，且只加载一次。YCM调用该模块中的FlagsForFile方法。该模块必须提供带有编译当前文件的必要信息的这个方法。需要修改<code>.ycm_extra_conf.py</code>文件中的flags部分，使用-isystem添加系统的头文件进行解析，使用-I添加第三方的头文件进行解析，在flags部分后添加如下内容：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'-isystem'</span>,</span><br><span class="line"><span class="string">'/usr/include'</span>,</span><br></pre></td></tr></table></figure>
<p>使用命令<code>:YcmDiags</code>可以打开location-list查看警告和错误信息。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">set</span> completeopt=longest,menu	"让Vim的补全菜单行为与一般IDE一致(参考VimTip1228)</span><br><span class="line">autocmd InsertLeave * <span class="keyword">if</span> pumvisible() == 0|pclose|endif	"离开插入模式后自动关闭预览窗口</span><br><span class="line">inoremap &lt;expr&gt; &lt;CR&gt;       pumvisible() ? <span class="string">"\&lt;C-y&gt;"</span> : <span class="string">"\&lt;CR&gt;"</span>	"回车即选中当前项</span><br><span class="line">"上下左右键的行为 会显示其他信息</span><br><span class="line">inoremap &lt;expr&gt; &lt;Down&gt;     pumvisible() ? <span class="string">"\&lt;C-n&gt;"</span> : <span class="string">"\&lt;Down&gt;"</span></span><br><span class="line">inoremap &lt;expr&gt; &lt;Up&gt;       pumvisible() ? <span class="string">"\&lt;C-p&gt;"</span> : <span class="string">"\&lt;Up&gt;"</span></span><br><span class="line">inoremap &lt;expr&gt; &lt;PageDown&gt; pumvisible() ? <span class="string">"\&lt;PageDown&gt;\&lt;C-p&gt;\&lt;C-n&gt;"</span> : <span class="string">"\&lt;PageDown&gt;"</span></span><br><span class="line">inoremap &lt;expr&gt; &lt;PageUp&gt;   pumvisible() ? <span class="string">"\&lt;PageUp&gt;\&lt;C-p&gt;\&lt;C-n&gt;"</span> : <span class="string">"\&lt;PageUp&gt;"</span></span><br><span class="line">" 跳转到定义处</span><br><span class="line">nnoremap &lt;leader&gt;jd :YcmCompleter GoToDefinitionElseDeclaration&lt;CR&gt;</span><br><span class="line">nnoremap &lt;F6&gt; :YcmForceCompileAndDiagnostics&lt;CR&gt;	"force recomile with syntastic</span><br><span class="line"><span class="string">" nnoremap &lt;leader&gt;lo :lopen&lt;CR&gt;	"</span><span class="keyword">open</span> locationlist</span><br><span class="line"><span class="string">" nnoremap &lt;leader&gt;lc :lclose&lt;CR&gt;	"</span><span class="keyword">close</span> locationlist</span><br><span class="line">inoremap &lt;leader&gt;&lt;leader&gt; &lt;C-x&gt;&lt;C-o&gt;</span><br><span class="line"></span><br><span class="line">let <span class="keyword">g</span>:ycm_global_ycm_extra_conf = '~/.vim/data/ycm/.ycm_extra_conf.py'</span><br><span class="line">" 不显示开启vim时检查ycm_extra_conf文件的信息  </span><br><span class="line">let <span class="keyword">g</span>:ycm_confirm_extra_conf=0</span><br><span class="line">" 开启基于tag的补全，可以在这之后添加需要的标签路径  </span><br><span class="line">let <span class="keyword">g</span>:ycm_collect_identifiers_from_tags_files=1</span><br><span class="line">"注释和字符串中的文字也会被收入补全</span><br><span class="line">let <span class="keyword">g</span>:ycm_collect_identifiers_from_comments_and_strings = 0</span><br><span class="line">" 输入第2个字符开始补全</span><br><span class="line">let <span class="keyword">g</span>:ycm_min_num_of_chars_for_completion=2</span><br><span class="line">" 禁止缓存匹配项,每次都重新生成匹配项</span><br><span class="line">let <span class="keyword">g</span>:ycm_cache_omnifunc=0</span><br><span class="line">" 开启语义补全</span><br><span class="line">let <span class="keyword">g</span>:ycm_seed_identifiers_with_syntax=1	</span><br><span class="line">"在注释输入中也能补全</span><br><span class="line">let <span class="keyword">g</span>:ycm_complete_in_comments = 1</span><br><span class="line">"在字符串输入中也能补全</span><br><span class="line">let <span class="keyword">g</span>:ycm_complete_in_strings = 1</span><br><span class="line">" 设置在下面几种格式的文件上屏蔽ycm</span><br><span class="line">let <span class="keyword">g</span>:ycm_filetype_blacklist = &#123;</span><br><span class="line">      \ 'tagbar' : 1,</span><br><span class="line">      \ 'nerdtree' : 1,</span><br><span class="line">      \&#125;</span><br><span class="line">"youcompleteme  默认<span class="keyword">tab</span>  s-<span class="keyword">tab</span> 和 ultisnips 冲突</span><br><span class="line">let <span class="keyword">g</span>:ycm_key_list_select_completion = ['&lt;Down&gt;']</span><br><span class="line">let <span class="keyword">g</span>:ycm_key_list_previous_completion = ['&lt;Up&gt;']</span><br><span class="line">" 修改对C函数的补全快捷键，默认是CTRL + space，修改为ALT + ;</span><br><span class="line">let <span class="keyword">g</span>:ycm_key_invoke_completion = '&lt;<span class="keyword">M</span>-;&gt;'</span><br><span class="line"></span><br><span class="line">" SirVer/ultisnips 代码片断</span><br><span class="line">" Trigger configuration. <span class="keyword">Do</span> not <span class="keyword">use</span> &lt;<span class="keyword">tab</span>&gt; <span class="keyword">if</span> you <span class="keyword">use</span> https:<span class="comment">//github.com/Valloric/YouCompleteMe.</span></span><br><span class="line">let <span class="keyword">g</span>:UltiSnipsExpandTrigger=<span class="string">"&lt;tab&gt;"</span></span><br><span class="line">let <span class="keyword">g</span>:UltiSnipsJumpForwardTrigger=<span class="string">"&lt;tab&gt;"</span></span><br><span class="line">let <span class="keyword">g</span>:UltiSnipsJumpBackwardTrigger=<span class="string">"&lt;s-tab&gt;"</span></span><br><span class="line">let <span class="keyword">g</span>:UltiSnipsListSnippets=<span class="string">"&lt;c-e&gt;"</span></span><br><span class="line">"定义存放代码片段的文件夹，使用自定义和默认的，将会的到全局，有冲突的会提示</span><br><span class="line">let <span class="keyword">g</span>:UltiSnipsSnippetDirectories=[<span class="string">"bundle/vim-snippets/UltiSnips"</span>]</span><br><span class="line"></span><br><span class="line">" 参考https:<span class="comment">//github.com/Valloric/YouCompleteMe/issues/36#issuecomment-62941322</span></span><br><span class="line">" 解决ultisnips和ycm <span class="keyword">tab</span>冲突，如果不使用下面的办法解决可以参考</span><br><span class="line">" https:<span class="comment">//github.com/Valloric/YouCompleteMe/issues/36#issuecomment-63205056的配置</span></span><br><span class="line">" begin</span><br><span class="line">" let <span class="keyword">g</span>:ycm_key_list_select_completion=['&lt;C-<span class="keyword">n</span>&gt;', '&lt;Down&gt;']</span><br><span class="line">" let <span class="keyword">g</span>:ycm_key_list_previous_completion=['&lt;C-p&gt;', '&lt;Up&gt;']</span><br><span class="line"><span class="string">" let g:UltiSnipsExpandTrigger="</span>&lt;<span class="keyword">Tab</span>&gt;"</span><br><span class="line"><span class="string">" let g:UltiSnipsJumpForwardTrigger="</span>&lt;<span class="keyword">Tab</span>&gt;"                                           </span><br><span class="line"><span class="string">" let g:UltiSnipsJumpBackwardTrigger="</span>&lt;S-<span class="keyword">Tab</span>&gt;"</span><br><span class="line">" end</span><br><span class="line">" UltiSnips completion function that tries to <span class="keyword">expand</span> a snippet. <span class="keyword">If</span> there's <span class="keyword">no</span></span><br><span class="line">" snippet <span class="keyword">for</span> expanding, it checks <span class="keyword">for</span> completion <span class="keyword">window</span> and <span class="keyword">if</span> it'<span class="literal">s</span></span><br><span class="line">" shown, selects first element. <span class="keyword">If</span> there's <span class="keyword">no</span> completion <span class="keyword">window</span> it tries to</span><br><span class="line">" jump to next placeholder. <span class="keyword">If</span> there's <span class="keyword">no</span> placeholder it just returns <span class="keyword">TAB</span> key </span><br><span class="line">function! <span class="keyword">g</span>:UltiSnips_Complete()</span><br><span class="line">    call UltiSnips#ExpandSnippet()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">g</span>:ulti_expand_res == 0</span><br><span class="line">        <span class="keyword">if</span> pumvisible()</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"\&lt;C-n&gt;"</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            call UltiSnips#JumpForwards()</span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">g</span>:ulti_jump_forwards_res == 0</span><br><span class="line">               <span class="keyword">return</span> <span class="string">"\&lt;TAB&gt;"</span></span><br><span class="line">            endif</span><br><span class="line">        endif</span><br><span class="line">    endif</span><br><span class="line">    <span class="keyword">return</span> <span class="string">""</span></span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">au BufEnter * exec <span class="string">"inoremap &lt;silent&gt; "</span> . <span class="keyword">g</span>:UltiSnipsExpandTrigger . <span class="string">" &lt;C-R&gt;=g:UltiSnips_Complete()&lt;cr&gt;"</span></span><br><span class="line"></span><br><span class="line">" <span class="keyword">Expand</span> snippet or <span class="literal">return</span></span><br><span class="line">let <span class="keyword">g</span>:ulti_expand_res = 1</span><br><span class="line">function! Ulti_ExpandOrEnter()</span><br><span class="line">    call UltiSnips#ExpandSnippet()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">g</span>:ulti_expand_res</span><br><span class="line">        <span class="keyword">return</span> ''</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"\&lt;return&gt;"</span></span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">" <span class="keyword">Set</span> &lt;space&gt; <span class="keyword">as</span> primary trigger</span><br><span class="line">inoremap &lt;<span class="keyword">return</span>&gt; &lt;C-R&gt;=Ulti_ExpandOrEnter()&lt;CR&gt;</span><br></pre></td></tr></table></figure>
<h2 id="YCM_&amp;_Eclim">YCM &amp; Eclim</h2><p>YCM配合Eclim可以实现对Java代码的自动提示，首先需要下载<a href="http://eclim.org/install.html" target="_blank" rel="external">Eclim</a>，下载好后执行<code>java -jar eclim_2.4.1.jar</code>，卸载的话，后面再加个参数<code>uninstaller</code>就行。按提示一步步安装就好了，安装好后首先要启动eclimd，它存放在eclipse的根目录下。</p>
<p>对不同的自动补全插件eclim都提供了<a href="http://eclim.org/vim/code_completion.html" target="_blank" rel="external">配置方法</a>，对于YCM我们只需要在vimrc中添加一行<code>let g:EclimCompletionMethod = &#39;omnifunc&#39;</code>就可以了。</p>
<p>打开vim执行<code>:ProjectCreate /path/to/project -n java</code>创建一个新的工程。这个工程的结构和eclipse类似。<code>:ProjectList</code>命令可以查看工程列表。</p>
<p>这个插件很有意思，可以在eclipse中嵌入vim，又可以在vim中享受eclipse一样的自动补全。对于Java来说，提供了一些以<code>Java</code>，<code>Project</code>，<code>New</code>，<code>Mvn</code>为前缀的命名。可以输入<code>:Java</code>按Tab键尝试一下。不过，我觉得还是使用eclipse配合viPlugin插件更方便些。</p>
<p>参考：</p>
<ol>
<li><a href="http://www.cnblogs.com/zhongcq/p/3630047.html" target="_blank" rel="external">Vim自动补全插件——YouCompleteMe安装与配置</a></li>
<li><a href="http://blog.csdn.net/leaf5022/article/details/21290509" target="_blank" rel="external">Vim智能补全插件YouCompleteMe安装</a></li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[Vim 自动补全；Vim YouCompleteMe 安装；Vim YouCompleteMe 配置；]]>
    
    </summary>
    
      <category term="Vim" scheme="http://howiefh.github.io/tags/Vim/"/>
    
      <category term="Vim" scheme="http://howiefh.github.io/categories/Vim/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shiro & CAS 实现单点登录]]></title>
    <link href="http://howiefh.github.io/2015/05/19/shiro-cas-single-sign-on/"/>
    <id>http://howiefh.github.io/2015/05/19/shiro-cas-single-sign-on/</id>
    <published>2015-05-18T16:11:12.000Z</published>
    <updated>2015-07-13T14:20:08.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概览">概览</h2><p>单点登录主要用于多系统集成，即在多个系统中，用户只需要到一个中央服务器登录一次即可访问这些系统中的任何一个，无须多次登录。</p>
<p>本文使用开源框架<a href="https://github.com/Jasig/cas/releases" target="_blank" rel="external">Jasig CAS</a>来完成单点登录。下载地址：<a href="https://www.apereo.org/cas/download" target="_blank" rel="external">https://www.apereo.org/cas/download</a>。在写本文时，使用的cas server版本为4.0.1</p>
<a id="more"></a>
<h2 id="部署服务器">部署服务器</h2><p>本文服务器使用Tomcat7，下载了<a href="http://downloads.jasig.org/cas/cas-server-4.0.0-release.zip" target="_blank" rel="external">cas-server-4.0.0-release.zip</a>，将其解压，找到modules目录下面的cas-server-webapp-4.0.0.war直接复制到webapps文件夹下即可。启动Tomcat，访问<a href="http://localhost:8080/cas-server-webapp-4.0.0，使用casuser/Mellon登录，即可登录成功。" target="_blank" rel="external">http://localhost:8080/cas-server-webapp-4.0.0，使用casuser/Mellon登录，即可登录成功。</a></p>
<p>Tomcat默认没有开启HTTPS协议，所以这里直接用了HTTP协议访问。为了能使客户端在HTTP协议下单点登录成功，需要修改一下配置：</p>
<ul>
<li><p>WEB-INF\spring-configuration\ticketGrantingTicketCookieGenerator.xml和WEB-INF\spring-configuration\warnCookieGenerator.xml：将<code>p:cookieSecure=&quot;true&quot;</code>改为<code>p:cookieSecure=&quot;false&quot;</code></p>
</li>
<li><p>WEB-INF\deployerConfigContext.xml：<code>&lt;bean class=&quot;org.jasig.cas.authentication.handler.support.HttpBasedServiceCredentialsAuthenticationHandler&quot; p:httpClient-ref=&quot;httpClient&quot; /&gt;</code>添加<code>p:requireSecure=&quot;false&quot;</code></p>
</li>
</ul>
<p>至此，一个简单的单点登录服务器就基本部署好了。</p>
<h2 id="部署客户端">部署客户端</h2><p>客户端需要添加对<a href="http://shiro.apache.org/cas.html" target="_blank" rel="external">shiro-cas</a>和cas-client-core这两个包的依赖。这里主要讲跟CAS相关的配置。</p>
<p>之后配置web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用于单点退出，该过滤器用于实现单点登出功能，可选配置。--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutHttpSessionListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 该过滤器用于实现单点登出功能，可选配置。 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自定义Realm：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyCasRealm</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">CasRealm</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">UserService</span> userService;</span><br><span class="line"></span><br><span class="line">    public void setUserService(<span class="type">UserService</span> userService) &#123;</span><br><span class="line">        <span class="keyword">this</span>.userService = userService;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="type">AuthorizationInfo</span> doGetAuthorizationInfo(<span class="type">PrincipalCollection</span> principals) &#123;</span><br><span class="line">        <span class="type">String</span> username = (<span class="type">String</span>)principals.getPrimaryPrincipal();</span><br><span class="line">        <span class="type">SimpleAuthorizationInfo</span> authorizationInfo = <span class="keyword">new</span> <span class="type">SimpleAuthorizationInfo</span>();</span><br><span class="line">        authorizationInfo.setRoles(userService.findRoles(username));</span><br><span class="line">        authorizationInfo.setStringPermissions(userService.findPermissions(username));</span><br><span class="line">        <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"casRealm"</span> <span class="attribute">class</span>=<span class="value">"package.for.your.MyCasRealm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"userService"</span> <span class="attribute">ref</span>=<span class="value">"userService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cachingEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authenticationCachingEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authenticationCacheName"</span> <span class="attribute">value</span>=<span class="value">"authenticationCache"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authorizationCachingEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authorizationCacheName"</span> <span class="attribute">value</span>=<span class="value">"authorizationCache"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--该地址为cas server地址 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"casServerUrlPrefix"</span> <span class="attribute">value</span>=<span class="value">"$&#123;shiro.casServer.url&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 该地址为是当前应用 CAS 服务 URL，即用于接收并处理登录成功后的 Ticket 的，</span><br><span class="line">    必须和loginUrl中的service参数保持一致，否则服务器会判断service不匹配--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"casService"</span> <span class="attribute">value</span>=<span class="value">"$&#123;shiro.client.cas&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>配置CAS过滤器</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"casFilter"</span> class=<span class="string">"org.apache.shiro.cas.CasFilter"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"failureUrl"</span> value=<span class="string">"/casFailure.jsp"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"shiroFilter"</span> class=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"securityManager"</span> <span class="keyword">ref</span>=<span class="string">"securityManager"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"loginUrl"</span> value=<span class="string">"$&#123;shiro.login.url&#125;"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"successUrl"</span> value=<span class="string">"$&#123;shiro.login.success.url&#125;"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"filters"</span>&gt;</span><br><span class="line">        &lt;util:map&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"cas"</span> value-<span class="keyword">ref</span>=<span class="string">"casFilter"</span>/&gt;</span><br><span class="line">            &lt;entry key=<span class="string">"logout"</span> value-<span class="keyword">ref</span>=<span class="string">"logoutFilter"</span> /&gt;</span><br><span class="line">        &lt;/util:map&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">    &lt;property name=<span class="string">"filterChainDefinitions"</span>&gt;</span><br><span class="line">        &lt;value&gt;</span><br><span class="line">            /casFailure.jsp = anon</span><br><span class="line">            /cas = cas</span><br><span class="line">            /logout = logout</span><br><span class="line">            /** = user</span><br><span class="line">        &lt;/value&gt;</span><br><span class="line">    &lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>上面登录url我的配置的是<code>http://localhost:8080/cas-server/login?service=http://localhost:8080/cas-client/cas</code>，service参数是之后服务将会跳转的地址。</p>
<p><code>/cas=cas</code>：即/cas 地址是服务器端回调地址，使用 CasFilter 获取 Ticket 进行登录。</p>
<p>之后通过eclipse部署，访问<a href="http://localhost:8080/cas-client" target="_blank" rel="external">http://localhost:8080/cas-client</a> 即可测试。为了看到单点登录的效果，可以直接复制一份webapps中的client为client2，只需要修改上述配置中的地址即可。如果用户已经登录，那么访问<a href="http://localhost:8080/cas-client2发现不会再跳转到登录页面了，用户已经是登录状态了。" target="_blank" rel="external">http://localhost:8080/cas-client2发现不会再跳转到登录页面了，用户已经是登录状态了。</a></p>
<p>还需要注意一个问题，就是cas server默认是开启单点登出的但是这里却没有这样的效果，APP1登出了，但是APP2仍能访问，如果查看浏览器的cookie的话，会发现有两个sessionid，一个是JSESSIONID，容器原生的，另一个是shiro中配置的:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 会话Cookie模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionIdCookie"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">SingleSignOutFilter发现是logoutRequest请求后，原来SingleSignOutHandler中创建的原生的session已经被销毁了，因为从a登出的，a的shiro session也会销毁，</span><br><span class="line">    但是b的shiro的session还没有被销毁，于是再访问b还是能访问，单点登出就有问题了--&gt;</span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"JSESSIONID"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"httpOnly"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxAge"</span> <span class="attribute">value</span>=<span class="value">"-1"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果我们把sid改为JSESSIONID会怎么样，答案是如果改为JSESSIONID会导致重定向循环，原因是当登录时，shiro发现浏览器发出的请求中的JSESSIONID没有或已经过期，于是生成一个JSESSIONID给浏览器，同时链接被重定向到服务器进行认证，认证成功后返回到客户端服务器的cas service url，并且带有一个ticket参数。因为有SingleSignOutFilter，当发现这是一个tocken请求时，SingleSignOutHandler会调用request.getSession()获取的是原生Session，如果没有原生session的话，又会创建并将JSESSIONID保存到浏览器cookie中，当客户端服务器向cas服务器验证ticket之后，客户端服务器重定向到之前的页面，这时shiro发现JSESSIONID是SingleSignOutHandler中生成的，在自己维护的session中查不到，又会重新生成新的session，然后login，然后又会重定向到cas服务器认证，然后再重定向到客户端服务器的cas service url，不同的是SingleSignOutHandler中这次调用session.getSession(true)不会新创建一个了，之后就如此循环。如果使用sid又会导致当单点登出时候，如果有a、b两个客户端服务器，从a登出，会跳转到cas服务器登出，cas服务器会对所有通过它认证的service调用销毁session的方法，但是b的shiro的session还没有被销毁，于是再访问b还是能访问，单点登出就有问题了</p>
<p>之所以这样是因为我设置shiro的session管理器为DefaultWebSessionManager，这个管理器直接抛弃了容器的session管理器，自己来维护session，所以就会出现上述描述的问题了。如果我们不做设置，那么shiro将使用默认的session管理器ServletContainerSessionManager：Web 环境，其直接使用 Servlet 容器的会话。这样单点登出就可以正常使用了。</p>
<p>此外如果我们非要使用DefaultWebSessionManager的话，我们就要重写一个SingleSignOutFilter、SingleSignOutHandler和SessionMappingStorage了。</p>
<p>如果没有使用Spring框架，则可以参考如下配置web.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-app</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">	<span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/javaee"</span> <span class="attribute">xmlns:web</span>=<span class="value">"http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span><br><span class="line">	<span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_2_5.xsd"</span></span><br><span class="line">	<span class="attribute">id</span>=<span class="value">"WebApp_ID"</span> <span class="attribute">version</span>=<span class="value">"2.5"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">display-name</span>&gt;</span>YPshop Authority Manage<span class="tag">&lt;/<span class="title">display-name</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">context-param</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">param-name</span>&gt;</span>webAppRootKey<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">param-value</span>&gt;</span>authority.root<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">&lt;!-- ======================== 单点登录开始 ======================== --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 说明：这种客户端的配置方式是不需要Spring支持的 --&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- 参考资料：http://blog.csdn.net/yaoweijq/article/details/6003187 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">listener</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutHttpSessionListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.jasig.cas.client.session.SingleSignOutFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Single Sign Out Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Authentication Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.jasig.cas.client.authentication.AuthenticationFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>casServerLoginUrl<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>https://localhost:8443/cas-server/login<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>serverName<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>https://localhost:8443<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Authentication Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Validation Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.jasig.cas.client.validation.Cas20ProxyReceivingTicketValidationFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>casServerUrlPrefix<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>https://localhost:8443/cas-server<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>serverName<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">	        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>https://localhost:8443<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Validation Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- 该过滤器使得开发者可以通过org.jasig.cas.client.util.AssertionHolder来获取用户的登录名。 比如AssertionHolder.getAssertion().getPrincipal().getName()。 --&gt;</span></span><br><span class="line"> 	<span class="tag">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Assertion Thread Local Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.jasig.cas.client.util.AssertionThreadLocalFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>CAS Assertion Thread Local Filter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- ======================== 单点登录结束 ======================== --&gt;</span></span><br><span class="line"></span><br><span class="line">	<span class="tag">&lt;<span class="title">welcome-file-list</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">welcome-file</span>&gt;</span>index.html<span class="tag">&lt;/<span class="title">welcome-file</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">welcome-file</span>&gt;</span>index.jsp<span class="tag">&lt;/<span class="title">welcome-file</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">welcome-file-list</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">distributable</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="进阶">进阶</h2><h3 id="使用HTTPS协议">使用HTTPS协议</h3><p>首先我们需要生成数字证书<br><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">keytool -genkey -keystore "D:\localhost.keystore" -alias localhost -keyalg RSA</span><br><span class="line">输入密钥库口令:</span><br><span class="line">再次输入新口令:</span><br><span class="line">您的名字与姓氏是什么?</span><br><span class="line">[<span class="link_reference">Unknown</span>]:<span class="link_url"> localhost</span></span><br><span class="line">您的组织单位名称是什么?</span><br><span class="line">[<span class="link_reference">Unknown</span>]:<span class="link_url"> xa</span></span><br><span class="line">您的组织名称是什么?</span><br><span class="line">[<span class="link_reference">Unknown</span>]:<span class="link_url"> xa</span></span><br><span class="line">您所在的城市或区域名称是什么?</span><br><span class="line">[<span class="link_reference">Unknown</span>]:<span class="link_url"> xi'an</span></span><br><span class="line">您所在的省/市/自治区名称是什么?</span><br><span class="line">[<span class="link_reference">Unknown</span>]:<span class="link_url"> xi'an</span></span><br><span class="line">该单位的双字母国家/地区代码是什么?</span><br><span class="line">[<span class="link_reference">Unknown</span>]:<span class="link_url"> cn</span></span><br><span class="line">CN=localhost, OU=xa, O=xa, L=xi'an, ST=xi'an, C=cn 是否正确</span><br><span class="line">?</span><br><span class="line">[<span class="link_reference">否</span>]:<span class="link_url"> y</span></span><br><span class="line">输入 <span class="xml"><span class="tag">&lt;<span class="title">localhost</span>&gt;</span></span> 的密钥口令</span><br><span class="line">(如果和密钥库口令相同, 按回车):</span><br></pre></td></tr></table></figure></p>
<p>需要注意的是 “您的名字与姓氏是什么?”这个地方不能随便填的，如果运行过程中提示“Caused by: java.security.cert.CertificateException: No name matching localhost found”那么就是因为这里设置错了，当然除了localhost也可以写其他的，如helloworld.com，但是需要能解析出来，可以直接在hosts中加<code>127.0.0.1 helloworld.com</code></p>
<p>然后，由于Tomcat默认没有开HTTPS，所以我们需要在server.xml文件中找到8443出现的地方。然后修改如下</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;Connector <span class="variable">port=</span><span class="string">"8443"</span> <span class="variable">protocol=</span><span class="string">"HTTP/1.1"</span> <span class="variable">SSLEnabled=</span><span class="string">"true"</span></span><br><span class="line">    <span class="variable">maxThreads=</span><span class="string">"150"</span> <span class="variable">scheme=</span><span class="string">"https"</span> <span class="variable">secure=</span><span class="string">"true"</span></span><br><span class="line">    <span class="variable">clientAuth=</span><span class="string">"false"</span> <span class="variable">sslProtocol=</span><span class="string">"TLS"</span></span><br><span class="line">    <span class="variable">keystoreFile=</span><span class="string">"D:\localhost.keystore"</span> <span class="variable">keystorePass=</span><span class="string">"123456"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>keystorePass 就是生成 keystore 时设置的密码。</p>
<p>如果出现下面的问题，修改server.xml中的protocol为<code>org.apache.coyote.http11.Http11Protocol</code></p>
<p>Failed to initialize end point associated with ProtocolHandler [“http-apr-8443”]<br>java.lang.Exception: Connector attribute SSLCertificateFile must be defined when using SSL with APR</p>
<p>因为 CAS client 需要使用该证书进行验证，所以我们要使用 localhost.keystore 导出数字证书（公钥）到 D:\localhost.cer。再将将证书导入到 JDK 中。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">keytool -export -alias localhost -<span class="keyword">file</span> <span class="keyword">D</span>:\localhost.cer -keystore <span class="keyword">D</span>:\localhost.keystore</span><br><span class="line"><span class="keyword">cd</span> <span class="keyword">D</span>:\jdk1.7.0_21\jre\lib\security</span><br><span class="line">keytool -import -alias localhost -<span class="keyword">file</span> <span class="keyword">D</span>:\localhost.cer -noprompt -trustcacerts -storetype jks -keystore cacerts -storepass 123456</span><br></pre></td></tr></table></figure>
<p>如果导入失败，可以先把 security 目录下的 cacerts 删掉</p>
<p>搞定证书之后，我们需要将之前client中配置的地址修改一下。然后还可以添加ssl过滤器。</p>
<p>如果遇到以下异常，一般是证书导入错误造成的，请尝试重新导入，如果还是不行，有可能是运行应用的 JDK 和安装数字证书的 JDK 不是同一个造成的：</p>
<p>Caused by: sun.security.validator.ValidatorException: PKIX path building failed: sun.security.provider.certpath.SunCertPathBuilderException: unable to find valid certification path to requested target</p>
<h3 id="单点登出重定向">单点登出重定向</h3><p>客户端中配置logout过滤器</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"logoutFilter"</span> <span class="variable">class=</span><span class="string">"org.apache.shiro.web.filter.authc.LogoutFilter"</span>&gt;</span><br><span class="line">    &lt;property <span class="variable">name=</span><span class="string">"redirectUrl"</span> <span class="variable">value=</span><span class="string">"<span class="subst">$&#123;shiro.logout.url&#125;</span>"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>WEB-INF/cas-servlet.xml中将 <code>cas.logout.followServiceRedirects</code>修改为true即可在登出后重定向到service参数提供的地址</p>
<h3 id="单点登出">单点登出</h3><p>单点登出重定向是很好解决了，但是在客户端与shiro集成过程中，如客户端部署部分所述，如果shiro没有使用 ServletContainerSessionManager 管理session，单点登出就会有问题了。最简单奏效的办法就是改用 ServletContainerSessionManager 了，但是我们偏要用 DefaultWebSessionManager 呢，那就应该要参考org.jasig.cas.client.session这个包中的几个类，重新实现单点登出了。我的思路是，添加一个shiro过滤器，继承自AdviceFilter在preHandle方法中实现逻辑：如果请求中包含了ticket参数，记录ticket和sessionID的映射；如果请求中包含logoutRequest参数，标记session为无效；如果session不为空，且被标记为无效，则登出。如果请求中包含了logoutRequest参数，那么这个请求是从cas服务器发出的，所以这里不能直接用subject.logout()，因为subject跟线程绑定，客户端对cas服务器端的请求会创建一个新的subject。</p>
<p>那么CAS单点登出是怎么实现的呢，下面是我对CAS单点登出的简单理解：</p>
<p>在TicketGrantingTicketImpl有一个HashMap<string, service=""> services字段，以id和通过认证的客户端service为键值对。当我们要登出时LogoutManagerImpl通过for (final String ticketId : services.keySet())向每个service发送一个POST请求，请求中包含一个logoutRequest参数，参数的值由SamlCompliantLogoutMessageCreator创建。客户端的 SingleSignOutFilter会判断请求中是否包含了logoutRequest参数，如果包含，那么销毁session。SingleSignOutHttpSessionListener实现了javax.servlet.http.HttpSessionListener接口，用于监听session销毁事件。</string,></p>
<p>我在配置的过程中发现单点登出有问题，首先在服务端打开 debug log，cas 服务器默认是打开单点登出功能的，所以正常的话日志中会记录<code>&lt;Sending logout request for: [https://localhost:8443/cas-client1/cas]&gt;</code>之类的内容，有日志记录发送了请求，一般服务器应该不会有什么问题了。那么有可能会是客户端的问题，我重新配置了一个客户端，这个客户端没有使用spring也没有使用shiro，只用了在部署客户端中提到的无spring的web.xml文件，发现从其他客户端登出，这个客户端也是登出的，所以这个配置是没有什么问题。后来在浏览器打开控制台才发现有两个SESSIONID一个是sid是在shiro中配置的，另一个是JSESSIONID，应该是容器原生的。再然后就下了3.2.2版本的cas-client-core，通过maven构建，导入eclipse中，开始调试。我们的cas-client要依赖这个cas-client-core工程，怎么设置可以参考<a href="http://howiefh.github.io/2014/02/08/eclipse-tips/">eclipse小技巧</a>。然后调试，一定要保证在cas-client的propertie 设置中的Deployment Assembly中已经没有之前的版本的cas-client-core的jar包了。调试的过程中才发现，SingleSignOutFilter销毁的是容器原生的session，但是shiro的session还在，所以如果是从其他客户端登出的，那这个客户端还是能够登录。</p>
<h3 id="通过数据库中的用户密码认证">通过数据库中的用户密码认证</h3><p>服务器端需要添加cas-server-support-jdbc和mysql-connector-java依赖。</p>
<p>cas-server-support-jdbc提供了org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler、org.jasig.cas.adaptors.jdbc.SearchModeSearchDatabaseAuthenticationHandler 和org.jasig.cas.adaptors.jdbc.QueryAndEncodeDatabaseAuthenticationHandler。他们都继承自AbstractJdbcUsernamePasswordAuthenticationHandler 能够通过配置sql语句验证用户凭证，后者更复杂些，能够配置盐，散列函数迭代次数。</p>
<p>下面说一下配置QueryDatabaseAuthenticationHandler，配置/src/main/webapp/WEB-INF/deployerConfigContext.xml，先注释掉原先的primaryAuthenticationHandler然后添加下面配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 自定义数据库鉴权 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"primaryAuthenticationHandler"</span> <span class="attribute">class</span>=<span class="value">"org.jasig.cas.adaptors.jdbc.QueryDatabaseAuthenticationHandler"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sql"</span>  <span class="attribute">value</span>=<span class="value">"$&#123;auth.sql&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"passwordEncoder"</span> <span class="attribute">ref</span>=<span class="value">"MD5PasswordEncoder"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 数据源 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClassName"</span> <span class="attribute">value</span>=<span class="value">"$&#123;dataSource.driver&#125;"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"url"</span> <span class="attribute">value</span>=<span class="value">"$&#123;dataSource.url&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"username"</span> <span class="attribute">value</span>=<span class="value">"$&#123;dataSource.username&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"$&#123;dataSource.password&#125;"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- MD5加密 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"MD5PasswordEncoder"</span> <span class="attribute">class</span>=<span class="value">"org.jasig.cas.authentication.handler.DefaultPasswordEncoder"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"MD5"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>加密算法可以自定义。</p>
<h3 id="添加验证码">添加验证码</h3><p>验证码的实现使用了kaptcha，所以需要添加其依赖。</p>
<p>web.xml添加如下配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>Kaptcha<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>com.google.code.kaptcha.servlet.KaptchaServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设定宽度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.image.width<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>100<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 设定高度 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.image.height<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>50<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 如果需要全部是数字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.textproducer.char.string<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>0123456789<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 去掉干扰线 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>kaptcha.noise.impl<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>com.google.code.kaptcha.impl.NoNoise <span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>Kaptcha<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/captcha.jpg<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在login-webflow.xml中找到viewLoginForm，在binder节点下面添加<code>&lt;binding property=&quot;captcha&quot; /&gt;</code>，对应我们页面提交的验证码参数</p>
<p>然后我们还要实现一个UsernamePasswordCaptchaCredential 类，继承UsernamePasswordCredential 在其中添加了captcha字段和相应setter和getter方法。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">UsernamePasswordCaptchaCredential</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">UsernamePasswordCredential</span> &#123;</span></span><br><span class="line">	<span class="keyword">private</span> static <span class="keyword">final</span> long serialVersionUID = -<span class="number">2988130322912201986</span>L;</span><br><span class="line">    <span class="annotation">@NotNull</span></span><br><span class="line">    <span class="annotation">@Size</span>(min=<span class="number">1</span>,message = <span class="string">"required.captcha"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> captcha;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//set、get方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着回到 login-webflow.xml ，找到credential的声明处，将org.jasig.cas.authentication.UsernamePasswordCredential修改为刚刚实现的类全路径名。viewLoginForm 也需要修改</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;transition <span class="variable">on=</span><span class="string">"submit"</span> <span class="variable">bind=</span><span class="string">"true"</span> <span class="variable">validate=</span><span class="string">"true"</span> <span class="variable">to=</span><span class="string">"validatorCaptcha"</span>&gt;</span><br><span class="line">    &lt;evaluate <span class="variable">expression=</span><span class="string">"authenticationViaFormAction.doBind(flowRequestContext, flowScope.credential)"</span> /&gt;</span><br><span class="line">&lt;/transition&gt;</span><br></pre></td></tr></table></figure>
<p>再添加如下配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 添加一个 validatorCaptcha 校验验证码的操作 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">action-state</span> <span class="attribute">id</span>=<span class="value">"validatorCaptcha"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">evaluate</span> <span class="attribute">expression</span>=<span class="value">"authenticationViaFormAction.validatorCaptcha(flowRequestContext, flowScope.credential, messageContext)"</span>&gt;</span><span class="tag">&lt;/<span class="title">evaluate</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">transition</span> <span class="attribute">on</span>=<span class="value">"error"</span> <span class="attribute">to</span>=<span class="value">"generateLoginTicket"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">transition</span> <span class="attribute">on</span>=<span class="value">"success"</span> <span class="attribute">to</span>=<span class="value">"realSubmit"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">action-state</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们在配置中添加了一个 validatorCaptcha 的操作，同时可以看到 expression 是 authenticationViaFormAction.validatorCaptcha(…)，所以我们需要在  authenticationViaFormAction 中添加一个校验验证码的方法 validatorCaptcha()。authenticationViaFormAction 这个bean是配置在 cas-servlet.xml 中的：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"authenticationViaFormAction"</span> class=<span class="string">"org.jasig.cas.web.flow.AuthenticationViaFormAction"</span></span><br><span class="line">    p:centralAuthenticationService-<span class="keyword">ref</span>=<span class="string">"centralAuthenticationService"</span></span><br><span class="line">    p:warnCookieGenerator-<span class="keyword">ref</span>=<span class="string">"warnCookieGenerator"</span></span><br><span class="line">    p:ticketRegistry-<span class="keyword">ref</span>=<span class="string">"ticketRegistry"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>我们可以看看 org.jasig.cas.web.flow.AuthenticationViaFormAction 的源代码，里面有一个 submit 方法，这个就是我们提交表单时的方法了。继承AuthenticationViaFormAction实现一个新类</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyAuthenticationViaFormAction</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">AuthenticationViaFormAction</span>&#123;</span></span><br><span class="line"></span><br><span class="line">    public <span class="keyword">final</span> <span class="type">String</span> validatorCaptcha(<span class="keyword">final</span> <span class="type">RequestContext</span> context, <span class="keyword">final</span> <span class="type">Credential</span> credential,</span><br><span class="line">            <span class="keyword">final</span> <span class="type">MessageContext</span> messageContext)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="type">HttpServletRequest</span> request = <span class="type">WebUtils</span>.getHttpServletRequest(context);</span><br><span class="line">            <span class="type">HttpSession</span> session = request.getSession();</span><br><span class="line">            <span class="type">String</span> captcha = (<span class="type">String</span>)session.getAttribute(com.google.code.kaptcha.<span class="type">Constants</span>.<span class="type">KAPTCHA_SESSION_KEY</span>);</span><br><span class="line">            session.removeAttribute(com.google.code.kaptcha.<span class="type">Constants</span>.<span class="type">KAPTCHA_SESSION_KEY</span>);</span><br><span class="line"></span><br><span class="line">            <span class="type">UsernamePasswordCaptchaCredential</span> upc = (<span class="type">UsernamePasswordCaptchaCredential</span>)credential;</span><br><span class="line">            <span class="type">String</span> submitAuthcodeCaptcha =upc.getCaptcha();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!<span class="type">StringUtils</span>.hasText(submitAuthcodeCaptcha) || !<span class="type">StringUtils</span>.hasText(submitAuthcodeCaptcha))&#123;</span><br><span class="line">                messageContext.addMessage(<span class="keyword">new</span> <span class="type">MessageBuilder</span>().code(<span class="string">"required.captcha"</span>).build());</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(submitAuthcodeCaptcha.equals(captcha))&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            messageContext.addMessage(<span class="keyword">new</span> <span class="type">MessageBuilder</span>().code(<span class="string">"error.authentication.captcha.bad"</span>).build());</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"error"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这边有抛出两个异常，这两个异常信息 required.captcha、error.authentication.captcha.bad 需要在 messages_zh_CN.properties 文件下添加</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">required.captcha=必须输入验证码。</span><br><span class="line">error<span class="class">.authentication</span><span class="class">.captcha</span><span class="class">.bad</span>=您输入的验证码有误。</span><br></pre></td></tr></table></figure>
<p>然后把 authenticationViaFormAction 这个Bean路径修改为我们新添加的类的全路径名。</p>
<p>当然最后，我们的页面也需要修改，找到casLoginView.jsp添加</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;section <span class="variable">class=</span><span class="string">"row"</span>&gt;</span><br><span class="line">        &lt;spring:message <span class="variable">code=</span><span class="string">"screen.welcome.label.captcha.accesskey"</span> <span class="variable">var=</span><span class="string">"captchaAccessKey"</span> /&gt;</span><br><span class="line">        &lt;spring:message <span class="variable">code=</span><span class="string">"screen.welcome.label.captcha"</span> <span class="variable">var=</span><span class="string">"captchaHolder"</span> /&gt;</span><br><span class="line">        &lt;form:input <span class="variable">cssClass=</span><span class="string">"required"</span> <span class="variable">cssErrorClass=</span><span class="string">"error"</span> <span class="variable">id=</span><span class="string">"captcha"</span> <span class="variable">size=</span><span class="string">"10"</span> <span class="variable">tabindex=</span><span class="string">"3"</span>  <span class="variable">path=</span><span class="string">"captcha"</span> <span class="variable">placeholder=</span><span class="string">"<span class="subst">$&#123;captchaHolder &#125;</span>"</span> <span class="variable">accesskey=</span><span class="string">"<span class="subst">$&#123;captchaAccessKey&#125;</span>"</span> <span class="variable">autocomplete=</span><span class="string">"off"</span> <span class="variable">htmlEscape=</span><span class="string">"true"</span> /&gt;</span><br><span class="line">        &lt;img <span class="variable">alt=</span><span class="string">"<span class="subst">$&#123;captchaHolder &#125;</span>"</span> <span class="variable">src=</span><span class="string">"captcha.jpg"</span> <span class="variable">onclick=</span><span class="string">"this.src='captcha.jpg?'+Math.random();"</span>&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<p>以上添加验证码参考<a href="http://www.cnblogs.com/vhua/p/cas_3.html" target="_blank" rel="external">http://www.cnblogs.com/vhua/p/cas_3.html</a></p>
<h3 id="添加记住密码">添加记住密码</h3><p>可以参考<a href="http://jasig.github.io/cas/development/installation/Configuring-LongTerm-Authentication.html" target="_blank" rel="external">http://jasig.github.io/cas/development/installation/Configuring-LongTerm-Authentication.html</a></p>
<p>在cas.properties中添加如下配置</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># <span class="typename">Long</span> term authentication session length <span class="keyword">in</span> seconds</span><br><span class="line">rememberMeDuration=<span class="number">1209600</span></span><br></pre></td></tr></table></figure>
<p>spring-configuration文件夹下找到 ticketExpirationPolicies.xml 和 ticketGrantingTicketCookieGenerator.xml 需要在这两个配置文件中定义长期有效的session</p>
<p>在 ticketExpirationPolicies.xml文件中更新如下配置</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"standardSessionTGTExpirationPolicy"</span></span><br><span class="line">      class=<span class="string">"org.jasig.cas.ticket.support.TicketGrantingTicketExpirationPolicy"</span></span><br><span class="line">      p:maxTimeToLiveInSeconds=<span class="string">"$&#123;tgt.maxTimeToLiveInSeconds:28800&#125;"</span></span><br><span class="line">      p:timeToKillInSeconds=<span class="string">"$&#123;tgt.timeToKillInSeconds:7200&#125;"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--</span><br><span class="line">   | <span class="type">The</span> following policy applies to long term <span class="type">CAS</span> <span class="type">SSO</span> sessions.</span><br><span class="line">   | <span class="type">Default</span> duration <span class="keyword">is</span> two weeks (<span class="number">1209600</span>s).</span><br><span class="line">   --&gt;</span><br><span class="line">&lt;bean id=<span class="string">"longTermSessionTGTExpirationPolicy"</span></span><br><span class="line">      class=<span class="string">"org.jasig.cas.ticket.support.TimeoutExpirationPolicy"</span></span><br><span class="line">      c:timeToKillInMilliSeconds=<span class="string">"#&#123; $&#123;rememberMeDuration:1209600&#125; * 1000 &#125;"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"grantingTicketExpirationPolicy"</span></span><br><span class="line">      class=<span class="string">"org.jasig.cas.ticket.support.RememberMeDelegatingExpirationPolicy"</span></span><br><span class="line">      p:sessionExpirationPolicy-<span class="keyword">ref</span>=<span class="string">"standardSessionTGTExpirationPolicy"</span></span><br><span class="line">      p:rememberMeExpirationPolicy-<span class="keyword">ref</span>=<span class="string">"longTermSessionTGTExpirationPolicy"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>更新ticketGrantingTicketCookieGenerator.xml</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"ticketGrantingTicketCookieGenerator"</span> class=<span class="string">"org.jasig.cas.web.support.CookieRetrievingCookieGenerator"</span></span><br><span class="line">      <span class="tag">p</span>:cookieSecure=<span class="string">"true"</span></span><br><span class="line">      <span class="tag">p</span>:cookieMaxAge=<span class="string">"-1"</span></span><br><span class="line">      <span class="tag">p</span>:rememberMeMaxAge=<span class="string">"$&#123;rememberMeDuration:1209600&#125;"</span></span><br><span class="line">      <span class="tag">p</span>:cookieName=<span class="string">"CASTGC"</span></span><br><span class="line">      <span class="tag">p</span>:cookiePath=<span class="string">"/cas"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>在 deployerConfigContext.xml 中找到 PolicyBasedAuthenticationManager 使其包含RememberMeAuthenticationMetaDataPopulator组件</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"authenticationMetaDataPopulators"</span>&gt;</span><br><span class="line">	&lt;<span class="type">list</span>&gt;</span><br><span class="line">		&lt;bean</span><br><span class="line">			<span class="type">class</span>=<span class="string">"org.jasig.cas.authentication.SuccessfulHandlerMetaDataPopulator"</span> /&gt;</span><br><span class="line">		&lt;bean</span><br><span class="line">			<span class="type">class</span>=<span class="string">"org.jasig.cas.authentication.principal.RememberMeAuthenticationMetaDataPopulator"</span> /&gt;</span><br><span class="line">	&lt;/<span class="type">list</span>&gt;</span><br><span class="line">&lt;/<span class="keyword">property</span>&gt;</span><br></pre></td></tr></table></figure>
<p>和添加验证码类似的，我们还需要修改login-webflow.xml</p>
<p>找到credential 的声明修改如下</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">var</span> name=<span class="string">"credential"</span> <span class="keyword">class</span>=<span class="string">"org.jasig.cas.authentication.RememberMeUsernamePasswordCredential"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>由于之前已经实现了验证码，所以这里不需要修改了，只需让 UsernamePasswordCaptchaCredential继承RememberMeUsernamePasswordCredential即可</p>
<p>找到viewLoginForm 在binder节点下添加<code>&lt;binding property=&quot;rememberMe&quot; /&gt;</code></p>
<p>更新 casLoginView.jsp</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="tag">section</span> class=<span class="string">"row check"</span>&gt;</span><br><span class="line">    &lt;<span class="tag">input</span> id=<span class="string">"rememberMe"</span> name=<span class="string">"rememberMe"</span> value=<span class="string">"false"</span> tabindex=<span class="string">"4"</span> accesskey=<span class="string">"&lt;spring:message code="</span>screen<span class="class">.welcome</span><span class="class">.label</span><span class="class">.rememberMe</span><span class="class">.accesskey</span><span class="string">" /&gt;"</span> type=<span class="string">"checkbox"</span> /&gt;</span><br><span class="line">    &lt;<span class="tag">label</span> <span class="keyword">for</span>=<span class="string">"rememberMe"</span>&gt;&lt;spring:message code=<span class="string">"screen.welcome.label.rememberMe"</span> /&gt;&lt;/label&gt;</span><br><span class="line">&lt;/section&gt;</span><br></pre></td></tr></table></figure>
<h3 id="自定义primaryAuthenticationHandler">自定义primaryAuthenticationHandler</h3><p>虽然已经有QueryDatabaseAuthenticationHandler和QueryAndEncodeDatabaseAuthenticationHandler两个类，能够通过配置sql语句验证用户凭证，后者还能配置盐，散列函数迭代次数。但是我们可能还需要判断用户是否被锁定或被禁用了，我们可以参考QueryAndEncodeDatabaseAuthenticationHandler自定义一个AuthenticationHandler，继承AbstractJdbcUsernamePasswordAuthenticationHandler。添加两个字段名lockedFieldName和disabledFieldName通过这两个字段判断用户是否被锁定或被禁用，关键代码如下</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class ValidUserQueryDBAuthenticationHandler extends AbstractJdbcUsernamePasswordAuthenticationHandler&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> DEFAULT_LOCKED_FIELD = <span class="string">"locked"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">String</span> DEFAULT_DISABLED_FIELD = <span class="string">"disabled"</span>;</span><br><span class="line">    ......</span><br><span class="line">    @NotNull</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">String</span> disabledFieldName = DEFAULT_DISABLED_FIELD;</span><br><span class="line">    @NotNull</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">String</span> lockedFieldName = DEFAULT_LOCKED_FIELD;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">public</span> ValidUserQueryDBAuthenticationHandler(<span class="keyword">final</span> DataSource datasource, <span class="keyword">final</span> <span class="keyword">String</span> sql, <span class="keyword">final</span> <span class="keyword">String</span> algorithmName) &#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        setDataSource(datasource);</span><br><span class="line">        <span class="keyword">this</span>.sql = sql;</span><br><span class="line">        <span class="keyword">this</span>.algorithmName = algorithmName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> HandlerResult authenticateUsernamePasswordInternal(<span class="keyword">final</span> UsernamePasswordCredential transformedCredential)</span><br><span class="line">            <span class="keyword">throws</span> GeneralSecurityException, PreventedException &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> username = getPrincipalNameTransformer().transform(transformedCredential.getUsername());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; values = getJdbcTemplate().queryForMap(<span class="keyword">this</span>.sql, username);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(values.<span class="built_in">get</span>(<span class="keyword">this</span>.disabledFieldName))) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AccountDisabledException(username + <span class="string">"  has been disabled."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(values.<span class="built_in">get</span>(<span class="keyword">this</span>.lockedFieldName))) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AccountLockedException(username + <span class="string">"  has been locked."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">String</span> digestedPassword = digestEncodedPassword(transformedCredential.getPassword(), values);</span><br><span class="line">            <span class="keyword">if</span> (!values.<span class="built_in">get</span>(<span class="keyword">this</span>.passwordFieldName).equals(digestedPassword)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FailedLoginException(<span class="string">"Password does not match value on record."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> createHandlerResult(transformedCredential,</span><br><span class="line">                    <span class="keyword">new</span> SimplePrincipal(username), <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> IncorrectResultSizeDataAccessException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (e.getActualSize() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> AccountNotFoundException(username + <span class="string">" not found with SQL query"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> FailedLoginException(<span class="string">"Multiple records found for "</span> + username);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> DataAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> PreventedException(<span class="string">"SQL exception while executing query for "</span> + username, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">String</span> digestEncodedPassword(<span class="keyword">final</span> <span class="keyword">String</span> encodedPassword, <span class="keyword">final</span> Map&lt;<span class="keyword">String</span>, <span class="keyword">Object</span>&gt; values) &#123;</span><br><span class="line">        <span class="keyword">final</span> ConfigurableHashService hashService = <span class="keyword">new</span> DefaultHashService();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(<span class="keyword">this</span>.staticSalt)) &#123;</span><br><span class="line">            hashService.setPrivateSalt(ByteSource.Util.bytes(<span class="keyword">this</span>.staticSalt));</span><br><span class="line">        &#125;</span><br><span class="line">        hashService.setHashAlgorithmName(<span class="keyword">this</span>.algorithmName);</span><br><span class="line"></span><br><span class="line">        Long numOfIterations = <span class="keyword">this</span>.numberOfIterations;</span><br><span class="line">        <span class="keyword">if</span> (values.containsKey(<span class="keyword">this</span>.numberOfIterationsFieldName)) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">String</span> longAsStr = values.<span class="built_in">get</span>(<span class="keyword">this</span>.numberOfIterationsFieldName).toString();</span><br><span class="line">            numOfIterations = Long.valueOf(longAsStr);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hashService.setHashIterations(numOfIterations.intValue());</span><br><span class="line">        <span class="keyword">if</span> (!values.containsKey(<span class="keyword">this</span>.saltFieldName)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Specified field name for salt does not exist in the results"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">String</span> dynaSalt = values.<span class="built_in">get</span>(<span class="keyword">this</span>.saltFieldName)==<span class="keyword">null</span>?<span class="string">""</span>:values.<span class="built_in">get</span>(<span class="keyword">this</span>.saltFieldName).toString();</span><br><span class="line">        <span class="keyword">final</span> HashRequest request = <span class="keyword">new</span> HashRequest.Builder()</span><br><span class="line">                                    .setSalt(dynaSalt)</span><br><span class="line">                                    .setSource(encodedPassword)</span><br><span class="line">                                    .build();</span><br><span class="line">        <span class="keyword">return</span> hashService.computeHash(request).toHex();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> setDisabledFieldName(<span class="keyword">final</span> <span class="keyword">String</span> disabledFieldName) &#123; <span class="keyword">this</span>.disabledFieldName = disabledFieldName; &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> setLockedFieldName(<span class="keyword">final</span> <span class="keyword">String</span> lockedFieldName) &#123; <span class="keyword">this</span>.lockedFieldName = lockedFieldName; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后更新配置deployerConfigContext.xml</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"primaryAuthenticationHandler"</span> class=<span class="string">"io.github.howiefh.cas.authentication.ValidUserQueryDBAuthenticationHandler"</span>&gt;</span><br><span class="line">    &lt;constructor-arg <span class="keyword">ref</span>=<span class="string">"dataSource"</span> index=<span class="string">"0"</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">"$&#123;auth.sql&#125;"</span> index=<span class="string">"1"</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">"MD5"</span> index=<span class="string">"2"</span>&gt;&lt;/constructor-arg&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="自定义登录页面">自定义登录页面</h3><ol>
<li>在cas.properties 修改 cas.viewResolver.basename  值为 custom_view ，那样系统就会自动会查找 custom_view.properties 这个配置文件</li>
<li>直接复制原来的 default_views.properties 就行了，重命名为custom_view.properties</li>
<li>把 custom_view.properties 中的WEB-INF\view\jsp\default全部替换把这地址替换成 WEB-INF\view\jsp\custom</li>
<li>接下来把 cas\WEB-INF\view\jsp\default 下面的所有文件复制，然后重命名为我们需要的名称，cas\WEB-INF\view\jsp\custom</li>
</ol>
<p>主要修改casLoginView.jsp和cas.css即可</p>
<p>布局时遇到一个问题，就是将页脚固定在页面底部。可以参看<a href="http://www.w3cplus.com/css/css-sticky-foot-at-bottom-of-the-page" target="_blank" rel="external">如何将页脚固定在页面底部</a></p>
<h3 id="其它">其它</h3><p><a href="http://www.cnblogs.com/vhua/p/cas_4.html" target="_blank" rel="external">【SSO单点系列】（4）：CAS4.0 SERVER登录后用户信息的返回</a><br><a href="http://www.cnblogs.com/huangbin/p/3282643.html" target="_blank" rel="external">在多点环境下使用cas实现单点登陆及登出</a><br><a href="http://blog.csdn.net/tch918/article/details/22316175" target="_blank" rel="external">关于单点登录中的用户信息存储问题的探讨</a></p>
<h2 id="原理">原理</h2><p>从结构来看，CAS主要分为Server和Client。Server主要负责对用户的认证工作；Client负责处理客户端受保护资源的访问请求，登录时，重定向到Server进行认证。</p>
<p>基础模式的SSO访问流程步骤：</p>
<ol>
<li>访问服务：客户端发送请求访问应用系统提供的服务资源。</li>
<li>定向认证：客户端重定向用户请求到中心认证服务器。</li>
<li>用户认证：用户进行身份认证</li>
<li>发放票据：服务器会产生一个随机的 Service Ticket 。</li>
<li>验证票据： SSO 服务器验证票据 Service Ticket 的合法性，验证通过后，允许客户端访问服务。</li>
<li>传输用户信息： SSO 服务器验证票据通过后，传输用户认证结果信息给客户端。</li>
</ol>
<p>CAS最基本的协议过程：</p>
<p><img src="http://fh-1.qiniudn.com/cas-clip.jpg" alt="CAS 最基本的协议过程"></p>
<p>如上图： CAS Client 与受保护的客户端应用部署在一起，以 Filter 方式保护 Web 应用的受保护资源，过滤从客户端过来的每一个 Web 请求，同时， CAS Client 会分析 HTTP 请求中是否包含请求 Service Ticket( ST 上图中的 Ticket) ，如果没有，则说明该用户是没有经过认证的；于是 CAS Client 会重定向用户请求到 CAS Server （ Step 2 ），并传递 Service （要访问的目的资源地址）。 Step 3 是用户认证过程，如果用户提供了正确的 Credentials ， CAS Server 随机产生一个相当长度、唯一、不可伪造的 Service Ticket ，并缓存以待将来验证，并且重定向用户到 Service 所在地址（附带刚才产生的 Service Ticket ） , 并为客户端浏览器设置一个 Ticket Granted Cookie （ TGC ） ； CAS Client 在拿到 Service 和新产生的 Ticket 过后，在 Step 5 和 Step6 中与 CAS Server 进行身份核实，以确保 Service Ticket 的合法性。</p>
<p>在该协议中，所有与 CAS Server 的交互均采用 SSL 协议，以确保 ST 和 TGC 的安全性。协议工作过程中会有两次重定向的过程。但是 CAS Client 与 CAS Server 之间进行 Ticket 验证的过程对于用户是透明的（使用 HttpsURLConnection ）。</p>
<h3 id="相关概念">相关概念</h3><p>TGT、ST、PGT、PGTIOU、PT，其中TGT、ST是CAS1.0协议中就有的票据，PGT、PGTIOU、PT是CAS2.0协议中有的票据。</p>
<p>CAS为用户签发登录票据，CAS认证成功后，将TGT对象放入自己的缓存，CAS生成cookie即TGC，自后登录时如果有TGC的话，则说明用户之前登录过，如果没有，则用户需要重新登录。</p>
<ul>
<li>TGC （Ticket-granting cookie）：存放用户身份认证凭证的cookie，在浏览器和CAS Server用来明确用户身份的凭证。</li>
<li>ST（Service Ticket）：CAS服务器通过浏览器分发给客户端服务器的票据。一个特定服务只能有一个唯一的ST。</li>
<li>PGT（Proxy Granting Ticket）：由 CAS Server 颁发给拥有 ST 凭证的服务， PGT 绑定一个用户的特定服务，使其拥有向 CAS Server 申请，获得 PT 的能力。</li>
<li>PGTIOU（全称 Proxy Granting Ticket I Owe You）：作用是将通过凭证校验时的应答信息由 CAS Server 返回给 CAS Client ，同时，与该 PGTIOU 对应的 PGT 将通过回调链接传给 Web 应用。 Web 应用负责维护 PGTIOU 与 PGT 之间映射关系的内容表。PGTIOU是CAS的serviceValidate接口验证ST成功后，CAS会生成验证ST成功的xml消息，返回给Proxy Service，xml消息中含有PGTIOU，proxy service收到Xml消息后，会从中解析出PGTIOU的值，然后以其为key，在map中找出PGT的值，赋值给代表用户信息的Assertion对象的pgtId，同时在map中将其删除。</li>
<li>PT（Proxy Ticket）：是应用程序代理用户身份对目标程序进行访问的凭证；</li>
</ul>
<p>CAS 基本流程图（没有使用PROXY代理）</p>
<p><img src="http://fh-1.qiniudn.com/cas-noproxy.png" alt="CAS 基本流程图（没有使用PROXY代理）"></p>
<p>对于客户端来说会通过客户端session判断用户是否已认证，没有的话跳转到服务器认证，对于服务器，通过SSO session判断用户是否认证，没有的话跳到登录页面。</p>
<p>CAS 基本流程图（使用PROXY代理）</p>
<p><img src="http://fh-1.qiniudn.com/cas-proxy.png" alt="CAS 基本流程图（使用PROXY代理）"></p>
<p>这一节参考：</p>
<p><a href="http://www.cnblogs.com/vhua/p/cas_6.html" target="_blank" rel="external">【SSO单点系列】（6）：CAS4.0 单点流程序列图（中文版）以及相关术语解释（TGT、ST、PGT、PT、PGTIOU）</a><br><a href="http://www.coin163.com/java/cas/cas.html" target="_blank" rel="external">CAS实现SSO单点登录原理</a></p>
<p>代码:<a href="https://github.com/howiefh/framework/tree/shiro-cas-sso" target="_blank" rel="external">github</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Shiro; CAS; SSO; Shrio 单点登录；单点登出；单点登录 验证码；单点登录 记住密码；单点登陆 查询数据库; 单点登录 自定义]]>
    
    </summary>
    
      <category term="CAS" scheme="http://howiefh.github.io/tags/CAS/"/>
    
      <category term="SSO" scheme="http://howiefh.github.io/tags/SSO/"/>
    
      <category term="Shiro" scheme="http://howiefh.github.io/tags/Shiro/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="Shiro" scheme="http://howiefh.github.io/categories/Java/Shiro/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Shiro笔记]]></title>
    <link href="http://howiefh.github.io/2015/05/12/shiro-note/"/>
    <id>http://howiefh.github.io/2015/05/12/shiro-note/</id>
    <published>2015-05-12T02:03:26.000Z</published>
    <updated>2015-05-21T16:13:33.000Z</updated>
    <content type="html"><![CDATA[<h2 id="简介">简介</h2><p>Apache Shiro是一个强大易用的Java安全框架，可以帮助我们完成：认证、授权、加密、会话管理、与Web集成、缓存等。</p>
<p><img src="http://fh-1.qiniudn.com/shiro/shiro-func.png" alt="Shiro基本功能"></p>
<ul>
<li>Authentication：身份认证/登录，验证用户是不是拥有相应的身份；</li>
<li>Authorization：授权，即权限验证，验证某个已认证的用户是否拥有某个权限；即判断用户是否能做事情，常见的如：验证某个用户是否拥有某个角色。或者细粒度的验证某个用户对某个资源是否具有某个权限；</li>
<li>Session Manager：会话管理，即用户登录后就是一次会话，在没有退出之前，它的所有信息都在会话中；会话可以是普通JavaSE环境的，也可以是如Web环境的；</li>
<li>Cryptography：加密，保护数据的安全性，如密码加密存储到数据库，而不是明文存储；</li>
<li>Web Support：Web支持，可以非常容易的集成到Web环境；</li>
<li>Caching：缓存，比如用户登录后，其用户信息、拥有的角色/权限不必每次去查，这样可以提高效率；</li>
<li>Concurrency：shiro支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去；</li>
<li>Testing：提供测试支持；</li>
<li>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问；</li>
<li>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>
</ul>
<a id="more"></a>
<p><strong>记住一点，Shiro不会去维护用户、维护权限；这些需要我们自己去设计/提供；然后通过相应的接口注入给Shiro即可。</strong></p>
<p>Shiro的三个核心组件：Subject, SecurityManager 和 Realms. 如下图： </p>
<p><img src="http://fh-1.qiniudn.com/shiro/shiro-core.png" alt="Shiro框架图"></p>
<p>Subject：即“当前操作用户”。但是，在Shiro中，Subject这一概念并不仅仅指人，也可以是第三方进程、后台帐户（Daemon Account）或其他类似事物。它仅仅意味着“当前跟软件交互的东西”。但考虑到大多数目的和用途，你可以把它认为是Shiro的“用户”概念。Subject代表了当前用户的安全操作，SecurityManager则管理所有用户的安全操作。与Subject的所有交互都会委托给SecurityManager。 </p>
<p>SecurityManager：它是Shiro框架的核心，典型的Facade模式，Shiro通过SecurityManager来管理内部组件实例，并通过它来提供安全管理的各种服务。可以把它看成 DispatcherServlet 前端控制器 </p>
<p>Realm： Realm充当了Shiro与应用安全数据间的“桥梁”或者“连接器”。也就是说，当对用户执行认证（登录）和授权（访问控制）验证时，Shiro会从应用配置的Realm中查找用户及其权限信息。从这个意义上讲，Realm实质上是一个安全相关的DAO：它封装了数据源的连接细节，并在需要时将相关数据提供给Shiro。当配置Shiro时，你必须至少指定一个Realm，用于认证和（或）授权。配置多个Realm是可以的，但是至少需要一个。Shiro内置了可以连接大量安全数据源（又名目录）的Realm，如LDAP、关系数据库（JDBC）、类似INI的文本配置资源以及属性文件等。如果缺省的Realm不能满足需求，你还可以插入代表自定义数据源的自己的Realm实现。 </p>
<p>Shiro完整架构图： </p>
<p><img src="http://fh-1.qiniudn.com/shiro/shiro-frame.png" alt="Shiro框架图"></p>
<ul>
<li><p>Subject (org.apache.shiro.subject.Subject)<br>  正在与软件交互的一个特定的实体“view”（用户、第三方服务、时钟守护任务等）。</p>
</li>
<li><p>SecurityManager (org.apache.shiro.mgt.SecurityManager)<br>  如同上面提到的，SecurityManager 是 Shiro 的核心，它基本上就是一把“保护伞”用来协调它管理的组件使之平稳地一起工作，它也管理着 Shiro 中每一个程序用户的视图，所以它知道每个用户如何执行安全操作。</p>
</li>
<li><p>Authenticator(org.apache.shiro.authc.Authenticator)<br>  Authenticator 是一个组件，负责执行和反馈用户的认证（登录），如果一个用户尝试登录，Authenticator 就开始执行。Authenticator 知道如何协调一个或多个保存有相关用户/帐号信息的 Realm，从这些 Realm中获取这些数据来验证用户的身份以确保用户确实是其表述的那个人。</p>
</li>
<li><p>Authentication Strategy(org.apache.shiro.authc.pam.AuthenticationStrategy)<br>  如果配置了多个 Realm，AuthenticationStrategy 将会协调 Realm 确定在一个身份验证成功或失败的条件（例如，如果在一个方面验证成功了但其他失败了，这次尝试是成功的吗？是不是需要所有方面的验证都成功？还是只需要第一个？）</p>
</li>
<li><p>Authorizer(org.apache.shiro.authz.Authorizer)<br>  Authorizer 是负责程序中用户访问控制的组件，它是最终判断一个用户是否允许做某件事的途径，像 Authenticator 一样，Authorizer 也知道如何通过协调多种后台数据源来访问角色和权限信息，Authorizer 利用这些信息来准确判断一个用户是否可以执行给定的动作。</p>
</li>
<li><p>SessionManager(org.apache.shiro.session.mgt.SessionManager)<br>  SessionManager 知道如何创建并管理用户 Session 生命周期而在所有环境中为用户提供一个强有力的 Session 体验。这在安全框架领域是独一无二—Shiro 具备管理在任何环境下管理用户 Session 的能力，即使没有 Web/Servlet 或者 EJB 容器。默认情况下，Shiro 将使用现有的session（如Servlet Container），但如果环境中没有，比如在一个独立的程序或非 web 环境中，它将使用它自己建立的 session 提供相同的作用，sessionDAO 用来使用任何数据源使 session 持久化。</p>
</li>
<li><p>SessionDAO(org.apache.shiro.session.mgt.eis.SessionDAO)<br>  SessionDAO 代表 SessionManager 执行 Session 持久（CRUD）动作，它允许任何存储的数据挂接到 session 管理基础上。</p>
</li>
<li><p>CacheManager(org.apache.shiro.cache.CacheManager)<br>  CacheManager 为 Shiro 的其他组件提供创建缓存实例和管理缓存生命周期的功能。因为 Shiro 的认证、授权、会话管理支持多种数据源，所以访问数据源时，使用缓存来提高访问效率是上乘的选择。当下主流开源或企业级缓存框架都可以继承到 Shiro 中，来获取更快更高效的用户体验。</p>
</li>
<li><p>Cryptography (<code>org.apache.shiro.crypto.*</code>)<br>  Cryptography 在安全框架中是一个自然的附加产物，Shiro 的 crypto 包包含了易用且易懂的加密方式，Hashes（即digests）和不同的编码实现。该包里所有的类都易于理解和使用，曾经用过 Java 自身的加密支持的人都知道那是一个具有挑战性的工作，而 Shiro 的加密 API 简化了 java 复杂的工作方式，将加密变得易用。</p>
</li>
<li><p>Realms (org.apache.shiro.realm.Realm)<br>  如同上面提到的，Realm 是 shiro 和你的应用程序安全数据之间的“桥”或“连接”，当实际要与安全相关的数据进行交互如用户执行身份认证（登录）和授权验证（访问控制）时，shiro 从程序配置的一个或多个Realm 中查找这些数据，你需要配置多少个 Realm 便可配置多少个 Realm（通常一个数据源一个），shiro 将会在认证和授权中协调它们。</p>
</li>
</ul>
<h2 id="身份验证">身份验证</h2><p>认证就是验证用户身份的过程。在认证过程中，用户需要提交实体信息(Principals)和凭据信息(Credentials)以检验用户是否合法。最常见的“实体/凭证”组合便是“用户名/密码”组合。 </p>
<h3 id="Shiro认证过程">Shiro认证过程</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、获取SecurityManager工厂，此处使用Ini配置文件初始化SecurityManager</span></span><br><span class="line">Factory&lt;SecurityManager&gt; factory = new IniSecurityManagerFactory<span class="params">(<span class="string">"classpath:shiro.ini"</span>)</span>;</span><br><span class="line"><span class="comment">//2、得到SecurityManager实例 并绑定给SecurityUtils</span></span><br><span class="line">SecurityManager securityManager = factory.getInstance<span class="params">()</span>;</span><br><span class="line">SecurityUtils.setSecurityManager<span class="params">(securityManager)</span>;</span><br><span class="line"><span class="comment">//3、获取当前执行用户:</span></span><br><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;</span><br><span class="line"><span class="comment">//做点跟 Session 相关的事</span></span><br><span class="line">Session session = currentUser.getSession<span class="params">()</span>;</span><br><span class="line">session.setAttribute<span class="params">(<span class="string">"someKey"</span>, <span class="string">"aValue"</span>)</span>;</span><br><span class="line">String value = <span class="params">(String)</span> session.getAttribute<span class="params">(<span class="string">"someKey"</span>)</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(value.equals<span class="params">(<span class="string">"aValue"</span>)</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"Retrieved the correct value! ["</span> + value + <span class="string">"]"</span>)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">if</span> <span class="params">(!currentUser.isAuthenticated<span class="params">()</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//4、创建用户名/密码身份验证Token（即用户身份/凭证）</span></span><br><span class="line">    UsernamePasswordToken token = new UsernamePasswordToken<span class="params">(</span><br><span class="line">            <span class="string">"lonestarr"</span>, <span class="string">"vespa"</span>)</span>;</span><br><span class="line">    token.setRememberMe<span class="params">(<span class="literal">true</span>)</span>;</span><br><span class="line">    try &#123;</span><br><span class="line">        <span class="comment">//5、登录、即身份验证</span></span><br><span class="line">        currentUser.login<span class="params">(token)</span>;</span><br><span class="line">    &#125; catch <span class="params">(UnknownAccountException uae)</span> &#123;</span><br><span class="line">        <span class="built_in">log</span>.info<span class="params">(<span class="string">"There is no user with username of "</span> + token.getPrincipal<span class="params">()</span>)</span>;</span><br><span class="line">    &#125; catch <span class="params">(IncorrectCredentialsException ice)</span> &#123;</span><br><span class="line">        <span class="built_in">log</span>.info<span class="params">(<span class="string">"Password for account "</span> + token.getPrincipal<span class="params">()</span> + <span class="string">" was incorrect!"</span>)</span>;</span><br><span class="line">    &#125; catch <span class="params">(LockedAccountException lae)</span> &#123;</span><br><span class="line">        <span class="built_in">log</span>.info<span class="params">(<span class="string">"The account for username "</span> + token.getPrincipal<span class="params">()</span> + <span class="string">" is locked. "</span> + <span class="string">"Please contact your administrator to unlock it."</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ... 捕获更多异常</span></span><br><span class="line">    catch <span class="params">(AuthenticationException ae)</span> &#123;</span><br><span class="line">        <span class="comment">// 无定义?错误?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 打印主要识别信息 (本例是 username):</span></span><br><span class="line"><span class="built_in">log</span>.info<span class="params">(<span class="string">"User ["</span> + currentUser.getPrincipal<span class="params">()</span> + <span class="string">"] logged in successfully."</span>)</span>;</span><br><span class="line"><span class="comment">// 测试角色:</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(currentUser.hasRole<span class="params">(<span class="string">"schwartz"</span>)</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"May the Schwartz be with you!"</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"Hello, mere mortal."</span>)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 测试一个权限 (非（ instance-level） 实例级别)</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(currentUser.isPermitted<span class="params">(<span class="string">"lightsaber:weild"</span>)</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"You may use a lightsaber ring. Use it wisely."</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"Sorry, lightsaber rings are for schwartz masters only."</span>)</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="comment">// 一个(非常强大)的实例级别的权限:</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(currentUser.isPermitted<span class="params">(<span class="string">"winnebago:drive:eagle5"</span>)</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"You are permitted to 'drive' the winnebago with license plate (id) 'eagle5'. "</span></span><br><span class="line">            + <span class="string">"Here are the keys - have fun!"</span>)</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">log</span>.info<span class="params">(<span class="string">"Sorry, you aren't allowed to drive the 'eagle5' winnebago!"</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//6、完成 - 退出t!</span></span><br><span class="line">currentUser.logout<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>shiro.ini文件：<br><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Users and their (optional) assigned roles</span></span><br><span class="line"><span class="comment"># username = password, role1, role2, ..., roleN</span></span><br><span class="line">[users]</span><br><span class="line"><span class="constant">root</span> = secret, admin</span><br><span class="line"><span class="constant">guest</span> = guest, guest</span><br><span class="line"><span class="constant">presidentskroob</span> = 12345, president</span><br><span class="line"><span class="constant">darkhelmet</span> = ludicrousspeed, darklord, schwartz</span><br><span class="line"><span class="constant">lonestarr</span> = vespa, goodguy, schwartz</span><br><span class="line"><span class="comment"># Roles with assigned permissions</span></span><br><span class="line"><span class="comment"># roleName = perm1, perm2, ..., permN</span></span><br><span class="line">[roles]</span><br><span class="line"><span class="constant">admin</span> = *</span><br><span class="line"><span class="constant">schwartz</span> = lightsaber:*</span><br><span class="line"><span class="constant">goodguy</span> = winnebago:drive:eagle5</span><br></pre></td></tr></table></figure></p>
<p>身份验证的主要流程就是：</p>
<ol>
<li>收集用户身份/凭证，即如用户名/密码；</li>
<li>调用 Subject.login 进行登录，如果失败将得到相应的 AuthenticationException 异常，根<br>据异常提示用户错误信息；否则登录成功；</li>
<li>最后调用 Subject.logout 进行退出操作。</li>
</ol>
<p><strong>收集实体/凭据信息</strong> </p>
<p>UsernamePasswordToken支持最常见的用户名/密码的认证机制。同时，由于它实现了RememberMeAuthenticationToken接口，我们可以通过令牌设置“记住我”的功能。但是，“已记住”和“已认证”是有区别的：已记住的用户仅仅是非匿名用户，你可以通过subject.getPrincipals()获取用户信息。但是它并非是完全认证通过的用户，当你访问需要认证用户的功能时，你仍然需要重新提交认证信息。这一区别可以参考亚马逊网站，网站会默认记住登录的用户，再次访问网站时，对于非敏感的页面功能，页面上会显示记住的用户信息，但是当你访问网站账户信息时仍然需要再次进行登录认证。 subject.isAuthenticated()和subject.isRemembered()的值总是相反的。</p>
<p><strong>提交实体/凭据信息</strong> </p>
<p>收集了实体/凭据信息之后，我们可以通过SecurityUtils工具类，获取当前的用户，然后通过调用login方法提交认证。 </p>
<p><strong>认证处理</strong> </p>
<p>如果login方法执行完毕且没有抛出任何异常信息，那么便认为用户认证通过。之后在应用程序任意地方调用SecurityUtils.getSubject() 都可以获取到当前认证通过的用户实例，使用subject.isAuthenticated()判断用户是否已验证都将返回true. 相反，如果login方法执行过程中抛出异常，那么将认为认证失败。Shiro有着丰富的层次鲜明的异常类来描述认证失败的原因，如代码示例。 </p>
<p><strong>登出操作</strong> </p>
<p>登出操作可以通过调用subject.logout()来删除你的登录信息，当执行完登出操作后，Session信息将被清空，subject将被视作为匿名用户。 </p>
<p>以上，是Shiro认证在应用程序中的处理过程，下面将详细解说Shiro认证的内部处理机制。 </p>
<p><img src="http://fh-1.qiniudn.com/shiro/shiro-authentication.png" alt="身份认证流程"></p>
<p>如上图，我们通过Shiro架构图的认证部分，来说明Shiro认证内部的处理顺序： </p>
<ol>
<li>应用程序构建了一个终端用户认证信息的AuthenticationToken 实例后，调用Subject.login方法。 </li>
<li>Subject的实例通常是DelegatingSubject类（或子类）的实例对象，在认证开始时，会委托应用程序设置的securityManager实例调用securityManager.login(token)方法。 </li>
<li>SecurityManager接受到token(令牌)信息后会委托内置的Authenticator的实例（通常都是ModularRealmAuthenticator类的实例）调用authenticator.authenticate(token). ModularRealmAuthenticator在认证过程中会对设置的一个或多个Realm实例进行适配，它实际上为Shiro提供了一个可拔插的认证机制。</li>
<li>如果在应用程序中配置了多个Realm，ModularRealmAuthenticator会根据配置的AuthenticationStrategy(认证策略)来进行多Realm的认证过程。在Realm被调用后，AuthenticationStrategy将对每一个Realm的结果作出响应。注：如果应用程序中仅配置了一个Realm，Realm将被直接调用而无需再配置认证策略。</li>
<li>判断每一个Realm是否支持提交的token，如果支持，Realm将调用getAuthenticationInfo(token); getAuthenticationInfo 方法就是实际认证处理，我们通过覆盖Realm的doGetAuthenticationInfo方法来编写我们自定义的认证处理。 </li>
</ol>
<p>Realm接口中需要实现的方法。</p>
<p>String getName(); //返回一个唯一的 Realm 名字<br>boolean supports(AuthenticationToken token); //判断此 Realm 是否支持此 Token<br>AuthenticationInfo getAuthenticationInfo(AuthenticationToken token) throws AuthenticationException; //根据 Token 获取认证信息</p>
<p><img src="http://fh-1.qiniudn.com/shiro/shiro-realm.png" alt="Realm"></p>
<p>一般继承AuthorizingRealm即可，需要实现getAuthenticationInfo(AuthenticationToken token)和doGetAuthenticationInfo(PrincipalCollection principals)两个方法</p>
<p>其中主要默认实现如下：<br>org.apache.shiro.realm.text.IniRealm：[users]部分指定用户名/密码及其角色；[roles]部分指定角色即权限信息；<br>org.apache.shiro.realm.text.PropertiesRealm：user.username=password,role1,role2 指定用户名/密码及其角色；role.role1=permission1,permission2 指定角色及权限信息；<br>org.apache.shiro.realm.jdbc.JdbcRealm：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line">jdbcRealm=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.realm</span><span class="class">.jdbc</span><span class="class">.JdbcRealm</span></span><br><span class="line">dataSource=com<span class="class">.alibaba</span><span class="class">.druid</span><span class="class">.pool</span><span class="class">.DruidDataSource</span></span><br><span class="line">dataSource.driverClassName=com<span class="class">.mysql</span><span class="class">.jdbc</span><span class="class">.Driver</span></span><br><span class="line">dataSource.url=jdbc:mysql:<span class="comment">//localhost:3306/shiro</span></span><br><span class="line">dataSource.username=root</span><br><span class="line"><span class="id">#dataSource</span>.password=</span><br><span class="line">jdbcRealm.dataSource=<span class="variable">$dataSource</span></span><br><span class="line">securityManager.realms=<span class="variable">$jdbcRealm</span></span><br></pre></td></tr></table></figure></p>
<h3 id="使用多个Realm的处理机制：">使用多个Realm的处理机制：</h3><p>有些网站既可以用用户名也可以用邮箱、手机登陆，通过多个Realm就可以实现。</p>
<h4 id="Authenticator">Authenticator</h4><p>默认实现是ModularRealmAuthenticator,它既支持单一Realm也支持多个Realm。如果仅配置了一个Realm，ModularRealmAuthenticator 会直接调用该Realm处理认证信息，如果配置了多个Realm，它会根据认证策略来适配Realm，找到合适的Realm执行认证信息。 </p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[main]  </span><br><span class="line">#指定 securityManager 的 authenticator 实现</span><br><span class="line">authenticator=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.authc</span><span class="class">.pam</span><span class="class">.ModularRealmAuthenticator</span></span><br><span class="line">securityManager.authenticator=<span class="variable">$authenticator</span></span><br></pre></td></tr></table></figure>
<h4 id="AuthenticationStrategy（认证策略）">AuthenticationStrategy（认证策略）</h4><p>当应用程序配置了多个Realm时，ModularRealmAuthenticator将根据认证策略来判断认证成功或是失败。<br>例如，如果只有一个Realm验证成功，而其他Realm验证失败，那么这次认证是否成功呢？如果大多数的Realm验证成功了，认证是否就认为成功呢？或者，一个Realm验证成功后，是否还需要判断其他Realm的结果？认证策略就是根据应用程序的需要对这些问题作出决断。 </p>
<p>认证策略是一个无状态的组件，在认证过程中会经过4次的调用： </p>
<ul>
<li>在所有Realm被调用之前</li>
<li>在调用Realm的getAuthenticationInfo 方法之前</li>
<li>在调用Realm的getAuthenticationInfo 方法之后</li>
<li>在所有Realm被调用之后</li>
</ul>
<p>认证策略的另外一项工作就是聚合所有Realm的结果信息封装至一个AuthenticationInfo实例中，并将此信息返回，以此作为Subject的身份信息。 </p>
<p>Shiro有3中认证策略的具体实现： </p>
<ul>
<li>AtLeastOneSuccessfulStrategy    只要有一个（或更多）的Realm验证成功，那么认证将被视为成功</li>
<li>FirstSuccessfulStrategy    第一个Realm验证成功，整体认证将被视为成功，且后续Realm将被忽略</li>
<li>AllSuccessfulStrategy    所有Realm成功，认证才视为成功</li>
</ul>
<p>ModularRealmAuthenticator 内置的认证策略默认实现是AtLeastOneSuccessfulStrategy 方式，因为这种方式也是被广泛使用的一种认证策略。当然，你也可以通过配置文件定义你需要的策略，如：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[main]  </span><br><span class="line">authcStrategy = org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.authc</span><span class="class">.pam</span><span class="class">.FirstSuccessfulStrategy</span>  </span><br><span class="line">securityManager<span class="class">.authenticator</span><span class="class">.authenticationStrategy</span> = <span class="variable">$authcStrategy</span></span><br></pre></td></tr></table></figure></p>
<h4 id="Realm的顺序">Realm的顺序</h4><p>由刚才提到的认证策略，可以看到Realm在ModularRealmAuthenticator 里面的顺序对认证是有影响的。 </p>
<p>ModularRealmAuthenticator 会读取配置在SecurityManager里的Realm。当执行认证是，它会遍历Realm集合，对所有支持提交的token的Realm调用getAuthenticationInfo 。 </p>
<p>因此，如果Realm的顺序对你使用的认证策略结果有影响，那么你应该在配置文件中明确定义Realm的顺序</p>
<h2 id="授权">授权</h2><p>授权即访问控制，它将判断用户在应用程序中对资源是否拥有相应的访问权限。<br>如，判断一个用户有查看页面的权限，编辑数据的权限，拥有某一按钮的权限，以及是否拥有打印的权限等等。 </p>
<h3 id="授权的三要素">授权的三要素</h3><p>授权有着三个核心元素：权限(permissions)、角色(roles)和用户(users)。 </p>
<p>权限 </p>
<p>权限是Apache Shiro安全机制最核心的元素。它在应用程序中明确声明了被允许的行为和表现。一个格式良好的权限声明可以清晰表达出用户对该资源拥有的权限。</p>
<p>大多数的资源会支持典型的CRUD操作（create,read,update,delete）,但是任何操作建立在特定的资源上才是有意义的。因此，权限声明的根本思想就是建立在资源以及操作上。 </p>
<p>而我们通过权限声明仅仅能了解这个权限可以在应用程序中做些什么，而不能确定谁拥有此权限。权限只描述行为。</p>
<p>于是，我们就需要在应用程序中对用户和权限建立关联。通常的做法就是将权限分配给某个角色，然后将这个角色关联一个或多个用户。 </p>
<p><strong>权限声明及粒度</strong> </p>
<p>Shiro权限声明通常是使用以冒号分隔的表达式。就像前文所讲，一个权限表达式可以清晰的指定资源类型，允许的操作，可访问的数据。同时，Shiro权限表达式支持简单的通配符，可以更加灵活的进行权限设置。 </p>
<p>字符串通配符权限<br>规则：“资源标识符：操作：对象实例 ID” 即对哪个资源的哪个实例可以进行什么操作。其默认支持通配符权限字符串，<code>:</code>表示资源/操作/实例的分割；<code>,</code>表示操作的分割；<code>*</code>表示任意资源/操作/实例。</p>
<p>下面以实例来说明权限表达式。<br>可查询用户数据 <code>User:view</code><br>可查询或编辑用户数据 <code>User:view,edit</code><br>可对用户数据进行所有操作 <code>User:* 或 user</code><br>可编辑id为123的用户数据 <code>User:edit:123</code></p>
<p>注意：通过“system:user:update,delete”验证“system:user:update, system:user:delete”是没问题的，但是反过来是规则不成立。</p>
<h3 id="角色">角色</h3><p>Shiro支持两种角色模式： </p>
<ol>
<li>传统角色：一个角色代表着一系列的操作，当需要对某一操作进行授权验证时，只需判断是否是该角色即可。这种角色权限相对简单、模糊，不利于扩展。 </li>
<li>权限角色：一个角色拥有一个权限的集合。授权验证时，需要判断当前角色是否拥有该权限。这种角色权限可以对该角色进行详细的权限描述，适合更复杂的权限设计。 </li>
</ol>
<p><a href="www.waylau.com/new-rbac-resource-based-access-control/">新的RBAC：基于资源的权限管理(Resource-Based Access Control)</a></p>
<h3 id="用户">用户</h3><p>一个用户本质上是程序中的“谁”，如同我们前面提到的，Subject 实际上是 shiro 的“用户”。</p>
<p>用户（Subjects）通过与角色或权限关联确定是否被允许执行程序内特定的动作，程序数据模型确切定义了 Subject 是否允许做什么事情。Shiro 依赖一个 Realm 实现将你的数据模型关联转换成 Shiro 可以理解的内容</p>
<h3 id="授权实现">授权实现</h3><p>Shiro支持三种方式实现授权过程： </p>
<ul>
<li>编码实现：if(subject.hasRole(“admin”)){//有权限}</li>
<li>注解实现：@RequiresRoles(“admin”)public void hello() {//有权限}</li>
<li>JSP Taglig实现：<code>&lt;shiro:hasRole name=&quot;admin&quot;&gt;&lt;!— 有权限 —&gt;&lt;/shiro:hasRole&gt;</code></li>
</ul>
<h4 id="基于编码的授权实现">基于编码的授权实现</h4><p><strong>基于传统角色授权实现</strong></p>
<p>当需要验证用户是否拥有某个角色时，可以调用Subject 实例的<code>hasRole*</code>方法验证。 </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;  </span><br><span class="line"><span class="keyword">if</span> <span class="params">(currentUser.hasRole<span class="params">(<span class="string">"administrator"</span>)</span>)</span> &#123;  </span><br><span class="line">    <span class="comment">//显示 admin 按钮</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">    <span class="comment">//不显示按钮?  灰色吗？ </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关验证方法如下： </p>
<table>
<thead>
<tr>
<th>Subject方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>hasRole(String roleName)</code></td>
<td>当用户拥有指定角色时，返回true</td>
</tr>
<tr>
<td><code>hasRoles(List&lt;String&gt; roleNames)</code></td>
<td>按照列表顺序返回相应的一个boolean值数组</td>
</tr>
<tr>
<td><code>hasAllRoles(Collection&lt;String&gt; roleNames)</code></td>
<td>如果用户拥有所有指定角色时，返回true</td>
</tr>
</tbody>
</table>
<p>断言支持 </p>
<p>Shiro还支持以断言的方式进行授权验证。断言成功，不返回任何值，程序继续执行；断言失败时，将抛出异常信息。使用断言，可以使我们的代码更加简洁。 </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;  </span><br><span class="line"><span class="comment">//保证当前用户是一个银行出纳员</span></span><br><span class="line"><span class="comment">//因此允许开立帐户：</span></span><br><span class="line">currentUser.checkRole<span class="params">(<span class="string">"bankTeller"</span>)</span>;  </span><br><span class="line">openBankAccount<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>断言的相关方法： </p>
<table>
<thead>
<tr>
<th>Subject方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>checkRole(String roleName)</code></td>
<td>断言用户是否拥有指定角色</td>
</tr>
<tr>
<td><code>checkRoles(Collection&lt;String&gt; roleNames)</code></td>
<td>断言用户是否拥有所有指定角色</td>
</tr>
<tr>
<td><code>checkRoles(String... roleNames)</code></td>
<td>对上一方法的方法重载</td>
</tr>
</tbody>
</table>
<p><strong>基于权限角色授权实现</strong> </p>
<p>相比传统角色模式，基于权限的角色模式耦合性要更低些，它不会因角色的改变而对源代码进行修改，因此，基于权限的角色模式是更好的访问控制方式。 </p>
<p>它的代码实现有以下几种实现方式： </p>
<p><strong>基于权限对象的实现</strong> </p>
<p>创建org.apache.shiro.authz.Permission的实例，将该实例对象作为参数传递给Subject.isPermitted()进行验证。 </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Permission printPermission = new PrinterPermission<span class="params">(<span class="string">"laserjet4400n"</span>, <span class="string">"print"</span>)</span>;</span><br><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(currentUser.isPermitted<span class="params">(printPermission)</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//显示 打印 按钮</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不显示按钮?  灰色吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相关方法如下： </p>
<table>
<thead>
<tr>
<th>Subject方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>isPermitted(Permission p)</code></td>
<td>Subject拥有制定权限时，返回treu</td>
</tr>
<tr>
<td><code>isPermitted(List&lt;Permission&gt; perms)</code></td>
<td>返回对应权限的boolean数组</td>
</tr>
<tr>
<td><code>isPermittedAll(Collection&lt;Permission&gt; perms)</code></td>
<td>Subject拥有所有制定权限时，返回true</td>
</tr>
</tbody>
</table>
<p><strong>基于字符串的实现</strong> </p>
<p>相比笨重的基于对象的实现方式，基于字符串的实现便显得更加简洁。 </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;</span><br><span class="line"><span class="keyword">if</span> <span class="params">(currentUser.isPermitted<span class="params">(<span class="string">"printer:print:laserjet4400n"</span>)</span>)</span> &#123;</span><br><span class="line">    <span class="comment">//显示 打印 按钮</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//不显示按钮?  灰色吗？</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用冒号分隔的权限表达式是org.apache.shiro.authz.permission.WildcardPermission 默认支持的实现方式。 </p>
<p>这里分别代表了 资源类型:操作:资源ID </p>
<p>类似基于对象的实现相关方法</p>
<table>
<thead>
<tr>
<th>Subject 方法</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>isPermitted(String perm)</td>
<td>如果Subject被允许执行字符串表达的动作或资源访问权限，返回真，否则返回假；</td>
</tr>
<tr>
<td>isPermitted(String… perms)</td>
<td>按照参数顺序返回isPermitted的结果数组，当许多字符串权限需要检查时非常有用（如定制一个复杂的视图时）；</td>
</tr>
<tr>
<td>isPermittedAll(String… perms)</td>
<td>当Subject具备所有字符串定义的权限时返回真，否则返回假。</td>
</tr>
</tbody>
</table>
<p><strong>基于权限对象的断言实现</strong> </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;</span><br><span class="line"><span class="comment">//担保允许当前用户</span></span><br><span class="line"><span class="comment">//开一个银行帐户：</span></span><br><span class="line">Permission p = new AccountPermission<span class="params">(<span class="string">"open"</span>)</span>;</span><br><span class="line">currentUser.checkPermission<span class="params">(p)</span>;</span><br><span class="line">openBankAccount<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><strong>基于字符串的断言实现</strong> </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Subject currentUser = SecurityUtils.getSubject<span class="params">()</span>;</span><br><span class="line"><span class="comment">//担保允许当前用户</span></span><br><span class="line"><span class="comment">//开一个银行帐户：</span></span><br><span class="line">currentUser.checkPermission<span class="params">(<span class="string">"account:open"</span>)</span>;</span><br><span class="line">openBankAccount<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p><strong>断言实现的相关方法</strong> </p>
<table>
<thead>
<tr>
<th>Subject方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>checkPermission(Permission p)</code></td>
<td>断言用户是否拥有制定权限</td>
</tr>
<tr>
<td><code>checkPermission(String perm)</code></td>
<td>断言用户是否拥有制定权限</td>
</tr>
<tr>
<td><code>checkPermissions(Collection&lt;Permission&gt; perms)</code></td>
<td>断言用户是否拥有所有指定权限</td>
</tr>
<tr>
<td><code>checkPermissions(String... perms)</code></td>
<td>断言用户是否拥有所有指定权限</td>
</tr>
</tbody>
</table>
<h4 id="基于注解的授权实现">基于注解的授权实现</h4><p>Shiro注解支持AspectJ、Spring、Google-Guice等，可根据应用进行不同的配置。 </p>
<p>相关的注解：<br>@RequiresAuthentication<br>可以用户类/属性/方法，用于表明当前用户需是经过认证的用户。 </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RequiresAuthentication</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">updateAccount</span><span class="params">(Account userAccount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个方法只会被调用在</span></span><br><span class="line">    <span class="comment">//Subject 保证被认证的情况下</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于判断了SecurityUtils.getSubject().isAuthenticated()</p>
<p>@RequiresGuest<br>表明该用户需为”guest”用户 </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RequiresGuest</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">signUp</span><span class="params">(User newUser)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个方法只会被调用在</span></span><br><span class="line">    <span class="comment">//Subject 未知/匿名的情况下</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于判断了principals == null || principals.isEmpty()</p>
<p>@RequiresPermissions<br>当前用户需拥指定权限 </p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RequiresPermissions</span>(<span class="string">"account:create"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">createAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//这个方法只会被调用在</span></span><br><span class="line">    <span class="comment">//Subject 允许创建一个 account 的情况下</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相当于判断了subject.isPermitted(“account:create”)</p>
<p>@RequiresRoles<br>当前用户需拥有指定角色<br>相当于判断了subject.hasRole(“administrator”)</p>
<p>@RequiresUser<br>当前用户需为已认证用户或已记住用户 </p>
<h4 id="基于JSP_TAG的授权实现">基于JSP TAG的授权实现</h4><p>Shiro提供了一套JSP标签库来实现页面级的授权控制。标签库描述文件 (TLD)被打包在 META-INF/shiro.tld 文件中的 shiro-web.jar 文件中。 </p>
<p>在使用Shiro标签库前，首先需要在JSP引入shiro标签： </p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">%</span>@ taglib prefix=<span class="string">"shiro"</span> uri=<span class="string">"http://shiro.apache.org/tags"</span> <span class="preprocessor">%</span>&gt;</span><br></pre></td></tr></table></figure>
<p>下面一一介绍Shiro的标签： </p>
<p>guest标签:验证当前用户是否为“访客”，即未认证（包含未记住）的用户<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">shiro:guest</span>&gt;</span>  </span><br><span class="line">    Hi there!  Please <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"login.jsp"</span>&gt;</span>Login<span class="tag">&lt;/<span class="title">a</span>&gt;</span> or <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"signup.jsp"</span>&gt;</span>Signup<span class="tag">&lt;/<span class="title">a</span>&gt;</span> today!  </span><br><span class="line"><span class="tag">&lt;/<span class="title">shiro:guest</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>user标签:认证通过或已记住的用户<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">shiro:user</span>&gt;</span>  </span><br><span class="line">    Welcome back John!  Not John? Click <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"login.jsp"</span>&gt;</span>here<span class="tag">&lt;<span class="title">a</span>&gt;</span> to login.  </span><br><span class="line"><span class="tag">&lt;/<span class="title">shiro:user</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>authenticated标签:已认证通过的用户。不包含已记住的用户，这是与user标签的区别所在。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">shiro:authenticated</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"updateAccount.jsp"</span>&gt;</span>Update your contact information<span class="tag">&lt;/<span class="title">a</span>&gt;</span>.  </span><br><span class="line"><span class="tag">&lt;/<span class="title">shiro:authenticated</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>notAuthenticated标签:未认证通过用户，与authenticated标签相对应。与guest标签的区别是，该标签包含已记住用户。<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;shiro:notAuthenticated&gt;</span>  </span><br><span class="line">    Please <span class="variable">&lt;a href="login.jsp"&gt;</span>login<span class="variable">&lt;/a&gt;</span> <span class="keyword">in</span> order <span class="keyword">to</span> update your credit card information.  </span><br><span class="line"><span class="variable">&lt;/shiro:notAuthenticated&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>principal 标签:输出当前用户信息，通常为登录帐号信息<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, <span class="tag">&lt;<span class="title">shiro:principal</span>/&gt;</span>, how are you today?</span><br></pre></td></tr></table></figure></p>
<p>principal property<br><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, &lt;shiro:principal <span class="class"><span class="keyword">type</span></span>=<span class="string">"com.foo.User"</span> property=<span class="string">"firstName"</span>/&gt;, how are you today?</span><br></pre></td></tr></table></figure></p>
<p>很大程度上等价于<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Hello</span>, &lt;%= <span class="type">SecurityUtils</span>.getSubject<span class="literal">()</span>.getPrincipals<span class="literal">()</span>.oneByType(com.foo.<span class="type">User</span>.<span class="keyword">class</span>).getFirstName<span class="literal">()</span>.toString<span class="literal">()</span> %&gt;, how are you today?</span><br></pre></td></tr></table></figure></p>
<p>hasRole标签:验证当前用户是否属于该角色<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">shiro:hasRole</span> <span class="attribute">name</span>=<span class="value">"administrator"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"admin.jsp"</span>&gt;</span>Administer the system<span class="tag">&lt;/<span class="title">a</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">shiro:hasRole</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>lacksRole标签:与hasRole标签逻辑相反，当用户不属于该角色时验证通过<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:lacksRole name=<span class="string">"administrator"</span>&gt;  </span><br><span class="line">    Sorry, you are <span class="operator">not</span> allowed <span class="built_in">to</span> administer <span class="operator">the</span> <span class="keyword">system</span>.  </span><br><span class="line">&lt;/shiro:lacksRole&gt;</span><br></pre></td></tr></table></figure></p>
<p>hasAnyRole标签:验证当前用户是否属于以下任意一个角色。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;shiro:hasAnyRoles <span class="property">name</span>=<span class="string">"developer, project manager, administrator"</span>&gt;  </span><br><span class="line">    You are either a developer, project manager, <span class="keyword">or</span> administrator.  </span><br><span class="line">&lt;/shiro:lacksRole&gt;</span><br></pre></td></tr></table></figure></p>
<p>hasPermission标签:验证当前用户是否拥有制定权限<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">shiro:hasPermission</span> <span class="attribute">name</span>=<span class="value">"user:create"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"createUser.jsp"</span>&gt;</span>Create a new User<span class="tag">&lt;/<span class="title">a</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>lacksPermission标签:与hasPermission标签逻辑相反，当前用户没有制定权限时，验证通过<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">shiro:hasPermission</span> <span class="attribute">name</span>=<span class="value">"user:create"</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"createUser.jsp"</span>&gt;</span>Create a new User<span class="tag">&lt;/<span class="title">a</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">shiro:hasPermission</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="授权流程">授权流程</h3><p><img src="http://fh-1.qiniudn.com/shiro/Shiro-AuthorizationSequence.png" alt="授权流程"></p>
<ol>
<li>程序或框架代码调用一个 Subject 的<code>hasRole*</code>、<code>checkRole*</code>、<code>isPermitted*</code>或者<code>checkPermission*</code>方法，传递所需的权限或角色。</li>
<li>Subject实例，通常是一个 DelegatingSubject（或子类），通过调用securityManager 与各 <code>hasRole*</code>、<code>checkRole*</code>、<code>isPermitted*</code>或<code>checkPermission*</code> 基本一致的方法将权限或角色传递给程序的 SecurityManager(实现了 org.apache.shiro.authz.Authorizer 接口)。 </li>
<li>接下来SecurityManager会委托内置的Authorizer的实例（默认是ModularRealmAuthorizer 类的实例，类似认证实例，它同样支持一个或多个Realm实例认证）调用相应的授权方法。 </li>
<li>每一个Realm将检查是否实现了相同的 Authorizer 接口。然后，将调用Reaml自己的相应的授权验证方法。 </li>
</ol>
<p>当使用多个Realm时，不同于认证策略处理方式，授权处理过程中： </p>
<ol>
<li>当Realm实现了Authorizer接口<ol>
<li>当调用Realm出现异常时，将立即抛出异常，结束授权验证。 </li>
<li>只要有一个Realm验证成功，那么将认为授权成功，立即返回，结束认证。 </li>
</ol>
</li>
<li>如果 Realm 没有实现 Authorizer 接口，将被忽略。</li>
</ol>
<p><strong>授权顺序</strong></p>
<p>ModularRealmAuthorizer 拥有 SecurityManager 配置的 Realm 实例的入口，当执行一个授权操作时，它将在整个集合中进行迭代（iteration），对于每一个实现 Authorizer 接口的 Realm，调用Realm 各自的 Authorizer 方法（如 hasRole、 checkRole、 isPermitted或 checkPermission）。</p>
<p><strong>配置全局的 PermissionResolver</strong></p>
<p>当执行一个基于字符串的权限检查时，大部分 Shiro 默认的 Realm 将会在执行权限隐含逻辑之前首先把这个字符串转换成一个常用的权限实例。</p>
<p>为了这个转换目的，Shiro 支持 PermissionResolver，大部分 Shiro Realm 使用 PermissionResolver 来支持它们对Authorizer 接口中基于字符串权限方法的实现：当这些方法在Realm上被调用时，将使用PermissionResolver 将字符串转换为权限实例，并执行检查。默认使用内部的 WildcardPermissionResolver</p>
<h2 id="Realms">Realms</h2><p>在认证、授权内部实现机制中都有提到，最终处理都将交给Realm进行处理。因为在Shiro中，最终是通过Realm来获取应用程序中的用户、角色及权限信息的。通常情况下，在Realm中会直接从我们的数据源中获取Shiro需要的验证信息。可以说，Realm是专用于安全框架的DAO. </p>
<h3 id="认证实现">认证实现</h3><p>正如前文所提到的，Shiro的认证过程最终会交由Realm执行，这时会调用Realm的getAuthenticationInfo(token)方法。在一个 Realm 执行一个验证尝试之前，它的supports)方法被调用。只有在返回值为 true 的时候它的getAuthenticationInfo(token) 方法才会执行。因此想要禁用认证过程主要supports始终返回false即可。 </p>
<p>该方法主要执行以下操作: </p>
<ol>
<li>检查提交的进行认证的令牌信息 </li>
<li>根据令牌信息从数据源(通常为数据库)中获取用户信息 </li>
<li>确定令牌支持的 credentials (凭证数据)和存储的数据相符。 </li>
<li>验证通过将返回一个封装了用户信息的AuthenticationInfo实例。 </li>
<li>验证失败则抛出AuthenticationException异常信息。 </li>
</ol>
<p>而在我们的应用程序中要做的就是自定义一个Realm类，继承AuthorizingRealm抽象类，重载doGetAuthenticationInfo()，重写获取用户信息的方法。 </p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken authcToken) throws AuthenticationException &#123;  </span><br><span class="line">    <span class="built_in">String</span> username <span class="subst">=</span> (<span class="built_in">String</span>)token<span class="built_in">.</span>getPrincipal();</span><br><span class="line">    User user <span class="subst">=</span> userService<span class="built_in">.</span>findByUsername(username);</span><br><span class="line">    <span class="keyword">if</span>(user <span class="subst">==</span> <span class="built_in">null</span>) &#123;</span><br><span class="line">        throw <span class="literal">new</span> UnknownAccountException();<span class="comment">//没找到帐号</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">Boolean</span><span class="built_in">.</span><span class="literal">TRUE</span><span class="built_in">.</span><span class="keyword">equals</span>(user<span class="built_in">.</span>getLocked())) &#123;</span><br><span class="line">        throw <span class="literal">new</span> LockedAccountException(); <span class="comment">//帐号锁定</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//交给AuthenticatingRealm使用CredentialsMatcher进行密码匹配，如果觉得人家的不好可以自定义实现</span></span><br><span class="line">    SimpleAuthenticationInfo authenticationInfo <span class="subst">=</span> <span class="literal">new</span> SimpleAuthenticationInfo(</span><br><span class="line">            user<span class="built_in">.</span>getUsername(), <span class="comment">//用户名</span></span><br><span class="line">            user<span class="built_in">.</span>getPassword(), <span class="comment">//密码</span></span><br><span class="line">            ByteSource<span class="built_in">.</span>Util<span class="built_in">.</span><span class="built_in">bytes</span>(user<span class="built_in">.</span>getCredentialsSalt()),<span class="comment">//salt=username+salt</span></span><br><span class="line">            getName()  <span class="comment">//realm name</span></span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">return</span> authenticationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>凭证匹配</strong></p>
<p>在上述 realm 认证工作流中，一个 Realm 必须较验 Subject 提交的凭证（如密码）是否与存储在数据中的凭证相匹配，如果匹配，验证成功，系统保留已认证的终端用户身份。</p>
<p>AuthenticatingRealm 以及它的子类支持用 CredentialsMatcher 来执行一个凭证对比。</p>
<p>在找到用户数据之后，它和提交的 AuthenticationToken 一起传递给一个 CredentialsMatcher ，后者用来检查提交的数据和存储的数据是否相匹配。Shiro某些 CredentialsMatcher 实现可以使你开箱即用，比如 SimpleCredentialsMatcher(直接比较明文) 和 HashedCredentialsMatcher(可以指定hash策略) 实现</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Realm</span> myRealm = <span class="keyword">new</span> com.company.shiro.realm.<span class="type">MyRealm</span><span class="literal">()</span>;</span><br><span class="line"><span class="type">CredentialsMatcher</span> customMatcher = <span class="keyword">new</span> com.company.shiro.realm.<span class="type">CustomCredentialsMatcher</span><span class="literal">()</span>;</span><br><span class="line">myRealm.setCredentialsMatcher(customMatcher);</span><br></pre></td></tr></table></figure>
<h3 id="授权实现-1">授权实现</h3><p>而授权实现则与认证实现非常相似，在我们自定义的Realm中，重载doGetAuthorizationInfo()方法，重写获取用户权限的方法即可。 </p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">protected AuthorizationInfo doGetAuthorizationInfo<span class="params">(PrincipalCollection principals)</span>&#123;  </span><br><span class="line">    String username = <span class="params">(String)</span>principals.getPrimaryPrincipal<span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo<span class="params">()</span>;</span><br><span class="line">    authorizationInfo.setRoles<span class="params">(userService.findRoles<span class="params">(username)</span>)</span>;</span><br><span class="line">    authorizationInfo.setStringPermissions<span class="params">(userService.findPermissions<span class="params">(username)</span>)</span>;</span><br><span class="line">    return authorizationInfo;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="会话管理">会话管理</h2><p>Shiro 提供了完整的企业级会话管理功能，不依赖于底层容器（如 web 容器 tomcat），不管JavaSE 还是 JavaEE 环境都可以使用，提供了会话管理、会话事件监听、会话存储/持久化、容器无关的集群、失效/过期支持、对 Web 的透明支持、SSO 单点登录的支持等特性。</p>
<h3 id="会话">　会话</h3><p>登录成功后使用 Subject.getSession()即可获取会话；其等价于 Subject.getSession(true)，即如果当前没有创建 Session 对象会创建一个；另外 Subject.getSession(false)，如果当前没有创建 Session 则返回 null</p>
<ul>
<li>session.getId(); //获取会话唯一标识</li>
<li>session.getHost(); //获取 Subject的主机地址,该地址是通过 HostAuthenticationToken.getHost()提供的</li>
<li>session.getTimeout(); //获取过期时间</li>
<li>session.setTimeout(毫秒); //设置会话过期时间</li>
<li>session.getStartTimestamp(); //获取会话启动时间</li>
<li>session.getLastAccessTime(); //获取最后访问时间</li>
<li>session.touch(); //更新最后访问时间</li>
<li>session.stop(); //销毁会话。</li>
<li>session.setAttribute(“key”, “123”); //设置session属性</li>
<li>session.getAttribute(“key”));  //获取session属性</li>
<li>session.removeAttribute(“key”);  //删除会话属性</li>
</ul>
<h3 id="会话管理器">会话管理器</h3><p>SessionManager，名如其意，在应用程序中为所有的 subject 管理Session —— 创建，删除，失效及验证，等等。如同其他在Shiro 中的核心结构组件一样，SessionManager 也是一个由 SecurityManager 维护的顶级组件。</p>
<ul>
<li>Session start(SessionContext context); //启动会话</li>
<li>Session getSession(SessionKey key) throws SessionException; //根据会话 Key 获取会话</li>
</ul>
<p>Shiro 提供了三个默认实现：</p>
<ul>
<li>DefaultSessionManager：DefaultSecurityManager 使用的默认实现，用于 JavaSE 环境；</li>
<li>ServletContainerSessionManager：DefaultWebSecurityManager 使用的默认实现，用于Web环境，其直接使用 Servlet 容器的会话；</li>
<li>DefaultWebSessionManager：用于Web环境的实现，可以替代 ServletContainerSessionManager，自己维护着会话，直接废弃了 Servlet 容器的会话管理。</li>
</ul>
<p>另外可以设置会话的全局过期时间（毫秒为单位），默认 30 分钟：sessionManager. globalSessionTimeout=1800000<br>另外如果使用 ServletContainerSessionManager 进行会话管理，Session 的超时依赖于底层 Servlet 容器的超时时间，可以在 web.xml 中配置其会话的超时时间（分钟为单位）：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">session-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">session-timeout</span>&gt;</span>30<span class="tag">&lt;/<span class="title">session-timeout</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">session-config</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在 Servlet 容器中，默认使用 JSESSIONID Cookie 维护会话，且会话默认是跟容器绑定的；在某些情况下可能需要使用自己的会话机制， 此时我们可以使用 DefaultWebSessionManager来维护会话：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">sessionIdCookie=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.web</span><span class="class">.servlet</span><span class="class">.SimpleCookie</span></span><br><span class="line">sessionManager=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.web</span><span class="class">.session</span><span class="class">.mgt</span><span class="class">.DefaultWebSessionManager</span></span><br><span class="line">sessionIdCookie.name=sid</span><br><span class="line"><span class="id">#sessionIdCookie</span>.domain=sishuok<span class="class">.com</span></span><br><span class="line"><span class="id">#sessionIdCookie</span>.path=</span><br><span class="line">sessionIdCookie.maxAge=<span class="number">1800</span></span><br><span class="line">sessionIdCookie.httpOnly=true</span><br><span class="line">sessionManager.sessionIdCookie=<span class="variable">$sessionIdCookie</span></span><br><span class="line">sessionManager.sessionIdCookieEnabled=true</span><br><span class="line">securityManager.sessionManager=<span class="variable">$sessionManager</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sessionIdCookie 是 sessionManager 创建会话 Cookie 的模板：</li>
<li>sessionIdCookie.name：设置 Cookie 名字，默认为 JSESSIONID；</li>
<li>sessionIdCookie.domain：设置 Cookie 的域名，默认空，即当前访问的域名；</li>
<li>sessionIdCookie.path：设置 Cookie 的路径，默认空，即存储在域名根下；</li>
<li>sessionIdCookie.maxAge：设置 Cookie 的过期时间，秒为单位，默认-1 表示关闭浏览器时过期 Cookie；</li>
<li>sessionIdCookie.httpOnly：如果设置为 true，则客户端不会暴露给客户端脚本代码，使用HttpOnly cookie有助于减少某些类型的跨站点脚本攻击； 此特性需要实现了 Servlet 2.5 MR6及以上版本的规范的 Servlet 容器支持；</li>
<li>sessionManager.sessionIdCookieEnabled：是否启用/禁用 Session Id Cookie，默认是启用的；如果禁用后将不会设置 Session Id Cookie，即默认使用了 Servlet 容器的 JSESSIONID，且通过 URL 重写（URL 中的“;JSESSIONID=id”部分）保存 Session Id。（这里设为false，url并没有重写，需要设置什么吗？)</li>
</ul>
<h3 id="会话监听器">会话监听器</h3><p>会话监听器用于监听会话创建、过期及停止事件。可以实现SessionListener中的onStart、onExpiration、onStop方法</p>
<h3 id="会话存储/持久化">会话存储/持久化</h3><p>Shiro 提供 SessionDAO 用于会话的 CRUD，即 DAO（Data Access Object）模式实现</p>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">-<span class="ruby">- <span class="constant">SessionDAO</span></span><br><span class="line"></span>    -<span class="ruby">- <span class="constant">AbstractSessionDAO</span> </span><br><span class="line"></span>        -<span class="ruby">- <span class="constant">CachingSessionDAO</span></span><br><span class="line"></span>            -<span class="ruby">- <span class="constant">EnterpriseCacheSessionDAO</span></span><br><span class="line"></span>        -<span class="ruby">- <span class="constant">MemorySessionDAO</span></span></span><br></pre></td></tr></table></figure>
<p>AbstractSessionDAO提供了SessionDAO的基础实现，如生成会话 ID等；CachingSessionDAO 提供了对开发者透明的会话缓存的功能，只需要设置相应的 CacheManager 即可；MemorySessionDAO 直接在内存中进行会话维护；而 EnterpriseCacheSessionDAO 提供了缓存功能的会话维护，默认情况下使用 MapCache 实现，内部使用 ConcurrentHashMap 保存缓存的会话。</p>
<p>Shiro 提供了使用 Ehcache 进行会话存储，Ehcache 可以配合 TerraCotta 实现容器无关的分布式集群。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sessionDAO=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.session</span><span class="class">.mgt</span><span class="class">.eis</span><span class="class">.EnterpriseCacheSessionDAO</span></span><br><span class="line">sessionDAO. activeSessionsCacheName=shiro-activeSessionCache</span><br><span class="line">sessionManager.sessionDAO=<span class="variable">$sessionDAO</span></span><br><span class="line">cacheManager = org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.cache</span><span class="class">.ehcache</span><span class="class">.EhCacheManager</span></span><br><span class="line">cacheManager.cacheManagerConfigFile=classpath:ehcache<span class="class">.xml</span></span><br><span class="line">securityManager<span class="class">.cacheManager</span> = <span class="variable">$cacheManager</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sessionDAO. activeSessionsCacheName：设置Session 缓存名字，默认就是shiro-activeSessionCache；</li>
<li>cacheManager：缓存管理器，用于管理缓存的，此处使用 Ehcache 实现；</li>
<li>cacheManager.cacheManagerConfigFile：设置 ehcache 缓存的配置文件；</li>
<li>securityManager.cacheManager：设置 SecurityManager 的 cacheManager，会自动设置实现了CacheManagerAware 接口的相应对象，如 SessionDAO 的 cacheManager；</li>
</ul>
<p>ehcache.xml：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;cache <span class="variable">name=</span><span class="string">"shiro-activeSessionCache"</span></span><br><span class="line">    <span class="variable">maxEntriesLocalHeap=</span><span class="string">"10000"</span></span><br><span class="line">    <span class="variable">overflowToDisk=</span><span class="string">"false"</span></span><br><span class="line">    <span class="variable">eternal=</span><span class="string">"false"</span></span><br><span class="line">    <span class="variable">diskPersistent=</span><span class="string">"false"</span></span><br><span class="line">    <span class="variable">timeToLiveSeconds=</span><span class="string">"0"</span></span><br><span class="line">    <span class="variable">timeToIdleSeconds=</span><span class="string">"0"</span></span><br><span class="line">    <span class="variable">statistics=</span><span class="string">"true"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Cache 的名字为 shiro-activeSessionCache，即设置的 sessionDAO 的 activeSessionsCacheName 属性值。</p>
<p>用于生成会话 ID，默认就是 JavaUuidSessionIdGenerator，使用 java.util.UUID 生成。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionIdGenerator=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.session</span><span class="class">.mgt</span><span class="class">.eis</span><span class="class">.JavaUuidSessionIdGenerator</span></span><br><span class="line">sessionDAO.sessionIdGenerator=<span class="variable">$sessionIdGenerator</span></span><br></pre></td></tr></table></figure></p>
<h3 id="会话验证">会话验证</h3><p>Shiro 提供了会话验证调度器，用于定期的验证会话是否已过期，如果过期将停止会话；出于性能考虑，一般情况下都是获取会话时来验证会话是否过期并停止会话的；但是如在 web环境中，如果用户不主动退出是不知道会话是否过期的，因此需要定期的检测会话是否过期，Shiro 提供了会话验证调度器 SessionValidationScheduler 来做这件事情。</p>
<p>可以通过如下 ini 配置开启会话验证：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">sessionValidationScheduler=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.session</span><span class="class">.mgt</span><span class="class">.ExecutorServiceSessionValidationScheduler</span></span><br><span class="line">sessionValidationScheduler<span class="class">.interval</span> = <span class="number">3600000</span></span><br><span class="line">sessionValidationScheduler.sessionManager=<span class="variable">$sessionManager</span></span><br><span class="line">sessionManager.globalSessionTimeout=<span class="number">1800000</span></span><br><span class="line">sessionManager.sessionValidationSchedulerEnabled=true</span><br><span class="line">sessionManager.sessionValidationScheduler=<span class="variable">$sessionValidationScheduler</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>sessionValidationScheduler：会话验证调度器，sessionManager 默认就是使用 ExecutorServiceSessionValidationScheduler， 其使用 JDK 的 ScheduledExecutorService 进行定期调度并验证会话是否过期；</li>
<li>sessionValidationScheduler.interval：设置调度时间间隔，单位毫秒，默认就是 1 小时；</li>
<li>sessionValidationScheduler.sessionManager：设置会话验证调度器进行会话验证时的会话管理器；</li>
<li>sessionManager.globalSessionTimeout：设置全局会话超时时间，默认 30 分钟，即如果 30 分钟内没有访问会话将过期；</li>
<li>sessionManager.sessionValidationSchedulerEnabled：是否开启会话验证器，默认是开启的；</li>
<li>sessionManager.sessionValidationScheduler：设置会话验证调度器，默认就是使用 ExecutorServiceSessionValidationScheduler。</li>
</ul>
<p>Shiro 也提供了使用 Quartz 会话验证调度器,使用时需要导入 shiro-quartz 依赖：</p>
<p>如上会话验证调度器实现都是直接调用 AbstractValidatingSessionManager 的 validateSessions 方法进行验证，其直接调用 SessionDAO 的 getActiveSessions 方法获取所有会话进行验证，如果会话比较多，会影响性能；可以考虑如分页获取会话并进行验证</p>
<p>如果在会话过期时不想删除过期的会话，可以通过如下 ini 配置进行设置：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sessionManager.<span class="variable">deleteInvalidSessions=</span><span class="constant">false</span></span><br></pre></td></tr></table></figure></p>
<p>会话工厂<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionFactory=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.session</span><span class="class">.mgt</span><span class="class">.OnlineSessionFactory</span></span><br><span class="line">sessionManager.sessionFactory=<span class="variable">$sessionFactory</span></span><br></pre></td></tr></table></figure></p>
<h2 id="编码/加密">编码/加密</h2><h3 id="编码/解码">编码/解码</h3><p>Shiro 内部的一些数据的存储/表示都使用了 base64 和 16 进制字符串。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span><span class="keyword">str </span>= <span class="string">"hello"</span><span class="comment">; </span></span><br><span class="line"><span class="keyword">String </span><span class="keyword">base64Encoded </span>= <span class="keyword">Base64.encodeToString(str.getBytes()); </span></span><br><span class="line"><span class="keyword">String </span><span class="keyword">str2 </span>= <span class="keyword">Base64.decodeToString(base64Encoded); </span></span><br><span class="line"><span class="label">Assert.assertEquals</span>(<span class="keyword">str, </span><span class="keyword">str2);</span></span><br></pre></td></tr></table></figure>
<p>还有一个可能经常用到的类 CodecSupport，提供了 toBytes(str,  “utf-8”)  /  toString(bytes, “utf-8”)用于在 byte 数组/String 之间转换。</p>
<h3 id="散列算法">散列算法</h3><p>散列算法一般用于生成数据的摘要信息，是一种不可逆的算法，一般适合存储密码之类的 数据，常见的散列算法如 MD5、SHA 等。一般进行散列时最好提供一个 salt（盐），因为md5解密网站很容易通过散列值得到密码。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"hello"</span>; </span><br><span class="line"><span class="keyword">String</span> salt = <span class="string">"123"</span>; </span><br><span class="line"><span class="keyword">String</span> md5 =<span class="keyword">new</span> Md5Hash(<span class="built_in">str</span>, salt, <span class="number">2</span>).toString();<span class="comment">//还可以转换为  toBase64()/toHex()  做两次hash</span></span><br></pre></td></tr></table></figure>
<p>除了Md5外还有Sha256/Sha1/Sha512</p>
<p>通用的散列支持<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span> <span class="built_in">str</span> = <span class="string">"hello"</span>; </span><br><span class="line"><span class="keyword">String</span> salt = <span class="string">"123"</span>; </span><br><span class="line"><span class="comment">//内部使用Java的 MessageDigest </span></span><br><span class="line"><span class="keyword">String</span> simpleHash =<span class="keyword">new</span> SimpleHash(<span class="string">"SHA-1"</span>, <span class="built_in">str</span>, salt).toString();</span><br></pre></td></tr></table></figure></p>
<p>为了方便使用，Shiro 提供了 HashService，默认提供了 DefaultHashService 实现</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DefaultHashService hashService =new DefaultHashService<span class="params">()</span>; <span class="comment">//默认算法 SHA-512 </span></span><br><span class="line">hashService.setHashAlgorithmName<span class="params">(<span class="string">"SHA-512"</span>)</span>; </span><br><span class="line">hashService.setPrivateSalt<span class="params">(newSimpleByteSource<span class="params">(<span class="string">"123"</span>)</span>)</span>; <span class="comment">//私盐，默认无</span></span><br><span class="line">hashService.setGeneratePublicSalt<span class="params">(<span class="literal">true</span>)</span>;<span class="comment">//是否生成公盐，默认 false </span></span><br><span class="line">hashService.setRandomNumberGenerator<span class="params">(new  SecureRandomNumberGenerator<span class="params">()</span>)</span>;<span class="comment">//用于生成公盐。默认就这个</span></span><br><span class="line">hashService.setHashIterations<span class="params">(<span class="number">1</span>)</span>; <span class="comment">//生成 Hash 值的迭代次数</span></span><br><span class="line">HashRequest request =new HashRequest.Builder<span class="params">()</span> </span><br><span class="line">.setAlgorithmName<span class="params">(<span class="string">"MD5"</span>)</span>.setSource<span class="params">(ByteSource.Util.bytes<span class="params">(<span class="string">"hello"</span>)</span>)</span> </span><br><span class="line">.setSalt<span class="params">(ByteSource.Util.bytes<span class="params">(<span class="string">"123"</span>)</span>)</span>.setIterations<span class="params">(<span class="number">2</span>)</span>.build<span class="params">()</span>; </span><br><span class="line">String hex =hashService.computeHash<span class="params">(request)</span>.toHex<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="加密/解密">加密/解密</h3><p>Shiro 还提供对称式加密/解密算法的支持，如 AES、Blowfish 等；当前还没有提供对非对称加密/解密算法支持，未来版本可能提供。</p>
<p>AES算法<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">AesCipherService aesCipherService =new AesCipherService<span class="params">()</span>; </span><br><span class="line">aesCipherService.setKeySize<span class="params">(<span class="number">128</span>)</span>; <span class="comment">//设置 key 长度</span></span><br><span class="line"><span class="comment">//生成 key </span></span><br><span class="line">Keykey = aesCipherService.generateNewKey<span class="params">()</span>; </span><br><span class="line">String <span class="built_in">text</span> = <span class="string">"hello"</span>; </span><br><span class="line"><span class="comment">//加密</span></span><br><span class="line">String encrptText = aesCipherService.encrypt<span class="params">(text.getBytes<span class="params">()</span>, key.getEncoded<span class="params">()</span>)</span>.toHex<span class="params">()</span>; </span><br><span class="line"><span class="comment">//解密</span></span><br><span class="line">String text2 = new String<span class="params">(aesCipherService.decrypt<span class="params">(Hex.decode<span class="params">(encrptText)</span>, key.getEncoded<span class="params">()</span>)</span>.getBytes<span class="params">()</span>)</span>; </span><br><span class="line">Assert.assertEquals<span class="params">(text, text2)</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="PasswordService/CredentialsMatcher">PasswordService/CredentialsMatcher</h3><p>Shiro 提供了 PasswordService 及 CredentialsMatcher 用于提供加密密码及验证密码服务。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PasswordService</span> </span>&#123; </span><br><span class="line"><span class="comment">//输入明文密码得到密文密码</span></span><br><span class="line"><span class="function">String <span class="title">encryptPassword</span><span class="params">(ObjectplaintextPassword)</span> <span class="keyword">throws</span> IllegalArgumentException</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CredentialsMatcher</span> </span>&#123; </span><br><span class="line"><span class="comment">//匹配用户输入的 token 的凭证（未加密）与系统提供的凭证（已加密）</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">doCredentialsMatch</span><span class="params">(AuthenticationToken token, AuthenticationInfo info)</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Shiro 默认提供了 PasswordService 实现 DefaultPasswordService；CredentialsMatcher 实现PasswordMatcher及HashedCredentialsMatcher（更强大）。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[main] </span><br><span class="line">passwordService=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.authc</span><span class="class">.credential</span><span class="class">.DefaultPasswordService</span> </span><br><span class="line">hashService=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.crypto</span><span class="class">.hash</span><span class="class">.DefaultHashService</span> </span><br><span class="line">passwordService.hashService=<span class="variable">$hashService</span> </span><br><span class="line">hashFormat=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.crypto</span><span class="class">.hash</span><span class="class">.format</span><span class="class">.Shiro1CryptFormat</span> </span><br><span class="line">passwordService.hashFormat=<span class="variable">$hashFormat</span> </span><br><span class="line">hashFormatFactory=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.crypto</span><span class="class">.hash</span><span class="class">.format</span><span class="class">.DefaultHashFormatFactory</span> </span><br><span class="line">passwordService.hashFormatFactory=<span class="variable">$hashFormatFactory</span> </span><br><span class="line">passwordMatcher=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.authc</span><span class="class">.credential</span><span class="class">.PasswordMatcher</span> </span><br><span class="line">passwordMatcher.passwordService=<span class="variable">$passwordService</span> </span><br><span class="line">myRealm=com<span class="class">.github</span><span class="class">.zhangkaitao</span><span class="class">.shiro</span><span class="class">.chapter5</span><span class="class">.hash</span><span class="class">.realm</span><span class="class">.MyRealm</span> </span><br><span class="line">myRealm.passwordService=<span class="variable">$passwordService</span> </span><br><span class="line">myRealm.credentialsMatcher=<span class="variable">$passwordMatcher</span> </span><br><span class="line">securityManager.realms=<span class="variable">$myRealm</span></span><br></pre></td></tr></table></figure>
<ol>
<li>passwordService 使用 DefaultPasswordService，如果有必要也可以自定义；</li>
<li>hashService 定义散列密码使用的 HashService，默认使用 DefaultHashService（默认SHA-256 算法）；</li>
<li>hashFormat 用于对散列出的值进行格式化，默认使用 Shiro1CryptFormat，另外提供了Base64Format 和 HexFormat，对于有 salt 的密码请自定义实现 ParsableHashFormat 然后把salt 格式化到散列值中；</li>
<li>hashFormatFactory 用于根据散列值得到散列的密码和 salt； 因为如果使用如 SHA 算法，那么会生成一个 salt，此 salt 需要保存到散列后的值中以便之后与传入的密码比较时使用；默认使用 DefaultHashFormatFactory；</li>
<li>passwordMatcher 使用 PasswordMatcher，其是一个 CredentialsMatcher 实现；</li>
<li>将 credentialsMatcher 赋值给 myRealm， myRealm 间接继承了 AuthenticatingRealm， 其在调用getAuthenticationInfo 方法获取到AuthenticationInfo信息后，会使用 credentialsMatcher 来验证凭据是否匹配，如果不匹配将抛出 IncorrectCredentialsException 异常。</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[main] </span><br><span class="line">credentialsMatcher=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.authc</span><span class="class">.credential</span><span class="class">.HashedCredentialsMatcher</span> </span><br><span class="line">credentialsMatcher.hashAlgorithmName=md5 </span><br><span class="line">credentialsMatcher.hashIterations=<span class="number">2</span> </span><br><span class="line">credentialsMatcher.storedCredentialsHexEncoded=true </span><br><span class="line">myRealm=com<span class="class">.github</span><span class="class">.zhangkaitao</span><span class="class">.shiro</span><span class="class">.chapter5</span><span class="class">.hash</span><span class="class">.realm</span><span class="class">.MyRealm2</span> </span><br><span class="line">myRealm.credentialsMatcher=<span class="variable">$credentialsMatcher</span> </span><br><span class="line">securityManager.realms=<span class="variable">$myRealm</span></span><br></pre></td></tr></table></figure>
<ol>
<li>通过 credentialsMatcher.hashAlgorithmName=md5 指定散列算法为 md5，需要和生成密码时的一样；</li>
<li>credentialsMatcher.hashIterations=2，散列迭代次数，需要和生成密码时的意义；</li>
<li>credentialsMatcher.storedCredentialsHexEncoded=true 表示是否存储散列后的密码为 16 进制，需要和生成密码时的一样，默认是 base64；</li>
</ol>
<p>此处最需要注意的就是 HashedCredentialsMatcher 的算法需要和生成密码时的算法一样。 另外 HashedCredentialsMatcher 会自动根据AuthenticationInfo 的类型是否是 SaltedAuthenticationInfo 来获取 credentialsSalt 盐。</p>
<h2 id="配置">配置</h2><p>Apache Shiro的配置主要分为四部分： </p>
<ol>
<li>对象和属性的定义与配置</li>
<li>URL的过滤器配置</li>
<li>静态用户配置</li>
<li>静态角色配置</li>
</ol>
<p>其中，由于用户、角色一般由后台进行操作的动态数据，因此Shiro配置一般仅包含前两项的配置。 </p>
<p>Apache Shiro的大多数组件是基于POJO的，因此我们可以使用POJO兼容的任何配置机制进行配置，例如：Java代码、Sping XML、YAML、JSON、ini文件等等。</p>
<p>Shiro 是从根对象 SecurityManager 进行身份验证和授权的；也就是所有操作都是自它开始的，这个对象是线程安全且整个应用只需要一个即可</p>
<p><strong>INI配置</strong></p>
<ol>
<li>对象名=全限定类名 相当于调用 public 无参构造器创建对象</li>
<li>对象名.属性名=值 相当于调用 setter 方法设置常量值</li>
<li>对象名.属性名=$对象引用 相当于调用 setter 方法设置对象引用</li>
</ol>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[main]</span><br><span class="line"><span class="comment">#提供了对根对象 securityManager 及其依赖的配置</span></span><br><span class="line"><span class="variable">securityManager=</span>org.apache.shiro.mgt.DefaultSecurityManager</span><br><span class="line">…………</span><br><span class="line">dataSource.<span class="variable">driverClassName=</span>com.mysql.jdbc.Driver</span><br><span class="line"><span class="comment">#常量值注入</span></span><br><span class="line">jdbcRealm.<span class="variable">permissionsLookupEnabled=</span><span class="constant">true</span></span><br><span class="line">…………</span><br><span class="line"><span class="comment">#对象引用值注入</span></span><br><span class="line">securityManager.<span class="variable">realms=</span>$jdbcRealm</span><br><span class="line">…………</span><br><span class="line"><span class="comment">#嵌套属性注入</span></span><br><span class="line">securityManager.authenticator.<span class="variable">authenticationStrategy=</span>$authenticationStrategy</span><br><span class="line"><span class="comment">#byte数组注入</span></span><br><span class="line"><span class="comment">#base64 byte[]</span></span><br><span class="line">authenticator.<span class="variable">bytes=</span><span class="variable">aGVsbG8=</span></span><br><span class="line"><span class="comment">#hex byte[]</span></span><br><span class="line">authenticator.<span class="variable">bytes=</span><span class="number">0</span>x68656c6c6f</span><br><span class="line"><span class="comment">#Array/Set/List注入</span></span><br><span class="line">authenticator.<span class="variable">array=</span><span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span></span><br><span class="line">authenticator.<span class="variable">set=</span>$jdbcRealm,$jdbcRealm</span><br><span class="line"><span class="comment">#Map注入</span></span><br><span class="line">authenticator.<span class="variable">map=</span>$jdbcRealm:$jdbcRealm,<span class="number">1</span>:<span class="number">1</span>,key:abc</span><br><span class="line">[users]</span><br><span class="line"><span class="comment">#提供了对用户/密码及其角色的配置，用户名=密码，角色 1，角色 2</span></span><br><span class="line"><span class="variable">username=</span>password,role1,role2</span><br><span class="line">[roles]</span><br><span class="line"><span class="comment">#提供了角色及权限之间关系的配置，角色=权限 1，权限 2</span></span><br><span class="line"><span class="variable">role1=</span>permission1,permission2</span><br><span class="line">[urls]</span><br><span class="line"><span class="comment">#用于 web，提供了对 web url 拦截相关的配置，url=拦截器[参数]，拦截器</span></span><br><span class="line">/index.<span class="variable">html =</span> anon</span><br><span class="line">/admin<span class="comment">/** = authc, roles[admin], perms["permission1"]</span></span><br></pre></td></tr></table></figure>
<p>XML配置： </p>
<p>主要是对Shiro各个组件的实现进行定义配置，主要组件在前文已做过简单介绍，这里不再一一说明。 </p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"securityManager"</span> class=<span class="string">"org.apache.shiro.mgt.DefaultSecurityManager"</span>&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"cacheManager"</span> <span class="keyword">ref</span>=<span class="string">"cacheManager"</span>/&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"sessionMode"</span> value=<span class="string">"native"</span>/&gt;  </span><br><span class="line">        &lt;!-- <span class="type">Single</span> realm app.  <span class="type">If</span> you have multiple realms, use the 'realms' property instead. --&gt;</span><br><span class="line">        &lt;property name=<span class="string">"realm"</span> <span class="keyword">ref</span>=<span class="string">"myRealm"</span>/&gt;  </span><br><span class="line">        &lt;property name=<span class="string">"sessionManager"</span> <span class="keyword">ref</span>=<span class="string">"sessionManager"</span>/&gt;   </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>Shiro过滤器的配置 </p>
<p>Shiro主要是通过URL过滤来进行安全管理，这里的配置便是指定具体授权规则定义。 </p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="property">id</span>=<span class="string">"shiroFilter"</span> <span class="type">class</span>=<span class="string">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;  </span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"securityManager"</span> <span class="keyword">ref</span>=<span class="string">"securityManager"</span>/&gt;  </span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"loginUrl"</span> value=<span class="string">"/login.jsp"</span>/&gt;  </span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"successUrl"</span> value=<span class="string">"/home.jsp"</span>/&gt;  </span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"unauthorizedUrl"</span> value=<span class="string">"/unauthorized.jsp"</span>/&gt; <span class="comment">--&gt;  </span></span><br><span class="line">    &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"filterChainDefinitions"</span>&gt;  </span><br><span class="line">        &lt;value&gt;  </span><br><span class="line">            <span class="comment"># some example chain definitions:  </span></span><br><span class="line">            /admin/** = authc, roles[admin]  </span><br><span class="line">            /docs/** = authc, perms[document:<span class="command">read</span>]  </span><br><span class="line">            /** = authc  </span><br><span class="line">            <span class="comment"># more URL-to-FilterChain definitions here  </span></span><br><span class="line">        &lt;/value&gt;  </span><br><span class="line">    &lt;/<span class="keyword">property</span>&gt;  </span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>URL过滤器配置说明： </p>
<p>Shiro可以通过配置文件实现基于URL的授权验证。FilterChain定义格式： <code>URL_Ant_Path_Expression = Path_Specific_Filter_Chain</code> </p>
<p>每个URL配置，表示匹配该URL的应用程序请求将由对应的过滤器进行验证。 </p>
<p>例如：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[urls] </span><br><span class="line">/index.html = anon </span><br><span class="line">/user/create = anon </span><br><span class="line">/user/<span class="keyword">*</span><span class="keyword">*</span> = authc </span><br><span class="line">/admin/<span class="keyword">*</span><span class="keyword">*</span> = authc, roles[administrator] </span><br><span class="line">/rest/<span class="keyword">*</span><span class="keyword">*</span> = authc, rest </span><br><span class="line">/remoting/rpc/<span class="keyword">*</span><span class="keyword">*</span> = authc, perms[<span class="string">"remote:invoke"</span>]</span><br></pre></td></tr></table></figure></p>
<p>URL表达式说明 </p>
<ol>
<li>URL目录是基于HttpServletRequest.getContextPath()此目录设置 </li>
<li>URL可使用通配符，**代表任意子目录 </li>
<li>Shiro验证URL时，URL匹配成功便不再继续匹配查找。所以要注意配置文件中的URL顺序，尤其在使用通配符时。 </li>
</ol>
<p>URL 路径表达式按事先定义好的顺序判断传入的请求，并遵循 FIRST MATCH WINS 这一原则。例如<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/account/<span class="keyword">*</span><span class="keyword">*</span> = ssl, authc</span><br><span class="line">/account/signup = anon</span><br></pre></td></tr></table></figure></p>
<p>如果传入的请求旨在访问 <code>/account/signup/index.html</code>（所有 ‘anon’ymous 用户都能访问），那么它将永不会被处理！原因是因为<code>/account/*</code>  的模式第一个匹配了传入的请求，“短路”了其余的定义。 </p>
<p>Filter Chain定义说明 </p>
<ol>
<li>一个URL可以配置多个Filter，使用逗号分隔 </li>
<li>当设置多个过滤器时，全部验证通过，才视为通过 </li>
<li>部分过滤器可指定参数，如perms，roles </li>
</ol>
<p>Shiro内置的FilterChain </p>
<table>
<thead>
<tr>
<th>Filter Name</th>
<th>Class</th>
</tr>
</thead>
<tbody>
<tr>
<td>anon</td>
<td>org.apache.shiro.web.filter.authc.AnonymousFilter</td>
</tr>
<tr>
<td>authc</td>
<td>org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td>
</tr>
<tr>
<td>authcBasic</td>
<td>org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td>
</tr>
<tr>
<td>logout</td>
<td>org.apache.shiro.web.filter.authc.LogoutFilter</td>
</tr>
<tr>
<td>noSessionCreation</td>
<td>org.apache.shiro.web.filter.session.NoSessionCreationFilter</td>
</tr>
<tr>
<td>perms</td>
<td>org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td>
</tr>
<tr>
<td>port</td>
<td>org.apache.shiro.web.filter.authz.PortFilter</td>
</tr>
<tr>
<td>rest</td>
<td>org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td>
</tr>
<tr>
<td>roles</td>
<td>org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td>
</tr>
<tr>
<td>ssl</td>
<td>org.apache.shiro.web.filter.authz.SslFilter</td>
</tr>
<tr>
<td>user</td>
<td>org.apache.shiro.web.filter.authc.UserFilter</td>
</tr>
</tbody>
</table>
<p>OncePerRequestFilter（及其所有子类）支持 Enabling/Disabling 所有请求及 per-request 基础。 一般为所有的请求启用或禁用一个过滤器是通过设置其 enabled 属性为true 或 false。</p>
<figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">main</span>]</span><br><span class="line">ssl.<span class="literal">enabled</span>=<span class="keyword">false</span></span><br></pre></td></tr></table></figure>
<h2 id="缓存">缓存</h2><ul>
<li>CacheManager - 负责所有缓存的主要管理组件，它返回 Cache 实例。</li>
<li>Cache - 维护key/value 对。</li>
<li>CacheManagerAware - 通过想要接收和使用 CacheManager 实例的组件来实现。</li>
</ul>
<p>CacheManager 返回Cache 实例，各种不同的Shiro 组件使用这些Cache 实例来缓存必要的数据。任何实现了 CacheManagerAware 的 Shiro 组件将会自动地接收一个配置好的 CacheManager，该 CacheManager 能够用来获取 Cache 实例。</p>
<h3 id="Realm缓存">Realm缓存</h3><p>Shiro 的 SecurityManager 实现及所有 AuthorizingRealm 实现都实现了 CacheManagerAware 。如果你在 SecurityManager 上设置了 CacheManger，它反过来也会将它设置到实现了CacheManagerAware 的各种不同的 Realm 上（OO delegation）</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">userRealm=com<span class="class">.github</span><span class="class">.zhangkaitao</span><span class="class">.shiro</span><span class="class">.chapter11</span><span class="class">.realm</span><span class="class">.UserRealm</span></span><br><span class="line">userRealm.credentialsMatcher=<span class="variable">$credentialsMatcher</span></span><br><span class="line">userRealm.cachingEnabled=true</span><br><span class="line">userRealm.authenticationCachingEnabled=true</span><br><span class="line">userRealm.authenticationCacheName=authenticationCache</span><br><span class="line">userRealm.authorizationCachingEnabled=true</span><br><span class="line">userRealm.authorizationCacheName=authorizationCache</span><br><span class="line">securityManager.realms=<span class="variable">$userRealm</span></span><br><span class="line">cacheManager=org<span class="class">.apache</span><span class="class">.shiro</span><span class="class">.cache</span><span class="class">.ehcache</span><span class="class">.EhCacheManager</span></span><br><span class="line">cacheManager.cacheManagerConfigFile=classpath:shiro-ehcache<span class="class">.xml</span></span><br><span class="line">securityManager.cacheManager=<span class="variable">$cacheManager</span></span><br></pre></td></tr></table></figure>
<ul>
<li>userRealm.cachingEnabled：启用缓存，默认 false；</li>
<li>userRealm.authenticationCachingEnabled：启用身份验证缓存，即缓存 AuthenticationInfo 信息，默认 false；</li>
<li>userRealm.authenticationCacheName：缓存 AuthenticationInfo 信息的缓存名称；</li>
<li>userRealm. authorizationCachingEnabled：启用授权缓存，即缓存 AuthorizationInfo 信息，默认 false；</li>
<li>userRealm. authorizationCacheName：缓存 AuthorizationInfo 信息的缓存名称；</li>
<li>cacheManager：缓存管理器，此处使用 EhCacheManager，即 Ehcache 实现，需要导入相应的 Ehcache 依赖，请参考 pom.xml；</li>
</ul>
<p>如果凭证数据或授权数据发生改变，需要调用Realm的clearCachedAuthenticationInfo 和 clearCachedAuthorizationInfo方法</p>
<h3 id="Session缓存">Session缓存</h3><p>如 securityManager 实现了 SessionsSecurityManager，其会自动判断 SessionManager 是否实现了 CacheManagerAware 接口，如果实现了会把 CacheManager 设置给它。然后sessionManager 会判断相应的 sessionDAO（如继承自 CachingSessionDAO）是否实现了CacheManagerAware， 如果实现了会把 CacheManager 设置给它</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionDAO=com<span class="class">.github</span><span class="class">.zhangkaitao</span><span class="class">.shiro</span><span class="class">.chapter11</span><span class="class">.session</span><span class="class">.dao</span><span class="class">.MySessionDAO</span></span><br><span class="line">sessionDAO.activeSessionsCacheName=shiro-activeSessionCache</span><br></pre></td></tr></table></figure>
<p>activeSessionsCacheName 默认就是 shiro-activeSessionCache。</p>
<h2 id="与Spring的集成">与Spring的集成</h2><h3 id="JavaSE">JavaSE</h3><p>spring-shiro.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 缓存管理器 使用 Ehcache 实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"cacheManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.cache.ehcache.EhCacheManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cacheManagerConfigFile"</span> <span class="attribute">value</span>=<span class="value">"classpath:ehcache.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 凭证匹配器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"credentialsMatcher"</span> <span class="attribute">class</span>=<span class="value">"com.github.zhangkaitao.shiro.chapter12.credentials.RetryLimitHashedCredentialsMatcher"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"cacheManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hashAlgorithmName"</span> <span class="attribute">value</span>=<span class="value">"md5"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hashIterations"</span> <span class="attribute">value</span>=<span class="value">"2"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"storedCredentialsHexEncoded"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Realm 实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"userRealm"</span> <span class="attribute">class</span>=<span class="value">"com.github.zhangkaitao.shiro.chapter12.realm.UserRealm"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"userService"</span> <span class="attribute">ref</span>=<span class="value">"userService"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"credentialsMatcher"</span> <span class="attribute">ref</span>=<span class="value">"credentialsMatcher"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cachingEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authenticationCachingEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authenticationCacheName"</span> <span class="attribute">value</span>=<span class="value">"authenticationCache"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authorizationCachingEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"authorizationCacheName"</span> <span class="attribute">value</span>=<span class="value">"authorizationCache"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话 ID 生成器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionIdGenerator"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.session.mgt.eis.JavaUuidSessionIdGenerator"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话 DAO --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionDAO"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.session.mgt.eis.EnterpriseCacheSessionDAO"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"activeSessionsCacheName"</span> <span class="attribute">value</span>=<span class="value">"shiro-activeSessionCache"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionIdGenerator"</span> <span class="attribute">ref</span>=<span class="value">"sessionIdGenerator"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话验证调度器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionValidationScheduler"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.session.mgt.quartz.QuartzSessionValidationScheduler"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionValidationInterval"</span> <span class="attribute">value</span>=<span class="value">"1800000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionManager"</span> <span class="attribute">ref</span>=<span class="value">"sessionManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.session.mgt.DefaultSessionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"globalSessionTimeout"</span> <span class="attribute">value</span>=<span class="value">"1800000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"deleteInvalidSessions"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionValidationSchedulerEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionValidationScheduler"</span> <span class="attribute">ref</span>=<span class="value">"sessionValidationScheduler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionDAO"</span> <span class="attribute">ref</span>=<span class="value">"sessionDAO"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"securityManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.mgt.DefaultSecurityManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"realms"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">list</span>&gt;</span><span class="tag">&lt;<span class="title">ref</span> <span class="attribute">bean</span>=<span class="value">"userRealm"</span>/&gt;</span><span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionManager"</span> <span class="attribute">ref</span>=<span class="value">"sessionManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cacheManager"</span> <span class="attribute">ref</span>=<span class="value">"cacheManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 相当于调用 SecurityUtils.setSecurityManager(securityManager) --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"staticMethod"</span> <span class="attribute">value</span>=<span class="value">"org.apache.shiro.SecurityUtils.setSecurityManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"arguments"</span> <span class="attribute">ref</span>=<span class="value">"securityManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Shiro 生命周期处理器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"lifecycleBeanPostProcessor"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.spring.LifecycleBeanPostProcessor"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>LifecycleBeanPostProcessor 用于在实现了 Initializable 接口的 Shiro bean 初始化时调用 Initializable 接口回调，在实现了 Destroyable 接口的 Shiro bean 销毁时调用 Destroyable 接口回调。 如 UserRealm 就实现了 Initializable， 而 DefaultSecurityManager 实现了 Destroyable。具体可以查看它们的继承关系。 </p>
<h3 id="Web应用">Web应用</h3><p>spring-shiro-web.xml，只列出了和JavaSE不同的项，其中会话管理器和安全管理器和JavaSE稍有不同，其他几个是新加的<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 会话 Cookie 模板 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionIdCookie"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"sid"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"httpOnly"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxAge"</span> <span class="attribute">value</span>=<span class="value">"180000"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 会话管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.session.mgt.DefaultWebSessionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"globalSessionTimeout"</span> <span class="attribute">value</span>=<span class="value">"1800000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"deleteInvalidSessions"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionValidationSchedulerEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionValidationScheduler"</span> <span class="attribute">ref</span>=<span class="value">"sessionValidationScheduler"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionDAO"</span> <span class="attribute">ref</span>=<span class="value">"sessionDAO"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionIdCookieEnabled"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionIdCookie"</span> <span class="attribute">ref</span>=<span class="value">"sessionIdCookie"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"securityManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"realm"</span> <span class="attribute">ref</span>=<span class="value">"userRealm"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionManager"</span> <span class="attribute">ref</span>=<span class="value">"sessionManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cacheManager"</span> <span class="attribute">ref</span>=<span class="value">"cacheManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 基于 Form 表单的身份验证过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"formAuthenticationFilter"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.filter.authc.FormAuthenticationFilter"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"usernameParam"</span> <span class="attribute">value</span>=<span class="value">"username"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"passwordParam"</span> <span class="attribute">value</span>=<span class="value">"password"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"loginUrl"</span> <span class="attribute">value</span>=<span class="value">"/login.jsp"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Shiro 的 Web 过滤器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"shiroFilter"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.spring.web.ShiroFilterFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"securityManager"</span> <span class="attribute">ref</span>=<span class="value">"securityManager"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"loginUrl"</span> <span class="attribute">value</span>=<span class="value">"/login.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"unauthorizedUrl"</span> <span class="attribute">value</span>=<span class="value">"/unauthorized.jsp"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"filters"</span>&gt;</span> <span class="comment">&lt;!-- 对应ini文件[filters] --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">util:map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"authc"</span> <span class="attribute">value-ref</span>=<span class="value">"formAuthenticationFilter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">util:map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"filterChainDefinitions"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">value</span>&gt;</span></span><br><span class="line">        /index.jsp = anon</span><br><span class="line">        /unauthorized.jsp = anon</span><br><span class="line">        /login.jsp = authc</span><br><span class="line">        /logout = logout</span><br><span class="line">        /** = user</span><br><span class="line">        <span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>还要在web.xml中添加shiro过滤器</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Shiro filter--&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">filter</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>  </span><br><span class="line">        org.springframework.web.filter.DelegatingFilterProxy  </span><br><span class="line">    <span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">filter</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>shiroFilter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>下面是上述配置所做的事情：</p>
<ol>
<li>EnvironmentLoaderListener 初始化一个Shiro WebEnvironment 实例（其中包含 Shiro 需要的一切操作，包括 SecurityManager ），使得它在 ServletContext 中能够被访问。如果你需要在任何时候获得WebEnvironment 实例，你可以调用WebUtils.getRequiredWebEnvironment（ServletContext）。</li>
<li>ShiroFilter 将使用此 WebEnvironment 对任何过滤的请求执行所有必要的安全操作。</li>
<li>最后，filter-mapping 的定义确保了所有的请求被 ShiroFilter 过滤，建议大多数 Web 应用程序使用以确保任何请求是安全的。</li>
</ol>
<p>通常为了shiro能够很好的工作，这个配置应该在其他过滤器之前</p>
<h3 id="Shiro_权限注解">Shiro 权限注解</h3><p>Shiro 提供了相应的注解用于权限控制，如果使用这些注解就需要使用 AOP 的功能来进行判断，如 Spring AOP；Shiro 提供了 Spring AOP 集成用于权限注解的解析和验证。为了测试，此处使用了 Spring MVC 来测试 Shiro 注解，当然 Shiro 注解不仅仅可以在 web 环境使用，在独立的 JavaSE 中也是可以用的</p>
<p>在spring-mvc.xml中添加权限注解的支持<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:config proxy-target-class=<span class="string">"true"</span>&gt;&lt;/aop:config&gt;</span><br><span class="line">&lt;bean class=<span class="string">"org.apache.shiro.spring.security.interceptor.AuthorizationAttributeSourceAdvisor"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"securityManager"</span> <span class="keyword">ref</span>=<span class="string">"securityManager"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="RememberMe">RememberMe</h3><p>spring-shiro-web.xml 配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"rememberMeCookie"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.servlet.SimpleCookie"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"rememberMe"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"httpOnly"</span> <span class="attribute">value</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxAge"</span> <span class="attribute">value</span>=<span class="value">"2592000"</span>/&gt;</span><span class="comment">&lt;!-- 30 天 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- rememberMe 管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"rememberMeManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.mgt.CookieRememberMeManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cipherKey"</span> <span class="attribute">value</span>=<span class="value">"#&#123;T(org.apache.shiro.codec.Base64).decode('4AvVhmFLUs0KTA3Kprsdag==')&#125;"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"cookie"</span> <span class="attribute">ref</span>=<span class="value">"rememberMeCookie"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 安全管理器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"securityManager"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.mgt.DefaultWebSecurityManager"</span>&gt;</span></span><br><span class="line">    ……</span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"rememberMeManager"</span> <span class="attribute">ref</span>=<span class="value">"rememberMeManager"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"formAuthenticationFilter"</span> <span class="attribute">class</span>=<span class="value">"org.apache.shiro.web.filter.authc.FormAuthenticationFilter"</span>&gt;</span></span><br><span class="line">    ……</span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"rememberMeParam"</span> <span class="attribute">value</span>=<span class="value">"rememberMe"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>rememberMe 管理器，cipherKey 是加密 rememberMe Cookie 的密钥；默认 AES 算法；设置 securityManager 安全管理器的 rememberMeManager；rememberMeParam，即 rememberMe 请求参数名，请求参数是 boolean 类型，true 表示 rememberMe。</p>
<p><code>/authenticated.jsp = authc</code> 表示访问该地址用户必须身份验证通过（ Subject.isAuthenticated()==true）；而<code>/** = user</code>表示访问该地址的用户是身份验证通过或 RememberMe 登录的都可以。</p>
]]></content>
    <summary type="html">
    <![CDATA[Shiro; Java安全框架; 认证、授权、加密和会话管理]]>
    
    </summary>
    
      <category term="Shiro" scheme="http://howiefh.github.io/tags/Shiro/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="Shiro" scheme="http://howiefh.github.io/categories/Java/Shiro/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FreeMarker-XML处理笔记]]></title>
    <link href="http://howiefh.github.io/2015/05/03/freemarker-XML-processing-note/"/>
    <id>http://howiefh.github.io/2015/05/03/freemarker-XML-processing-note/</id>
    <published>2015-05-03T01:20:51.000Z</published>
    <updated>2015-05-21T15:55:14.000Z</updated>
    <content type="html"><![CDATA[<h2 id="揭示XML文档">揭示XML文档</h2><p>test.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">book</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">title</span>&gt;</span>Test Book<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">chapter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">title</span>&gt;</span>Ch1<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">para</span>&gt;</span>p1.1<span class="tag">&lt;/<span class="title">para</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">para</span>&gt;</span>p1.2<span class="tag">&lt;/<span class="title">para</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">para</span>&gt;</span>p1.3<span class="tag">&lt;/<span class="title">para</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">chapter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">chapter</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">title</span>&gt;</span>Ch2<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">para</span>&gt;</span>p2.1<span class="tag">&lt;/<span class="title">para</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">para</span>&gt;</span>p2.2<span class="tag">&lt;/<span class="title">para</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">chapter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">book</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>根节点是“文档”而不是book</li>
<li>如果 B 是 A 的直接后继，我们说 B 节点是 A 节点的 child 子节点，A节点是B节点的parent父节点。</li>
<li>元素，文本，注释，处理指令都是DOM树的节点</li>
</ul>
<a id="more"></a>
<h3 id="将XML放到数据模型中">将XML放到数据模型中</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Map root = new HashMap<span class="params">()</span>;</span><br><span class="line">root.put<span class="params">(<span class="string">"doc"</span>, freemarker.ext.dom.NodeModel.parse<span class="params">(new File<span class="params">(<span class="string">"test.xml"</span>)</span>)</span>)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>parse 方法默认移除注释和处理指令节点。参见 API 文档获取详细信息。</li>
<li>NodeModel 也允许你直接包装 org.w3c.dom.Node。首先你也许想用静态的实用方法清空 DOM 树，比如 NodeModel.simplify 或你自定义的清空规则。</li>
</ul>
<h2 id="必要的XML处理">必要的XML处理</h2><h3 id="通过例子来学习">通过例子来学习</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>$&#123;doc.book.title&#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>尝试访问有子元素的元素将导致错误<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>$&#123;doc.book&#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>doc.book.chapter是存储两个元素节点的序列<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>$&#123;doc.book.chapter[0].title&#125;<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>$&#123;doc.book.chapter[1].title&#125;<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">doc.book.chapter</span> <span class="attribute">as</span> <span class="attribute">ch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">h2</span>&gt;</span>$&#123;ch.title&#125;<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>就算只有一个元素节点，也可以当做一个序列<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>$&#123;doc.book[0].title[0]&#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果 book 没有 chapter，那么book.chapter 就是一个空序列，所以 doc.book.chapter 就不会是 false，它就一直是 true！类似地，<code>&lt;#if doc.book.somethingTotallyNonsense??&gt;&lt;/#if&gt;</code>也不会是false。来检查是否有子节点，可以使用doc.book.chapter[0]??（或doc.book.chapter?size == 0）。当然你可以使用类似所有的控制处理操作符（比如 doc.book.author[0]!”Anonymous”），只是不要忘了那个[0]。</p>
<p>一个完整示例<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#assign</span> <span class="attribute">book</span> = <span class="attribute">doc.book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>$&#123;book.title&#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">book.chapter</span> <span class="attribute">as</span> <span class="attribute">ch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">h2</span>&gt;</span>$&#123;ch.title&#125;<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">#list</span> <span class="attribute">ch.para</span> <span class="attribute">as</span> <span class="attribute">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span>&gt;</span>$&#123;p&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>得到所有的para<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> doc.book.chapter.para <span class="keyword">as</span> p&gt;</span><br><span class="line">&lt;p&gt;<span class="label">$&#123;p&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="访问属性">访问属性</h3><p>如果test.xml中title是属性而不是元素，只需在其前加@即可。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#assign</span> <span class="attribute">book</span> = <span class="attribute">doc.book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>$&#123;book.@title&#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">book.chapter</span> <span class="attribute">as</span> <span class="attribute">ch</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">h2</span>&gt;</span>$&#123;ch.@title&#125;<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">#list</span> <span class="attribute">ch.para</span> <span class="attribute">as</span> <span class="attribute">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">p</span>&gt;</span>$&#123;p&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果你很好奇是否 foo 含有属性 bar，那么你不得不写 foo.@bar[0]??来验证。（ foo.@bar??是不对的，因为它总是返回 true）。类似地，如果你想要一个bar属性的默认值，那么你就不得不写 foo.@bar[0]!”theDefaultValue”。</p>
<h3 id="探索DOM">探索DOM</h3><p>枚举所有book的子元素<br><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="symbol">#list</span> doc.book?children as c&gt;</span><br><span class="line">- <span class="char">$&#123;</span>c?node_type&#125; &lt;<span class="symbol">#if</span> c?node_type = <span class="string">'element'</span>&gt;<span class="char">$&#123;</span>c?node_name&#125;&lt;/<span class="symbol">#if</span>&gt;</span><br><span class="line">&lt;/<span class="symbol">#list</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>children：子元素序列<br>node_type：节点类型，”element”， “text”， “comment”， “pi”<br>node_name：节点名称</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;book <span class="variable">foo=</span><span class="string">"Foo"</span> <span class="variable">bar=</span><span class="string">"Bar"</span> <span class="variable">baaz=</span><span class="string">"Baaz"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以通过元素的自变量@@获取元素的属性序列</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> doc.book.@@ <span class="keyword">as</span> attr&gt;</span><br><span class="line">- <span class="label">$&#123;attr</span>?node_name&#125; = <span class="label">$&#123;attr&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure>
<p>返回元素的子节点序列可以用*</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> doc.book.* <span class="keyword">as</span> c&gt;</span><br><span class="line">- <span class="label">$&#123;c</span>?node_name&#125;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可以使用内建函数 parent 来获得元素的父节点。你可以使用内建函数 root 来快速返回到文档节点<br><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="comment">#assign e = doc.book.chapter[0].para[0]&gt;</span></span><br><span class="line">$&#123;e?node_name&#125;</span><br><span class="line">$&#123;e?<span class="keyword">parent</span>?node_name&#125;</span><br><span class="line">$&#123;e?<span class="keyword">parent</span>?<span class="keyword">parent</span>?node_name&#125;</span><br><span class="line">$&#123;e?<span class="keyword">parent</span>?<span class="keyword">parent</span>?<span class="keyword">parent</span>?node_name&#125;</span><br><span class="line">$&#123;e?root?node_name&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用XPath表达式">使用XPath表达式</h3><p>XPath 表达式仅在 Jaxen（推荐使用，但是使用至少 Jaxen 1.1-beta-8 版本，不能再老了） 或 Apache Xalan 库可用时有效。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">doc</span>["<span class="attribute">book</span>/<span class="attribute">chapter</span>[<span class="attribute">title</span>=<span class="value">'Ch1'</span><span class="value">]</span>/<span class="attribute">para</span>"] <span class="attribute">as</span> <span class="attribute">p</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">p</span>&gt;</span></span>$&#123;p&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span></span><br><span class="line">$&#123;doc[<span class="link_label">"book/chapter[title='Ch1'</span>]/para[<span class="link_label">1</span>]"][0]&#125;</span><br><span class="line">$&#123;doc.book["chapter[title='Ch1']/para[1]"]&#125;</span><br></pre></td></tr></table></figure>
<p>注意 XPath 序列的项索引从 1 开始，而 FTL 的序列项索引是用 0 开始的。</p>
<p>如果使用 Jaxen 而不是 Xalan，那么 FreeMarker 的变量在使用 XPath 变量引用时是可见的<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="id">#assign</span> currentTitle = <span class="string">"Ch1"</span>&gt;</span><br><span class="line">&lt;<span class="id">#list</span> doc[<span class="string">"book/chapter[title=$currentTitle]/para"</span>] as p&gt;</span><br></pre></td></tr></table></figure></p>
<p>注意$currentTitle 不是 FreeMarker 的插值，因为那里没有{和}。那是 XPath 表达式。</p>
<p>一些 XPath 表达式的结果不是节点集，而是字符串，数字或者布尔值。获取para元素的总数<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;</span>x[<span class="string">"count(//para)"</span>]&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="XML命名空间">XML命名空间</h3><p>如果元素book是命名空间 <a href="http://example.com/ebook，那么你不得不关联一个前缀，要在模板的顶部使用" target="_blank" rel="external">http://example.com/ebook，那么你不得不关联一个前缀，要在模板的顶部使用</a> ftl 指令的 the ns_prefixes 参数：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">#ftl ns_prefixes=&#123;</span></span><br><span class="line"><span class="string">"e"</span>:<span class="string">"http://example.com/ebook"</span>,</span><br><span class="line"><span class="string">"f"</span>:<span class="string">"http://example.com/form"</span>,</span><br><span class="line"><span class="string">"vg"</span>:<span class="string">"http://example.com/vectorGraphics"</span>&#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
<p>现在你可以编写如 doc[“e:book”]的表达式。使用保留前缀D可以设置默认命名空间。XPath不支持默认命名空间</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">#ftl</span> <span class="attribute">ns_prefixes</span>=</span></span><span class="expression">&#123;<span class="string">"D"</span>:<span class="string">"http://example.com/ebook"</span>&#125;</span><span class="xml"><span class="tag">&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>注意当你使用默认命名空间时，那么你可以使用保留前缀 N 来选择不属于任意节点空间的元素。比如 doc.book[“N:foo”]。这对 XPath 表达式不起作用</p>
<h3 id="转义">转义</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#escape</span> <span class="attribute">x</span> <span class="attribute">as</span> <span class="attribute">x</span>?<span class="attribute">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#assign</span> <span class="attribute">book</span> = <span class="attribute">doc.book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span>$&#123;book.title&#125;<span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">book.chapter</span> <span class="attribute">as</span> <span class="attribute">ch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>$&#123;ch.title&#125;<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">ch.para</span> <span class="attribute">as</span> <span class="attribute">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>$&#123;p&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#escape</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="声明的XML处理">声明的XML处理</h2><p>最经常使用来处理声明方式的指令就是 recurse 指令，这个指令获取节点变量，并把它作为是参数，从第一个子元素开始，一个接一个地“访问”所有它的子元素。“访问”一个节点意味着它调用了用户自定义的指令（比如宏），它的名字和子节点（ ?node_name）的名字相同。我们这么说，用户自定义指令操作节点。使用用户自定义指令处理的节点作为特殊变量.node 是可用的。</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="comment">#recurse doc&gt;</span></span><br><span class="line">&lt;<span class="comment">#macro book&gt;</span></span><br><span class="line">    Book <span class="keyword">element</span> <span class="operator">with</span> title $&#123;.node.title&#125;</span><br><span class="line">    &lt;<span class="comment">#recurse&gt;</span></span><br><span class="line">    End book</span><br><span class="line">&lt;/<span class="comment">#macro&gt;</span></span><br><span class="line">&lt;<span class="comment">#macro title&gt;</span></span><br><span class="line">    Title <span class="keyword">element</span></span><br><span class="line">&lt;/<span class="comment">#macro&gt;</span></span><br><span class="line">&lt;<span class="comment">#macro chapter&gt;</span></span><br><span class="line">    Chapter <span class="keyword">element</span> <span class="operator">with</span> title: $&#123;.node.title&#125;</span><br><span class="line">&lt;/<span class="comment">#macro&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果你调用 recurse 而不用参数，那么它使用.node，也就是说，它访问现在处理这个节点的所有子节点。</p>
<p>所有文本节点的节点名字都是@text。转义HTML<br><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">macro</span> <span class="keyword">@text</span>&gt;$&#123;.node?html&#125;&lt;/#<span class="keyword">macro</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="默认处理器">默认处理器</h3><ul>
<li>文本节点： 打印其中的文本。要注意，在很多应用程序中，这对你来说并不好，因为你应该在你发送它们到输出（使用?html 或?xml 或?rtf 等，这基于输出的格式）前转义这些文本。</li>
<li>处理指令节点： 如果你定义了自定义指令，可以通过调用处理器调用@pi，否则将什么都不做（忽略这些节点）。</li>
<li>注释节点，文档类型节点：什么都不做（忽略这些节点）。</li>
<li>文档节点：调用 recurse，也就是说，访问文档节点的所有子节点。</li>
</ul>
<p>元素节点的情形，这意味着如果你定义了一个称为@element 的宏（或其他种类的用户自定义指令），没有其他特定的处理器时，那么它会捕捉所有元素节点。如果你没有@element 处理器，那么你必须为所有可能的元素定义处理器。</p>
<p>属性节点在 recurse 指令中不可见，所以不需要为它们编写处理器。</p>
<h3 id="访问单独节点">访问单独节点</h3><p>使用visit指令你可以访问单独的节点</p>
<h3 id="XML_命名空间">XML 命名空间</h3><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">book </span>xmlns=<span class="string">"http://example.com/ebook"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>考虑命名空间</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">#ftl</span> <span class="attribute">ns_prefixes</span>=</span></span><span class="expression">&#123;<span class="string">"e"</span>:<span class="string">"http://example.com/ebook"</span>&#125;</span><span class="xml"><span class="tag">&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#recurse</span> <span class="attribute">doc</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#macro</span> "<span class="attribute">e:book</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">title</span>&gt;</span><span class="tag">&lt;<span class="title">#recurse</span> <span class="attribute">.node</span>["<span class="attribute">e:title</span>"]&gt;</span><span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h1</span>&gt;</span><span class="tag">&lt;<span class="title">#recurse</span> <span class="attribute">.node</span>["<span class="attribute">e:title</span>"]&gt;</span><span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#recurse</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#macro</span> "<span class="attribute">e:chapter</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span><span class="tag">&lt;<span class="title">#recurse</span> <span class="attribute">.node</span>["<span class="attribute">e:title</span>"]&gt;</span><span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#recurse</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#macro</span> "<span class="attribute">e:para</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span><span class="tag">&lt;<span class="title">#recurse</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#macro</span> "<span class="attribute">e:title</span>"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#--</span></span><br><span class="line"><span class="attribute">We</span> <span class="attribute">have</span> <span class="attribute">handled</span> <span class="attribute">this</span> <span class="attribute">element</span> <span class="attribute">imperatively</span>,</span><br><span class="line"><span class="attribute">so</span> <span class="attribute">we</span> <span class="attribute">do</span> <span class="attribute">nothing</span> <span class="attribute">here.</span></span><br><span class="line"><span class="attribute">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#macro</span> @<span class="attribute">text</span>&gt;</span>$</span><span class="expression">&#123;<span class="variable">.node</span>?<span class="variable">html</span>&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>设置为默认命名空间</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="subst">&lt;</span><span class="variable">#ftl</span> ns_prefixes<span class="subst">=</span>&#123;<span class="string">"D"</span>:<span class="string">"http://example.com/ebook"</span>&#125;<span class="subst">&gt;</span></span><br><span class="line"><span class="subst">&lt;</span><span class="variable">#recurse</span> doc<span class="subst">&gt;</span></span><br><span class="line"><span class="subst">&lt;</span><span class="variable">#macro</span> book<span class="subst">&gt;</span></span><br><span class="line"><span class="attribute">...</span></span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[FreeMarker;Java模板引擎;XML处理]]>
    
    </summary>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/tags/FreeMarker/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/categories/Java/FreeMarker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FreeMarker-程序开发指南笔记]]></title>
    <link href="http://howiefh.github.io/2015/05/02/freemarker-program-development-note/"/>
    <id>http://howiefh.github.io/2015/05/02/freemarker-program-development-note/</id>
    <published>2015-05-02T01:20:06.000Z</published>
    <updated>2015-05-21T15:54:02.000Z</updated>
    <content type="html"><![CDATA[<h2 id="快速入门">快速入门</h2><ul>
<li>使用 java.lang.String 来构建字符串。</li>
<li>使用 java.lang.Number 来派生数字类型。</li>
<li>使用 java.lang.Boolean 来构建布尔值。</li>
<li>使用 java.util.List 或 Java 数组来构建序列。</li>
<li>使用 java.util.Map 来构建哈希表。</li>
<li>使用你自己定义的 bean 类来构建哈希表， bean 中的项和 bean 的属性对应。例如product 中的 price 属性可以用 product.price 来获取。</li>
</ul>
<a id="more"></a>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> freemarker.<span class="keyword">template</span>.*;</span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> TestFTLDemo &#123;</span><br><span class="line">	<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main(String[] args) throws Exception &#123;</span><br><span class="line">		<span class="comment">/* 在整个应用的生命周期中，这个工作你应该只做一次。 */</span></span><br><span class="line">		<span class="comment">/* 创建和调整配置。 */</span></span><br><span class="line">		Configuration cfg = <span class="keyword">new</span> Configuration();</span><br><span class="line">		cfg.setDirectoryForTemplateLoading(<span class="keyword">new</span> File(</span><br><span class="line">				<span class="string">"/where/you/store/templates"</span>));</span><br><span class="line">		cfg.setObjectWrapper(<span class="keyword">new</span> DefaultObjectWrapper());</span><br><span class="line">		<span class="comment">/* 在整个应用的生命周期中，这个工作你可以执行多次 */</span></span><br><span class="line">		<span class="comment">/* 获取或创建模板 */</span></span><br><span class="line">		Template temp = cfg.getTemplate(<span class="string">"test.ftl"</span>);</span><br><span class="line">		<span class="comment">/* 创建数据模型 */</span></span><br><span class="line">		Map root = <span class="keyword">new</span> HashMap();</span><br><span class="line">		root.put(<span class="string">"user"</span>, <span class="string">"Big Joe"</span>);</span><br><span class="line">		Map latest = <span class="keyword">new</span> HashMap();</span><br><span class="line">		root.put(<span class="string">"latestProduct"</span>, latest);</span><br><span class="line">		latest.put(<span class="string">"url"</span>, <span class="string">"products/greenmouse.html"</span>);</span><br><span class="line">		latest.put(<span class="string">"name"</span>, <span class="string">"green mouse"</span>);</span><br><span class="line">		<span class="comment">/* 将模板和数据模型合并 */</span></span><br><span class="line">		Writer <span class="keyword">out</span> = <span class="keyword">new</span> OutputStreamWriter(System.<span class="keyword">out</span>);</span><br><span class="line">		temp.process(root, <span class="keyword">out</span>);</span><br><span class="line">		<span class="keyword">out</span>.flush();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="数据模型">数据模型</h2><p>在内部，模板中可用的变量都是实现了freemarker.template.TemplateModel 接口的 Java 对象。但在你自己的数据模型中，可以使用基本的 Java 集合类作为变量， 因为这些变量会在内部被替换为适当的TemplateModel 类型。这种功能特性被称作是 object wrapping 对象包装。对象包装功能可以透明地把任何类型的对象转换为实现了 TemplateModel 接口类型的实例。要注意一个类可以实现多个TemplateModel 接口，这就是为什么 FTL 变量可以有多种类型</p>
<h3 id="标量">标量</h3><p>布尔值、数字、字符串、日期这四种标量每一种标量类型都是 TemplateTypeModel 接口的实现，这里的 Type 就是类型的名称（比如Boolean,Number,Scalar,Date）。 这些接口只定义了一个方法 type getAsType()；它返回变量的 Java 类型（boolean，Number， String 和 Date 各自代表的值）的值。这些接口的有一个实现类SimpleType 类。但是没有 SimpleBooleanModel 类型；为了代表布尔值，可以使用TemplateBooleanModel.TRUE 和 TemplateBooleanModel.FALSE 来单独使用。</p>
<p>Date有个问题，就是模板不知道它是date还是time还是datetime。TemplateDateModel 接口有两个方法：分别是java.util.Date getAsDate() 和int getDateType()。这个接口典型的实现是存储一个 java.util.Date 对象，加上一个整数来辨别“数据库存储的类型”。这个整数的值也必须是 TemplateDateModel 接口中的常量之一：DATE，TIME，DATETIME和UNKNOWN。通过内建函数date、time、datetime和string可以解决这个问题。</p>
<h3 id="容器">容器</h3><h4 id="哈希表">哈希表</h4><p>哈希表是实现了 TemplateHashModel 接口的 Java 对象。TemplateHashModel 接口有两个方法：TemplateModel get(String key)，boolean isEmpty()。</p>
<p>TemplateHashModelEx 接口扩展了 TemplateHashModel 接口。它增加了更多的方法，使得可以使用内建函数 values 和 keys 来枚举哈希表中的子变量。经常使用的实现类是 SimpleHash，该类实现了 TemplateHashModelEx 接口。 </p>
<h4 id="序列">序列</h4><p>序列是实现了 TemplateSequenceModel 接口的 Java 对象。它包含两个方法：TemplateModel get(int index)和 int size()。</p>
<p>经常使用的实现类是 SimpleSequence， 该类内部使用一个 java.util.List 类型的对象存储它的子变量。</p>
<h4 id="集合">集合</h4><p>集合是实现了 TemplateCollectionModel 接口的 Java 对象。这个接口只定义了一个方法：TemplateModelIterator iterator() 。TemplateModelIterator 接口和 java.util.Iterator 相似，但是它返回 TemplateModels 而不是Object，而且它能抛出TemplateModelException 异常。通常使用的实现类是 SimpleCollection。</p>
<h3 id="方法">方法</h3><p>方法变量在存于实现了 TemplateMethodModel 接口的模板中。这个接口仅包含一个方法： TemplateModel exec(java.util.List arguments)。当使用方法调用表达式调用方法时，exec 方法将会被调用。形参将会包含 FTL方法调用形参的值。exec 方法的返回值给出了 FTL 方法调用表达式的返回值。TemplateMethodModelEx 接口扩展了 TemplateMethodModel 接口。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IndexOfMethod</span> <span class="keyword">implements</span> <span class="title">TemplateMethodModel</span> </span>&#123;</span><br><span class="line">	public TemplateModel exec(<span class="built_in">List</span> args) throws TemplateModelException &#123;</span><br><span class="line">		<span class="keyword">if</span> (args.size() != <span class="number">2</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TemplateModelException(<span class="string">"Wrong arguments"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> SimpleNumber(((<span class="built_in">String</span>) args.<span class="literal">get</span>(<span class="number">1</span>)).indexOf((<span class="built_in">String</span>) args.<span class="literal">get</span>(<span class="number">0</span>)));</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">root.put(<span class="string">"indexOf"</span>, <span class="keyword">new</span> IndexOfMethod());</span><br></pre></td></tr></table></figure>
<p>在模板中调用<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">#</span><span class="built_in">assign</span> x = <span class="string">"something"</span>&gt;</span><br><span class="line">$&#123;indexOf<span class="params">(<span class="string">"met"</span>, x)</span>&#125;</span><br><span class="line">$&#123;indexOf<span class="params">(<span class="string">"foo"</span>, x)</span>&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="指令">指令</h3><p>可以使用 TemplateDirectiveModel 接口在 Java 代码中实现自定义指令。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * FreeMarker 的用户自定义指令在逐步改变 它嵌套内容的输出转换为大写形式</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * &lt;b&gt;指令内容&lt;/b&gt;</span><br><span class="line"> * &lt;/p&gt;</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 指令参数：无</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 循环变量：无</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 指令嵌套内容：是</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title">UpperDirective</span> <span class="title">implements</span> <span class="title">TemplateDirectiveModel</span> &#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span>(<span class="params">Environment env, Map <span class="keyword">params</span>, TemplateModel[] loopVars,</span><br><span class="line">			TemplateDirectiveBody body</span>) throws TemplateException, IOException </span>&#123;</span><br><span class="line">		<span class="comment">// 检查参数是否传入</span></span><br><span class="line">		<span class="keyword">if</span> (!<span class="keyword">params</span>.isEmpty()) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TemplateModelException(<span class="string">"This directive doesn't allow parameters."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (loopVars.length != <span class="number">0</span>) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TemplateModelException(<span class="string">"This directive doesn't allow loop variables."</span>);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 是否有非空的嵌入内容</span></span><br><span class="line">		<span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 执行嵌入体部分，和 FTL 中的&lt;#nested&gt;一样，除了</span></span><br><span class="line">			<span class="comment">// 我们使用我们自己的 writer 来代替当前的 output writer.</span></span><br><span class="line">			body.render(<span class="keyword">new</span> UpperCaseFilterWriter(env.getOut()));</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"missing body"</span>);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span><br><span class="line">	 * &#123;@link Writer&#125;改变字符流到大写形式， 而且把它发送到另外一个&#123;@link Writer&#125;中。</span><br><span class="line">	 */</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">class</span> <span class="title">UpperCaseFilterWriter</span> <span class="title">extends</span> <span class="title">Writer</span> &#123;</span><br><span class="line">		<span class="keyword">private</span> final Writer <span class="keyword">out</span>;</span><br><span class="line">		UpperCaseFilterWriter(Writer <span class="keyword">out</span>) &#123;</span><br><span class="line">			<span class="keyword">this</span>.<span class="keyword">out</span> = <span class="keyword">out</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span>(<span class="params"><span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len</span>) throws IOException </span>&#123;</span><br><span class="line">			<span class="keyword">char</span>[] transformedCbuf = <span class="keyword">new</span> <span class="keyword">char</span>[len];</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">				transformedCbuf[i] = Character.toUpperCase(cbuf[i + off]);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">out</span>.write(transformedCbuf);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span>(<span class="params"></span>) throws IOException </span>&#123;</span><br><span class="line">			<span class="keyword">out</span>.flush();</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span>(<span class="params"></span>) throws IOException </span>&#123;</span><br><span class="line">			<span class="keyword">out</span>.close();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">root.put(<span class="string">"upper"</span>, <span class="keyword">new</span> UpperDirective());</span><br></pre></td></tr></table></figure>
<p>然后在模板中使用<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[@<span class="atom">upper</span>]</span><br><span class="line"><span class="atom">hello</span> <span class="atom">world</span>!</span><br><span class="line">[#<span class="atom">list</span> [<span class="string">"red"</span>,<span class="string">"blue"</span>,<span class="string">"white"</span>,<span class="string">"black"</span>] <span class="atom">as</span> <span class="atom">color</span>]</span><br><span class="line">$&#123;<span class="atom">color</span>&#125;</span><br><span class="line">[/#<span class="atom">list</span>]</span><br><span class="line">[/@<span class="atom">upper</span>]</span><br></pre></td></tr></table></figure></p>
<h3 id="节点">节点</h3><p>节点变量有下列属性， 它们都由 TemplateNodeModel 接口的方法提供。</p>
<ul>
<li>基本属性：<ul>
<li>TemplateSequenceModel getChildNodes()：一个节点的子节点序列（除非这个节点是叶子节点，这时方法返回一个空序列或者是 null）。子节点本身应该也是节点变量。</li>
<li>TemplateNodeModel getParentNode()：一个节点只有一个父节点（除非这个节点是节点树的根节点，这时方法返回 null）。</li>
</ul>
</li>
<li>可选属性。如果一个属性在具体的使用中没有意义，那对应的方法应该返回 null：<ul>
<li>String getNodeName()：节点名称也是宏的名称，当使用 recurse和 visit 指令时，它用来控制节点。因此， 如果想通过节点使用这些指令，那么节点的名称是必须的。</li>
<li>String getNodeType()：在 XML 技术中： “element”， “text”，”comment”等类型。 如果这些信息可用，就是通过 recurse 和 visit 指令来查找节点的默认处理宏。而且，它对其他有具体用途的应用程序也是有用的。</li>
<li>String getNamespaceURI()：这个节点所属的命名空间（和用于库的 FTL 命名空间无关）。例如，在 XML 中，这就是元素和属性所属 XML 命名空间的 URI。 这个信息如果可用，就是通过 recurse 和 visit 指令来查找存储控制宏的 FTL 命名空间。</li>
</ul>
</li>
</ul>
<p>在 FTL 这里，节点属性的直接使用可以通过内建函数 node 完成， 还有 visit 和 recurse 宏。</p>
<h3 id="对象包装">对象包装</h3><p>Template.process()可以接收任何Java对象，不一定是TemplateModel，因为末班实现是会用合适的TemplateModel对象来替换原有对象。替换在获取自变量时必须会发生，因为getter方法返回TemplateModel，而不是Object。</p>
<p>替换策略通过ObjectWrapper实现，</p>
<ul>
<li>ObjectWrapper.DEFAULT_WRAPPER：它使用 SimpleScalar 来替换String， SimpleNumber 来替换 Number， SimpleSequence 来替换 List和数组，SimpleHash 来替换Map，TemplateBooleanModel.TRUE 或 TemplateBooleanModel.FALSE 来替换 Boolean，freemarker.ext.dom.NodeModel 来替换 W3C 组织定义的 DOM 模型节点类型。对于Jython 类型的对象，包装器会调用 freemarker.ext.jython.JythonWrapper。而对于其他对象，则会调用 BEAN_WRAPPER。</li>
<li>ObjectWrapper.BEANS_WRAPPER：它可以通过 Java 的反射机制来获取到Java Bean 的属性和其他任意对象类型的成员变量。</li>
</ul>
<p>如果在数据模型中放了任意的对象，那么DEFAULT_WRAPPER 就会调用BEANS_WRAPPER 来包装这个对象</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.put(<span class="string">"person"</span>, new <span class="keyword">Person</span>(1, <span class="string">"Jack"</span>));</span><br></pre></td></tr></table></figure>
<p>Person类有两个字段id和name。这里Person类必须是public的，而且字段需要提供getter方法。如果还有公开方法，那么公开方法名不能和字段名相同。否则会抛出异常。</p>
<h2 id="配置">配置</h2><p>配置对象是freemarker.template.Configuration 的实例，可以通过构造方法来创建它。一个应用程序通常只使用一个共享的 Configuration 实例。</p>
<h3 id="共享变量">共享变量</h3><p>Shared variables 共享变量是为所有模板所定义的变量。可以使用setSharedVariable 方法向配置实例中添加共享变量。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cfg.setSharedVariable<span class="params">(<span class="string">"wrap"</span>, new WrapDirective<span class="params">()</span>)</span>;</span><br><span class="line">cfg.setSharedVariable<span class="params">(<span class="string">"company"</span>, <span class="string">"Foo Inc."</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>如果配置对象在多线程环境中使用，不要使用 TemplateModel 实现类来作为共享变量，因为它是线程不安全的。这也是基于 Servlet 的 Web 站点的典型情况。</p>
<h3 id="配置信息">配置信息</h3><p>Settings 配置信息是影响 FreeMarker 行为的已经被命名的值。</p>
<p>Environment中能覆盖Template中的配置信息，Template中能覆盖Configuration中的配置信息。</p>
<p>Configuration可以通过setter方法或setSetting方法设置配置信息。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">myCfg.setLocale<span class="params">(java.util.Locale.ITALY)</span>;</span><br><span class="line">myCfg.setNumberFormat<span class="params">(<span class="string">"0.####"</span>)</span>;</span><br><span class="line">myCfg.setSetting<span class="params">(<span class="string">"locale"</span>,<span class="string">"it_IT"</span>)</span>;</span><br><span class="line">myCfg.setSetting<span class="params">(<span class="string">"number_format"</span>,<span class="string">"0.####"</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>Template层不需要设置配置信息。</p>
<p>Environment层这里有两种设置方法</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Environment <span class="keyword">env</span> =</span><br><span class="line">myTemplate.createProcessingEnvironment(root, out);</span><br><span class="line"><span class="keyword">env</span>.setLocale(java.util.Locale.ITALY);</span><br><span class="line"><span class="keyword">env</span>.setNumberFormat(<span class="string">"0.####"</span>);</span><br><span class="line"><span class="keyword">env</span>.process(); <span class="comment">// 处理模板</span></span><br></pre></td></tr></table></figure>
<p>或在模板中直接使用指令<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="id">#setting</span> locale=<span class="string">"it_IT"</span>&gt;</span><br><span class="line">&lt;<span class="id">#setting</span> number_format=<span class="string">"0.####"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="模板加载">模板加载</h3><h4 id="内建模板加载器">内建模板加载器</h4><p>在 Configuration 中可以使用下面的方法来方便建立三种模板加载。（每种方法都会在其内部新建一个模板加载器对象，然后创建 Configuration 实例来使用它。）</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setDirectoryForTemplateLoading</span><span class="params">(File dir)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setClassForTemplateLoading</span><span class="params">(Class cl, String prefix)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setServletContextForTemplateLoading</span><span class="params">(Object servletContext, String path)</span></span>;</span><br></pre></td></tr></table></figure>
<p>上述的第一种方法在磁盘的文件系统上设置了一个明确的目录，它确定了从哪里加载模板。</p>
<p>第二种调用方法使用了一个 Class 类型的参数和一个前缀。这是让你来指定什么时候通过相同的机制来加载模板，不过是用 Java 的 ClassLoader 来加载类。 这就意味着传入的 Class 参数会被用来调用 Class.getResource()方法来找到模板。参数 prefix是给模板的名称来加前缀的。在实际运行的环境中，类加载机制是首选用来加载模板的方法，因为通常情况下，从类路径下加载文件的这种机制， 要比从文件系统的特定目录位置加载安全而且简单。 在最终的应用程序中，所有代码都使用.jar 文件打包也是不错的，这样用户就可以直接执行包含所有资源的.jar 文件了。</p>
<p>第三种调用方式需要 Web 应用的上下文和一个基路径作为参数，这个基路径是 Web 应用根路径（ WEB-INF 目录的上级目录）的相对路径。那么加载器将会从 Web 应用目录开始加载模板。尽管加载方法对没有打包的.war 文件起作用，因为它使用了ServletContext.getResource()方法来访问模板，注意这里我们指的是“目录”。</p>
<h4 id="从多个位置加载">从多个位置加载</h4><p>如果需要从多个位置加载模板，那就不得不为每个位置都实例化模板加载器对象，将它们包装到一个被成为 MultiTemplateLoader 的特殊模板加载器</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">FileTemplateLoader</span> ftl1 = <span class="keyword">new</span> <span class="type">FileTemplateLoader</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"/tmp/templates"</span>));</span><br><span class="line"><span class="type">FileTemplateLoader</span> ftl2 = <span class="keyword">new</span> <span class="type">FileTemplateLoader</span>(<span class="keyword">new</span> <span class="type">File</span>(<span class="string">"/usr/data/templates"</span>));</span><br><span class="line"><span class="type">ClassTemplateLoader</span> ctl = <span class="keyword">new</span> <span class="type">ClassTemplateLoader</span>(getClass<span class="literal">()</span>, <span class="string">""</span>);</span><br><span class="line"><span class="type">TemplateLoader</span><span class="literal">[]</span> loaders = <span class="keyword">new</span> <span class="type">TemplateLoader</span><span class="literal">[]</span> &#123; ftl1, ftl2, ctl &#125;;</span><br><span class="line"><span class="type">MultiTemplateLoader</span> mtl = <span class="keyword">new</span> <span class="type">MultiTemplateLoader</span>(loaders);</span><br><span class="line">cfg.setTemplateLoader(mtl);</span><br></pre></td></tr></table></figure>
<p>FreeMarker 将会尝试从/tmp/templates 目录加载模板，如果在这个目录下没有发现请求的模板，它就会继续尝试从/usr/data/templates 目录下加载，如果还是没有发现请求的模板，那么它就会使用类加载器来加载模板。</p>
<h4 id="从其他资源加载模板">从其他资源加载模板</h4><p>需要自己实现加载器实现freemarker.cache.TemplateLoader 或freemarker.cache.URLTemplateLoader 接口</p>
<h4 id="模板路径">模板路径</h4><p>强烈建议模板加载器使用 URL 风格的路径</p>
<h3 id="模板缓存">模板缓存</h3><p>FreeMarker 是会缓存模板的（假设使用 Configuration 对象的方法来创建 Template 对象）。这就是说当调用 getTemplate 方法时， FreeMarker 不但返回了Template 对象的结果，而且还会将它存储在缓存中，当下一次再以相同（或相等）路径调用 getTemplate 方法时，那么它只返回缓存的 Template 实例， 而不会再次加载和解析模板文件了。</p>
<p>如果更改了模板文件，当下次调用模板时， FreeMarker 将会自动重新载入和解析模板。然而，要检查模板文件是否改变内容了是需要时间的，有一个 Configuration 级别的设置被称作为“更新延迟”可以用来配置这个时间。这个时间就是从上次对某个模板检查更新后， FreeMarker 再次检查模板所要间隔的时间。 其默认值是 5 秒。如果想要看到模板立即更新的效果，那么就要把它设置为 0。要注意某些模板加载器也许在模板更新时可能会有问题。例如，典型的例子就是在基于类加载器的模板加载器就不会注意到模板文件内容的改变。</p>
<p>当调用了 getTemplate 方法时，与此同时 FreeMarker 意识到这个模板文件已经被<br>移除了，所以这个模板也会从缓存中移除。 如果 Java 虚拟机认为会有内存溢出时，默认情况它会将任意的模板从缓存中移除。此外，你还可以使用 Configuration 对象的clearTemplateCache 方法手动清空缓存。</p>
<p>何时将一个被缓存了的模板清除的实际应用策略是由配置的属性 cache_storage来确定的，通过这个属性可以配置任何 CacheStorage 的实现。对于大多数用户来说，使用 freemarker.cache.MruCacheStorage 就足够了。这个缓存存储实现了二级最近使用的缓存。在第一级缓存中，组件都被强烈引用到特定的最大数目（引用次数最多的组件不会被 Java 虚拟机抛弃，而引用次数很少的组件则相反）。当超过最大数量时，最近最少使用的组件将被送至二级缓存中，在那里它们被很少引用，直到达到另一个最大的数目。引用强度的大小可以由构造方法来指定。例如，设置强烈部分为 20，轻微部分为 250：</p>
<p>或者，使用 MruCacheStorage 缓存，它是默认的缓存存储实现。当创建了一个新的 Configuration 对象时，它使用一个 maxStrongSize 值为0 的 MruCacheStorage 缓存来初始化，maxSoftSize 的值是Integer.MAX_VALUE（也就是说在实际中，是无限大 的）。 但是使用非 0 的 maxStrongSize 对于高负载的服务器来说也许是一个更好的策略，对于少量引用的组件来说，如果资源消耗已经很高的话， Java 虚拟机往往会引发更高的资源消耗，因为它不断从缓存中抛出经常使用的模板，这些模板还不得不再次加载和解析。</p>
<h3 id="错误控制">错误控制</h3><h4 id="可能的异常">可能的异常</h4><p>当加载和解析模板时发生异常： 调用了 Configuration.getTemplate(…) 方法， FreeMarker 就要把模板文件加载到内存中然后来解析它（除非模板已经在Configuration 对象中被缓存了）。 在这期间，有两种异常可能发生：</p>
<ul>
<li>因模板文件没有找到而发生的 IOException 异常，或在读取文件时发生其他的 I/O 问题。比如没有读取文件的权限，或者是磁盘错误。这些错误的发出者是TemplateLoader 对象，可以将它设置到 Configuration 对象中。（为了正确起见：这里所说的”文件”，是简化形式。例如，模板也可以存储在关系型数据库的表中。这是 TemplateLoader 所要做的事。）</li>
<li>根据FTL语言的规则，模板文件发生语法错误时会导致 freemarker.core.ParseException 异常。当获得 Template 对象（ Configuration.getTemplate(…)）时，这种错误就会发生，而不是当执行（Template.process(…) ）模板的时候。这种异常是IOException 异常的一个子类。</li>
</ul>
<p>当执行（处理）模板时发生的异常，也就是当调用了 Template.process(…)方法时会发生的两种异常：</p>
<ul>
<li>当试图写入输出对象时发生错误而导致的 IOException 异常。</li>
<li>当执行模板时发生的其它问题而导致的freemarker.template.TemplatException 异常。比如，一个频繁发生的错误，就是当模板引用一个不存在的变量。默认情况下，当TemplatException 异常发生时， FreeMarker 会用普通文本格式在输出中打印出 FTL 的错误信息和堆栈跟踪信息。然后通过再次抛出 TemplatException异常而中止模板的执行，然后就可以捕捉到 Template.process(…)方法抛出的异常了。而这种行为是可以来定制的。FreeMarker也会经常写 TemplatException 异常的日志。</li>
</ul>
<h4 id="根据_TemplateException_来制定处理方式">根据 TemplateException 来制定处理方式</h4><p>Configuration中通过setTemplateExceptionHandler可以制定处理方式</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTemplateExceptionHandler</span> <span class="keyword">implements</span> <span class="title">TemplateExceptionHandler</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleTemplateException</span><span class="params">(TemplateException te, Environment env,</span><br><span class="line">			java.io.Writer out)</span> <span class="keyword">throws</span> TemplateException </span>&#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			out.write(<span class="string">"[ERROR: "</span> + te.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> TemplateException(<span class="string">"Failed to print error message. Cause: "</span> + e, env);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">cfg.setTemplateExceptionHandler(<span class="keyword">new</span> MyTemplateExceptionHandler());</span><br></pre></td></tr></table></figure>
<p>FreeMarker 本身带有这些预先编写的错误控制器：</p>
<ul>
<li>TemplateExceptionHandler.DEBUG_HANDLER：打印堆栈跟踪信息（包括 FTL 错误信息和 FTL 堆栈跟踪信息）和重新抛出的异常。这是默认的异常控制器（也就是说，在所有新的 Configuration 对象中，它是初始配置的）。</li>
<li>TemplateExceptionHandler.HTML_DEBUG_HANDLER：DEBUG_HANDLER 相同，但是它可以格式化堆栈跟踪信息，那么就可以在 Web 浏览器中来阅读错误信息。当你在制作 HTML 页面时，建议使用它而不是DEBUG_HANDLER。</li>
<li>TemplateExceptionHandler.IGNORE_HANDLER：简单地压制所有异常（但是要记住， FreeMarker 仍然会写日志）。它对处理异常没有任何作用，也不会重新抛出异常。</li>
<li>TemplateExceptionHandler.RETHROW_HANDLER：简单重新抛出所有异常而不会做其它的事情。这个控制器对 Web 应用程序（假设你在发生异常之后不想继续执行模板）来说非常好，因为它在生成的页面发生错误的情况下，给了你很多对 Web应用程序的控制权。</li>
</ul>
<h4 id="在模板中明确地处理错误">在模板中明确地处理错误</h4><p>你可以在模板中直接控制错误。通常这不是一个好习惯（尽量保持模板简单，技术含量不要太高），但有时仍然需要：</p>
<ul>
<li>控制不存在/为空的变量：请阅读模板开发指南/模板/表达式/处理不存在的值部分。</li>
<li>在发生障碍的“ porlets” 中留存下来</li>
</ul>
<h2 id="其他">其他</h2><h3 id="变量">变量</h3><p>当你想要读取一个变量时， FreeMarker 将会以这种顺序来查找，直到发现了完全匹配的的变量名称才会停下来</p>
<ol>
<li>在 Environment 对象中：<ol>
<li>如果在循环中，在循环变量的集合中。循环变量是由 （ 如 list 指令）来创建的。</li>
<li>如果在宏中，在宏的局部变量集合中。局部变量可以由 local 指令创建。而且，宏的参数也是局部变量。</li>
<li>在当前的命名空间中。可以使用 assign 指令将变量放到一个命名空间中。</li>
<li>在由 global 指令创建的变量集合中。FTL 将它们视为数据模型的普通成员变量一样来控制它们。也就是说，它们在所有的命名空间中都可见，你也可以像访问一个数据模型中的数据一样来访问它们。</li>
</ol>
</li>
<li>在传递给 process 方法的数据模型对象中。</li>
<li>在 Configuration 对象存储的共享变量集合中。</li>
</ol>
<p>1.4, 2,3 共同构成了全局变量的集合</p>
<h3 id="编码">编码</h3><p>输入编码</p>
<p>可以使用配置对象的setEncoding(Locale locale, String encoding)方法来填充编码表；编码表初始化时是空的。默认的初始编码是系统属性 file.encoding 的值，但是可以通过 setDefaultEncoding 方法来设置一个不同的默认值。</p>
<p>输出编码</p>
<p>原则上， FreeMarker 不处理输出内容的字符集问题，因为 FreeMarker 将输出内容都写入了 java.io.Writer 对象中。而 Writer 对象是由封装了 FreeMarker（比如 Web应用框架）的软件生成的，那么输出内容的字符集就是由封装软件来控制的。而 FreeMarker有一个称为 output_encoding（开始于 FreeMarker 2.3.1 版本之后）的设置。封装软件应该使用这个设置（ Writer 对象使用的字符集） 来通知 FreeMarker 在输出中（ 否则 FreeMarker 不能找到它）使用哪种字符集。 </p>
<p>为独立模板设置编码</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Writer</span> w = new <span class="type">OutputStreamWriter</span>(<span class="keyword">out</span>, outputCharset);</span><br><span class="line"><span class="type">Environment</span> env = <span class="keyword">template</span>.createProcessingEnvironment(dataModel, w);</span><br><span class="line">env.setOutputEncoding(outputCharset);</span><br><span class="line">env.process();</span><br></pre></td></tr></table></figure>
<h3 id="多线程">多线程</h3><p>在多线程运行环境中， Configuration 实例， Template 实例和数据模型应该是永远不能改变（只读）的对象。也就是说， 创建和初始化它们（如使用 set…方法） 之后， 就不能再修改它们了（ 比如不能再次调用 set…方法）。 </p>
<p>不鼓励你编写修改数据模型对象或共享变量的方法。多试试使用存储在环境对象（这个对象是为独立的 Template.process 调用而创建的，用来存储模板处理的运行状态）中的变量，所以最好不要修改那些由多线程使用的数据。</p>
<h3 id="Bean_的包装">Bean 的包装</h3><p>当 出 现 下 面 这 些 情 况 时 ， 你 会 想 使 用 BeansWrapper 包 装 器 来 代 替 DefaultObjectWrapper：<br>在模板执行期间，数据模型中的 Collection 和 Map 应该被允许修改。（ DefaultObjectWrapper 会阻止这样做，因为当它包装对象时创建了数据集合的拷贝，而这些拷贝都是只读的。）<br>如果 array， Collection 和 Map 对象的标识符当在模板中被传递到被包装对象的方法时，必须被保留下来。 也就是说，那些方法必须得到之前包装好的同类对象。<br>如果在之前列出的 Java API 中的类（ 如 String， Map， List 等），应该在模板中可见。还有，默认情况下它们是不可见的，但是可以设置获取的可见程度</p>
<h4 id="安全性">安全性</h4><p>默认情况下，不能访问模板制作时认为是不安全的一些方法。比如，不能使用同步方法（ wait， notify， notifyAll），线程和线程组的管理方法（ stop， suspend，resume， setDaemon ， setPriority ），反射相关方法（ Field setXxx ，Method.invoke， Constructor.newInstance， Class.newInstance，Class.getClassLoader 等）， System 和 Runtime 类中各种有危险性的方法（ exec， exit， halt， load 等）。 BeansWrapper 也有一些安全级别（被称作“方法暴露的级别”）， 默认的级别被称作为 EXPOSE_SAFE，它可能对大多数应用程序来说是适用的。没有安全保证的级别称作是 EXPOSE_ALL，它允许你调用上述的不安全的方法。一个严格的级别是 EXPOSE_PROPERTIES_ONLY，它只会暴露出 bean 属性的 getters方法。最后，一个称作是 EXPOSE_NOTHING 的级别，它不会暴露任何属性和方法。这种情况下，你可以通过哈希表模型接口访问的那些数据只是 map 和资源包中的项，还有，可以从通用 get(Object) 方法和 get(String)方法调用返回的对象，所提供的受影响的对象就有这样的方法。</p>
<h4 id="访问静态变量">访问静态变量</h4><p>从 BeansWrapper.getStaticModels() 方法返回的 TemplateHashModel 对象可以用来创建哈希表模型来访问静态方法和任意类型的字段。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BeansWrapper wrapper = BeansWrapper.getDefaultInstance<span class="params">()</span>;</span><br><span class="line">TemplateHashModel staticModels = wrapper.getStaticModels<span class="params">()</span>;</span><br><span class="line">TemplateHashModel fileStatics = <span class="params">(TemplateHashModel)</span> staticModels.get<span class="params">(<span class="string">"java.io.File"</span>)</span>;</span><br><span class="line">root.put<span class="params">(<span class="string">"File"</span>, fileStatics)</span>;</span><br></pre></td></tr></table></figure></p>
<p>模板中使用<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="id">#list</span> File.<span class="function"><span class="title">listRoots</span><span class="params">()</span></span> as fileSystemRoot&gt;...&lt;/#list&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果使用，将带来更多自由<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.put<span class="params">(<span class="string">"statics"</span>, BeansWrapper.getDefaultInstance<span class="params">()</span>.getStaticModels<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>可以这样使用<br><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;</span>statics[<span class="string">"java.lang.System"</span>].currentTimeMillis()&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，这样会有更多的安全隐患，比如，如果方法暴露级别对 EXPOSE_ALL 是很弱的，那么某些人可以使用这个模型调用 System.exit()方法。</p>
<h4 id="访问枚举类型">访问枚举类型</h4><p>BeansWrapper.getDefaultInstance()返回的对象可以被用作创建访问枚举类型值的哈希表模型</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BeansWrapper wrapper = BeansWrapper.getDefaultInstance<span class="params">()</span>;</span><br><span class="line">TemplateHashModel enumModels = wrapper.getEnumModels<span class="params">()</span>;</span><br><span class="line">TemplateHashModel roundingModeEnums = <span class="params">(TemplateHashModel)</span>enumModels.get<span class="params">(<span class="string">"java.math.RoundingMode"</span>)</span>;</span><br><span class="line">root.put<span class="params">(<span class="string">"RoundingMode"</span>, roundingModeEnums)</span>;</span><br></pre></td></tr></table></figure>
<p>使用<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">RoundingMode</span><span class="class">.UP</span></span><br></pre></td></tr></table></figure></p>
<p>更自由的方式<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root.put<span class="params">(<span class="string">"enums"</span>, BeansWrapper.getDefaultInstance<span class="params">()</span>.getEnumModels<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<p>使用</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;</span>enums[<span class="string">"java.math.RoundingMode"</span>].<span class="constant">UP&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="日志">日志</h3><p>默认情况下， FreeMarker 会按如下顺序来查找日志包，而且会自动使用第一个发现的包： SLF4J，Apache Commons Logging，Log4J，Avalon， java.util.logging。 然而，如果在 freemarker.log.Logger 类用合适的参数中调用静态的 selectLoggerLibrary 方法，而且在使用任何 FreeMarker 类之前记录信息，你可以明确地选择一个日志包，或者关闭日志功能。</p>
<h3 id="在_Servlet_中使用_FreeMarker">在 Servlet 中使用 FreeMarker</h3><ol>
<li>复制 freemarker.jar 到（从 FreeMarker 发布包的 lib 目录中）你的 Web<br>应用程序的 WEB-INF/lib 目录下。</li>
<li>将下面的部分添加到 Web 应用程序的 WEB-INF/web.xml 文件中（调整它是否<br>需要）。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span></span><br><span class="line">freemarker.ext.servlet.FreemarkerServlet</span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- FreemarkerServlet 设置: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>TemplatePath<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>/<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>NoCache<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>true<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>ContentType<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>text/html; charset=UTF-8<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 强制使用 UTF-8 作为输出编码格式! --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- FreeMarker 设置: --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>template_update_delay<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>0<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 0 只对开发使用! 否则使用大一点的值. --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>default_encoding<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>ISO-8859-1<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 模板文件的编码方式. --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-name</span>&gt;</span>number_format<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">param-value</span>&gt;</span>0.##########<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="title">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>freemarker<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>*.ftl<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="comment">&lt;!-- 为了阻止从 Servlet 容器外部访问 MVC 的视图层组件。</span><br><span class="line">RequestDispatcher.forward/include 应该起到作用。</span><br><span class="line">移除下面的代码可能开放安全漏洞!</span><br><span class="line">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">security-constraint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-resource-collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-resource-name</span>&gt;</span></span><br><span class="line">FreeMarker MVC Views</span><br><span class="line"><span class="tag">&lt;/<span class="title">web-resource-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>*.ftl<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-resource-collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">auth-constraint</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 不允许任何人访问这里 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">auth-constraint</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">security-constraint</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>它是怎么工作的？让我们来看看 JSP 是怎么工作的。许多 servlet 容器处理 JSP 时使用一个映射为<em>.jsp 的 servlet 请求 URL 格式。 这样 servlet 就会接收所有 URL 是以.jsp结尾的请求，查找请求 URL 地址中的 JSP 文件，内部编译完后交给 Servlet，然后调用 生 成 信 息 的 serlvet 来 生 成 页 面 。 这 里 为 URL 类 型 是 </em>.ftl 映射的 FreemarkerServlet 也是相同功能，只是 FTL 文件不会编译给 Servlet，而是给 Template 对象，之后 Template 对象的 process 方法就会被调用来生成<br>页面。</p>
<p>Freemarker现在页面中寻找变量，其次在 HttpServletRequest中寻找，然后在 HttpSession，最后在ServletContext中</p>
<p>FreemarkerServlet 也会在数据模型中放置 3 个哈希表，这样你就可以直接访问 3 个对象中的属性了。这些哈希表变量是： Request， Session， Application（和ServletContext 对应）。它还会暴露另外一个名为 RequestParameters 的哈希表，这个哈希表提供访问 HTTP 请求中的参数。</p>
<p>FreemarkerServlet 也有很多初始参数。它可以被设置从任意路径来加载模板，从类路径下，或相对于 Web 应用程序的目录。你可以设置模板使用的字符集。你还可以设置想使用的对象包装器等。</p>
<p>通过子类别， FreemarkerServlet 易于定制特殊需要。那就是说，你需要对所有模板添加一个额外的可用变量，使用 servlet 的子类，覆盖 preTemplateProcess()方法，在模板被执行前，将你需要的额外数据放到模型中。或者在 servlet 的子类中，在Configuration 中设置这些全局的变量作为共享变量。</p>
<h4 id="包含其它Web应用程序资源中的内容">包含其它Web应用程序资源中的内容</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">@include_page</span> <span class="attribute">path</span>=<span class="value">"path/to/some.jsp"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>和使用 JSP 指令是相同的：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:<span class="preprocessor">include</span> page=<span class="string">"path/to/some.jsp"</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p><code>&lt;@include_page ...&gt;</code>会开始一个独立的 HTTP 请求处理。</p>
<p>除了参数 path 之外，你也可以用布尔值（当不指定时默认是 true）指定一个名为 inherit_params 可选的参数来指定被包含的页面对当前的请求是否可见 HTTP 请求中的参数。</p>
<p>最后，你可以指定一个名为 params 的可选参数，来指定被包含页面可见的新请求参数。 如果也传递继承的参数，那么指定参数的值将会得到前缀名称相同的继承参数的值。params 的值必须是一个哈希表类型，它其中的每个值可以是字符串，或者是字符串序列（如果你需要多值参数）。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;@include_page <span class="variable">path=</span><span class="string">"path/to/some.jsp"</span> <span class="variable">inherit_params=</span><span class="constant">true</span> <span class="variable">params=</span>&#123;<span class="string">"foo"</span>: <span class="string">"99"</span>, <span class="string">"bar"</span>: [<span class="string">"a"</span>, <span class="string">"b"</span>]&#125;/&gt;</span><br></pre></td></tr></table></figure>
<p>如果“foo”有值“111”和“123”，那么现在它会有“99”，“111”，“123”。</p>
<h4 id="在_FTL_中使用_JSP_客户化标签">在 FTL 中使用 JSP 客户化标签</h4><p>FreemarkerServlet 将一个哈希表类型的 JspTaglibs 放到数据模型中，就可以使用它来访问 JSP 标签库了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="id">#assign</span> html=JspTaglibs[<span class="string">"/WEB-INF/struts-html.tld"</span>]&gt;</span><br><span class="line">&lt;<span class="id">#assign</span> bean=JspTaglibs[<span class="string">"/WEB-INF/struts-bean.tld"</span>]&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;&lt;@bean<span class="class">.message</span> key=<span class="string">"welcome.title"</span>/&gt;&lt;/h1&gt;</span><br><span class="line">&lt;@<span class="tag">html</span>.errors/&gt;</span><br><span class="line">&lt;@<span class="tag">html</span><span class="class">.form</span> action=<span class="string">"/query"</span>&gt;</span><br><span class="line">Keyword: &lt;@<span class="tag">html</span><span class="class">.text</span> property=<span class="string">"keyword"</span>/&gt;&lt;br&gt;</span><br><span class="line">Exclude: &lt;@<span class="tag">html</span><span class="class">.text</span> property=<span class="string">"exclude"</span>/&gt;&lt;br&gt;</span><br><span class="line">&lt;@<span class="tag">html</span><span class="class">.submit</span> value=<span class="string">"Send"</span>/&gt;</span><br><span class="line">&lt;/@<span class="tag">html</span>.form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>
<p>因为 JSP 客户化标签是在 JSP 环境中来书写操作的，它们假设变量（在 JSP 中常被指代“beans”）被存储在 4 个范围中： page 范围， request 范围， session 范围和 application 范围。FTL 没有这样的表示法（ 4 种范围），但是 FreemarkerServlet 给客户化标签提供仿真的环境，这样就可以维持 JSP 范围中的“ beans”和 FTL 变量之间的对应关系。对于自定义的JSP标签，请求，会话和应用范围是和真实JSP相同的：javax.servlet.ServletContext，HttpSession 和 ServerRequest 对象中的属性。从 FTL 的角度来看，这三种范围都在数据模型中</p>
]]></content>
    <summary type="html">
    <![CDATA[FreeMarker;Java模板引擎;程序开发]]>
    
    </summary>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/tags/FreeMarker/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/categories/Java/FreeMarker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FreeMarker-模板开发笔记]]></title>
    <link href="http://howiefh.github.io/2015/04/30/freemarker-template-development-note/"/>
    <id>http://howiefh.github.io/2015/04/30/freemarker-template-development-note/</id>
    <published>2015-04-30T01:19:31.000Z</published>
    <updated>2015-05-21T15:56:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概览">概览</h2><h3 id="if">if</h3><figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">Welcome</span> <span class="char">$&#123;</span>user&#125;&lt;<span class="symbol">#if</span> user == <span class="comment">"Big Joe"</span>&gt;, our beloved leader&lt;/<span class="symbol">#if</span>&gt;!</span><br></pre></td></tr></table></figure>
<h3 id="list">list</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">animals</span> <span class="attribute">as</span> <span class="attribute">being</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span>$&#123;being.name&#125;<span class="tag">&lt;<span class="title">td</span>&gt;</span>$&#123;being.price&#125; Euros</span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="include">include</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">#<span class="keyword">include</span> "/copyright_footer.html"&gt;</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h2 id="数值和类型">数值和类型</h2><h3 id="支持的类型">支持的类型</h3><ul>
<li>标量：<ul>
<li>字符串</li>
<li>数字</li>
<li>布尔值</li>
<li>日期</li>
</ul>
</li>
<li>容器：<ul>
<li>哈希表</li>
<li>序列</li>
<li>集</li>
</ul>
</li>
<li>子程序：<ul>
<li>方法和函数：方法是来自于数据模型（它们反射了 Java 对象的方法），而函数是定义在模板内的（使用了函数指令-这也是高级主题），但二者可以用同一种方式来使用。内置的方法<code>${avg(6, 10, 20)}</code></li>
<li>用户自定义指令：按经验来说，如果能够实现，请先用自定义指令而不要用函数/方法。 <code>&lt;@box title=&quot;Attention!&quot;&gt; hello &lt;/@box&gt;</code></li>
</ul>
</li>
<li>其它/很少使用：<ul>
<li>节点</li>
</ul>
</li>
</ul>
<h2 id="模板">模板</h2><p>模板（ FTL 编程）是由如下部分混合而成的：</p>
<ul>
<li>Text 文本：文本会照着原样来输出。</li>
<li>Interpolation 插值： 这部分的输出会被计算的值来替换。插值由${和}所分隔（或者#{和}，这种风格已经不建议再使用了）。</li>
<li>FTL tags 标签： FTL 标签和 HTML 标签很相似，但是它们却是给 FreeMarker 的指示， 而且不会打印在输出内容中。</li>
<li>Comments 注释： FTL 的注释和 HTML 的注释也很相似，但它们是由<code>&lt;#--</code>和<code>--&gt;</code>来分隔的。注释会被 FreeMarker 所忽略，更不会在输出内容中显示。</li>
</ul>
<p>FTL 标签不可以在其他 FTL 标签和插值中使用。下面这样写就是错的：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="id">#if</span> &lt;<span class="id">#include</span> <span class="string">'foo'</span>&gt;=<span class="string">'bar'</span>&gt;...&lt;/#<span class="keyword">if</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>注释可以放在 FTL 标签和插值中间。<br>插值可以在文本区域和字符串中出现，但是不能在标签中使用<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;#if $&#123;isBig&#125;&gt;</span><span class="tag">&lt;/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的就是错误的，正确的应该这样写<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">#<span class="keyword">if</span> isBig&gt;&lt;/<span class="keyword">if</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>FreeMarker可以忽略标签、插值内的空格，但是<code>&lt;</code>、<code>&lt;\</code>和指令之间的空格不能忽略</p>
<h3 id="快速浏览">快速浏览</h3><ul>
<li>直接指定值<ul>
<li>字符串： “Foo” 或者 ‘Foo’ 或者 “It’s \”quoted\”” 或者<br>r”C:\raw\string”</li>
<li>数字： 123.45</li>
<li>布尔值： true, false</li>
<li>序列： [“foo”, “bar”, 123.45], 1..100</li>
<li>哈希表： {“name”:”green mouse”, “price”:150}</li>
</ul>
</li>
<li>检索变量<ul>
<li>顶层变量： user</li>
<li>从哈希表中检索数据： user.name, user[“name”]</li>
<li>从序列中检索： products[5]</li>
<li>特殊变量： .main  。 特殊变量是由 FreeMarker 引擎本身定义的，为了使用它们，可以按照如下语法形式来进行： .variable_name。</li>
</ul>
</li>
<li>字符串操作<ul>
<li>插值（ 或连接）： “Hello ${user}!”（或”Free” + “Marker”）</li>
<li>获取一个字符： name[0]</li>
</ul>
</li>
<li>序列操作<ul>
<li>连接： users + [“guest”]</li>
<li>序列切分： products[10..19] 或 products[5..]</li>
</ul>
</li>
<li>哈希表操作<ul>
<li>连接： passwords + {“joe”:”secret42”}</li>
</ul>
</li>
<li>算数运算: (x * 1.5 + 10) / 2 - y % 100</li>
<li>比较运算 ： <code>x == y, x != y, x &lt; y, x &gt; y, x &gt;= y, x &lt;= y, x &amp;lt; y,</code> 等等</li>
<li>逻辑操作： !registered &amp;&amp; (firstVisit || fromEurope)</li>
<li>内建函数： name?upper_case</li>
<li>方法调用： repeat(“What”, 3)</li>
<li>处理不存在的值<ul>
<li>默认值： name!”unknown” 或者(user.name)!”unknown” 或者<br>name! 或者 (user.name)!</li>
<li>检测不存在的值： name?? 或者(user.name)??</li>
</ul>
</li>
<li>运算符的优先级</li>
</ul>
<p>最高优先级运算符:  [subvarName][subStringRange].?(methodParams)<br>一元前缀运算符: +expr -expr !expr<br>乘除法，求模: * / %<br>加减法: + -<br>关系运算符: <code>&lt; &gt; &lt;= &gt;= (相当于: gt, lt, 等)</code><br>相等，不等: == (也可以是: =) !=<br>逻辑与: &amp;&amp;<br>逻辑或: ||<br>数字范围: ..</p>
<h3 id="字符串">字符串</h3><p>可以使用转义字符<code>\\</code>、<code>\&quot;</code>等。一种特殊的字符串就是原生字符串。在原生字符串中，反斜杠和${没有特殊的含义，它们被视为普通的字符。 为了表明字符串是原生字符串，在开始的引号或单引号之前放置字母 r，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">r"$&#123;foo&#125;"</span>&#125;</span><br><span class="line">$&#123;<span class="string">r"C:\foo\bar"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>将会打印：<br><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$<span class="list">&#123;foo&#125;</span></span><br><span class="line"><span class="keyword">C</span>:\foo\bar</span><br></pre></td></tr></table></figure></p>
<p>连接<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">"Hello <span class="subst">$&#123;user&#125;</span>!"</span>&#125;</span><br><span class="line">$&#123;<span class="string">"<span class="subst">$&#123;user&#125;</span><span class="subst">$&#123;user&#125;</span><span class="subst">$&#123;user&#125;</span><span class="subst">$&#123;user&#125;</span>"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>和<br><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$&#123;<span class="string">"Hello "</span> + <span class="literal">user</span> + <span class="string">"!"</span>&#125;</span><br><span class="line">$&#123;<span class="literal">user</span> + <span class="literal">user</span> + <span class="literal">user</span> + <span class="literal">user</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>效果上是一样的</p>
<p>可以使用${user[0]}获取某个字符，也可以使用${user[2..5]}和${user[2..]}获取子串</p>
<h3 id="数字">数字</h3><p>数值文字 08, +8, 8.00 和 8 是完全相等的，它们都是数字 8。因此${08}, ${+8}, ${8.00}和${8}打印的都是相同的。</p>
<h3 id="序列">序列</h3><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> [<span class="string">"winter"</span>, <span class="string">"spring"</span>, <span class="string">"summer"</span>, <span class="string">"autumn"</span>] <span class="keyword">as</span> x&gt;</span><br><span class="line"><span class="label">$&#123;x&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure>
<p>列表中的项目是表达式，那么也可以这样做： [2 + 2, [1, 2, 3, 4], “whatnot”]，其中第一个子变量是数字 4，第二个子变量是一个序列，第三个子变量是字符串”whatnot”。<br>也可以用 start..end 定义存储数字范围的序列，这里的 start 和 end 是处理数字值表达式，比如 2..5 和[2, 3, 4, 5]是相同的，但是使用前者会更有效率（ 内存占用少而且速度快）。</p>
<p>序列的连接可以使用+号来进行<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">list</span> [<span class="string">"Joe"</span>, <span class="string">"Fred"</span>] + [<span class="string">"Julia"</span>, <span class="string">"Kate"</span>] <span class="keyword">as</span> user&gt;</span><br><span class="line">- <span class="label">$&#123;user&#125;</span></span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>序列切分<br>使用 [firstindex..lastindex] 可以获取序列中的一部分，这里的firstindex 和lastindex 表达式的结果是数字。</p>
<h3 id="哈希表">哈希表</h3><p>在模板中指定一个哈希表，就可以遍历用逗号分隔开的“键/值”对，把列表放到花括号内。键和值成对出现并以冒号分隔。看这个例子：{“name”:”green mouse”, “price”:150}。注意到名字和值都是表达式，但是用来检索的名字就必须是字符串类型的。</p>
<p>两种方式从哈希表中检索数据:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">book.name</span></span><br><span class="line"><span class="title">book["name"]</span></span><br></pre></td></tr></table></figure></p>
<p>哈希表也可以使用+连接，如果有相同键，+后面出现的会覆盖之前的<br><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">#assign</span> <span class="attribute">ages</span> = </span></span><span class="expression">&#123;<span class="string">"Joe"</span>:23, <span class="string">"Fred"</span>:25&#125;</span><span class="xml"><span class="tag"> + </span></span><span class="expression">&#123;<span class="string">"Joe"</span>:30, <span class="string">"Julia"</span>:18&#125;</span><span class="xml"><span class="tag">&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="+、-、*、/、%"><code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code></h3><p>内建函数int可以取出整数部分<code>${(x/2)?int}</code></p>
<h3 id="比较">比较</h3><p>为了避免大于、小于被当做标签处理，可以用圆括号包含表达式<code>&lt;#if (x&gt;y)&gt;&lt;/if&gt;</code>。也可以用lt、<br>lte、gt、gte来比较</p>
<h2 id="内建函数">内建函数</h2><p>内建函数以?形式提供变量的不同形式或者其他信息。</p>
<ul>
<li>字符串使用的内建函数：<ul>
<li>html: 字符串中所有的特殊 HTML 字符都需要用实体引用来代替（比如<code>&lt;</code>代替&lt;）。</li>
<li>cap_first:字符串的第一个字母变为大写形式</li>
<li>lower_case:字符串的小写形式</li>
<li>upper_case:字符串的大写形式</li>
<li>trim:去掉字符串首尾的空格</li>
</ul>
</li>
<li>序列使用的内建函数：<ul>
<li>size：序列中元素的个数</li>
</ul>
</li>
<li>数字使用的内建函数：<ul>
<li>int:数字的整数部分（比如-1.9?int 就是-1）</li>
</ul>
</li>
</ul>
<h2 id="方法调用">方法调用</h2><ul>
<li>avg求均值</li>
<li>repeat重复输出3次What<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$&#123;</span>repeat(<span class="string">"What"</span>, <span class="number">3</span>)&#125;</span><br><span class="line"><span class="variable">$&#123;</span>avg(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h2 id="处理不存在的变量">处理不存在的变量</h2><p>一个不存在的变量和一个是 null 的变量， 对于 FreeMarker 来说是一样的，所以这里所指的丢失包含这两种情况。<br>就像下面的例子，当 user 从数据模型中丢失时，模板将会将user 的值表示为字符串”Anonymous”。（若 user 并没有丢失，那么模板就会表现<br>出”Anonymous”不存在一样）：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;h1&gt;</span>Welcome $&#123;<span class="keyword">user</span>!<span class="string">"Anonymous"</span>&#125;!<span class="variable">&lt;/h1&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当然也可以在变量名后面通过放置??来询问 FreeMarker 一个变量是否存在。 将它和 if 指令合并，那么如果 user 变量不存在的话将会忽略整个问候代码段：<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;#if user??&gt;</span><span class="variable">&lt;h1&gt;</span>Welcome $&#123;<span class="keyword">user</span>&#125;!<span class="variable">&lt;/h1&gt;</span><span class="variable">&lt;/#if&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>关于多级访问的变量，比 如 animals.python.price，书写代码：animals.python.price!0，仅当 animals.python 存在而仅仅最后一个子变量 price 可能不存在（这种情况下我们假设价格是 0）。 如果 animals 或者 python<br>不存在，那么模板处理过程将会以“未定义的变量”错误而停止。为了防止这种情况的发生，可以这样来书写代码(animals.python.price)!0。这种情况下当 animals 或<br>python 不存在时表达式的结果仍然是 0。 对于??也是同样用来的处理这种逻辑的</p>
<h3 id="默认值">默认值</h3><p>使用形式概览：unsafe_expr!default_expr 或 unsafe_expr! 或 (unsafe_expr)!default_expr 或(unsafe_expr)!</p>
<p>hits!0 或 colors![“red”, “green”, “blue”]</p>
<p>由于 FreeMarker 2.3.x 版本的源码中的小失误所以必须这么来做。 !（作为默认值操作）的优先级非常低。 这就意味着${x!1 + y}会被 FreeMarker 误解为${x!(1 + y)}，而真实的意义是${(x!1) + y}。 这个源码的错误在 FreeMarker 2.4 中会得到修正。</p>
<h2 id="插值">插值</h2><p>字符串<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#escape</span> <span class="attribute">x</span> <span class="attribute">as</span> <span class="attribute">x</span>?<span class="attribute">html</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>Title: $&#123;book.title&#125;<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span>&gt;</span>Description:</span><br><span class="line"><span class="tag">&lt;<span class="title">#noescape</span>&gt;</span>$&#123;book.description&#125;<span class="tag">&lt;/<span class="title">#noescape</span>&gt;</span><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>Comments:<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#list</span> <span class="attribute">comments</span> <span class="attribute">as</span> <span class="attribute">comment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">div</span> <span class="attribute">class</span>=<span class="value">"comment"</span>&gt;</span></span><br><span class="line">$&#123;comment&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#list</span>&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="title">#escape</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果插值在文本区 （也就是说，不再字符串表达式中）， 如果 escapse 指令起作用了，即将被插入的字符串会被自动转义（将&amp;转为&amp;）。如果你要生成 HTML，那么强烈建议你利用它来阻止跨站脚本攻击和非格式良好的 HTML 页面。使用 noescape 可以抵消 escape 的转义。如果你想把所有的输出为大写的话可以x.upper_case</p>
<p>数字</p>
<p>小数的分隔符是根据所在地的标准确定的，如匈牙利的分隔符是<code>,</code>。那么<code>{1.5}</code>会输出<code>1,5</code></p>
<p>可以通过string内置函数来设置输出的格式。</p>
<h2 id="其他">其他</h2><h3 id="自定义指令">自定义指令</h3><p>自定义指令可以使用 macro 指令来定义，这是模板设计者所关心的内容。 Java 程序员若不想在模板中实现定义指令，而是在 Java 语言中实现指令的定义， 这时可以使用freemarker.template.TemplateDirectiveModel 类来扩展</p>
<p>定义宏<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#macro</span> <span class="attribute">greet</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">font</span> <span class="attribute">size</span>=<span class="value">"+2"</span>&gt;</span>Hello Joe!<span class="tag">&lt;/<span class="title">font</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用自定义指令<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;@greet&gt;</span><span class="tag">&lt;/@greet&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;@greet/&gt;</span></span><br></pre></td></tr></table></figure></p>
<h4 id="参数">参数</h4><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro greet <span class="keyword">person</span>&gt;</span><br><span class="line">&lt;font size=<span class="string">"+2"</span>&gt;Hello $&#123;<span class="keyword">person</span>&#125;!&lt;/font&gt;</span><br><span class="line">&lt;/#macro&gt;</span><br></pre></td></tr></table></figure>
<p>使用<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;@greet <span class="keyword">person</span>=<span class="string">"Joe"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">font</span> <span class="attribute">size</span>=<span class="value">"+2"</span>&gt;</span>Hello Joe!<span class="tag">&lt;/<span class="title">font</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用自定义指令提供的参数必须与宏定义的参数对应，如果多于宏定义中的参数则报错；如果少于宏定义中的参数，并且宏中也没有指定有默认值的话，会报错，指定了默认值的话不会报错。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;#macro greet <span class="keyword">person</span> color=<span class="string">"red"</span>&gt;</span><br><span class="line">&lt;font size=<span class="string">"+2"</span> color=<span class="string">"$&#123;color&#125;"</span>&gt;Hello $&#123;<span class="keyword">person</span>&#125;!&lt;/font&gt;</span><br><span class="line">&lt;/#macro&gt;</span><br></pre></td></tr></table></figure>
<p>使用下面的指令是对的，如果没有color=”red”的话则会报错<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;@greet <span class="keyword">person</span>=<span class="string">"Joe"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>someParam=foo 和 someParam=”${foo}”是不同的。第一种情况，是把变量 foo 的值作为参数的值来使 用。第二种情况则是使用插值形式的字符串，那么参数值就是字符串了</p>
<h4 id="嵌套内容">嵌套内容</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">#macro</span> <span class="attribute">border</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">border</span>=<span class="value">4</span> <span class="attribute">cellspacing</span>=<span class="value">0</span> <span class="attribute">cellpadding</span>=<span class="value">4</span>&gt;</span><span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">#nested</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">#macro</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><code>&lt;#nested&gt;</code>指令执行位于开始和结束标记指令之间的模板代码段。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">@border</span>&gt;</span>The bordered text<span class="tag">&lt;/<span class="title">@border</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>输出<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">border</span>=<span class="value">4</span> <span class="attribute">cellspacing</span>=<span class="value">0</span> <span class="attribute">cellpadding</span>=<span class="value">4</span>&gt;</span><span class="tag">&lt;<span class="title">tr</span>&gt;</span><span class="tag">&lt;<span class="title">td</span>&gt;</span></span><br><span class="line">The bordered text<span class="tag">&lt;/<span class="title">td</span>&gt;</span><span class="tag">&lt;/<span class="title">tr</span>&gt;</span><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>nested可以多次被调用</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;#macro do_thrice&gt;</span></span><br><span class="line"><span class="tag">&lt;#nested&gt;</span></span><br><span class="line"><span class="tag">&lt;#nested&gt;</span></span><br><span class="line"><span class="tag">&lt;#nested&gt;</span></span><br><span class="line"><span class="tag">&lt;/#macro&gt;</span></span><br><span class="line"><span class="tag">&lt;@do_thrice&gt;</span></span><br><span class="line"><span class="keyword">Anything</span>.</span><br><span class="line"><span class="tag">&lt;/@do_thrice&gt;</span></span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Anything</span>.</span><br><span class="line"><span class="variable">Anything</span>.</span><br><span class="line"><span class="variable">Anything</span>.</span><br></pre></td></tr></table></figure></p>
<p>嵌套的内容可以是任意有效的 FTL，包含其他的用户自定义指令，这样也是对的：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;@border&gt;</span><br><span class="line">&lt;ul&gt;</span><br><span class="line">&lt;@do_thrice&gt;</span><br><span class="line">&lt;li&gt;&lt;@greet <span class="keyword">person</span>=<span class="string">"Joe"</span>/&gt;</span><br><span class="line">&lt;/@do_thrice&gt;</span><br><span class="line">&lt;/ul&gt;</span><br><span class="line">&lt;/@border&gt;</span><br></pre></td></tr></table></figure></p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">macro</span> <span class="keyword">repeat</span> <span class="keyword">count</span>&gt;</span><br><span class="line">&lt;#<span class="keyword">local</span> y = <span class="string">"test"</span>&gt;</span><br><span class="line">&lt;#<span class="keyword">list</span> 1..<span class="keyword">count</span> <span class="keyword">as</span> x&gt;</span><br><span class="line"><span class="label">$&#123;y&#125;</span> <span class="label">$&#123;count&#125;</span>/<span class="label">$&#123;x&#125;</span>: &lt;#nested&gt;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line">&lt;/#<span class="keyword">macro</span>&gt;</span><br><span class="line">&lt;@<span class="keyword">repeat</span> <span class="keyword">count</span>=3&gt;<span class="label">$&#123;y</span>!<span class="string">"?"</span>&#125; <span class="label">$&#123;x</span>!<span class="string">"?"</span>&#125; <span class="label">$&#123;count</span>!<span class="string">"?"</span>&#125;&lt;/@<span class="keyword">repeat</span>&gt;</span><br></pre></td></tr></table></figure>
<p>在宏的外部，宏中的局部变量是不可见的</p>
<h4 id="宏和循环变量">宏和循环变量</h4><p>自定义指令也可以有循环变量。比如我们来扩展先前例子中的 do_thrice 指令，就可以拿到当前的循环变量的值。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="comment">#macro do_thrice&gt;</span></span><br><span class="line">&lt;<span class="comment">#nested 1&gt;</span></span><br><span class="line">&lt;<span class="comment">#nested 2&gt;</span></span><br><span class="line">&lt;<span class="comment">#nested 3&gt;</span></span><br><span class="line">&lt;/<span class="comment">#macro&gt;</span></span><br><span class="line">&lt;@<span class="keyword">do</span>_thrice ; x&gt; &lt;<span class="comment">#-- 用户自定义指令 使用";"代替"as" --&gt;</span></span><br><span class="line"><span class="variable">$&#123;x&#125;</span> Anything.</span><br><span class="line">&lt;/@<span class="keyword">do</span>_thrice&gt;</span><br></pre></td></tr></table></figure>
<p>输出<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> <span class="variable">Anything</span>.</span><br><span class="line"><span class="number">2</span> <span class="variable">Anything</span>.</span><br><span class="line"><span class="number">3</span> <span class="variable">Anything</span>.</span><br></pre></td></tr></table></figure></p>
<p>nested 指令（当然参数可以是任意的表达式）的参数。 循环变量的名称是在自定义指令的开始标记（ <code>&lt;@...&gt;</code>）的参数后面通过分号确定的。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="keyword">macro</span> <span class="keyword">repeat</span> <span class="keyword">count</span>&gt;</span><br><span class="line">&lt;#<span class="keyword">list</span> 1..<span class="keyword">count</span> <span class="keyword">as</span> x&gt;</span><br><span class="line">&lt;#nested x, x/2, x==<span class="keyword">count</span>&gt;</span><br><span class="line">&lt;/#<span class="keyword">list</span>&gt;</span><br><span class="line">&lt;/#<span class="keyword">macro</span>&gt;</span><br><span class="line">&lt;@<span class="keyword">repeat</span> <span class="keyword">count</span>=4 ; c, halfc, last&gt;</span><br><span class="line"><span class="label">$&#123;c&#125;</span>. <span class="label">$&#123;halfc&#125;</span>&lt;#<span class="keyword">if</span> last&gt; Last!&lt;/#<span class="keyword">if</span>&gt;</span><br><span class="line">&lt;/@<span class="keyword">repeat</span>&gt;</span><br></pre></td></tr></table></figure>
<p>如果在分号后面指定了比 nested 指令还多的变量，那么最后的循环变量将不会被创建（在嵌套内容中不会被定义）。如果分号后的指定了比nested指令少的变量，没有问题。</p>
<h4 id="在模板中可以定义三种类型的变量">在模板中可以定义三种类型的变量</h4><ul>
<li>简单变量： 它能从模板中的任何位置来访问，或者从使用 include 指令引入的<br>模板访问。可以使用 assign 或 macro 指令来创建或替换这些变量。</li>
<li>局部变量： 它们只能被设置在宏定义体内，而且只在宏内可见。一个局部变量的生<br>存周期只是宏的调用过程。可以使用 local 指令在宏定义体内创建或替换局部变<br>量。</li>
<li>循环变量：循环变量是由指令（如 list）自动创建的，而且它们只在指令的开始<br>和结束标记内有效。宏的参数是局部变量而不是循环变量。</li>
</ul>
<h3 id="命名空间">命名空间</h3><p>当运行 FTL 模板时，就会有使用 assign 和 macro 指令创建的变量的集合（可能是空的），可以从前一章节来看如何使用它们。像这样的变量集合被称为 namespace 命名空间。在简单的情况下可以只使用一个命名空间，称之为 main namespace 主命名空间。</p>
<h4 id="创建一个库">创建一个库</h4><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="subst">&lt;</span><span class="variable">#macro</span> copyright <span class="built_in">date</span><span class="subst">&gt;</span></span><br><span class="line"><span class="subst">&lt;</span>p<span class="subst">&gt;</span>Copyright (C) $&#123;<span class="built_in">date</span>&#125; Julia Smith<span class="built_in">. </span><span class="literal">All</span> rights reserved<span class="built_in">.</span><span class="subst">&lt;</span>/p<span class="subst">&gt;</span></span><br><span class="line"><span class="subst">&lt;</span><span class="subst">/</span><span class="variable">#macro</span><span class="subst">&gt;</span></span><br><span class="line"><span class="subst">&lt;</span><span class="variable">#assign</span> mail <span class="subst">=</span> <span class="string">"jsmith@acme.com"</span><span class="subst">&gt;</span></span><br></pre></td></tr></table></figure>
<p>把上面的这些定义存储在文件 lib/my_test.ftl 中（目录是你存放模板的位置）。假设想在aWebPage.ftl中使用这个模板。如果在aWebPage.ftl 使用<code>&lt;#include &quot;/lib/my_test.ftl&quot;&gt;</code>，那么就会在主命名空间中创建两个变量，所以就不得不使用import 指令来代替 include 了。它会为 lib/my_test.ftl 创建一个空的命名空间，然后在那里执行。在 aWebPage.ftl中就可以用下面的代码。如果在主命名空间中有一个变量，名为 mail 或 copyright， 那么就不会引起混乱了</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;#<span class="literal">import</span> <span class="string">"/lib/my_test.ftl"</span> <span class="literal">as</span> my&gt;</span><br><span class="line">&lt;#-- 被称为<span class="string">"my"</span>的哈希表就会是那个<span class="string">"大门"</span> --&gt;</span><br><span class="line">&lt;<span class="annotation">@my</span>.copyright date=<span class="string">"1999-2002"</span>/&gt;</span><br><span class="line">$&#123;my.mail&#125;</span><br></pre></td></tr></table></figure>
<h4 id="命名空间和数据模型">命名空间和数据模型</h4><p>数据模型中的变量在任何位置都是可见的。数据模型user在lib/my_test.ftl和aWebPage.ftl 都能访问。</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;#macro copyright date&gt;</span></span><br><span class="line"><span class="tag">&lt;p&gt;</span><span class="keyword">Copyright</span> (C) <span class="cbracket">$&#123;date&#125;</span> <span class="cbracket">$&#123;user&#125;</span>. <span class="literal">All</span> rights reserved.&lt;/p&gt;</span><br><span class="line"><span class="tag">&lt;/#macro&gt;</span></span><br><span class="line"><span class="tag">&lt;#assign mail = "$&#123;user&#125;@acme.com"&gt;</span></span><br></pre></td></tr></table></figure>
<p>在模板的命名空间（可以使用 assign 或 macro 指令来创建的变量）中的变量有着比数据模型中的变量更高的优先级，可以覆盖数据模型。如果想在模板中创建任何命名空间都能访问的变量，那么可以使用global指令</p>
<h4 id="命名空间的生命周期">命名空间的生命周期</h4><p>命名空间由使用的 import 指令中所写的路径来识别。如果想多次 import 这个路径，那么只会为第一次的 import 引用创建命名空间执行模板。 后面相同路径的 import 只是创建一个哈希表当作访问相同命名空间的“门”。</p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="symbol">#import</span> <span class="comment">"/lib/my_test.ftl"</span> as my&gt;</span><br><span class="line">&lt;<span class="symbol">#import</span> <span class="comment">"/lib/my_test.ftl"</span> as foo&gt;</span><br><span class="line">&lt;<span class="symbol">#import</span> <span class="comment">"/lib/my_test.ftl"</span> as bar&gt;</span><br><span class="line"><span class="char">$&#123;</span>my.mail&#125;, <span class="char">$&#123;</span>foo.mail&#125;, <span class="char">$&#123;</span>bar.mail&#125;</span><br><span class="line">&lt;<span class="symbol">#assign</span> mail=<span class="comment">"jsmith@other.com"</span> in my&gt;</span><br><span class="line"><span class="char">$&#123;</span>my.mail&#125;, <span class="char">$&#123;</span>foo.mail&#125;, <span class="char">$&#123;</span>bar.mail&#125;</span><br></pre></td></tr></table></figure>
<p>还要注意命名空间是不分层次的，它们相互之间是独立存在的。那么，如果在命名空间N1 中 import 命名空间 N2，那 N2 也不在 N1 中， N1 只是可以通过哈希表来访问 N2。 这和在主命名空间中 importN2，然后直接访问命名空间 N2 是一样的过程。</p>
<p>每一次模板执行工作都是一个分离且有序的过程，它们仅仅存在一段很短的时间， 同时页面用以呈现内容，然后就和所有填充过的命名空间一起消失了。</p>
<h4 id="编写类库">编写类库</h4><p>命名和Java包命名规范相似，存放路径一般是</p>
<p>/lib/example.sourceforge.net/example.ftl 或<br>/lib/geocities.com/jsmith/example.ftl</p>
<h3 id="空白处理">空白处理</h3><p>FreeMarker 提供下面的工具来处理这个问题：</p>
<ul>
<li>忽略某些模板文件的空白的工具（ 解析阶段空白就被移除了）：<ul>
<li>剥离空白： 这个特性会自动忽略在 FTL 标签周围多余的空白。这个特性可以通过模板来随时使用和禁用。</li>
<li>微调指令： t， rt 和 lt， 使用这些指令可以明确地告诉 FreeMarker 去忽略某些空白。可以阅读参考手册来获取更多信息。</li>
<li>FTL 参数 strip_text：这将从模板中删除所有顶级文本。对模板来说这很有用，它只包含某些定义的宏（还有以他一些没有输出的指令），因为它可以移除宏定义和其他顶级指令中的换行符，这样可以提高模板的可读性。</li>
</ul>
</li>
<li>从输出中移除空白的工具（移除临近的空白）：<ul>
<li>compress 指令</li>
</ul>
</li>
</ul>
<h3 id="替换（方括号）语法">替换（方括号）语法</h3><p>这个特性从 FreeMarker 2.3.4 版本后才可用。<br>FreeMarker 支持一个替换的语法。就是在 FreeMarker 的指令和注释中用[和]来代替<code>&lt;</code>和<code>&gt;</code>，例如下面这个例子：</p>
<ul>
<li>调用预定义指令： [#list animals as being]…[/#list]</li>
<li>调用自定义指令： [@myMacro /]</li>
<li>注释： [#— the comment —]</li>
</ul>
<p>为了使用这种语法从而代替默认语法，从模板开始，使用 ftl 指令都要使用这用语法。[#ftl]</p>
<p>2.4 版本中的默认配置将会自动检测，也就是说第一个 FreeMarker 标签决定了语法形式（它可以是任意的，而不仅仅是 ftl）。</p>
]]></content>
    <summary type="html">
    <![CDATA[FreeMarker;Java模板引擎;模板开发]]>
    
    </summary>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/tags/FreeMarker/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
      <category term="FreeMarker" scheme="http://howiefh.github.io/categories/Java/FreeMarker/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解Java虚拟机笔记三（JVM性能监控与故障处理工具）]]></title>
    <link href="http://howiefh.github.io/2015/04/09/jvm-note-3/"/>
    <id>http://howiefh.github.io/2015/04/09/jvm-note-3/</id>
    <published>2015-04-09T08:00:22.000Z</published>
    <updated>2015-08-17T08:11:46.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>大多工具都是对jdk/lib/tools.jar类库的一层包装，SUN JDK监控和故障处理工具：</p>
<ol>
<li>jps：JVM Process Status Tool，显示指定系统内所有的HotSpot虚拟机进程</li>
<li>jstat：JVM Statistics Monitoring Tool，用于收集HotSpot虚拟机各方面的运行数据</li>
<li>jinfo：Configuration Info for Java，显示虚拟机配置信息</li>
<li>jmap：Memory Map for Java，生成虚拟机的内存转储快照(heap dump文件)</li>
<li>jhat：JVM Heap Dump Browser，用于分析heap dump文件，会建立一个HTTP/HTML服务器，让用户可以在浏览器查看分析结果</li>
<li>jstack：Stack Trace for Java，显示虚拟机的线程快照</li>
</ol>
<p>然后还有两个GUI工具：</p>
<ol>
<li>jconsole：略微过时的JVM各状态查看工具</li>
<li>visualVM：Sun出品的强大的JVM工具，推荐使用！</li>
</ol>
<a id="more"></a>
<h2 id="JDK的命令行工具">JDK的命令行工具</h2><h3 id="jps：虚拟机进程状况工具">jps：虚拟机进程状况工具</h3><p>它和Unix的ps命令有类似功能：</p>
<p><strong>它可以列出正在运行的虚拟机进程，并显示虚拟机执行主类（Main Claas，main()函数所在的类）的名称，以及这些进程的内地虚拟机的唯一ID（LVMID，Local Virtual Machine Identifier）。</strong></p>
<p>命令格式：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">jps</span> <span class="attr_selector">[options]</span> <span class="attr_selector">[hostid]</span></span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-q</td>
<td>只输出LVMID，省略主类的名称</td>
</tr>
<tr>
<td>-m</td>
<td>输出虚拟机进程启动时传递给主类main()函数的参数</td>
</tr>
<tr>
<td>-l</td>
<td>输出主类的全名，如果进程执行的是jar包，输出jar包路径</td>
</tr>
<tr>
<td>-v</td>
<td>输出虚拟机进程启动时JVM参数</td>
</tr>
</tbody>
</table>
<h3 id="jstat：虚拟机统计信息监视工具">jstat：虚拟机统计信息监视工具</h3><p>jstat的全称是JVM Statistics Monitoring Tool，它用于监视虚拟机各种运行状态信息。可以显示<strong>本地或远程虚拟机进程中的类装载、内存、垃圾收集、JIT编译等运行数据</strong>，在没有GUI图形界面，只提供纯文本控制台环境的服务器上，它将是运行期定位虚拟机性能问题的首选工具。</p>
<p>命令格式：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstat <span class="comment">[options vmid <span class="comment">[interval<span class="comment">[s|ms]</span> <span class="comment">[count]</span>]</span> ]</span></span><br></pre></td></tr></table></figure>
<p>假如我想监控gc，每250ms查询一次，一共查询20次，进程号为1234。命令就是:<code>jstat -gc 1234 250 20</code>。如何监控远程机器呢？很简单，使用jstatd。和mysql类似，mysql是客户端，mysqld是服务器端。所以当远程机器开始了jstatd，就相当于开启了远程虚拟机进程的监控，本地可通过RMI查看远程机器的运行时数据，非常方便。</p>
<p>在这里，option主要分为3类：</p>
<ol>
<li>类装载</li>
<li>垃圾收集</li>
<li>运行期编译状况</li>
</ol>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-class</td>
<td>监视类装载、卸载数量、总空间及类装载所耗费的时间</td>
</tr>
<tr>
<td>-gc</td>
<td>监视Java堆状况，包括Eden区、2个survivor区、老年代、永久代等的容量、已用空间、GC时间合计等信息</td>
</tr>
<tr>
<td>-gccapacity</td>
<td>监视内容与-gc基本相同，但输出主要关注Java堆各个区域使用到的最大和最新空间</td>
</tr>
<tr>
<td>-gcutil</td>
<td>监视内容与-gc基本相同，但输出主要关注已使用空间占总空间的百分比</td>
</tr>
<tr>
<td>-gccause</td>
<td>监视内容与-gc基本相同，但会额外输出导致上一次GC产生的原因</td>
</tr>
<tr>
<td>-gcnew</td>
<td>监视新生代GC状况</td>
</tr>
<tr>
<td>-gcnewcapacity</td>
<td>监视内容与-gcnew基本相同，输出主要关注使用到的最大和最小空间</td>
</tr>
<tr>
<td>-gcold</td>
<td>监视老年代GC的状况</td>
</tr>
<tr>
<td>-gcoldcapacity</td>
<td>监视内容与-gcold基本相同，输出主要关注使用到的最大和最小空间</td>
</tr>
<tr>
<td>-gcpermcapacity</td>
<td>输出永久代使用到的最大和最小空间</td>
</tr>
<tr>
<td>-compiler</td>
<td>输出JIT编译期编译过的方法、耗时等信息</td>
</tr>
<tr>
<td>-printcomplilation</td>
<td>输出已经被JIT编译的方法</td>
</tr>
</tbody>
</table>
<h3 id="jinfo：Java配置信息工具">jinfo：Java配置信息工具</h3><p>jinfo全称为Configuration Info for Java，它的作用是<strong>实时地查看和调整虚拟机的各项参数</strong>。</p>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jinfo [ <span class="keyword">option</span> ] pid</span><br></pre></td></tr></table></figure>
<p>使用jps命令的-v参数可以查看虚拟机启动时显式指定的参数列表，但如果想知道未被显式指定的参数的系统默认值，除了去找资料外，就只能使用jinfo的-flag选项进行查询了（如果只限于JDK1.6或以上版本的话，使用java -XX:+PrintFlasFinal查看参数默认值也是一个很好的选择），jinfo还可以使用-sysprops选项把虚拟机进程的System.getProperties()的内容打印出来。可以使用-flag [+-] name或-flag name=value修改一部分运行期可写的虚拟机参数值。</p>
<h3 id="jmap：Java内存映像工具">jmap：Java内存映像工具</h3><p>jmap全称为Memory Map for Java，它<strong>用于生成堆转储快照（一般称为heap dump或者dump文件）</strong>。jmap的作用并不仅仅是为了获取dump文件供其他工具分析当前JVM的内存情况，它还可以<strong>查询finalize执行队列，Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等</strong>。它的命令格式为：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jmap [ <span class="keyword">option</span> ] vmid</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-dump</td>
<td>生成java堆转储快照。格式为：-dump:[live,]format=b,file=<filename>，其中live子参数说明是否只dump出存活的对象</filename></td>
</tr>
<tr>
<td>-finalizerinfo</td>
<td>显示在F-Queue中等待Filalizer线程执行finalize方法的对象，只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-heap</td>
<td>显示java堆详细信息，如使用哪种回收器、参数配置、分代状况等，只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-histo</td>
<td>显示堆中统计信息，包括类、实例数量和合计容量</td>
</tr>
<tr>
<td>-permstat</td>
<td>以ClassLoader为统计口径显示永久代内存状态。只在Linux/Solaris平台下有效</td>
</tr>
<tr>
<td>-F</td>
<td>当虚拟机进程对-dump选项没有响应时，可使用这个选项强制生成dump快照。只在Linux/Solaris平台下有效</td>
</tr>
</tbody>
</table>
<p>比如我得到dump快照，就可以先通过jps拿到虚拟机的LVMID，然后使用<code>jmap -dump:format=b,file=haha.bin &lt;LVMID&gt;</code>就可以了。</p>
<h3 id="jhat：虚拟机堆转储快照分析工具">jhat：虚拟机堆转储快照分析工具</h3><p>jhat命令与jmap搭配使用，来分析jmap生成的堆转储快照。jhat内置了一个微型的http/html服务器，生成dump文件的分析结果后，可以在浏览器中查看。但一般情况下，这个命令使用的几率不会太大。首先对于线上服务器来说，生成dump快照后，分析快照是一个很耗时且吃硬件的过程，如果dump快照过于复杂，甚至会影响线上服务；其次jhat的分析功能相对来说比较简陋。建议是将这个dump快照拷贝到线下，然后使用更强大的GUI工具来直观分析，比如Eclipse Memory Analyzer、IBM HeapAnalyzer等工具。</p>
<p>如果打开后，可以在本地localhost:7000查看结果。拉到最下面有个Heap Histogram，点进去就可以看到虚拟机中所有对象实例的数目和大小。</p>
<h3 id="jstack：Java堆栈跟踪工具">jstack：Java堆栈跟踪工具</h3><p>jstack全称为Stack Trace for Java，它<strong>用于生成虚拟机当前时刻的线程快照（一般称为threaddump或者javacore文件）。线程快照就是当前虚拟机内存每一个线程正在执行的方法堆栈的集合</strong>。生成线程快照的主要目的就是<strong>定位线程出现长时间停顿的原因</strong>，比如线程间死锁、死循环、请求外部资源导致的长时间等待都是导致线程长时间停顿的常见原因。</p>
<p>命令格式：</p>
<figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jstack [ <span class="keyword">option</span> ] vmid</span><br></pre></td></tr></table></figure>
<p>option选项说明如下：</p>
<table>
<thead>
<tr>
<th>选项</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>-F</td>
<td>当正常输出的请求不被响应时，强制输出线程堆栈</td>
</tr>
<tr>
<td>-l</td>
<td>除堆栈外，显示关于锁的附加信息</td>
</tr>
<tr>
<td>-m</td>
<td>如果调用到本地方法的话，可以显示C/C++的堆栈</td>
</tr>
</tbody>
</table>
<p>在JDK 1.5中，java.lang.Thread类新增了一个叫做getAllStackTraces()方法用于获取虚拟机中所有线程的StackTraceElement对象，使用这个方法可以通过简单的几行代码就完成jstack的大部分功能。</p>
<h3 id="JDK的可视化工具">JDK的可视化工具</h3><p>JDK除了提供大量的命令行工具外，还提供了两个功能强大的可视化工具：JConsole和VisualVM，这两个工具是JDK的正式成员</p>
<p>其实现在Sun主推VisualVM了，因为JConsole稍微有点老。而且可视化工具基本不需要学习，稍微看看就知道啥情况。说白了就是把上面的jdk工具，比如jstat、jmap、jstack结果套个GUI。</p>
<p>其中看了感觉比较有价值的是BTrace这个插件，它竟然可以动态的在项目中插入调试信息</p>
]]></content>
    <summary type="html">
    <![CDATA[深入理解Java虚拟机; JVM性能监控与故障处理工具;]]>
    
    </summary>
    
      <category term="JVM" scheme="http://howiefh.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解Java虚拟机笔记二（垃圾收集器与内存分配策略）]]></title>
    <link href="http://howiefh.github.io/2015/04/08/jvm-note-2/"/>
    <id>http://howiefh.github.io/2015/04/08/jvm-note-2/</id>
    <published>2015-04-08T14:40:22.000Z</published>
    <updated>2015-08-17T08:11:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="概述">概述</h2><p>程序计数器、虚拟机栈、本地方法栈这些区域不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。垃圾收集器关注的是堆和方法区中的垃圾。</p>
<a id="more"></a>
<h2 id="对象已死吗">对象已死吗</h2><h3 id="引用计数器">引用计数器</h3><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。</p>
<p>这种计数法无法解决循环引用的问题</p>
<h3 id="可达性分析算法">可达性分析算法</h3><p>通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的。</p>
<p>在Java语言中，可作为GC Roots的对象包括下面几种：</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li>
</ul>
<h3 id="再谈引用">再谈引用</h3><p>在Java1.2之前，引用的定义是这样的：</p>
<blockquote>
<p>如果reference类型的数据中存储的数值代表的是另外一块内存中的起始地址，就称这块内存代表着一个引用。</p>
</blockquote>
<p>我们可以看到，这个引用的定义是非常狭隘的，和指针类似，只有引用、非引用区分。所以，在JAVA1.2以后提出了新的引用定义：</p>
<ul>
<li>强引用：在代码中普遍存在的，类似<code>Object obj = new Object();</code>。只要强引用还存在，垃圾回收期就永远不会回收被引用的对象</li>
<li>软引用：用来描述一些还有用，但并非必须的对象。这样当系统要发生内存溢出异常之前，就会把软引用列进第二次垃圾回收的计划中。SoftReference</li>
<li>弱引用：比软引用还弱的引用，被弱引用的对象只能存活到下一次垃圾回收之前。WeakReference</li>
<li>虚引用：最弱的一种引用关系了。使用虚引用的唯一目的就是在这个对象回收前收到一个系统回收通知。PhantomReference</li>
</ul>
<p>《Java编程思想》中也有相关<a href="http://howiefh.github.io/2014/10/30/thinking-in-java-note-5/#持有引用">内容</a></p>
<h3 id="生存还是死亡">生存还是死亡</h3><p>即使是不可达对象，也并非是非死不可的，这时候它们暂时处于”缓刑“阶段，真正宣告一个对象死亡，至少要经过<strong>两次标记过程</strong>：</p>
<p>如果对象在进行根搜索后发现跟root不同根，就被标记一次，同时进行筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize()方法，或者finalize()已经被JVM调用过（说明一个对象的finalize()方法只能执行一次），JVM会将这两种情况视为“没有必要执行”。如果这个对象有必要执行finalize()方法，JVM就会把它放在F-Queue中，稍后JVM会触发一个低优先级的线程去执行。<strong>但是去执行并并不承诺会等待它运行结束，因为如果一个对象在finalize()方法中执行缓慢，甚至发生了死循环，就会导致F-Queue其他对象永久处于等待状态，更严重的话可能会拖垮整个内存回收系统。</strong>finalize()是对象逃脱死亡命运的最后一次机会，稍后GC将会对F-Queue进行第二次小规模的标记，如果在finalize()中将自己和root挂在一个根上（比如把自己赋值给某个类变量或者对象的成员变量），那么在这第二次标记将会被移除出“即将回收的集合”：如果对象还没有逃脱，那么就基本上真的被回收了。</p>
<p><img src="http://fh-1.qiniudn.com/gc_mark.png" alt="两次标记过程"></p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"haha, i'm still alive!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span>(<span class="params"></span>) throws Throwable </span>&#123;</span><br><span class="line">        super.finalize();</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) throws Throwable </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第一次拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第二次拯救自己，但是却跪了。因为finalize只能执行一次呀，亲！！</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>) &#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"5555, i'm dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;<span class="comment">/*output:</span><br><span class="line">finalize method executed!</span><br><span class="line">haha, i'm still alive!</span><br><span class="line">5555, i'm dead!</span><br><span class="line">*/</span></span><br></pre></td></tr></table></figure>
<p>我们可以清楚的看到，第一次在finalize()中赋值给类变量，所以和root同根自救了一次，但是因为finalize()只会执行一次，所以第二次标记时，JVM发现已经调用这个对象的finalize()，就知道没必要再执行finalize了，然后就被回收了。</p>
<p>作者非常不推荐使用finalize()方法自救对象，因为这是Java刚诞生为了使C/C++程序员更容易接受它作的一个妥协。它的运行带价高昂，不确定性大，无法保证各个对象的调用顺序。<strong>有些教材中提到它使用“关闭外部资源”之类的工作，这完全是对这种方法的用途的一种自我安慰。finalize()能做的所有工作，使用try-finally或其他方法都可以做的更好、更及时，完全可以忘掉Java有finalize()。</strong></p>
<h3 id="方法回收区">方法回收区</h3><p>Java虚拟机规范中确实说过可以不要求虚拟机在方法区实现垃圾回收，主要是因为在方法区进行垃圾回收的“性价比”很低：在堆中，尤其是在新生代中，常规应用进行一次垃圾回收一般可以回收70%-95%的空间，而永久代的垃圾回收效率也远低于此。</p>
<p>永久代的垃圾收集主要回收两部分内容：</p>
<ul>
<li>废弃常量：以常量池中字面量的回收为例，假如一个字符串“abc”已经进入了常量池中，但是当前系统没有任何一个String对象是叫做“abc”的，换句话说，就是没有任何String对象引用常量池中的“abc”常量，也没有其他地方引用了这个字面量，如果这时发生内存回收，而且必要的话，这个“abc”常量就会被系统清理出常量池。常量池中的其他类（接口）、方法、字段的符号引用也与此类似。</li>
<li><p>无用的类：判断一个类是无用的类，条件比废弃变量要苛刻的多，要同时满足下面3个条件才能算是“无用的类”：</p>
<ol>
<li>该类所有的实例都已经被回收，意思是堆上没有该对象的实例了</li>
<li>加载该类的ClassLoader已经被回收</li>
<li>该类对象的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法（因为通过反射，就一定要加载该类）</li>
</ol>
</li>
</ul>
<p>在大量使用反射、动态代理、CGLib等ByteCode框架、动态生成JSP以及OSGi这类频繁自定义ClassLoader的场景都需要虚拟机具备类卸载的功能，以保证永久代不会溢出。</p>
<h2 id="垃圾收集算法">垃圾收集算法</h2><ul>
<li>标记-清除算法：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，它的标记过程其实在前一节讲述对象标记判定时已经介绍过了。有两个问题：一是效率不高；而是会产生内存碎片，当需要大的连续内存空间时，即使碎片内存总和远大于需求，也会触将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。实现简单，运行高效，但是空间缩小为原来的一半了。<strong>现在的商业JVM采用这种算法来回收新生代，IBM经过调研发现，新生代的对象98%都是朝生夕死的，所有并不需要按照1：1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和和两块较小的Survivor空间，每次使用Eden和其中的一块Survivor。</strong>当回收时，将Eden和Survivor还存活着的对象一次性拷贝到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor的空间。<strong>HotSpot虚拟机默认Eden和Survivor的大小比例是8：1</strong>，也就是每次新生代中可用内存空间为整个内存空间的9/10，只有10%的内存是用来浪费的。当然了，我们无法保证每次回收只有少于10%的对象存活，当存活对象大于10%，就会借用其他内存（这里指老年代）进行分配担保。分配担保就相当于现实生活中的担保。</li>
<li>标记-整理算法：标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。（老年代就是采用这个方法）</li>
<li>分代收集算法：当前商业虚拟机的垃圾回收都采用分代收集算法，这种算法没有啥特别的，就是<strong>根据对象的存活周期的不同将内存划分为几块</strong>，一般是把Java堆分为新生代和老年代，这样就可以根据每个代不同的特点采用最适当的回收算法。比如新生代存活对象少，就采用Eden-Survivor复制算法；老年代存活对象少，复制的话代价太大，就可以采用标记-整理算法。</li>
</ul>
<p>总结：<br>标记-清除：简单，效率低，有内存碎片<br>复制：新生代，实现简单，运行高效，空间利用率低<br>标记-整理：老年代</p>
<h2 id="HotSpot_的算法实现">HotSpot 的算法实现</h2><h3 id="枚举根节点">枚举根节点</h3><p>可达性分析在逐个检查引用链和GC停顿（保证分析工作的一致性）上浪费时间较多。主流Java虚拟机使用的都是准确式GC，虚拟机应当有办法直接得知哪些地方存放着对象的引用。HotSpot是通过一个OopMap的数据结构来达到这个目的的。在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。</p>
<h3 id="安全点">安全点</h3><p>HotSpot没有为每条指令都生成OopMap，那样占用空间太多，前面已经提到，只是在“特定的位置”记录了这些信息，这些位置称为安全点（Safepoint），即程序执行时并非在所有地方都能停顿下来开始GC，只有在到达安全点时才能暂停。Safepoint的选定既不能太少以致于让GC等待时间太长，也不能过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p>
<p>另一个问题是如何让所有线程都跑到最近的安全点停顿。这里有两种方案可供选择：<strong>抢先式中断（Preemptive Suspension）和主动式中断（Voluntary Suspension）</strong>，其中抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。而主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。</p>
<h3 id="安全区域">安全区域</h3><p>如果线程没有在执行呢，比如线程处于Sleep状态或者Blocked状态，就需要安全区域解决了。安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。</p>
<p>在线程执行到Safe Region中的代码时，首先标识自己已经进入了Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为Safe Region状态的线程了。在线程要离开Safe Region时，它要检查系统是否已经完成了根节点枚举（或者是整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开Safe Region的信号为止。</p>
<h2 id="垃圾收集器">垃圾收集器</h2><p><img src="http://fh-1.qiniudn.com/hotspot_gc.jpg" alt="HotSpot虚拟机的垃圾收集器"></p>
<h3 id="Serial收集器">Serial收集器</h3><p>最基本，历史最悠久。新生代的，单线程的，只会用一个CPU或一个线程工作，并且收集时，必须暂停所有的工作线程，直到收集结束。它依然是虚拟机运行在Client端的默认新生代收集器。简单而高效，因为它不需要考虑线程切换，只专注一次把收集工作搞定，而且在Client端，新生代的内存一般只有几十M或者一两百M的样子，完成一次收集工作完全可以控制在几十毫秒或者一百毫秒左右，不会有很大的停顿感。</p>
<h3 id="ParNew收集器">ParNew收集器</h3><p>这个本质上就是Serial收集器的多线程版本。许多运行在Server模式下的虚拟机中首选的<strong>新生代收集器</strong>，其中还有一个与性能无关<strong>但很重要的原因是：除了Serial收集器外，目前只有它能与CMS收集器配合工作</strong>。（原因是Parallel Scavenge收集器和后面的G1收集器都没有使用传统的GC收集器代码框架，而是另外独立实现的，其余几种收集器则共用了框架代码）。ParNew收集器也是使用<code>-XX:+UseConcMarkSweepGC</code>选项后的默认新生代收集器，当然也可以使用<code>-XX:+UseParNewGC</code>选项来显式指定使用</p>
<p>单CPU的话一般会考虑用Serial，多CPU的话一般考虑用ParNew，<strong>它默认开启的收集器线程数和CPU核数相同，当你想控制的时候，可以使用```-XX:ParallelGCThreads参数来限制收集器的线程数。</strong></p>
<p>然后提前解释一下<strong>并行</strong>和<strong>并发</strong>的概念，因为后面会有几个并发和并行的收集器：</p>
<ul>
<li>并行(Parallel)：指多条垃圾收集线程并行工作，<strong>但此时用户线程仍然处于等待状态</strong>。所以，遇到 Parallel 关键字的话，都是并行。所以当它们工作的时候，用户线程是阻塞的。所以也是 stop the world</li>
<li>并发(Concurrent)：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会根据时间片轮转交替进行），用户程序继续运行，而垃圾收集程序运行在另外一个CPU上。所以遇到 concurrent 关键字就是 GC 线程和用户线程在一段时间内交叉运行，不会将用户线程阻塞，不是 stop the world</li>
</ul>
<h3 id="Parallel_Scavenge收集器">Parallel Scavenge收集器</h3><p>Parallel Scavenge也是<strong>一个新生代收集器</strong>，它也是<strong>使用复制算法</strong>的收集器，同时也是<strong>并行的多线程收集器</strong>。它的目标是达到可控制的CPU吞吐量。所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即吞吐量=运行用户代码时间/（运行用户代码时间+垃圾回收时间）。比如虚拟机运行了100分钟，垃圾回收使用了1分钟，那么吞吐量就是99%。</p>
<p>这就说说一下应用场景了。</p>
<ul>
<li>停顿时间（垃圾回收时间）： 停顿时间越短越适合于用户交互的程序，良好的响应速度能提升用户体验</li>
<li>高吞吐量： 可以最高效率的利用CPU时间，尽快的完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务</li>
</ul>
<p>为了这两个目的，Parallel Scavenge收集器提供了2个参数：</p>
<ul>
<li>-XX:MaxGCPauseMillis:大于0的毫秒数，收集器将尽力保证内存回收时间不超过这个值。不过不要异想天开认为把这个值设的特别小，就能使系统垃圾收集速度更快，GC停顿时间缩短肯定是有代价的，它会牺牲吞吐量和新生代空间来实现。</li>
<li>-XX:GCTimeRatio:大于0小于100的整数.假如设为N，那么垃圾收集时间占总时间的比率就是1/(1+N),比如设置为19,占比就是1/(1+19)=5%，默认值是99，即1%。</li>
<li>-XX:+UseAdaptiveSizePolicy:这也是一个有用的参数，放在这里说一下。它是一个开关参数，当这个参数打开之后，就不需要手工指定新生代的大小(-Xmn)、Eden、Survivor区的比例(-XX:SurvivorRatio)、晋升老年代对象年龄(-XX:PretenureSizeThreshold)等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以一同最合适的停顿时间或最大的吞吐量，这种调节方式称为GC自适应的调节策略（GC Ergonomics）。<strong>自适应调节策略也是Parallel Scavenge收集器和ParNew收集器的一个重要区别</strong></li>
</ul>
<h3 id="Serial_Old_收集器">Serial Old 收集器</h3><p>Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记-整理“算法。这个收集器的主要意义就是被Client模式下的虚拟机使用。如果在Server模式下，它还有两大用途：在JDK1.5及之前的版本中与Parallel Scavenge收集器搭配使用；另外一个就是CMS的后备预案，在并发收集发生Concurrent Mode Failure的时候使用。</p>
<h3 id="Parallel_Old收集器">Parallel Old收集器</h3><p>Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和标记-整理算法。是在JDK 1.6之后才提供的。前面说过，Parallel Scavenge收集器采用了独立的架构，无法和CMS配合使用。那么，在JDK 1.6以前，Parallel Scavenge只能和Serial Old配合使用。因为Serial Old是单线程的，所以在多CPU情况下无法发挥性能，所以根本实现不了高吞吐量的需求，直到JDK 1.6推出了Parallel Old之后，Parallel Scavenge收集器和Parallel Old搭配，才真正实现了对吞吐量优先的控制。所以，<strong>在注重吞吐量及CPU资源敏感的场合，都可以考虑Parallel Scavenge和Parallel Old组合</strong>。</p>
<h3 id="CMS（Comcurrent_Mark_Sweep）收集器">CMS（Comcurrent Mark Sweep）收集器</h3><p>CMS收集器是<strong>以获取最短回收停顿时间为目标的收集器</strong>。目前很大一部分的Java应用都集中在互联网站或者B/S系统上，这类应用<strong>尤其重视服务的响应速度，希望系统停顿时间最短，给用户最佳的用户体验。而CMS收集器就非常符合这类应用的需求</strong></p>
<p>从名字上可以看出，”Mark Sweep“是基于标记-清除算法实现的，它的运作过程相对于前面几种收集器来说要更复杂一些，整个过程分为4个步骤：</p>
<ol>
<li>初始标记(stop the world):初始标记仅仅只是标记一下GC roots能直接关联到的对象，速度很快</li>
<li>并发标记:并发标记就是进行GC Roots Tracing的过程</li>
<li>重新标记(stop the world):重新标记则是为了修正并发标记期间，因用户程序继续运作而导致标记产生变化的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍微长一些，但远比并发标记的时间短</li>
<li>并发清除:垃圾清除</li>
</ol>
<p>由于整个过程中，并发标记和并发清除时间最长，收集器线程可以和用户线程一起工作，所以从总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。</p>
<p>CMS收集器的优点在于<strong>并发收集、低停顿</strong>，但是也不是完美的，主要有3个显著的缺点：</p>
<ol>
<li>CMS收集器对CPU资源非常敏感。默认情况下，CMS的收集线程数=(CPU数目+3)/4，当CPU个数大于4的时候，CMS的收集线程不会超过整个CPU占用率的25%。但是在CPU个数比较小的情况下，CPU占用就会突然增大，这样对于初始标记和并发标记这样”Stop The World”的过程来说，用户就会明显感觉到停顿。虽然有了解决方法，但已经废除了，就不多说了。</li>
<li><strong>CMS收集器无法处理浮动垃圾，可能出现”Concurrent Mode Failure”失败而导致另一次Full GC的产生</strong>。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法在当次收集中处理掉它们，只好留待下一次GC时再清理掉。这一部分垃圾就称为“浮动垃圾”。CMS收集器不能像其他收集器那样等到老年代几乎完全被填满了再进行收集，它<strong>需要预留一部分空间提供并发收集时的线程使用。在JDK1.5默认设置下，CMS收集器在老年代使用了68%的空间会被激活，这是一个偏保守的设置。</strong>如果在应用中，老年代增长不是太快，可以适当调高这个参数-XX:CMSInitiatingOccupancyFraction。要是CMS运行期间预留的内存无法满足程序的需要，就会出现”Concurrent Mode Failure”失败，这时候JVM会启动后备方案：临时启动Serial Old收集器来重新进行老年代的垃圾收集，因为是单线程，停顿时间就会更长了。所以如果大量出现”Concurrent Mode Failure”，就可以将这个值调低</li>
<li>CMS是基于<strong>标记-清除</strong>算法实现的收集器，所以会产生内存碎片。空间碎片过多时，将会给大对象分配带来很大的麻烦：老年代还有空间但是没有连续的足够大的空间，于是不得不触发一次Full GC。为了解决这个问题，有一个开关叫做-XX:+UseCMSCompactAtFullCollection，用于在Full GC时开启内存碎片的合并整理过程。当然，这个内存整理没法并发，只有”Stop The World”了。另外，虚拟机还设计了一个参数-XX:CMSFullGCsBeforeCompaction,用于指定在多少次不压缩的Full GC后，跟着来一次带压缩的。</li>
</ol>
<h3 id="G1收集器">G1收集器</h3><p>G1是一款面向服务端应用的垃圾收集器。与其他GC收集器相比，G1具备如下特点。</p>
<p>并行与并发：G1能充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿的时间，部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让Java程序继续执行。<br>分代收集：与其他收集器一样，分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果。<br>空间整合：与CMS的“标记—清理”算法不同，G1从整体来看是基于“标记—整理”算法实现的收集器，从局部（两个Region之间）上来看是基于“复制”算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片，收集后能提供规整的可用内存。这种特性有利于程序长时间运行，分配大对象时不会因为无法找到连续内存空间而提前触发下一次GC。<br>可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同的关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒，这几乎已经是实时Java（RTSJ）的垃圾收集器的特征了。</p>
<p>G1收集器的运作大致可划分为以下几个步骤：</p>
<p>初始标记（Initial Marking）<br>并发标记（Concurrent Marking）<br>最终标记（Final Marking）<br>筛选回收（Live Data Counting and Evacuation）</p>
<p>总结：</p>
<p>Serial收集器：新生代；复制算法；单线程；GC区域名称(GCLogging)：DefNew；优点：简单高效，Client模式下的默认新生代收集器；缺点：进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。“Stop The World”。<br>ParNew收集器：新生代；复制算法；多线程；GC区域名称(GCLogging)：ParNew；优点：Server模式下的虚拟机中首选的新生代收集器。除了Serial收集器外，目前只有它能与CMS收集器配合工作；缺点：在单CPU的环境中绝对不会有比Serial收集器更好的效果<br>Parallel Scavenge收集器：新生代；复制算法；多线程；GC区域名称(GCLogging)：PSYoungGen；优点：吞吐量优先。缺点：无法与CMS配合使用<br>Serial Old收集器：老年代；标记-整理算法（Mark-Compact）；单线程；<br>GC区域名称(GCLogging)：Tenured；优点：与Parallel Scavenge配合；作为CMS的后备方案。缺点：性能较低<br>Parallel Old收集器：老年代；标记-整理算法（Mark-Compact）；多线程；GC区域名称(GCLogging)：ParOldGen；优点：与Parallel Scavenge配合，真正成为吞吐量优先的收集器组合。在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。<br>CMS收集器：老年代；标记-清楚算法（Mark-Sweep）；多线程；GC区域名称(GCLogging)：ParOldGen；优点：响应速度快、停顿时间短。；缺点：1.对CPU资源敏感；2.无法处理浮动垃圾，因为GC标记和用户线程并发运行着；3.空间碎片多<br>G1：新生代，老年代；标记-整理，复制；多线程；优点：并行与并发，分代收集，空间整合，可预测的停顿</p>
<h2 id="理解GC日志">理解GC日志</h2><figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">33.125</span>: [GC [DefNew: <span class="number">3324</span><span class="keyword">K</span>-&gt;<span class="number">152</span><span class="keyword">K</span>(<span class="number">3712</span><span class="keyword">K</span>), <span class="number">0.0025925</span> secs] <span class="number">3324</span><span class="keyword">K</span>-&gt;<span class="number">152</span><span class="keyword">K</span>(<span class="number">11904</span><span class="keyword">K</span>), <span class="number">0.0031680</span> secs]<span class="number">100.667</span>: [<span class="keyword">Full</span> GC [Tenured: <span class="number">0</span><span class="keyword">K</span>-&gt;<span class="number">210</span><span class="keyword">K</span>(<span class="number">10240</span><span class="keyword">K</span>), <span class="number">0.0149142</span> secs] <span class="number">4603</span><span class="keyword">K</span>-&gt;<span class="number">210</span><span class="keyword">K</span>(<span class="number">19456</span><span class="keyword">K</span>), [Perm : <span class="number">2999</span><span class="keyword">K</span>-&gt;<span class="number">2999</span><span class="keyword">K</span>(<span class="number">21248</span><span class="keyword">K</span>)], <span class="number">0.0150007</span> secs] [<span class="keyword">Times</span>: user=<span class="number">0.01</span> sys=<span class="number">0.00</span>, real=<span class="number">0.02</span> secs]</span><br></pre></td></tr></table></figure>
<p>最前面的数字“33.125：”和“100.667：”代表了GC发生的时间，这个数字的含义是从Java虚拟机启动以来经过的秒数。</p>
<p>GC日志开头的“[GC”和“[Full GC”说明了这次垃圾收集的停顿类型，而不是用来区分新生代GC还是老年代GC的。如果有“Full”，说明这次GC是发生了Stop-The-World的，例如下面这段新生代收集器ParNew的日志也会出现“[Full GC”（这一般是因为出现了分配担保失败之类的问题，所以才导致STW）。如果是调用System.gc()方法所触发的收集，那么在这里将显示“[Full GC（System）”。</p>
<p>接下来的“[DefNew”、“[Tenured”、“[Perm”表示GC发生的区域，这里显示的区域名称与使用的GC收集器是密切相关的</p>
<p>后面方括号内部的“3324K-&gt;152K（3712K）”含义是“GC前该内存区域已使用容量-&gt;GC后该内存区域已使用容量（该内存区域总容量）”。而在方括号之外的“3324K-&gt;152K（11904K）”表示“GC前Java堆已使用容量-&gt;GC后Java堆已使用容量（Java堆总容量）”。</p>
<p>再往后，“0.0025925 secs”表示该内存区域GC所占用的时间，单位是秒。有的收集器会给出更具体的时间数据，如“[Times：user=0.01 sys=0.00，real=0.02 secs]”，这里面的user、sys和real与Linux的time命令所输出的时间含义一致</p>
<h3 id="垃圾收集器参数总结">垃圾收集器参数总结</h3><table>
<thead>
<tr>
<th>参数</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>UseSerialGC</td>
<td>虚拟机运行在Client模式下的默认值，打开此开关后，使用Serial+Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseParNewGC</td>
<td>打开此开关后，使用ParNew+Serial Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseConcMarkSweepGC</td>
<td>打开此开关后，使用ParNew+CMS+Serial Old的收集器组合进行内存回收。Serial Old收集器将作为CMS收集器出现Concurrent Mode Failure失败后的后壁收集器使用</td>
</tr>
<tr>
<td>UseParallelGC</td>
<td>虚拟机运行在Server模式下的默认值，打开此开关后，使用Parallel Scavenge+Serial Old（PS MarkSweep）的收集器组合进行内存回收</td>
</tr>
<tr>
<td>UseParallelOldGC</td>
<td>打开此开关后，使用Parallel Scavenge+Parallel Old的收集器组合进行内存回收</td>
</tr>
<tr>
<td>SurvivorRatio</td>
<td>新生代中Eden区域与Survivor区域的容量比值，默认为8，代表Eden:Survivor=8:1</td>
</tr>
<tr>
<td>PretenureSizeThreshold</td>
<td>直接晋升到老年代的对象大小，设置这个参数后，大于这个参数的对象将直接在老年代分配</td>
</tr>
<tr>
<td>MaxTenuringThreshold</td>
<td>晋升到老年代的对象年龄。每个对象在坚持过一次Minor GC之后，年龄加1，当超过这个参数值时就进入老年代</td>
</tr>
<tr>
<td>UseAdaptiveSizePolicy</td>
<td></td>
</tr>
</tbody>
</table>
<p>动态调整Java堆中各个区域的大小以及进入老年代的年龄<br>HandlePromotionFailure | 是否允许分配担保失败，即老年代的剩余空间不足以应对新生代的整个Eden和Survivor区的所有对象都存活的极端情况<br>ParallelGCThreads |  设置并行GC时进行内存回收的线程数<br>GCTimeRatio | GC时间占总时间的比率，默认值为99，即允许1%的GC时间。仅在使用Parallel Scavenge收集器时生效<br>MaxGCPauseMillis   | 设置GC的最大停顿时间。仅在使用Parallel Scavenge收集器时生效<br>CMSinitiatingOccupancyFraction | 设置CMS收集器在老年代空间被使用多少后出发垃圾收集。默认值为68%，仅在使用CMS收集器时生效<br>UseCMSCompactAtFullCollection  | 设置CMS收集器在完成垃圾收集后是否要进行一次内存碎片整理。仅在使用CMS收集器时生效<br>CMSFullGCsBeforeCompaction | 设置CMS收集器在进行若干次垃圾收集后再启动一次内存碎片整理。仅在使用CMS收集器时生效</p>
<h2 id="内存分配与回收策略">内存分配与回收策略</h2><p>对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中。</p>
<h3 id="对象优先在Eden分配">对象优先在Eden分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<p>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>
<p>老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p>
<p>请看下面例子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@VM</span> param -XX:+UseSerialGC -Xms20M -Xmx20M -Xmn10M -XX:+PrintGCDetails -XX:SurvivorRatio=8</span><br><span class="line"> *</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestEdenAllocation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] alloc1, alloc2, alloc3, alloc4;</span><br><span class="line"></span><br><span class="line">        alloc1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        alloc2 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        alloc3 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">2</span> * _1MB];</span><br><span class="line">        alloc4 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span> * _1MB];</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先看vm的参数：</p>
<p>-XX:+UseSerialGC： 保证使用Serial/SerialOld收集器作为例子<br>-Xms20M -Xmx20M -Xmn10M： 限制堆为20M，10M新生代10M老年代<br>-XX:SurvivorRatio=8： 新生代Eden区与一个Survivor区比例8:1<br>-XX:+PrintGCDetails： 收集器日志参数</p>
<p>输出如下：</p>
<p>[GC[DefNew: 6817K-&gt;484K(9216K), 0.0038248 secs] 6817K-&gt;6628K(19456K), 0.0038598 secs] [Times: user=0.00 sys=0.00, real=0.00 secs]<br>Heap<br> def new generation   total 9216K, used 5072K [0x00000000f9a00000, 0x00000000fa400000, 0x00000000fa400000)<br>  eden space 8192K,  56% used [0x00000000f9a00000, 0x00000000f9e7af60, 0x00000000fa200000)<br>  from space 1024K,  47% used [0x00000000fa300000, 0x00000000fa379110, 0x00000000fa400000)<br>  to   space 1024K,   0% used [0x00000000fa200000, 0x00000000fa200000, 0x00000000fa300000)<br> tenured generation   total 10240K, used 6144K [0x00000000fa400000, 0x00000000fae00000, 0x00000000fae00000)<br>   the space 10240K,  60% used [0x00000000fa400000, 0x00000000faa00030, 0x00000000faa00200, 0x00000000fae00000)<br> compacting perm gen  total 21248K, used 2519K [0x00000000fae00000, 0x00000000fc2c0000, 0x0000000100000000)<br>   the space 21248K,  11% used [0x00000000fae00000, 0x00000000fb075e08, 0x00000000fb076000, 0x00000000fc2c0000)<br>No shared spaces configured.</p>
<p>分析如下：</p>
<p>分配alloc4时发生一次minorGC，Eden区从6817K减少到484K。由于alloc1、alloc2、alloc3都是存活的所以没有对象可收。<br>这次GC发生的原因是给allo-cation4分配内存的时候，发现Eden已经被占用了6MB，剩余空间已不足以分配allocation4所需的4MB内存，因此发生Minor GC。<br>GC期间虚拟机又发现已有的3个2MB大小的对象全部无法放入Survivor空间（Survivor空间只有1MB大小），所以只好通过分配担保机制提前转移到老年代去。<br>这次GC结束后，4MB的allocation4对象顺利分配在Eden中，因此程序执行完的结果是Eden占用4MB（被allocation4占用），Survivor空闲，老年代被占用6MB（被allocation1、allocation2、allocation3占用）</p>
<h3 id="大对象直接进入老年代">大对象直接进入老年代</h3><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组（笔者列出的例子中的byte[]数组就是典型的大对象）。大对象对虚拟机的内存分配来说就是一个坏消息，经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>
<p>虚拟机提供了一个-XX:PretenureSizeThreshold参数，令大于这个设置值的对象直接在老年代分配。这样做的目的是避免在Eden区及两个Sur-vivor区之间发生大量的内存复制。注意PretenureSizeThreshold参数只对Serial和ParNew两款收集器有效</p>
<h3 id="长期存活的对象将进入老年代">长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数-XX:MaxTenuringThreshold设置。</p>
<h3 id="动态对象年龄判定">动态对象年龄判定</h3><p>虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>
<h3 id="空间分配担保">空间分配担保</h3><p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。</p>
<p>在JDK 6 Update 24之后，HandlePromotionFailure参数不会再影响到虚拟机的空间分配担保策略，规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行Minor GC，否则将进行Full GC。</p>
]]></content>
    <summary type="html">
    <![CDATA[深入理解Java虚拟机; 垃圾收集器与内存分配策略]]>
    
    </summary>
    
      <category term="JVM" scheme="http://howiefh.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解Java虚拟机笔记一（Java内存区域与内存溢出异常）]]></title>
    <link href="http://howiefh.github.io/2015/04/07/jvm-note-1/"/>
    <id>http://howiefh.github.io/2015/04/07/jvm-note-1/</id>
    <published>2015-04-07T15:31:59.000Z</published>
    <updated>2015-08-18T04:52:03.000Z</updated>
    <content type="html"><![CDATA[<h2 id="运行时数据区域">运行时数据区域</h2><p>Java虚拟机在执行Java程序的过程中，会把内存分为不同的数据区域。如下图所示：</p>
<p><img src="http://fh-1.qiniudn.com/jvm_model.jpg" alt="Java虚拟机运行时数据区"></p>
<a id="more"></a>
<h3 id="程序计数器">程序计数器</h3><p>它是一块较小的内存空间，作用可以当做是<strong>当前线程所执行的字节码的行号指示器</strong>。在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一跳需要执行的字节码指令，<strong>分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器</strong>（字节码行号记录器）。</p>
<p>因为java虚拟机的多线程是通过时间片轮转占用cpu，所以一个处理器只会执行一条线程的指令。为了线程切换后能恢复到正确的位置，每个线程都需要一个独立的程序计数器，这样能使各个线程之间的计数器互不影响，独立存储。这类区域为<strong>线程私有内存</strong>。</p>
<ul>
<li>如果线程正在执行一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令地址</li>
<li>如果线程正在执行的是 Native 方法，这个计数器值为空（Undefined）</li>
</ul>
<p><strong>此内存区域是唯一一个在 Java 虚拟机规范中没有规定任何 OOM 情况的区域</strong>。</p>
<h3 id="Java虚拟机栈">Java虚拟机栈</h3><p>Java虚拟机栈也是<strong>线程私有</strong>的，它的生命周期和线程相同。</p>
<p>Java虚拟机栈描述的是<strong>Java方法执行的内存模型</strong>：每个方法被执行的时候都会创建一个栈帧，用于存储局部变量表、操作栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机中从入栈到出栈的过程。调用一个方法时创建新的栈帧并压入栈顶部，方法执行完后，这个栈帧就会弹出栈帧的元素作为这个方法的返回值，并清除这个栈帧，Java栈的栈顶就是当前正在执行的活动栈，也就是当前正在执行的方法，PC寄存器也会指向这个地址。</p>
<p>局部变量表存放了基本数据类型、对象引用和returnAddress类型（指向一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（slot），其余数据类型只占用1个。局部变量表所需的内存空间在编译期间完成分配。</p>
<p>在Java虚拟机规范中，对这个区域规定了两种异常情况：</p>
<ul>
<li><strong>如果线程请求的栈深度太深，超出了虚拟机所允许的深度，就会出现StackOverFlowError（比如无限递归。因为每一层栈帧都占用一定空间，而 Xss 规定了栈的最大空间，超出这个值就会报错）</strong></li>
<li><strong>虚拟机栈可以动态扩展，如果扩展到无法申请足够的内存空间，会出现OOM</strong></li>
</ul>
<h3 id="本地方法栈">本地方法栈</h3><p>本地方法栈与虚拟机栈的作用是非常类似的，区别是<strong>虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native方法服务</strong>。因为虚拟机规范没有对这块有太多规定，所以不同的虚拟机可以自由实现它。有的虚拟机（Sun的HotSpot虚拟机）直接就把<strong>本地方法栈和虚拟机栈合二为一</strong>了。</p>
<h3 id="Java堆">Java堆</h3><p>对于大多数应用来说，Java堆是Java虚拟机所管理的内存中最大的一块，它是<strong>所有线程共享的，在虚拟机启动时候创建</strong>。Java堆唯一的目的就是<strong>存放对象实例（当然还有数组）</strong>，Java堆是垃圾收集器管理的主要区域。堆可分为老年代和新生代，再细分还可以分为Eden空间、From Survivor空间、To Survivor空间等。主流虚拟机都可扩展（-Xmx和-Xms）</p>
<p><strong>如果堆上没有内存可以完成对象实例的分配，并且堆已经达到了最大容量，无法向OS继续申请的时候，就会抛出OOM异常</strong>。</p>
<h3 id="方法区">方法区</h3><p>方法区与Java堆一样，是<strong>所有线程共享</strong>的内存区域，它用于存储<strong>已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码</strong>等数据。</p>
<p>对于习惯在 HotSpot虚拟机上开发部署程序的开发者来说，很多人倾向于把方法区成为“永久代（Perm Generation）”，但<strong>本质上两者并不等价，仅仅是因为 HotSpot 团队选择把 GC 分代收集扩展到方法区，或者说使用永久代来实现方法区而已</strong>，目的是为了让 HotSpot 的垃圾回收器可以像管理 Java 堆一样管理这部分内存，不能再编写这部分内存的内存管理代码。对于其他虚拟机（比如 JRockit、IMB J9）来说，是不存在永久代的概念的。</p>
<p>其实 JVM 规范并没有规定如何实现方法区，但是从目前状况来看：<strong>使用永久代来实现方法区不是一个好的做法。因为这样更容易遇到内存溢出问题（永久代有-XX:MaxPermSize 的上限，而 J9和 Jrockit 只要没有触碰到进程可用内存的上限，例如32位的4GB，就不会出现问题）</strong>，同时有极少数方法（比如 String.intern()，这个函数能直接操纵方法区中的常量池）会因为这个原因在不同虚拟机有不同的表现。因此，HotSpot 团队有了<em>放弃永久代并逐步改为采用 Native Memory 来实现方法区的规划</em>，在目前已经发布的 JDK1.7 的 HotSpot 中，已经把放在永久代的字符串常量池移出。</p>
<p><strong>当方法区无法满足分寸分配需求时，就会抛出OOM异常</strong>。</p>
<h4 id="运行时常量池">运行时常量池</h4><p><strong>方法区的一部分</strong>。class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池(class文件中)，用于存放编译期生成的各种字面量和符号引用，这部分内容将在<strong>类加载后存放到方法区的运行时常量池中</strong>。除了保存Class文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中。</p>
<p>运行时常量池相对于class文件常量池的另外一个重要特性是具备动态性，Java语言并不要求常量一定是在编译期产生，也就是说，并非是预置入class文件中常量池的内容内能进入方法区的运行时常量池，<strong>运行期间也可以将新的常量放入池中，用的比较多是有String.intern()</strong>，可以去看下文档。说的很清楚：</p>
<h3 id="直接内存">直接内存</h3><p><strong>直接内存并不是虚拟机运行时数据区的一部分</strong>，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现。</p>
<p>JDK 1.4中新加入了NIO(NEW Input/Output)类，引入了一种基于通道与缓冲区的I/O方式，可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆里面的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，<strong>因为避免了在Java堆和Native堆中来回复制数据</strong>。</p>
<p>服务器管理员在配置虚拟机参数时，会根据实际内存设置-Xmx等参数信息，但经常忽略直接内存，使得各个内存区域总和大于物理内存限制（包括物理的和操作系统级的限制），从而导致动态扩展时出现OOM。</p>
<h3 id="总结">总结</h3><ul>
<li>程序计数器：行号指示器；空间小，最快；线程私有；不会有OOM</li>
<li>Java虚拟机栈：Java方法执行的内存模型,用于存储局部变量表、操作栈、动态链接、方法出口等信息；线程私有；StackOverFlowError,OOM</li>
<li>本地方法栈：和Java虚拟机栈发挥的作用非常相似，但是市委Native方法服务。</li>
<li>Java堆：存放对象实例；线程共享；OOM</li>
<li>方法区：存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；线程共享；OOM</li>
<li>运行时常量池：方法区的一部分；线程共享；存放编译期生成的各种字面量和符号引用；OOM</li>
<li>直接内存：直接内存并不是虚拟机运行时数据区的一部分，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError异常出现；新NIO利用了直接内存，效率高</li>
</ul>
<h2 id="HotSpot虚拟机对象探秘">HotSpot虚拟机对象探秘</h2><p>探讨Java堆中对象分配、布局和访问的全过程。</p>
<h3 id="对象的创建">对象的创建</h3><ol>
<li>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，就得执行类的加载过程，这个过程在第七章讲了。TODO 添加第七章链接</li>
<li><p>类加载检查过之后，虚拟机就为这个新生对象分配内存。目前有两种做法，使用哪种方式是由 GC 回收器是否带有压缩整理功能决定的：</p>
<ul>
<li>指针碰撞（Bump the Pointer）：假设Java堆中内存是绝对规整的 ，没用过的内存和用过的内存用一个指针划分（<em>需要保证 java 堆中的内存是规整的，一般情况是使用的 GC 回收器有压缩整理功能</em>），分配内存仅仅是将指针向空闲空间那边挪动一段与对象大小相等的距离。假如需要分配8个字节，指针就往后挪8个字节</li>
<li>空闲列表（Free List）：假设Java堆中内存是不规整的，已使用内存和空闲内存交错，虚拟机维护一个列表，记录哪些内存是可用的，分配的时候从列表中遍历，找到合适的内存分配，然后更新列表</li>
</ul>
</li>
<li><p>分配内存过程中还需要解决线程安全问题。 就刚才的一个修改指针操作，就会带来隐患：对象 A 正分配内存呢，突然对象 B 又同时使用了原来的指针来分配 B 的内存。解决方案也有两种：</p>
<ul>
<li>同步处理——实际上虚拟机采用 CAS 配上失败重试来保证更新操作的原子性</li>
<li>把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在 Java 堆中预先分配一小块内存，成为本地线程分配缓存（Thread Local Allocation Buffer，TLAB）。哪个线程要分配内存，就在哪个线程的 TLAB 上分配，用完并分配新的TLAB时，才需要同步锁定（虚拟机是否使用 TLAB，可以通过<code>-XX:+/-UseTLAB</code> 参数来设置）</li>
</ul>
</li>
<li><p>给内存分配了空间之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）。如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。</p>
</li>
<li><p>接下来要对对象进行必要的设置，比如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的 hashcode 值是多少、对象的 GC 分代年龄等信息，这些信息都放在对象头中。</p>
</li>
<li><p>上面的步骤都完成后，从虚拟机角度来看，一个新的对象已经产生了，但是从 Java 程序的视角来看，对象创建才刚刚开始——<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
</li>
</ol>
<h3 id="对象的内存布局">对象的内存布局</h3><p>首先我们要知道的是：<strong>在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header）、实例数据（Instantce Data）、对齐补充（Padding）。</strong></p>
<ol>
<li>对象头（Header）：包含两部分信息。第一部分用于存储对象自身的运行时数据，如 hashcode 值、GC 分代的年龄、锁状态标志、线程持有的锁等，官方称为“Mark Word”。第二部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li>
<li>实例数据（Instance Data）：就是程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</li>
<li>内存对齐，对象的大小必须是8字节的整数倍</li>
</ol>
<h3 id="对象的访问定位">对象的访问定位</h3><ol>
<li>假如代码出现在方法体中，那么Object obj就会存在在<strong>Java虚拟机栈的本地变量表</strong>中，作为一个引用类型数据。</li>
<li>new Object()则存在在<strong>Java堆</strong>上。另外，在Java堆上还必须包含能查找到该对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在<strong>方法区</strong>中。</li>
<li><p>由于引用类型在Java虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式可能不同，主流的有：</p>
<ol>
<li>使用句柄：Java堆中划分一块区域作为句柄池，引用存储的是对象的句柄地址，而句柄中含有对象实例数据和类型数据各自的数据信息</li>
<li>直接指针：引用中直接存储的就是对象的地址，同时还必须包括方法区类型信息的指针</li>
</ol>
</li>
</ol>
<p>下面是对应的图片：</p>
<p><img src="http://fh-1.qiniudn.com/reference_handler.jpg" alt="通过句柄访问对象"><br><img src="http://fh-1.qiniudn.com/direct_reference.jpg" alt="通过直接指针访问对象"></p>
<p>对于引用类型的实现，不同的实现方法有不同的特点：</p>
<ol>
<li>使用句柄：Java堆会划出一块区域作为句柄池，引用中存储的是稳定的句柄地址，而句柄中包含了<strong>对象实例数据（也在Java堆）和类型数据（方法区中）</strong>各自的地址信息。在对象被移动（垃圾回收时移动对象是非常普遍的行为）时只需要改变句柄中的实例数据指针，而引用本身核方法区的类型数据指针都不需要修改</li>
<li>直接指针：速度更快，因为不需要间接寻址。对于效率而言是更好的，Sun HotSpot就是使用这种方式实现对象访问的。但在其他虚拟机中，使用句柄方式也非常常见。</li>
</ol>
<h2 id="实战">实战</h2><p>下面我们会演示几个小程序，目的有两个：</p>
<ol>
<li>通过代码验证Java虚拟机规范中描述的各个运行时区域存储的内容</li>
<li>希望以后遇到类似问题时，能根据异常的信息快速判断是哪个区域的内存溢出，知道怎样的代码可能会导致这些区域的内存溢出，以及出现这些异常后改如何处理</li>
</ol>
<h3 id="Java堆溢出">Java堆溢出</h3><p>这个顾名思义，是最常见的。因为Java堆上存储的是对象实例，所以只要保证GC roots到该对象有路径可达，就会在不断创建对象的过程中达到Java堆的最大容量而导致溢出。下面是实例代码：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main (String[] args)&#123;</span><br><span class="line">        <span class="keyword">List</span>&lt;OOMObject&gt; <span class="keyword">list</span> = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">list</span>.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的结果可以看到，发生了OOM异常。要解决这个异常，一般是把内存快照dump（通过-XX:+HeapDumpOnOutOfMemoryError）下来用工具（Eclipse Memmory Analyzer）分析，确认<strong>内存中的对象是否是必要的</strong>，也就是要先分清到底是出现了内存泄露（Memory Leak）还是内存溢出（Memory overflow）。</p>
<ul>
<li>如果是内存泄露：使用工具查看泄露对象到GC Roots的引用链。于是就可以顺藤摸瓜找到泄漏对象是通过怎样的路径关联GC Roots的，从而准确定位泄露代码的位置</li>
<li>如果是内存溢出：就应当检查虚拟机的堆参数（-Xmx和-Xms），与机器物理内存对比看是否可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长等情况，尝试减少程序运行期间的内存消耗</li>
</ul>
<h3 id="虚拟机栈和本地方法栈溢出">虚拟机栈和本地方法栈溢出</h3><p>-Xss可以设置栈容量。</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的最大深度，将抛出StackOverFlowError异常</li>
<li>如果虚拟机在扩展栈时无法申请到足够的内存空间，将抛出OutOfMemoryError异常</li>
</ul>
<p>通过调用无限递归调用，单线程下，无论由于栈帧太大还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是StackOverflowError。通过不断创建线程倒是可以产生内存溢出异常，不过和栈空间是否足够大并不存在任何联系。</p>
<h3 id="方法区和运行时常量池溢出">方法区和运行时常量池溢出</h3><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class RuntimeConstantPoolOOM&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> main（<span class="keyword">String</span>[]args）&#123;</span><br><span class="line">        <span class="keyword">String</span> str1=<span class="keyword">new</span> StringBuilder（<span class="string">"计算机"</span>）.<span class="built_in">append</span>（<span class="string">"软件"</span>）.toString（）；</span><br><span class="line">        System.out.<span class="built_in">println</span>（str1.intern（）==str1）；</span><br><span class="line">        <span class="keyword">String</span> str2=<span class="keyword">new</span> StringBuilder（<span class="string">"ja"</span>）.<span class="built_in">append</span>（<span class="string">"va"</span>）.toString（）；</span><br><span class="line">        System.out.<span class="built_in">println</span>（str2.intern（）==str2）；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码在JDK 1.6中运行，会得到两个false，而在JDK 1.7中运行，会得到一个true和一个false。产生差异的原因是：在JDK 1.6中，intern（）方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用，将返回false。<strong>而JDK 1.7（以及部分其他虚拟机，例如JRockit）的intern（）实现不会再复制实例，只是在常量池中记录首次出现的实例引用，因此intern（）返回的引用和由StringBuilder创建的那个字符串实例是同一个</strong>。对str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString（）之前已经出现过，字符串常量池中已经有它的引用了，不符合“首次出现”的原则，而“计算机软件”这个字符串则是首次出现的，因此返回true。</p>
<p>方法区溢出也是一种常见的内存溢出异常，一个类要被垃圾收集器回收掉，判定条件是比较苛刻的。在经常动态生成大量Class的应用中，需要特别注意类的回收状况。这类场景除了使用了CGLib字节码增强和动态语言之外，常见的还有：大量JSP或动态产生JSP文件的应用（JSP第一次运行时需要编译为Java类）、基于OSGi的应用（即使是同一个类文件，被不同的加载器加载也会视为不同的类）等。</p>
<h3 id="本机直接内存溢出">本机直接内存溢出</h3><p>由DirectMemory导致的内存溢出，一个明显的特征是在Heap Dump文件中不会看见明显的异常，如果读者发现OOM之后Dump文件很小，而程序中又直接或间接使用了NIO，那就可以考虑检查一下是不是这方面的原因。</p>
]]></content>
    <summary type="html">
    <![CDATA[深入理解Java虚拟机;Java内存区域与内存溢出异常;]]>
    
    </summary>
    
      <category term="JVM" scheme="http://howiefh.github.io/tags/JVM/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[JSP/Servlet及相关技术笔记]]></title>
    <link href="http://howiefh.github.io/2015/03/13/jsp-servlet-note/"/>
    <id>http://howiefh.github.io/2015/03/13/jsp-servlet-note/</id>
    <published>2015-03-13T02:04:54.000Z</published>
    <updated>2015-04-12T12:00:43.000Z</updated>
    <content type="html"><![CDATA[<h2 id="web应用">web应用</h2><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">`<span class="variable">&lt;webDemo&gt;</span>` : web应用名称</span><br><span class="line">|<span class="string">--WEB-INF</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">--classes : 保存单个`*.class`文件</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">--lib     : 保存jar包</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">--web.xml : 配置描述符，servlet3.0后不再是必须</span><br><span class="line"></span>|<span class="string">--`&lt;a.jsp&gt;` : jsp页面</span></span><br></pre></td></tr></table></figure>
<h2 id="java脚本">java脚本</h2><p><code>&lt;% %&gt;</code>中的内容即java脚本，会被系统编译在Servlet类中的service方法中。<br>每个jsp页面其实还是servlet</p>
<a id="more"></a>
<h2 id="jsp注释">jsp注释</h2><p><code>&lt;%-- 注释内容 --%&gt;</code>不会被输出到浏览器中</p>
<h2 id="jsp声明">jsp声明</h2><p><code>&lt;%! 声明部分 %&gt;</code>声明部分用于声明变量和方法。声明的变量和方法对应于编译后Servlet类中的成员变量和方法。</p>
<p>jsp页面会编译成Servlet类，每个Servlet在容器中只有一个实例：在jsp中声明的变量是成员变量，成员变量，成员变量只在创建实例时初始化，该变量的值将一直保存，直到实例销毁。</p>
<h2 id="输出jsp表达式">输出jsp表达式</h2><p><code>&lt;%= 表达式 %&gt;</code> 不可以有分号，编译时会转换为Servlet中的输出语句。</p>
<h2 id="jsp_3个编译指令">jsp 3个编译指令</h2><ul>
<li>page：该指令是针对当前页面的指令</li>
<li>include：用于指定包含另一个页面</li>
<li>taglib：用于定义和访问自定义标签</li>
</ul>
<p>编译指令的语法格式</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">%@</span> 编译指令名 属性名=<span class="value">"属性值"</span><span class="value">...</span> %&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="page指令">page指令</h3><ul>
<li>language：声明当前jsp页面使用的脚本语言种类，默认是java。</li>
<li>extends：指定jsp页面编译所产生的java类所继承的父类，或所实现的接口。</li>
<li>import：用于导入包，<code>java.lang.*、javax.servlet.*、javax.servlet.jsp.*、javax.servlet.http.*</code></li>
<li>session：设定这个jsp页面是否需要http session</li>
<li>buffer：指定输出缓存区大小，jsp内部对象：out用于缓存jsp页面对客户端浏览器的输出。默认值为8kb，可以设置为none，也可设为其它值，单位kb。</li>
<li>autoFlush：当缓存即将溢出时，是否需要强制输出缓存区的内容。设置为true时为正常输出；如果设置为false，则会在溢出时产生异常。</li>
<li>info：设置jsp程序的信息，可调用getServletInfo()方法获取该值，因为jsp页面实质就是Servlet。</li>
<li>errorPage：指定错误处理页面。如果本页面产生异常或错误，而该jsp页面没有对应处理代码，将会自动调用指定的页面。实质是jsp的异常处理机制，jsp脚本不要求强制处理异常，即使是受检查的。</li>
<li>isErrorPage：设置本jsp页面是否为错误处理程序，如果该页面已经是错误处理页面，则无需errorPage属性。</li>
<li>contentType：用于设定生成网页的文件格式和编码字符集，即MIME类型和页面字符集类型，默认MIME类型是text/html，默认的字符集类型为ISO-8859-1。</li>
<li>pageEncoding：指定生成网页的编码字符集。</li>
</ul>
<h3 id="include指令">include指令</h3><p>include指令会将包含的页面加入到本页面，融合成一个页面，因此被包含页面甚至不需要是一个完整的页面，可以是静态页面，也可以是动态的jsp页面。</p>
<p>语法</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="variable">%@</span>include <span class="keyword">file</span>=<span class="string">"relativeUrlSpec"</span><span class="variable">%&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意，静态include会将包含页面的编译指令也包含进来，如果两个页面的编译指令冲突，那么页面就会出错</strong>。</p>
<h2 id="jsp7个动作指令">jsp7个动作指令</h2><ul>
<li>jsp:forward：执行页面转向，将请求的处理转发到下一个页面。</li>
<li>jsp:param：用于传递参数，必须与其他支持参数的标签一起使用。</li>
<li>jsp:include：用于动态引入一个jsp页面。</li>
<li>jsp:plugin：用于下载JavaBean或Applet到客户端执行。很少会用到。</li>
<li>jsp:useBean：创建一个JavaBean实例。</li>
<li>jsp:setProperty：设置JavaBean实例的属性。</li>
<li>jsp:getProperty：获取JavaBean实例的属性。</li>
</ul>
<h3 id="forward指令">forward指令</h3><p>既可以转发到静态的html页面，也可以转发到动态的jsp页面，或者转发到容器中的Servlet。</p>
<p>jsp1.0：</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">jsp:forward</span> <span class="attribute">page</span>=<span class="value">"&#123;relativeURL|</span></span></span>&lt;%=<span class="ruby">expression</span>%&gt;<span class="xml"><span class="tag"><span class="value">&#125;"</span>/&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>jsp1.1</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">jsp:forward</span> <span class="attribute">page</span>=<span class="value">"&#123;relativeURL|</span></span></span>&lt;%=<span class="ruby">expression</span>%&gt;<span class="xml"><span class="tag"><span class="value">&#125;"</span>&gt;</span></span><br><span class="line">&#123;<span class="tag">&lt;<span class="title">jsp:param</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"value"</span>/&gt;</span>&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="title">jsp:forward</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>第二种用于转发时添加额外的请求参数。</p>
<p><strong>执行forward指令时，用户请求的地址依然没有发生改变，但页面内容却完全变为被forward目标页的内容</strong>。</p>
<p>执行forward指令时，客户端请求参数不会丢失。</p>
<p><strong>实际上forward并没有重新向新页面发送请求，它只是完全采用了新页面来对用户生成响应—请求依然是一次，所以请求参数、属性没丢失</strong>。</p>
<h3 id="include指令-1">include指令</h3><p><strong>动态include指令，也用于包含某个页面，它不会导入include页面的编译指令，仅仅将被导入页面的body内容插入本页面</strong>。</p>
<p>语法</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">jsp:include</span> <span class="attribute">page</span>=<span class="value">"&#123;relativeURL|</span></span></span>&lt;%=<span class="ruby">expression</span>%&gt;<span class="xml"><span class="tag"><span class="value">&#125;"</span> <span class="attribute">flush</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">//或</span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:include</span> <span class="attribute">page</span>=<span class="value">"&#123;relativeURL|</span></span></span>&lt;%=<span class="ruby">expression</span>%&gt;<span class="xml"><span class="tag"><span class="value">&#125;"</span> <span class="attribute">flush</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:param</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"value"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">jsp:include</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>编译为servlet后，只是使用一个include方法来插入目标页面内容，而不是将目标页面完全融入本页面中。</p>
<p><strong>静态导入和动态导入的三点区别</strong>：</p>
<ul>
<li>静态导入是将导入页面的代码完全融入，两个页面融合成一个整体servlet；而动态导入则在servlet中使用include方法来引入被导入页面的内容。</li>
<li>静态导入时被导入页面的编译指令会起作用；而动态导入时被导入页面的编译指令则失去作用，只是插入被导入页面的body内容。</li>
<li>动态包含还可以增加额外的参数。</li>
</ul>
<p>forward 指令和 include 指令动作十分相似。forward 指令使用_jspx_page_context的forward() 方法来引入目标页面。include用JspRuntimeLibrary 的include()方法引入目标页面。区别在于：forward拿目标页面代替原有页面，而include则拿目标页面插入原有页面。</p>
<h3 id="useBean、setProperty、getProperty指令">useBean、setProperty、getProperty指令</h3><p>这三个指令都是与JavaBean相关的指令，其中useBean指令用于在JSP页面中初始化一个Java实例；setProperty指令用于为JavaBean实例的属性设置值；getProperty指令用于输出JavaBean实例的属性。</p>
<p>useBean语法格式如下：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:useBean <span class="variable">id=</span><span class="string">"name"</span> <span class="variable">class=</span><span class="string">"classname"</span> <span class="variable">scope=</span><span class="string">"page|request|session|application"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>其中id是JavaBean的实例名，class属性确定JavaBean的实现类。Scope属性用于指定JavaBean实例的作用范围：</p>
<p>page：仅在该页面有效。<br>request：在本次请求有效。<br>session：在本次session内有效。<br>application：在本次应用内一直有效。</p>
<p>setProperty语法格式如下：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:setProperty <span class="variable">property=</span><span class="string">"ProtertyName"</span> <span class="variable">name=</span><span class="string">"BeanName"</span> <span class="variable">value=</span><span class="string">"value"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>name属性是需要设定JavaBean的实例名；property属性确定需要设置的属性名；value属性则确定需要设置的属性值。</p>
<p>getProperty语法格式如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:getProperty <span class="keyword">property</span>=<span class="string">"ProtertyName"</span> <span class="property">name</span>=<span class="string">"BeanName"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>name属性确定需要输出的JavaBean的实例名，property属性确定需要输出的属性名。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 创建lee.Person 实例，该实例的名称是p1--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:useBean</span> <span class="attribute">id</span>=<span class="value">"p1"</span> <span class="attribute">class</span>=<span class="value">"Person"</span> <span class="attribute">scope</span>=<span class="value">"page"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:setProperty</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">property</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"waw"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:setProperty</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">property</span>=<span class="value">"age"</span> <span class="attribute">value</span>=<span class="value">"29"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:getProperty</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">property</span>=<span class="value">"name"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp:getProperty</span> <span class="attribute">name</span>=<span class="value">"p1"</span> <span class="attribute">property</span>=<span class="value">"age"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>不使用这三个标签，也可以通过jsp脚本完成相同功能。</p>
<h3 id="param指令">param指令</h3><p>和jsp:include、jsp:forward、jsp:plugin指令结合使用，语法：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;jsp:<span class="built_in">param</span> name=<span class="string">"paramName"</span> <span class="built_in">value</span>=<span class="string">"paramValue"</span> /&gt;</span><br></pre></td></tr></table></figure>
<h2 id="jsp脚本中的9个内置对象">jsp脚本中的9个内置对象</h2><p>jsp页面对应的Servlet的<code>_jspService()</code>方法来创建内置对象。</p>
<ul>
<li>application：javax.servlet.ServletContext的实例，<strong>该实例代表JSP所属的Web应用本身，可用于JSP页面，或者Servlet之间交换信息</strong>。常用的方法有getAttribute(String attName)、setAttribute(String attName , String attValue)和getInitParameter(String paramName)等。</li>
<li>config：javax.servlet.ServletConfig的实例，该实例代表该JSP的配置信息。常用的方法有getInitParameter(String paramName)和getInitParameternames()等方法。事实上，JSP页面通常无须配置，也就不存在配置信息。因此，该对象更多地在Servlet中有效。</li>
<li>exception：java.lang.Throwable的实例，该实例代表其他页面中的异常和错误。<strong>只有当页面是错误处理页面，即编译指令page的isErrorPage属性为true时，该对象才可以使用</strong>。常用的方法有getMessage()和printStackTrace()等。</li>
<li>out：javax.servlet.jsp.JspWriter的实例，该实例代表JSP页面的输出流，用于输出内容，形成HTML页面。</li>
<li>page：代表该页面本身，通常没有太大用处。也就是Servlet中的this，其类型就是生成的Servlet类，能用page的地方就可用this。</li>
<li>pageContext：javax.servlet.jsp.PageContext的实例，该对象代表该JSP页面上下文，使用该对象可以访问页面中的共享数据。常用的方法有getServletContext()和getServletConfig()等。</li>
<li>request：javax.servlet.http.HttpServletRequest的实例，该对象封装了一次请求，客户端的请求参数都被封装在该对象里。这是一个常用的对象，获取客户端请求参数必须使用该对象。常用的方法有getParameter(String paramName)、getParameterValues(String paramName)、setAttribute(String atttName,Object attrValue)、getAttribute(String attrName)和setCharacterEncoding(String env)等。</li>
<li>response：javax.servlet.http.HttpServletResponse的实例，代表服务器对客户端的响应。通常很少使用该对象直接响应，而是使用out对象，除非需要生成非字符响应。而response对象常用于重定向，常用的方法有getOutputStream()、sendRedirect(java.lang.String location)等。</li>
<li>session：javax.servlet.http.HttpSession的实例，该对象代表一次会话。当客户端浏览器与站点建立连接时，会话开始；当客户端关闭浏览器时，会话结束。常用的方法有：getAttribute(String attrName)、setAttribute(String attrName, Object attrValue)等。</li>
</ul>
<p>request、response是<code>_jspService()</code>方法的形参，其它都是其局部变量。</p>
<p><strong>由于jsp内置对象都是在<code>_jspService()</code>方法中完成初始化的，因此只能在jsp脚本、jsp输出表达式中使用这些内置变量。千万不要在jsp声明中使用它们</strong>。</p>
<h3 id="application">application</h3><p>对于每次客户端请求而言，<strong>Web服务器大致需要完成如下几个步骤</strong>：</p>
<ol>
<li>启动单独的线程。</li>
<li>使用I/O流读取用户的请求数据。</li>
<li>从请求数据中解析参数。</li>
<li>处理用户请求。</li>
<li>生成响应数据。</li>
<li>使用IO流向客户端发送请求数据。</li>
</ol>
<p>在上面6个步骤中，第1、2和6步是通用的，可以由Web服务器来完成，但第3、4和5步则存在差异：因为不同请求里包含的请求参数不同，处理用户请求的方式也不同，所生成的响应自然也不同。Web服务器会调用Servlet的<code>_jspService()</code>方法来完成第3、4和5步，<strong>当我们编写JSP页面时，页面里的静态内容、JSP脚本都会转换成<code>_jspService()</code>方法的执行代码，这些执行代码负责完成解析参数、处理请求、生成响应等业务功能，而Web服务器则负责完成多线程、网络通信等底层功能</strong>。</p>
<p>为了解决JSP、Servlet之间如何交换数据的问题，几乎所有Web服务器（包括Java、ASP、PHP、Ruby等）都会提供4个类似Map的结构，分别是application、session、request、page，并允许JSP、Servlet将数据放入这4个类似Map的结构中，并允许从这4个Map结构中取出数据。这4个Map结构的区别是范围不同。</p>
<ul>
<li>application：对于整个Web应用有效，一旦JSP、Servlet将数据放入application中，该数据将可以被该应用下其他所有的JSP、Servlet访问。</li>
<li>session：仅对一次会话有效，一旦JSP、Servlet将数据放入session中，该数据将可以被本次会话的其他所有的JSP、Servlet访问。</li>
<li>request：仅对本次请求有效，一旦JSP、Servlet将数据放入request中，该数据将可以被该次请求的其他JSP、Servlet访问。</li>
<li>page：仅对当前页面有效，一旦JSP、Servlet将数据放入page中，该数据只可以被当前页面的JSP脚本、声明部分访问。</li>
</ul>
<p>application对象通常有如下两个作用：</p>
<ul>
<li>在整个Web应用的多个JSP、Servlet之间共享数据。</li>
<li>访问Web应用的配置参数。</li>
</ul>
<ol>
<li><p>让多个jsp、servlet共享数据</p>
<p> application通过setAttribute(String attrName,Object value)方法将一个值设置成application的attrName属性，该属性的值对整个Web应用有效，因此该Web应用的每个JSP页面或Servlet都可以访问该属性，访问属性的方法为getAttribute(String attrName)。<br> <strong>由于在Servlet中并没有application内置对象，所以可以通过<code>ServletContext sc = getServletConfig().getServletContext()</code>显式获取了该Web应用的ServletContext实例</strong>，每个Web应用只有一个ServletContext实例，在JSP页面中可通过application内置对象访问该实例，而Servlet中则必须通过代码获取。<br> 编译Servlet时可能由于没有添加环境出现异常，如果安装了Java EE 6 SDK，只需将Java EE 6 SDK路径的javaee.jar文件添加到CLASSPATH环境变量中；如果没有安装Java EE SDK，可以将Tomcat 7的lib路径下的jsp-api.jar、servlet-api.jar两个文件添加到CLASSPATH环境变量中。<br> <strong>虽然使用application（即ServletContext实例）可以方便多个JSP、Servlet共享数据，但不要仅为了JSP、Servlet共享数据就将数据放入application中！由于application代表整个Web应用，所以通常只应该把Web应用的状态数据放入application里</strong>。</p>
</li>
<li><p>获得Web应用配置参数</p>
<p> 一些配置信息可以放在web.xml文件中，使用context-param元素配置，每个<context-param…>元素配置一个参数，该元素下有如下两个子元素。</context-param…></p>
<ul>
<li>param-name：配置Web参数名。</li>
<li>param-value：配置Web参数值。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置第一个参数：user --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">context-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>user<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">context-param</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 配置第二个参数：pass --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">context-param</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>pass<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>32147<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
之后可以通过application的 getInitParameter(String paramName)方法获取配置参数。<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">String user = application.getInitParameter(<span class="string">"user"</span>);</span><br><span class="line">String <span class="keyword">pwd</span> = application.getInitParameter(<span class="string">"pass"</span>);</span><br><span class="line">out.println(user + <span class="string">" "</span> + <span class="keyword">pwd</span>);</span><br><span class="line"><span class="variable">%&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ol>
<h3 id="config">config</h3><p>config对象代表当前JSP配置信息，但JSP页面通常无须配置，因此也就不存在配置信息。该对象在JSP页面中比较少用，但在Servlet中则用处相对较大，因为Servlet需要在web.xml文件中进行配置，可以指定配置参数。</p>
<p>在jsp输出config的getServletName()方法的返回值为jsp，所有的JSP页面都有相同的名字：jsp</p>
<p>config对象是ServletConfig的实例，该接口用于获取配置参数的方法是getInitParameter(String paramName)</p>
<p>配置JSP也是在web.xml文件中进行的，JSP被当成Servlet配置，为Servlet配置参数使用init-param元素，该元素可以接受param-name和param-value两个子元素，分别指定参数名和参数值。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 指定Servlet名字 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>config<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 指定将哪个JSP页面配置成Servlet --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">jsp-file</span>&gt;</span>/configTest2.jsp<span class="tag">&lt;/<span class="title">jsp-file</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置名为name的参数，值为yeeku --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>name<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>yeeku<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置名为age的参数，值为30 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>age<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>30<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 指定将config Servlet配置到/config路径 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>config<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/config<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的配置文件片段为该Servlet（其实是JSP）配置了2个参数：name和age。上面的配置片段把configTest2.jsp页面配置成名为config的Servlet，并将该Servlet映射到/config处，这就允许我们通过/config来访问该页面。</p>
<p>通过config可以访问到web.xml文件中的配置参数。实际上，我们也可以直接访问configTest2.jsp页面。</p>
<p>如果希望JSP页面可以获取web.xml配置文件中的配置信息，则必须通过为该JSP配置的路径来访问该页面，因为只有这样访问JSP页面才会让配置参数起作用。</p>
<h3 id="exception">exception</h3><p>exception对象是Throwable的实例，代表JSP脚本中产生的错误和异常，是JSP页面异常机制的一部分。</p>
<p>exception对象仅在异常处理页面中才有效，即isErrorPage为true时。</p>
<p>编译为servlet后，这些脚本已经处于<code>_jspService()</code>方法的try块中。一旦try块捕捉到JSP脚本的异常，并且<code>_jspx_page_context</code>不为null，就会由该对象来处理该异常，如上面粗体字代码所示。<code>_jspx_page_context</code>对异常的处理也非常简单：如果该页面的page指令指定了errorPage属性，则将请求forward到errorPage属性指定的页面，否则使用系统页面来输出异常信息。只有jsp脚本、输出表达式才会对应于<code>_jspService()</code>方法里的代码，所以这两部分的代码无须处理checked异常。但是jsp的异常处理机制对jsp声明不起作用。</p>
<h3 id="out">out</h3><p>out对象代表一个页面输出流，通常用于在页面上输出变量值及常量。一般在使用输出表达式的地方，都可以使用out对象来达到同样效果。</p>
<h3 id="pageContext">pageContext</h3><p>这个对象代表页面上下文，该对象主要用于访问JSP之间的共享数据。使用pageContext可以访问page、request、session、application范围的变量。</p>
<p>pageContext是PageContext类的实例，它提供了如下两个方法来访问page、request、session、application范围的变量。</p>
<ul>
<li>getAttribute(String name)：取得page范围内的name属性。</li>
<li><p>getAttribute(String name,int scope)：取得指定范围内的name属性，其中scope可以是如下4个值。</p>
<ul>
<li>PageContext.PAGE_SCOPE：对应于page范围。</li>
<li>PageContext.REQUEST_SCOPE：对应于request范围。</li>
<li>PageContext.SESSION_SCOPE：对应于session范围。</li>
<li>PageContext.APPLICATION_SCOPE：对应于application范围。</li>
</ul>
</li>
</ul>
<p>与getAttribute()方法相对应，PageContext也提供了2个对应的setAttribute()方法，用于将指定变量放入page、request、session、application范围内。</p>
<p>pageContext还可用于获取其他内置对象，pageContext对象包含如下方法。</p>
<ul>
<li>ServletRequest getRequest()：获取request对象。</li>
<li>ServletResponse getResponse()：获取response对象。</li>
<li>ServletConfig getServletConfig()：获取config对象。</li>
<li>ServletContext getServletContext()：获取application对象。</li>
<li>HttpSession getSession()：获取session对象。</li>
</ul>
<p>因此一旦在JSP、Servlet编程中获取了pageContext对象，就可以通过它提供的上面方法来获取其他内置对象。</p>
<h3 id="request">request</h3><p>request对象是获取请求参数的重要途径。除此之外，request可代表本次请求范围，所以还可用于操作request范围的属性。</p>
<ol>
<li><p>获取请求头/请求参数</p>
<p> request是HttpServletRequest接口的实例，它提供了如下几个方法来获取请求参数。</p>
<ul>
<li>String getParameter(String paramName)：获取paramName请求参数的值。</li>
<li>Map getParameterMap()：获取所有请求参数名和参数值所组成的Map对象。</li>
<li>Enumeration getParameterNames()：获取所有请求参数名所组成的Enumeration对象。</li>
<li><p>String[] getParameterValues(String name)：paramName请求参数的值，当该请求参数有多个值时，该方法将返回多个值所组成的数组。</p>
<p>HttpServletRequest提供了如下方法来访问请求头。</p>
</li>
<li><p>String getHeader(String name)：根据指定请求头的值。</p>
</li>
<li>java.util.Enumeration<string> getHeaderNames()：获取所有请求头的名称。</string></li>
<li>java.util.Enumeration<string> getHeaders(String name)：获取指定请求头的多个值。</string></li>
<li><p>int getIntHeader(String name)：获取指定请求头的值，并将该值转为整数值。</p>
<p>对于开发人员来说，请求头和请求参数都是由用户发送到服务器的数据，区别在于请求头通常由浏览器自动添加，因此一次请求总是包含若干请求头；而请求参数则通常需要开发人员控制添加，让客户端发送请求参数通常分两种情况。</p>
<p><strong>GET方式的请求：直接在浏览器地址栏输入访问地址所发送的请求或提交表单发送请求时，该表单对应的form元素没有设置method属性，或设置method属性为get，这几种请求都是GET方式的请求。GET方式的请求会将请求参数的名和值转换成字符串，并附加在原URL之后，因此可以在地址栏中看到请求参数名和值。且GET请求传送的数据量较小，一般不能大于2KB</strong>。</p>
<p><strong>POST方式的请求：这种方式通常使用提交表单（由form HTML元素表示）的方式来发送，且需要设置form元素的method属性为post。POST方式传送的数据量较大，通常认为POST请求参数的大小不受限制，但往往取决于服务器的限制，POST请求传输的数据量总比GET传输的数据量大。而且POST方式发送的请求参数以及对应的值放在HTML HEADER中传输，用户不能在地址栏里看到请求参数值，安全性相对较高</strong>。</p>
<p>对比上面两种请求方式，由此可见我们通常应该采用POST方式发送请求。</p>
<p>并不是每个表单域都会生成请求参数的，而是有name属性的表单域才生成请求参数。关于表单域和请求参数的关系遵循如下4点：</p>
</li>
<li><p>每个有name属性的表单域对应一个请求参数。</p>
</li>
<li>如果有多个表单域有相同的name属性，则多个表单域只生成一个请求参数，只是该参数有多个值。</li>
<li>表单域的name属性指定请求参数名，value指定请求参数值。</li>
<li><p>如果某个表单域设置了disabled=”disabled”属性，则该表单域不再生成请求参数。</p>
<p>如果发送请求的表单页采用gb2312字符集，该表单页发送的请求也将采用gb2312字符集，所以本页面需要先执行如下方法。 <code>setCharacterEncoding(&quot;gb2312&quot;)</code>：设置request编码所用的字符集。<br>使用GET方法，如果请求参数值里包含非西欧字符，那么是不是应该先调用setCharacterEncoding()来设置request编码的字符集呢？读者可以试一下。答案是不行，如果GET方式的请求值里包含了非西欧字符，则获取这些参数比较复杂。为了获取GET请求里的中文参数值，必须借助于java.net.URLDecoder类。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">%</span></span><br><span class="line"><span class="comment">//获取请求里包含的查询字符串  </span></span><br><span class="line">String rawQueryStr = request.getQueryString<span class="params">()</span>;  </span><br><span class="line">out.println<span class="params">(<span class="string">"原始查询字符串为："</span> + rawQueryStr + <span class="string">"&lt;hr/&gt;"</span>)</span>;  </span><br><span class="line"><span class="comment">//使用URLDecoder解码字符串  </span></span><br><span class="line">String queryStr = java.net.URLDecoder.decode<span class="params">(rawQueryStr , <span class="string">"gbk"</span>)</span>; </span><br><span class="line">out.println<span class="params">(<span class="string">"解码后的查询字符串为："</span> + queryStr + <span class="string">"&lt;hr/&gt;"</span>)</span>;</span><br><span class="line"><span class="built_in">%</span>&gt;</span><br></pre></td></tr></table></figure>
<p>可通过如下代码来取得name请求参数的参数值。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;%</span><br><span class="line"><span class="comment">//获取原始的请求参数值  </span></span><br><span class="line"><span class="keyword">String</span> rawName = request.getParameter(<span class="string">"name"</span>);  </span><br><span class="line"><span class="comment">//将请求参数值使用ISO-8859-1字符串分解成字节数组  </span></span><br><span class="line"><span class="built_in">byte</span>[] rawBytes = rawName.getBytes(<span class="string">"ISO-8859-1"</span>);  </span><br><span class="line"><span class="comment">//将字节数组重新解码成字符串  </span></span><br><span class="line"><span class="keyword">String</span> name = <span class="keyword">new</span> <span class="keyword">String</span>(rawBytes , <span class="string">"gb2312"</span>); </span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>操作request范围的属性</p>
<p> HttpServletRequest还包含如下两个方法，用于设置和获取request范围的属性。</p>
<ul>
<li>setAttribute(String attName , Object attValue)：将attValue设置成request范围的属性。</li>
<li>Object getAttribute(String attName)：获取request范围的属性。<br>当forward用户请求时，请求的参数和请求属性都不会丢失。通过<code>setAttribute</code>方法设置的属性也不会丢失。</li>
</ul>
</li>
<li><p>执行forward或include</p>
<p> request还有一个功能就是执行forward和include，也就是代替JSP所提供的forward和include动作指令。<br> HttpServletRequest类提供了一个getRequestDispatcher (String path)方法，其中path就是希望forward或者include的目标路径，该方法返回RequestDispatcher，该对象提供了如下两个方法。</p>
<ul>
<li>forward(ServletRequest request, ServletResponse response)：执行forward。</li>
<li><p>include(ServletRequest request, ServletResponse response)：执行include。</p>
<p>使用request的getRequestDispatcher(String path)方法时，该path字符串必须以斜线开头。</p>
</li>
</ul>
</li>
</ol>
<h3 id="response">response</h3><p>response代表服务器对客户端的响应。大部分时候，程序无须使用response来响应客户端请求，因为有个更简单的响应对象—out，它代表页面输出流，直接使用out生成响应更简单。</p>
<p>但out是JspWriter的实例，JspWriter是Writer的子类，Writer是字符流，无法输出非字符内容。假如需要在JSP页面中动态生成一幅位图、或者输出一个PDF文档，使用out作为响应对象将无法完成，此时必须使用response作为响应输出。</p>
<p>除此之外，还可以使用response来重定向请求，以及用于向客户端增加Cookie。</p>
<ol>
<li><p>response响应生成非字符响应</p>
<p> response是HttpServletResponse接口的实例，该接口提供了一个getOutputStream()方法，该方法返回响应输出字节流。下面的方法可以输出图像。</p>
 <figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">%</span>-- 通过contentType属性指定响应数据是图片 --<span class="built_in">%</span>&gt; </span><br><span class="line">&lt;<span class="built_in">%</span>@ page contentType=<span class="string">"image/jpeg"</span> language=<span class="string">"java"</span><span class="built_in">%</span>&gt; </span><br><span class="line">&lt;<span class="built_in">%</span>@ page <span class="built_in">import</span>=<span class="string">"java.awt.image.*,javax.imageio.*,java.io.*,java.awt.*"</span><span class="built_in">%</span>&gt; </span><br><span class="line">&lt;<span class="built_in">%</span>  </span><br><span class="line"><span class="comment">//创建BufferedImage对象  </span></span><br><span class="line">BufferedImage image = new BufferedImage<span class="params">(<span class="number">340</span> , <span class="number">160</span>, BufferedImage.TYPE_INT_RGB)</span>;  </span><br><span class="line"><span class="comment">//以Image对象获取Graphics对象  </span></span><br><span class="line">Graphics g = image.getGraphics<span class="params">()</span>;  </span><br><span class="line"><span class="comment">//使用Graphics画图，所画的图像将会出现在image对象中  </span></span><br><span class="line">g.fillRect<span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">400</span>,<span class="number">400</span>)</span>;  </span><br><span class="line"><span class="comment">//设置颜色：红  </span></span><br><span class="line">g.setColor<span class="params">(new Color<span class="params">(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>)</span>)</span>;  </span><br><span class="line"><span class="comment">//画出一段弧  </span></span><br><span class="line">g.fillArc<span class="params">(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>,<span class="number">100</span>, <span class="number">30</span>, <span class="number">120</span>)</span>;  </span><br><span class="line"><span class="comment">//设置颜色：绿  </span></span><br><span class="line">g.setColor<span class="params">(new Color<span class="params">(<span class="number">0</span> , <span class="number">255</span>, <span class="number">0</span>)</span>)</span>;  </span><br><span class="line"><span class="comment">//画出一段弧  </span></span><br><span class="line">g.fillArc<span class="params">(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>,<span class="number">100</span>, <span class="number">150</span>, <span class="number">120</span>)</span>;  </span><br><span class="line"><span class="comment">//设置颜色：蓝  </span></span><br><span class="line">g.setColor<span class="params">(new Color<span class="params">(<span class="number">0</span> , <span class="number">0</span>, <span class="number">255</span>)</span>)</span>;  </span><br><span class="line"><span class="comment">//画出一段弧  </span></span><br><span class="line">g.fillArc<span class="params">(<span class="number">20</span>, <span class="number">20</span>, <span class="number">100</span>,<span class="number">100</span>, <span class="number">270</span>, <span class="number">120</span>)</span>;  </span><br><span class="line"><span class="comment">//设置颜色：黑  </span></span><br><span class="line">g.setColor<span class="params">(new Color<span class="params">(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>)</span>)</span>;  </span><br><span class="line">g.setFont<span class="params">(new Font<span class="params">(<span class="string">"Arial Black"</span>, Font.PLAIN, <span class="number">16</span>)</span>)</span>;  </span><br><span class="line"><span class="comment">//画出三个字符串  </span></span><br><span class="line">g.drawString<span class="params">(<span class="string">"red:climb"</span> , <span class="number">200</span> , <span class="number">60</span>)</span>;  </span><br><span class="line">g.drawString<span class="params">(<span class="string">"green:swim"</span> , <span class="number">200</span> , <span class="number">100</span>)</span>;  </span><br><span class="line">g.drawString<span class="params">(<span class="string">"blue:jump"</span> , <span class="number">200</span> , <span class="number">140</span>)</span>;  </span><br><span class="line">g.dispose<span class="params">()</span>;  </span><br><span class="line"><span class="comment">//将图像输出到页面的响应  </span></span><br><span class="line">ImageIO.write<span class="params">(image , <span class="string">"jpg"</span> , response.getOutputStream<span class="params">()</span>)</span>;  </span><br><span class="line"><span class="built_in">%</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重定向</p>
<p> 重定向是response的另外一个用处，与forward不同的是，重定向会丢失所有的请求参数和request范围的属性，因为重定向将生成第二次请求，与前一次请求不在同一个request范围内，所以发送一次请求的请求参数和request范围的属性全部丢失。</p>
<p> HttpServletResponse提供了一个sendRedirect(String path)方法，该方法用于重定向到path资源，即重新向path资源发送请求。</p>
<p> forward和redirect对比</p>
<p> <strong>执行redirect后生成第二次请求，而forward依然是上一次请求。<br> redirect的目标页面不能访问原请求的请求参数，因为是第二次请求了，所有原请求的请求参数、request范围的属性全部丢失。forward的目标页面可以访问原请求的请求参数，因为依然是同一次请求，所有原请求的请求参数、request范围的属性全部存在。<br> 地址栏改为重定向的目标URL。相当于在浏览器地址栏里输入新的URL后按回车键。而forward地址栏里请求的URL不会改变</strong></p>
</li>
<li><p>增加Cookie</p>
<p> <strong>Cookie与session的不同之处在于：session会随浏览器的关闭而失效，但Cookie会一直存放在客户端机器上，除非超出Cookie的生命期限</strong>。</p>
<p> 增加Cookie也是使用response内置对象完成的，response对象提供了如下方法。<br> void addCookie(Cookie cookie)：增加Cookie。<br> 增加Cookie请按如下步骤进行。</p>
<ul>
<li>创建Cookie实例，Cookie的构造器为Cookie(String name, String value)。</li>
<li>设置Cookie的生命期限，即该Cookie在多长时间内有效。</li>
<li>向客户端写Cookie。<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="built_in">%</span></span><br><span class="line"><span class="comment">//增加cookie</span></span><br><span class="line">String name = request.getParameter<span class="params">(<span class="string">"name"</span>)</span>;  </span><br><span class="line"><span class="comment">//以获取到的请求参数为值，创建一个Cookie对象  </span></span><br><span class="line">Cookie c = new Cookie<span class="params">(<span class="string">"username"</span> , name)</span>;  </span><br><span class="line"><span class="comment">//设置Cookie对象的生存期限  </span></span><br><span class="line">c.setMaxAge<span class="params">(<span class="number">24</span> * <span class="number">3600</span>)</span>;  </span><br><span class="line"><span class="comment">//向客户端增加Cookie对象  </span></span><br><span class="line">response.addCookie<span class="params">(c)</span>;  </span><br><span class="line"><span class="built_in">%</span>&gt;</span><br></pre></td></tr></table></figure>
访问客户端Cookie使用request对象，request对象提供了getCookies()方法，该方法将返回客户端机器上所有Cookie组成的数组，遍历该数组的每个元素，找到希望访问的Cookie即可。<br>使用Cookie对象必须设置其生存期限，否则Cookie将会随浏览器的关闭而自动消失。<br>默认情况下，Cookie值不允许出现中文字符，如果我们需要值为中文内容的Cookie怎么办呢？同样可以借助于java.net.URLEncoder先对中文字符串进行编码，将编码后的结果设为Cookie值。当程序要读取Cookie时，则应该先读取，然后使用java.net.URLDecoder对其进行解码。</li>
</ul>
</li>
</ol>
<h3 id="session">session</h3><p><strong>session对象也是一个非常常用的对象，这个对象代表一次用户会话。一次用户会话的含义是：从客户端浏览器连接服务器开始，到客户端浏览器与服务器断开为止，这个过程就是一次会话</strong>。</p>
<p>session通常用于跟踪用户的会话信息，如判断用户是否登录系统，或者在购物车应用中，用于跟踪用户购买的商品等。</p>
<p>session对象是HttpSession的实例，HttpSession有如下两个常用的方法。</p>
<p>setAttribute(String attName，Object attValue)：设置session范围内attName属性的值为attValue。<br>getAttribute(String attName)：返回session范围内attName属性的值。</p>
<p>关于session还有一点需要指出，<strong>session机制通常用于保存客户端的状态信息，这些状态信息需要保存到Web服务器的硬盘上，所以要求session里的属性值必须是可序列化的，否则将会引发不可序列化的异常</strong>。</p>
<p>session的属性值可以是任何可序列化的Java对象。</p>
<h2 id="servlet介绍">servlet介绍</h2><h3 id="Servlet的开发">Servlet的开发</h3><p>前面介绍的JSP的本质就是Servlet，Servlet通常被称为服务器端小程序，是运行在服务器端的程序，用于处理及响应客户端的请求。</p>
<p>Servlet是个特殊的Java类，这个Java类必须继承HttpServlet。每个Servlet可以响应客户端的请求。Servlet提供不同的方法用于响应客户端请求。</p>
<ul>
<li>doGet：用于响应客户端的GET请求。</li>
<li>doPost：用于响应客户端的POST请求。</li>
<li>doPut：用于响应客户端的PUT请求。</li>
<li>doDelete：用于响应客户端的DELETE请求。</li>
</ul>
<p>事实上，客户端的请求通常只有GET和POST两种，Servlet为了响应这两种请求，必须重写doGet()和doPost()两个方法。如果Servlet为了响应4个方式的请求，则需要同时重写上面的4个方法。</p>
<p>大部分时候，Servlet对于所有请求的响应都是完全一样的。此时，可以采用重写一个方法来代替上面的几个方法：只需重写service()方法即可响应客户端的所有请求。</p>
<p>另外，HttpServlet还包含两个方法。</p>
<ul>
<li>init(ServletConfig config)：创建Servlet实例时，调用该方法的初始化Servlet资源。</li>
<li>destroy()：销毁Servlet实例时，自动调用该方法的回收资源。</li>
</ul>
<p>通常无须重写init()和destroy()两个方法，除非需要在初始化Servlet时，完成某些资源初始化的方法，才考虑重写init方法。如果需要在销毁Servlet之前，先完成某些资源的回收，比如关闭数据库连接等，才需要重写destroy方法。</p>
<p>不用为Servlet类编写构造器，如果需要对Servlet执行初始化操作，应将初始化操作放在Servlet的init()方法中定义。如果重写了init(ServletConfig config)方法，则应在重写该方法的第一行调用super.init(config)。该方法将调用HttpServlet的init方法。</p>
<p>Servlet和JSP的区别在于：</p>
<ul>
<li>Servlet中没有内置对象，原来JSP中的内置对象都必须由程序显式创建。</li>
<li>对于静态的HTML标签，Servlet都必须使用页面输出流逐行输出。</li>
</ul>
<p><strong>普通Servlet类里的service()方法的作用，完全等同于JSP生成Servlet类的<code>_jspService()</code>方法。因此原JSP页面的JSP脚本、静态HTML内容，在普通Servlet里都应该转换成service()方法的代码或输出语句；原JSP声明中的内容，对应为在Servlet中定义的成员变量或成员方法</strong>。</p>
<h3 id="servlet的配置">servlet的配置</h3><p>编辑好的Servlet源文件需编译成class文件才能响应用户请求。将编译后的.class文件放在WEB-INF/classes路径下，如果Servlet有包，则还应该将class文件放在对应的包路径下。</p>
<p>如果需要直接采用javac命令来编译Servlet类，则必须将Servlet API接口和类添加到系统的CLASSPATH环境变量里。也就是将Tomcat 7安装目录下lib目录中servlet-api. jar和jsp-api.jar添加到CLASSPATH环境变量中。</p>
<p>为了让Servlet能响应用户请求，还必须将Servlet配置在Web应用中。配置Servlet时，需要修改web.xml文件。</p>
<p>从Servlet 3.0开始，配置Servlet有两种方式：</p>
<ul>
<li>在Servlet类中使用@WebServlet Annotation进行配置。</li>
<li>通过在web.xml文件中进行配置。</li>
</ul>
<p>上面开发Servlet类时使用了@WebServlet Annotation修饰该Servlet类，使用@WebServlet时可指定如表所示的常用属性。</p>
<p>属    性          | 是否必需 | 说    明<br>asyncSupported    | 否       | 指定该Servlet是否支持异步操作模式。关于Servlet的异步调用请参考2.15节<br>displayName       | 否       | 指定该Servlet的显示名<br>initParams        | 否       | 用于为该Servlet配置参数<br>loadOnStartup     | 否       | 用于将该Servlet配置成 load-on-startup的Servlet<br>name              | 否       | 指定该Servlet的名称<br>urlPatterns/value | 否       | 这两个属性的作用完全相同。都指定该Servlet处理的URL</p>
<p>如果打算使用Annotation来配置Servlet，有两点需要指出：</p>
<ul>
<li>不要在web.xml文件的根元素（<code>&lt;web-app.../&gt;</code>）中指定metadata-complete=”true”。</li>
<li>不要在web.xml文件中配置该Servlet。</li>
</ul>
<p>如果打算使用web.xml文件来配置该Servlet，则需要配置如下两个部分。</p>
<ul>
<li>配置Servlet的名字：对应web.xml文件中的<code>&lt;servlet/&gt;</code>元素。</li>
<li>配置Servlet的URL：对应web.xml文件中的<code>&lt;servlet-mapping/&gt;</code>元素。这一步是可选的。但如果没有为Servlet配置URL，则该Servlet不能响应用户请求。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Servlet的名字 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 指定Servlet的名字，相当于指定@WebServlet的name属性 --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>firstServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 指定Servlet的实现类 --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>lee.FirstServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span> <span class="tag">&lt;/<span class="title">servlet</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 配置Servlet的URL --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 指定Servlet的名字 --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>firstServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 指定Servlet映射的URL地址，相当于指定@WebServlet的urlPatterns属性--&gt;</span>    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/aa<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过注解<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function"><span class="title">WebServlet</span><span class="params">(name=<span class="string">"firstServlet"</span>, urlPatterns=&#123;<span class="string">"/firstServlet"</span>&#125;)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="JSP/Servlet的生命周期">JSP/Servlet的生命周期</h3><p>创建Servlet实例有两个时机。</p>
<ul>
<li>客户端第一次请求某个Servlet时，系统创建该Servlet的实例：大部分的Servlet都是这种Servlet。</li>
<li>Web应用启动时立即创建Servlet实例，即load-on-startup Servlet。</li>
</ul>
<p><strong>每个Servlet的运行都遵循如下生命周期</strong>。</p>
<ol>
<li>创建Servlet实例。</li>
<li>Web容器调用Servlet的init方法，对Servlet进行初始化。</li>
<li>Servlet初始化后，将一直存在于容器中，用于响应客户端请求。如果客户端发送GET请求，容器调用Servlet的doGet方法处理并响应请求；如果客户端发送POST请求，容器调用Servlet的doPost方法处理并响应请求。或者统一使用service()方法处理来响应用户请求。</li>
<li>Web容器决定销毁Servlet时，先调用Servlet的destroy方法，通常在关闭Web应用之时销毁Servlet。</li>
</ol>
<h3 id="load-on-startup_Servlet">load-on-startup Servlet</h3><p>配置load-on-startup的Servlet有两种方式：</p>
<ul>
<li>在web.xml文件中通过<code>&lt;servlet.../&gt;</code>元素的<code>&lt;load-on-startup.../&gt;</code>子元素进行配置。</li>
<li>通过@WebServlet Annotation的loadOnStartup属性指定。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- Servlet名 --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>timerServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- Servlet的实现类 --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>lee.TimerServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 配置应用启动时，创建Servlet实例，相当于指定@WebServlet的loadOnStartup属性--&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="title">load-on-startup</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过注解<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function"><span class="title">WebServlet</span><span class="params">(loadOnStartup=<span class="number">1</span>)</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="访问Servlet的配置参数">访问Servlet的配置参数</h3><p>为Servlet配置参数有两种方式：</p>
<ul>
<li>通过@WebServlet的initParams属性来指定。</li>
<li>通过在web.xml文件的<code>&lt;servlet.../&gt;</code>元素中添加<code>&lt;init-param.../&gt;</code>子元素来指定。</li>
</ul>
<p>访问Servlet配置参数通过ServletConfig对象完成，ServletConfig提供如下方法。<br>java.lang.String getInitParameter(java.lang.String name)：用于获取初始化参数。<br>JSP的内置对象config就是此处的ServletConfig。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">servlet</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置Servlet名 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>testServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 指定Servlet的实现类 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-class</span>&gt;</span>lee.TestServlet<span class="tag">&lt;/<span class="title">servlet-class</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置Servlet的初始化参数：user --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>user<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置Servlet的初始化参数：pass --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">init-param</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>pass<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>32147<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">init-param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">servlet-mapping</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 确定Servlet名 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">servlet-name</span>&gt;</span>testServlet<span class="tag">&lt;/<span class="title">servlet-name</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置Servlet映射的URL --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/testServlet<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过注解<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@WebServlet</span>(name=<span class="string">"testServlet"</span> </span><br><span class="line">    , urlPatterns=&#123;<span class="string">"/testServlet"</span>&#125;  </span><br><span class="line">    , initParams=&#123;  </span><br><span class="line">        <span class="variable">@WebInitParam</span>(name=<span class="string">"user"</span>, value=<span class="string">"root"</span>),  </span><br><span class="line">        <span class="variable">@WebInitParam</span>(name=<span class="string">"pass"</span>, value=<span class="string">"32147"</span>)&#125;)</span><br></pre></td></tr></table></figure></p>
<h3 id="使用Servlet作为控制器">使用Servlet作为控制器</h3><p>在标准的MVC模式中，Servlet仅作为控制器使用。Java EE应用架构正是遵循MVC模式的，对于遵循MVC模式的Java EE应用而言，JSP仅作为表现层（View）技术，其作用有两点：</p>
<ul>
<li>负责收集用户请求参数。</li>
<li>将应用的处理结果、状态数据呈现给用户。</li>
</ul>
<p>Servlet则仅充当控制器（Controller）角色，它的作用类似于调度员：所有用户请求都发送给 Servlet，Servlet调用Model来处理用户请求，并调用JSP来呈现处理结果；或者Servlet直接调用JSP将应用的状态数据呈现给用户。</p>
<p>Model通常由JavaBean来充当，所有业务逻辑、数据访问逻辑都在Model中实现。实际上隐藏在Model下的可能还有很多丰富的组件，例如DAO组件、领域对象等。</p>
<p>下面是MVC中各个角色的对应组件。</p>
<p>M：Model，即模型，对应JavaBean。<br>V：View，即视图，对应JSP页面。<br>C：Controller，即控制器，对应Servlet。</p>
<h2 id="JSP_2的自定义标签">JSP 2的自定义标签</h2><p>在JSP 2中开发标签库只需如下几个步骤。</p>
<ul>
<li>开发自定义标签处理类；</li>
<li>建立一个<code>*.tld</code>文件，每个<code>*.tld</code>文件对应一个标签库，每个标签库可包含多个标签；</li>
<li>在JSP文件中使用自定义标签。</li>
</ul>
<h3 id="开发自定义标签类">开发自定义标签类</h3><p>自定义标签类应该继承一个父类：javax.servlet.jsp.tagext.SimpleTagSupport，除此之外，JSP自定义标签类还有如下要求：</p>
<ul>
<li>如果标签类包含属性，每个属性都有对应的getter和setter方法。</li>
<li>重写doTag()方法，这个方法负责生成页面内容。</li>
</ul>
<h3 id="建立TLD文件">建立TLD文件</h3><p>TLD是Tag Library Definition的缩写，即标签库定义，文件的后缀是tld，每个TLD文件对应一个标签库，一个标签库中可包含多个标签。TLD文件也称为标签库定义文件。</p>
<p>标签库定义文件的根元素是taglib，它可以包含多个tag子元素，每个tag子元素都定义一个标签。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">taglib</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee"</span> </span><br><span class="line"><span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span>     </span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee web-jsptaglibrary_2_0.xsd"</span>     </span><br><span class="line"><span class="attribute">version</span>=<span class="value">"2.0"</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">tlib-version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="title">tlib-version</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">short-name</span>&gt;</span>mytaglib<span class="tag">&lt;/<span class="title">short-name</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 定义该标签库的URI --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">uri</span>&gt;</span>http://www.crazyit.org/mytaglib<span class="tag">&lt;/<span class="title">uri</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 定义第一个标签 --&gt;</span>     </span><br><span class="line"><span class="tag">&lt;<span class="title">tag</span>&gt;</span>         </span><br><span class="line"><span class="comment">&lt;!-- 定义标签名 --&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="title">name</span>&gt;</span>helloWorld<span class="tag">&lt;/<span class="title">name</span>&gt;</span>         </span><br><span class="line"><span class="comment">&lt;!-- 定义标签处理类 --&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="title">tag-class</span>&gt;</span>lee.HelloWorldTag<span class="tag">&lt;/<span class="title">tag-class</span>&gt;</span>         </span><br><span class="line"><span class="comment">&lt;!-- 定义标签体为空 --&gt;</span>         </span><br><span class="line"><span class="tag">&lt;<span class="title">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="title">body-content</span>&gt;</span>     </span><br><span class="line"><span class="tag">&lt;/<span class="title">tag</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>taglib下有如下三个子元素。</p>
<ul>
<li>tlib-version：指定该标签库实现的版本，这是一个作为标识的内部版本号，对程序没有太大的作用。</li>
<li>short-name：该标签库的默认短名，该名称通常也没有太大的用处。</li>
<li>uri：这个属性非常重要，它指定该标签库的URI，相当于指定该标签库的唯一标识。如上面斜体字代码所示，JSP页面中使用标签库时就是根据该URI属性来定位标签库的。</li>
</ul>
<p>除此之外，taglib元素下可以包含多个tag元素，每个tag元素定义一个标签，tag元素下允许出现如下常用子元素。</p>
<ul>
<li>name：该标签库的名称，这个子元素很重要，JSP页面中就是根据该名称来使用此标签的。</li>
<li>tag-class：指定标签的处理类，毋庸置疑，这个子元素非常重要，它指定了标签由哪个标签处理类来处理。</li>
<li>body-content：这个子元素也很重要，它指定标签体内容。该子元素的值可以是如下几个。<ul>
<li>tagdependent：指定标签处理类自己负责处理标签体。</li>
<li>empty：指定该标签只能作为空标签使用。</li>
<li>scriptless：指定该标签的标签体可以是静态HTML元素、表达式语言，但不允许出现JSP脚本。</li>
<li>JSP：指定该标签的标签体可以使用JSP脚本。</li>
<li>dynamic-attributes：指定该标签是否支持动态属性。只有当定义动态属性标签时才需要该子元素。</li>
</ul>
</li>
</ul>
<p>因为JSP 2规范不再推荐使用JSP脚本，所以JSP 2自定义标签的标签体中不能包含JSP脚本。所以，实际上body-content元素的值不可以是JSP。</p>
<p>定义了上面的标签库定义文件后，将标签库文件放在Web应用的WEB-INF路径或任意子路径下，Java Web规范会自动加载该文件，则该文件定义的标签库也将生效。</p>
<h3 id="使用标签库">使用标签库</h3><p>在JSP页面中确定指定的标签需要两点。</p>
<ul>
<li>标签库URI：确定使用哪个标签库。</li>
<li>标签名：确定使用哪个标签。</li>
</ul>
<p>使用标签库分成以下两个步骤。</p>
<ul>
<li>导入标签库：使用taglib编译指令导入标签库，就是将标签库和指定前缀关联起来。</li>
<li>使用标签：在JSP页面中使用自定义标签。</li>
</ul>
<p>taglib的语法格式如下：<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">%</span>@ taglib uri=<span class="string">"tagliburi"</span> prefix=<span class="string">"tagPrefix"</span> <span class="preprocessor">%</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>其中uri属性确定标签库的URI，这个URI可以确定一个标签库。而prefix属性指定标签库前缀，即所有使用该前缀的标签将由此标签库处理。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">%@</span> <span class="attribute">page</span> <span class="attribute">contentType</span>=<span class="value">"text/html; charset=GBK"</span> <span class="attribute">language</span>=<span class="value">"java"</span> <span class="attribute">errorPage</span>=<span class="value">""</span> %&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 导入标签库，指定mytag前缀的标签，由http://www.crazyit.org/mytaglib的标签库处理 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">%@</span> <span class="attribute">taglib</span> <span class="attribute">uri</span>=<span class="value">"http://www.crazyit.org/mytaglib"</span> <span class="attribute">prefix</span>=<span class="value">"mytag"</span><span class="value">%</span>&gt;</span> </span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/1999/xhtml"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">title</span>&gt;</span>自定义标签示范<span class="tag">&lt;/<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">body</span> <span class="attribute">bgcolor</span>=<span class="value">"#ffffc0"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>下面显示的是自定义标签中的内容<span class="tag">&lt;/<span class="title">h2</span>&gt;</span> </span><br><span class="line"><span class="comment">&lt;!-- 使用标签 ，其中mytag是标签前缀，根据taglib的编译指令，mytag前缀将由http://www.crazyit.org/mytaglib的标签库处理 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">mytag:helloWorld</span>/&gt;</span><span class="tag">&lt;<span class="title">br</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span> <span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="带属性的标签">带属性的标签</h3><p>带属性标签必须为每个属性提供对应的setter和getter方法。</p>
<p>对于有属性的标签，需要为<code>&lt;tag.../&gt;</code>元素增加<code>&lt;attribute.../&gt;</code>子元素，每个attribute子元素定义一个标签属性。<code>&lt;attribute.../&gt;</code>子元素通常还需要指定如下几个子元素。</p>
<ul>
<li>name：设置属性名，子元素的值是字符串内容。</li>
<li>required：设置该属性是否为必需属性，该子元素的值是true或false。</li>
<li>fragment：设置该属性是否支持JSP脚本、表达式等动态内容，子元素的值是true或false。</li>
</ul>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">tag</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 定义标签名 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>tagname<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 定义标签处理类 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">tag-class</span>&gt;</span>lee.Tag<span class="tag">&lt;/<span class="title">tag-class</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 定义标签体为空 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="title">body-content</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置标签属性:user --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">attribute</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">name</span>&gt;</span>user<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">required</span>&gt;</span>true<span class="tag">&lt;/<span class="title">required</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">fragment</span>&gt;</span>true<span class="tag">&lt;/<span class="title">fragment</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">attribute</span>&gt;</span> </span><br><span class="line">    <span class="comment">&lt;!-- 配置标签属性:pass --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">attribute</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">name</span>&gt;</span>pass<span class="tag">&lt;/<span class="title">name</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">required</span>&gt;</span>true<span class="tag">&lt;/<span class="title">required</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="title">fragment</span>&gt;</span>true<span class="tag">&lt;/<span class="title">fragment</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;/<span class="title">attribute</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">tag</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>JSTL是Sun提供的一套标签库，这套标签库的功能非常强大。另外，DisplayTag是Apache组织下的一套开源标签库，主要用于生成页面并显示效果。</p>
<h3 id="带标签体的标签">带标签体的标签</h3><p>带标签体的标签，可以在标签内嵌入其他内容（包括静态的HTML内容和动态的JSP内容），通常用于完成一些逻辑运算，例如判断和循环等。下面以一个迭代器标签为示例，介绍带标签体标签的开发过程。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">IteratorTag</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SimpleTagSupport</span>  &#123;</span></span><br><span class="line">    <span class="comment">//标签属性，用于指定需要被迭代的集合</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> collection;</span><br><span class="line">    <span class="comment">//标签属性，指定迭代集合元素，为集合元素指定的名称</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> item;</span><br><span class="line">    <span class="comment">//省略collection属性的setter和getter方法      ...      </span></span><br><span class="line">    <span class="comment">//省略item属性的setter和getter方法      ...      </span></span><br><span class="line">    <span class="comment">//标签的处理方法，简单标签处理类只需要重写doTag方法      </span></span><br><span class="line">    public void doTag() <span class="keyword">throws</span> <span class="type">JspException</span>, <span class="type">IOException</span>&#123;</span><br><span class="line">        <span class="comment">//从page scope中获取属性名为collection的集合</span></span><br><span class="line">        <span class="type">Collection</span> itemList = (<span class="type">Collection</span>)getJspContext().getAttribute(collection);</span><br><span class="line">        <span class="comment">//遍历集合          </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Object</span> s : itemList)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">//将集合的元素设置到page 范围</span></span><br><span class="line">            getJspContext().setAttribute(item, s );</span><br><span class="line">            <span class="comment">//输出标签体              </span></span><br><span class="line">            getJspBody().invoke(<span class="literal">null</span>);</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>标签处理类的doTag方法首先从page范围内获取了指定名称的Collection对象，然后遍历Collection对象的元素，每次遍历都调用了getJspBody()方法，该方法返回该标签所包含的标签体：JspFragment对象，执行该对象的invoke()方法，即可输出标签体内容。该标签的作用是：遍历指定集合，每遍历一个集合元素，即输出标签体一次。</p>
<p>mytaglib.tld:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">tag</span>&gt;</span>     </span><br><span class="line"><span class="comment">&lt;!-- 定义标签名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">name</span>&gt;</span>iterator<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义标签处理类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tag-class</span>&gt;</span>lee.IteratorTag<span class="tag">&lt;/<span class="title">tag-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义标签体不允许出现JSP脚本 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body-content</span>&gt;</span>scriptless<span class="tag">&lt;/<span class="title">body-content</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置标签属性:collection --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">attribute</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>collection<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">required</span>&gt;</span>true<span class="tag">&lt;/<span class="title">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">fragment</span>&gt;</span>true<span class="tag">&lt;/<span class="title">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">attribute</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置标签属性:item --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">attribute</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>item<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">required</span>&gt;</span>true<span class="tag">&lt;/<span class="title">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">fragment</span>&gt;</span>true<span class="tag">&lt;/<span class="title">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">attribute</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">tag</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>iteratorTag.jsp:<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="vbscript">&lt;%@ page contentType=<span class="string">"text/html; charset=GBK"</span> language=<span class="string">"java"</span> errorPage=<span class="string">""</span> %&gt;</span><span class="xml"> </span><br><span class="line"></span><span class="vbscript">&lt;%@ page import=<span class="string">"java.util.*"</span>%&gt;</span><span class="xml"></span><br><span class="line"><span class="comment">&lt;!-- 导入标签库，指定mytag前缀的标签，由http://www.crazyit.org/mytaglib的标签库处理 --&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%@ taglib uri=<span class="string">"http://www.crazyit.org/mytaglib"</span> prefix=<span class="string">"mytag"</span>%&gt;</span><span class="xml"></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>带标签体的标签-迭代器标签<span class="tag">&lt;/<span class="title">h2</span>&gt;</span><span class="tag">&lt;<span class="title">hr</span>/&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%</span><br><span class="line">//创建一个List对象</span><br><span class="line">List&lt;<span class="built_in">String</span>&gt; a = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">a.add(<span class="string">"疯狂Java"</span>);</span><br><span class="line">a.add(<span class="string">"www.crazyit.org"</span>);</span><br><span class="line">a.add(<span class="string">"java"</span>);</span><br><span class="line">//将List对象放入page范围内</span><br><span class="line">pageContext.setAttribute(<span class="string">"a"</span> , a); </span><br><span class="line">%&gt;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">border</span>=<span class="value">"1"</span> <span class="attribute">bgcolor</span>=<span class="value">"#aaaadd"</span> <span class="attribute">width</span>=<span class="value">"300"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用迭代器标签，对a集合进行迭代 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">mytag:iterator</span> <span class="attribute">collection</span>=<span class="value">"a"</span> <span class="attribute">item</span>=<span class="value">"item"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>$&#123;pageScope.item&#125;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span>         </span><br><span class="line"><span class="tag">&lt;/<span class="title">mytag:iterator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p>
<h3 id="以页面片段作为属性的标签">以页面片段作为属性的标签</h3><p>JSP 2规范的自定义标签还允许直接将一段”页面片段”作为属性，这种方式给自定义标签提供了更大的灵活性。</p>
<p>以”页面片段”为属性的标签与普通标签区别并不大，只有两个简单的改变：</p>
<ul>
<li>标签处理类中定义类型为JspFragment的属性，该属性代表了”页面片段”。</li>
<li>使用标签库时，通过<code>&lt;jsp:attribute.../&gt;</code>动作指令为标签库属性指定值。</li>
</ul>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">FragmentTag</span> <span class="title">extends</span> <span class="title">SimpleTagSupport</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> JspFragment fragment;     </span><br><span class="line">    <span class="comment">//fragment属性的setter和getter方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFragment</span>(<span class="params">JspFragment fragment</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fragment = fragment;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> JspFragment <span class="title">getFragment</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.fragment;</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doTag</span>(<span class="params"></span>) throws JspException, IOException </span>&#123;</span><br><span class="line">        JspWriter <span class="keyword">out</span> = getJspContext().getOut();</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"&lt;div style='padding:10px;border:1px solid black'&gt;"</span>);</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"&lt;h3&gt;下面是动态传入的JSP片段&lt;/h3&gt;"</span>);</span><br><span class="line">        <span class="comment">//调用、输出"页面片段"</span></span><br><span class="line">        fragment.invoke( <span class="keyword">null</span> );</span><br><span class="line">        <span class="keyword">out</span>.println(<span class="string">"&lt;/div"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mytaglib.tld:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">tag</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义标签名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">name</span>&gt;</span>fragment<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义标签处理类 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tag-class</span>&gt;</span>lee.FragmentTag<span class="tag">&lt;/<span class="title">tag-class</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定该标签不支持标签体 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="title">body-content</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义标签属性：fragment --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">attribute</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>fragment<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">required</span>&gt;</span>true<span class="tag">&lt;/<span class="title">required</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">fragment</span>&gt;</span>true<span class="tag">&lt;/<span class="title">fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">attribute</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tag</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>fragmentTag.jsp:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>下面显示的是自定义标签中的内容<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">mytag:fragment</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用jsp:attribute标签传入fragment参数 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">jsp:attribute</span> <span class="attribute">name</span>=<span class="value">"fragment"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 下面是动态的JSP页面片段 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">mytag:helloWorld</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">jsp:attribute</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">mytag:fragment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">br</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">mytag:fragment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">jsp:attribute</span> <span class="attribute">name</span>=<span class="value">"fragment"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 下面是动态的JSP页面片段 --&gt;</span></span><br><span class="line">        $&#123;pageContext.request.remoteAddr&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="title">jsp:attribute</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">mytag:fragment</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="动态属性的标签">动态属性的标签</h3><p>前面介绍带属性标签时，那些标签的属性个数是确定的，属性名也是确定的，绝大部分情况下这种带属性的标签能处理得很好，但在某些特殊情况下，我们需要传入自定义标签的属性个数是不确定的，属性名也不确定，这就需要借助于动态属性的标签了。</p>
<p>动态属性标签比普通标签多了如下两个额外要求：</p>
<ul>
<li>标签处理类还需要实现DynamicAttributes接口。</li>
<li>配置标签时通过<code>&lt;dynamic-attributes.../&gt;</code>子元素指定该标签支持动态属性。</li>
</ul>
<p>DynaAttributesTag.java<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class DynaAttributesTag extends SimpleTagSupport implements DynamicAttributes &#123;</span><br><span class="line">    <span class="comment">//保存每个属性名的集合</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;<span class="keyword">String</span>&gt; keys = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">String</span>&gt;();</span><br><span class="line">    <span class="comment">//保存每个属性值的集合</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;<span class="keyword">Object</span>&gt; values = <span class="keyword">new</span> ArrayList&lt;<span class="keyword">Object</span>&gt;();</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> doTag() <span class="keyword">throws</span> JspException, IOException &#123;</span><br><span class="line">        JspWriter out = getJspContext().getOut();</span><br><span class="line">        <span class="comment">//此处只是简单地输出每个属性</span></span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"&lt;ol&gt;"</span>);</span><br><span class="line">        <span class="keyword">for</span>( <span class="built_in">int</span> i = <span class="number">0</span>; i &lt; keys.<span class="built_in">size</span>(); i++ ) &#123;</span><br><span class="line">            <span class="keyword">String</span> <span class="variable">key</span> = keys.<span class="built_in">get</span>( i );</span><br><span class="line">            <span class="keyword">Object</span> value = values.<span class="built_in">get</span>( i );</span><br><span class="line">            out.<span class="built_in">println</span>( <span class="string">"&lt;li&gt;"</span> + <span class="variable">key</span> + <span class="string">" = "</span> + value + <span class="string">"&lt;/li&gt;"</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        out.<span class="built_in">println</span>(<span class="string">"&lt;/ol&gt;"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> setDynamicAttribute( <span class="keyword">String</span> uri, <span class="keyword">String</span> localName, <span class="keyword">Object</span> value ) <span class="keyword">throws</span> JspException &#123;</span><br><span class="line">        <span class="comment">//添加属性名</span></span><br><span class="line">        keys.<span class="built_in">add</span>( localName );</span><br><span class="line">        <span class="comment">//添加属性值</span></span><br><span class="line">        values.<span class="built_in">add</span>( value );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>mytaglib.tld</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义接受动态属性的标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>dynaAttr<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">tag-class</span>&gt;</span>lee.DynaAttributesTag<span class="tag">&lt;/<span class="title">tag-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">body-content</span>&gt;</span>empty<span class="tag">&lt;/<span class="title">body-content</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定支持动态属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">dynamic-attributes</span>&gt;</span>true<span class="tag">&lt;/<span class="title">dynamic-attributes</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tag</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>dynaAttrTag.jsp</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入标签库，指定mytag前缀的标签，由http://www.crazyit.org/mytaglib的标签库处理 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">%@</span> <span class="attribute">taglib</span> <span class="attribute">uri</span>=<span class="value">"http://www.crazyit.org/mytaglib"</span> <span class="attribute">prefix</span>=<span class="value">"mytag"</span><span class="value">%</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>下面显示的是自定义标签中的内容<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h4</span>&gt;</span>指定两个属性<span class="tag">&lt;/<span class="title">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">mytag:dynaAttr</span> <span class="attribute">name</span>=<span class="value">"crazyit"</span> <span class="attribute">url</span>=<span class="value">"crazyit.org"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">br</span>/&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="title">h4</span>&gt;</span>指定四个属性<span class="tag">&lt;/<span class="title">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">mytag:dynaAttr</span> 书名=<span class="value">"疯狂Java讲义"</span> 价格=<span class="value">"99.0"</span> 出版时间=<span class="value">"2008年"</span> 描述=<span class="value">"Java图书"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">br</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="Filter介绍">Filter介绍</h2><p>Filter可认为是Servlet的一种”加强版”，它主要用于对用户请求进行预处理，也可以对HttpServletResponse进行后处理，是个典型的处理链。Filter也可对用户请求生成响应，这一点与Servlet相同，但实际上很少会使用Filter向用户请求生成响应。使用Filter完整的流程是：Filter对用户请求进行预处理，接着将请求交给Servlet进行处理并生成响应，最后Filter再对服务器响应进行后处理。</p>
<p>Filter有如下几个用处。</p>
<ul>
<li>在HttpServletRequest到达Servlet之前，拦截客户的HttpServletRequest。</li>
<li>根据需要检查HttpServletRequest，也可以修改HttpServletRequest头和数据。</li>
<li>在HttpServletResponse到达客户端之前，拦截HttpServletResponse。</li>
<li>根据需要检查HttpServletResponse，也可以修改HttpServletResponse头和数据。</li>
</ul>
<p>Filter有如下几个种类。</p>
<ul>
<li>用户授权的Filter：Filter负责检查用户请求，根据请求过滤用户非法请求。</li>
<li>日志Filter：详细记录某些特殊的用户请求。</li>
<li>负责解码的Filter：包括对非标准编码的请求解码。</li>
<li>能改变XML内容的XSLT Filter等。</li>
<li>Filter可负责拦截多个请求或响应；一个请求或响应也可被多个Filter拦截。</li>
</ul>
<p>创建一个Filter只需两个步骤：</p>
<ul>
<li>创建Filter处理类。</li>
<li>web.xml文件中配置Filter。</li>
</ul>
<h3 id="创建Filter类">创建Filter类</h3><p>创建Filter必须实现javax.servlet.Filter接口，在该接口中定义了如下三个方法。</p>
<ul>
<li>void init（FilterConfig config）：用于完成Filter的初始化。</li>
<li>void destroy()：用于Filter销毁前，完成某些资源的回收。</li>
<li>void doFilter（ServletRequest request，ServletResponse response,FilterChain chain）：实现过滤功能，该方法就是对每个请求及响应增加的额外处理。</li>
</ul>
<h3 id="配置Filter">配置Filter</h3><p>前面已经提到，Filter可以认为是Servlet的”增强版”，因此配置Filter与配置Servlet非常相似，都需要配置如下两个部分：</p>
<ul>
<li>配置Filter名。</li>
<li>配置Filter拦截URL模式。</li>
</ul>
<p>区别在于，Servlet通常只配置一个URL，而Filter可以同时拦截多个请求的URL。因此，在配置Filter的URL模式时通常会使用模式字符串，使得Filter可以拦截多个请求。与配置Servlet相似的是，配置Filter同样有两种方式：</p>
<ul>
<li>在Filter类中通过Annotation进行配置。</li>
<li>在web.xml文件中通过配置文件进行配置。</li>
</ul>
<p>@WebFilter(filterName=”log”, urlPatterns={“/*”})<br>@WebFilter修饰一个Filter类，用于对Filter进行配置，它支持如表所示的常用属性</p>
<p>@WebFilter支持的常用属性</p>
<p>属    性          | 是否必需 | 说    明<br>asyncSupported    | 否       | 指定该Filter是否支持异步操作模式。关于Filter的异步调用请参考2.15节<br>dispatcherTypes   | 否       | 指定该Filter仅对那种dispatcher模式的请求进行过滤。该属性支持ASYNC、ERROR、FORWARD、INCLUDE、REQUEST 这5个值的任意组合。默认值为同时过滤5种模式的请求<br>displayName       | 否       | 指定该Filter的显示名<br>filterName        |          | 指定该Filter的名称<br>initParams        | 否       | 用于为该Filter配置参数<br>servletNames      | 否       | 该属性值可指定多个Servlet的名称，用于指定该Filter仅对这几个Servlet执行过滤<br>urlPatterns/value | 否       | 这两个属性的作用完全相同。都指定该Filter所拦截的URL</p>
<p>在web.xml文件中配置Filter与配置Servlet非常相似，需要为Filter指定它所过滤的URL，并且也可以为Filter配置参数。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义Filter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Filter的名字，相当于指定@WebFilter的filterName属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>log<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Filter的实现类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>lee.LogFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义Filter拦截的URL地址 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Filter的名字 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>log<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Filter负责拦截的URL，相当于指定@WebFilter的urlPatterns属性 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>实际上Filter和Servlet极其相似，区别只是Filter的doFilter()方法里多了一个FilterChain的参数，通过该参数可以控制是否放行用户请求。</p>
<p>假设系统有包含多个Servlet，这些Servlet都需要进行一些的通用处理：比如权限控制、记录日志等，这将导致在这些Servlet的service方法中有部分代码是相同的—为了解决这种代码重复的问题，我们可以考虑把这些通用处理提取到Filter中完成，这样各Servlet中剩下的只是特定请求相关的处理代码，而通用处理则交给Filter完成。</p>
<p>由于Filter和Servlet如此相似，所以Filter和Servlet具有完全相同的生命周期行为，且Filter也可以通过<init-param...>元素或@WebFilter的initParams属性来配置初始化参数，获取Filter的初始化参数则使用FilterConfig的getInitParameter()方法。</init-param...></p>
<p>对于Java Web应用来说，要实现伪静态非常简单：可以通过Filter拦截所有发向<em>.html请求，然后按某种规则将请求forward到实际的</em>.jsp页面即可。现有的URL Rewrite开源项目为这种思路提供了实现，使用URL Rewrite实现网站伪静态也很简单。</p>
<p>下载URL Rewrite应下载其src项（urlrewritefilter-3.2.0-src.zip），下载完成后得到一个urlrewritefilter-3.2.0-src.zip文件，将该压缩文件解压缩，得到如下文件结构。</p>
<ul>
<li>api：该路径下存放了URL Rewrite项目的API文档。</li>
<li>lib：该路径下存放了URL Rewrite项目的编译和运行所需的第三方类库。</li>
<li>manual：该路径下存放了URL Rewrite项目使用手册。</li>
<li>src：该路径下存放了URL Rewrite项目的源代码。</li>
<li>webapp：该路径是一个URL Rewrite的示例应用。</li>
<li>LICENSE.txt等杂项文档。</li>
</ul>
<p>web.xml<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置Url Rewrite的Filter --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>UrlRewriteFilter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.tuckey.web.filters.urlrewrite.UrlRewriteFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置Url Rewrite的Filter拦截所有请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>UrlRewriteFilter<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的配置片段指定使用URL Rewrite Filter拦截所有的用户请求。</p>
<p>在应用的WEB-INF路径下增加urlrewrite.xml文件，该文件定义了伪静态映射规则，这份伪静态规则是基于正则表达式的。</p>
<p>下面是本应用所使用的urlrewrite.xml伪静态规则文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE urlrewrite PUBLIC "-//tuckey.org//DTD UrlRewrite 3.2//EN" "http://tuckey.org/res/dtds/urlrewrite3.2.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">urlrewrite</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">rule</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 所有配置如下正则表达式的请求 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">from</span>&gt;</span>/userinf-(\w*).html<span class="tag">&lt;/<span class="title">from</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将被forward到如下JSP页面，其中$1代表上面第一个正则表达式所匹配的字符串 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">to</span> <span class="attribute">type</span>=<span class="value">"forward"</span>&gt;</span>/userinf.jsp?username=$1<span class="tag">&lt;/<span class="title">to</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">rule</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">urlrewrite</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的规则文件中只定义了一个简单的规则：所有发向/userinf-(\w<em>).html的请求都将被forward到user.jsp页面，并将(\w</em>)正则表达式所匹配的内容作为username参数值。根据这个伪静态规则，我们应该为该应用提供一个userinf.jsp页面，该页面只是一个模拟了一个显示用户信息的页面</p>
<p>userinf.jsp</p>
<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="vbscript">&lt;%@ page contentType=<span class="string">"text/html; charset=GBK"</span> language=<span class="string">"java"</span> errorPage=<span class="string">""</span> %&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%</span><br><span class="line">//获取请求参数</span><br><span class="line"><span class="built_in">String</span> user = <span class="built_in">request</span>.getParameter(<span class="string">"username"</span>);</span><br><span class="line">%&gt;</span><span class="xml"></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">title</span>&gt;</span> </span><span class="vbscript">&lt;%=user%&gt;</span><span class="xml">的个人信息 <span class="tag">&lt;/<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%</span><br><span class="line">//此处应该通过数据库读取该用户对应的信息</span><br><span class="line">//此处只是模拟，因此简单输出：</span><br><span class="line">out.println(<span class="string">"现在时间是："</span> + <span class="keyword">new</span> java.util.<span class="built_in">Date</span>() + <span class="string">"&lt;br/&gt;"</span>);</span><br><span class="line">out.println(<span class="string">"用户名："</span> + user);  %&gt;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span> <span class="tag">&lt;/<span class="title">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<h2 id="Listener_介绍">Listener 介绍</h2><p>当Web应用在Web容器中运行时，Web应用内部会不断地发生各种事件：如Web应用被启动、Web应用被停止，用户session开始、用户session结束、用户请求到达等，通常来说，这些Web事件对开发者是透明的。</p>
<p>实际上，Servlet API提供了大量监听器来监听Web应用的内部事件，从而允许当Web内部事件发生时回调事件监听器内的方法。</p>
<p>使用Listener只需要两个步骤：</p>
<ul>
<li>定义Listener实现类。</li>
<li>通过Annotation或在web.xml文件中配置Listerner。</li>
</ul>
<h3 id="实现Listenner类">实现Listenner类</h3><p>常用的Web事件监听器接口有如下几个。</p>
<ul>
<li>ServletContextListener：用于监听Web应用的启动和关闭。</li>
<li>ServletContextAttributeListener：用于监听ServletContext范围（application）内属性的改变。</li>
<li>ServletRequestListener：用于监听用户请求。</li>
<li>ServletRequestAttributeListener：用于监听ServletRequest范围（request）内属性的改变。</li>
<li>HttpSessionListener：用于监听用户session的开始和结束。</li>
<li>HttpSessionAttributeListener：用于监听HttpSession范围（session）内属性的改变。</li>
</ul>
<p>下面先以ServletContextListener为例来介绍Listener的开发和使用，ServletContextListener用于监听Web应用的启动和关闭。该Listener类必须实现ServletContextListener接口，该接口包含如下两个方法。</p>
<ul>
<li>contextInitialized(ServletContextEvent sce)：启动Web应用时，系统调用Listener的该方法。</li>
<li>contextDestroyed(ServletContextEvent sce)：关闭Web应用时，系统调用Listener的该方法。</li>
</ul>
<h3 id="配置Listener">配置Listener</h3><p>为Web应用配置Listener也有两种方式：</p>
<ul>
<li>使用@WebListener修饰Listener实现类即可。</li>
<li>在web.xml文档中使用<listener...>元素进行配置。</listener...></li>
</ul>
<p>在web.xml中使用<listener...>元素进行配置时只要配置如下子元素即可。<br>listener-class：指定Listener实现类。</listener...></p>
<p>使用ServletContextAttributeListener</p>
<p>ServletContextAttributeListener用于监听ServletContext（application）范围内属性的变化，实现该接口的监听器需要实现如下三个方法。</p>
<ul>
<li>attributeAdded(ServletContextAttributeEvent event)：当程序把一个属性存入application范围时触发该方法。</li>
<li>attributeRemoved(ServletContextAttributeEvent event)：当程序把一个属性从application范围删除时触发该方法。</li>
<li>attributeReplaced(ServletContextAttributeEvent event)：当程序替换application范围内的属性时将触发该方法。</li>
</ul>
<h3 id="使用ServletRequestListener和ServletRequestAttributeListener">使用ServletRequestListener和ServletRequestAttributeListener</h3><p>ServletRequestListener用于监听用户请求的到达，实现该接口的监听器需要实现如下两个方法。</p>
<ul>
<li>requestInitialized(ServletRequestEvent sre)：用户请求到底、被初始化时触发该方法。</li>
<li>requestDestroyed(ServletRequestEvent sre)：用户请求结束、被销毁时触发该方法。</li>
</ul>
<p>ServletRequestAttributeListener则用于监听ServletRequest（request）范围内属性的变化，实现该接口的监听器需要实现attributeAdded、attributeRemoved、attributeReplaced三个方法。</p>
<h3 id="使用HttpSessionListener和HttpSessionAttributeListener">使用HttpSessionListener和HttpSessionAttributeListener</h3><p>HttpSessionListener用于监听用户session的创建和销毁，实现该接口的监听器需要实现如下两个方法。</p>
<ul>
<li>sessionCreated(HttpSessionEvent se)：用户与服务器的会话开始、创建时时触发该方法。</li>
<li>sessionDestroyed(HttpSessionEvent se)：用户与服务器的会话断开、销毁时触发该方法。</li>
</ul>
<p>HttpSessionAttributeListener则用于监听HttpSession（session）范围内属性的变化，实现该接口的监听器需要实现attributeAdded、attributeRemoved、attributeReplaced三个方法。</p>
<h2 id="JSP_2特性">JSP 2特性</h2><p>相比JSP 1.2，JSP 2主要增加了如下新特性。</p>
<ul>
<li>直接配置JSP属性。</li>
<li>表达式语言。</li>
<li>简化的自定义标签API。</li>
<li>Tag文件语法。</li>
</ul>
<p>如果需要使用JSP 2语法，其web.xml文件必须使用Servlet 2.4以上版本的配置文件。Servlet 2.4以上版本的配置文件的根元素写法如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  不再使用DTD，而是使用Schema描述，版本也升级为 2.4--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-app</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee"</span> </span><br><span class="line"><span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span> <span class="attribute">version</span>=<span class="value">"2.4"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此处是Web应用的其他配置 --&gt;</span></span><br><span class="line">...</span><br><span class="line"><span class="tag">&lt;/<span class="title">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="配置jsp属性">配置jsp属性</h3><p>JSP属性定义使用元素配置，主要包括如下4个方面。</p>
<ul>
<li>是否允许使用表达式语言：使用元素确定，默认值为false，即允许使用表达式语言。</li>
<li>是否允许使用JSP脚本：使用元素确定，默认值为false，即允许使用JSP脚本。</li>
<li>声明JSP页面的编码：使用元素确定，配置该元素后，可以代替每个页面里page指令contentType属性的charset部分。</li>
<li>使用隐式包含：使用和元素确定，可以代替在每个页面里使用include编译指令来包含其他页面。</li>
</ul>
<p>此处隐式包含的作用与JSP提供的静态包含的作用相似。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-app</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line"><span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/javaee   http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd"</span> <span class="attribute">version</span>=<span class="value">"3.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">jsp-config</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/noscript/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">el-ignored</span>&gt;</span>true<span class="tag">&lt;/<span class="title">el-ignored</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">page-encoding</span>&gt;</span>GBK<span class="tag">&lt;/<span class="title">page-encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">scripting-invalid</span>&gt;</span>true<span class="tag">&lt;/<span class="title">scripting-invalid</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">include-prelude</span>&gt;</span>/inc/top.jspf<span class="tag">&lt;/<span class="title">include-prelude</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">include-coda</span>&gt;</span>/inc/bottom.jspf<span class="tag">&lt;/<span class="title">include-coda</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">jsp-property-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>*.jsp<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">el-ignored</span>&gt;</span>false<span class="tag">&lt;/<span class="title">el-ignored</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">page-encoding</span>&gt;</span>GBK<span class="tag">&lt;/<span class="title">page-encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">scripting-invalid</span>&gt;</span>false<span class="tag">&lt;/<span class="title">scripting-invalid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">jsp-property-group</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">jsp-property-group</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/inc/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">el-ignored</span>&gt;</span>false<span class="tag">&lt;/<span class="title">el-ignored</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">page-encoding</span>&gt;</span>GBK<span class="tag">&lt;/<span class="title">page-encoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">scripting-invalid</span>&gt;</span>true<span class="tag">&lt;/<span class="title">scripting-invalid</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">jsp-property-group</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">jsp-config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="表达式语言">表达式语言</h3><p>表达式语言（Expression Language）是一种简化的数据访问方式。使用表达式语言可以方便地访问JSP的隐含对象和JavaBeans组件，在JSP 2规范中，建议尽量使用表达式语言使JSP文件的格式一致，避免使用Java脚本。</p>
<p>表达式语言的语法格式是： <code>${expression}</code><br>如果想输出<code>$</code>符号，则在<code>$</code>前加转义字符<code>\</code></p>
<ol>
<li><p>表达式语言支持的算术运算符和逻辑运算符</p>
<p> 所有java语言里的算术运算符都支持，甚至java不支持的运算符也支持。<br> div(除)、mod(取余)、lt(小于)、gt(大于)、ge(大于等于)、le(小于等于)、eq(等于)、ne(不等于)<br> 表达式语言不仅可在数字与数字之间比较，还可在字符与字符之间比较，字符串的比较是根据其对应UNICODE值来比较大小的。<br> 表达式语言把所有数值都当成浮点数处理，所以3/0的实质是3.0/0.0，得到结果应该是Infinity。</p>
</li>
<li><p>表达式语言的内置对象</p>
<p> 表达式语言包含如下11个内置对象。</p>
<ul>
<li>pageContext：代表该页面的pageContext对象，与JSP的pageContext内置对象相同。</li>
<li>pageScope：用于获取page范围的属性值。</li>
<li>requestScope：用于获取request范围的属性值。</li>
<li>sessionScope：用于获取session范围的属性值。</li>
<li>applicationScope：用于获取application范围的属性值。</li>
<li>param：用于获取请求的参数值。</li>
<li>paramValues：用于获取请求的参数值，与param的区别在于，该对象用于获取属性值为数组的属性值。</li>
<li>header：用于获取请求头的属性值。</li>
<li>headerValues：用于获取请求头的属性值，与header的区别在于，该对象用于获取属性值为数组的属性值。</li>
<li>initParam：用于获取请求Web应用的初始化参数。</li>
<li>cookie：用于获取指定的Cookie值。<br>两种方法取得请求参数值：<br><code>${param.name}</code>、 <code>${param[&quot;name&quot;]</code></li>
</ul>
</li>
<li><p>表达式语言的自定义函数</p>
<p> 表达式语言除了可以使用基本的运算符外，还可以使用自定义函数。通过自定义函数，能够大大加强表达式语言的功能。自定义函数的开发步骤非常类似于标签的开发步骤，定义方式也几乎一样。区别在于自定义标签直接在页面上生成输出，而自定义函数则需要在表达式语言中使用。</p>
<p> 函数功能大大扩充了EL的功能，EL本身只是一种数据访问语言，因此它不支持调用方法。如果需要在EL中进行更复杂的处理，就可以通过函数来完成。函数的本质是：提供一种语法允许在EL中调用某个类的静态方法。</p>
<p> 使用标签库定义函数：定义函数的方法与定义标签的方法大致相似。在<code>&lt;taglib.../&gt;</code>元素下增加<code>&lt;tag.../&gt;</code>元素用于定义自定义标签；增加<code>&lt;function.../&gt;</code>元素则用于定义自定义函数。每个<code>&lt;function.../&gt;</code>元素只要三个子元素即可。</p>
<ul>
<li>name：指定自定义函数的函数名。</li>
<li>function-class：指定自定义函数的处理类。</li>
<li><p>function-signature：指定自定义函数对应的方法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">taglib</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee"</span></span><br><span class="line"><span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee web-jsptaglibrary_2_0.xsd"</span> <span class="attribute">version</span>=<span class="value">"2.0"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tlib-version</span>&gt;</span>1.0<span class="tag">&lt;/<span class="title">tlib-version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">short-name</span>&gt;</span>crazyit<span class="tag">&lt;/<span class="title">short-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义该标签库的URI --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">uri</span>&gt;</span>http://www.crazyit.org/tags<span class="tag">&lt;/<span class="title">uri</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义第一个函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">function</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义函数名:reverse --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>reverse<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义函数的处理类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">function-class</span>&gt;</span>lee.Functions<span class="tag">&lt;/<span class="title">function-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义函数的实现方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">function-signature</span>&gt;</span>java.lang.String reverse(java.lang.String)<span class="tag">&lt;/<span class="title">function-signature</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">function</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义第二个函数: countChar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">function</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义函数名:countChar --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">name</span>&gt;</span>countChar<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义函数的处理类 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">function-class</span>&gt;</span>lee.Functions<span class="tag">&lt;/<span class="title">function-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义函数的实现方法--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">function-signature</span>&gt;</span>int countChar(java.lang.String)<span class="tag">&lt;/<span class="title">function-signature</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">function</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">taglib</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的粗体字代码定义了两个函数，不难发现其实定义函数比定义自定义标签更简单，因为自定义函数只需配置三个子元素即可，变化更少。</p>
<p>useFunctions.jsp：</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="title">%@</span> <span class="attribute">page</span> <span class="attribute">contentType</span>=<span class="value">"text/html; charset=GBK"</span> <span class="attribute">language</span>=<span class="value">"java"</span> <span class="attribute">errorPage</span>=<span class="value">""</span> %&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">%@</span> <span class="attribute">taglib</span> <span class="attribute">prefix</span>=<span class="value">"crazyit"</span> <span class="attribute">uri</span>=<span class="value">"http://www.crazyit.org/tags"</span><span class="value">%</span>&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">title</span>&gt;</span>new document<span class="tag">&lt;/<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>表达式语言 - 自定义函数<span class="tag">&lt;/<span class="title">h2</span>&gt;</span><span class="tag">&lt;<span class="title">hr</span>/&gt;</span></span><br><span class="line">请输入一个字符串：</span><br><span class="line"><span class="tag">&lt;<span class="title">form</span> <span class="attribute">action</span>=<span class="value">"useFunctions.jsp"</span> <span class="attribute">method</span>=<span class="value">"post"</span>&gt;</span></span><br><span class="line">字符串 = <span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"text"</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"$</span></span></span><span class="expression">&#123;<span class="variable">param</span>['<span class="variable">name</span>']&#125;</span><span class="xml"><span class="tag"><span class="value">"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">input</span> <span class="attribute">type</span>=<span class="value">"submit"</span>  <span class="attribute">value</span>=<span class="value">"提交"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">border</span>=<span class="value">"1"</span> <span class="attribute">bgcolor</span>=<span class="value">"aaaadd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">b</span>&gt;</span>表达式语言<span class="tag">&lt;/<span class="title">b</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">b</span>&gt;</span>计算结果<span class="tag">&lt;/<span class="title">b</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>\$</span><span class="expression">&#123;<span class="variable">param</span>[<span class="string">"name"</span>]&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>$</span><span class="expression">&#123;<span class="variable">param</span>[<span class="string">"name"</span>]&#125;</span><span class="xml">&amp;nbsp;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--  使用reverse函数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>\$</span><span class="expression">&#123;<span class="variable">crazyit</span>:<span class="variable">reverse</span>(<span class="variable">param</span>[<span class="string">"name"</span>])&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>$</span><span class="expression">&#123;<span class="variable">crazyit</span>:<span class="variable">reverse</span>(<span class="variable">param</span>[<span class="string">"name"</span>])&#125;</span><span class="xml">&amp;nbsp;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>\$</span><span class="expression">&#123;<span class="variable">crazyit</span>:<span class="variable">reverse</span>(<span class="variable">crazyit</span>:<span class="variable">reverse</span>(<span class="variable">param</span>[<span class="string">"name"</span>]))&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>$</span><span class="expression">&#123;<span class="variable">crazyit</span>:<span class="variable">reverse</span>(<span class="variable">crazyit</span>:<span class="variable">reverse</span>(<span class="variable">param</span>[<span class="string">"name"</span>]))&#125;</span><span class="xml">&amp;nbsp;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 使用countChar函数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>\$</span><span class="expression">&#123;<span class="variable">crazyit</span>:<span class="variable">countChar</span>(<span class="variable">param</span>[<span class="string">"name"</span>])&#125;</span><span class="xml"><span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">td</span>&gt;</span>$</span><span class="expression">&#123;<span class="variable">crazyit</span>:<span class="variable">countChar</span>(<span class="variable">param</span>[<span class="string">"name"</span>])&#125;</span><span class="xml">&amp;nbsp;<span class="tag">&lt;/<span class="title">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span> <span class="tag">&lt;/<span class="title">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>如上面程序中粗体字代码所示，导入标签库定义文件后（实质上也是函数库定义文件），就可以在表达式语言中使用函数定义库文件里定义的各函数了。</p>
</li>
</ul>
</li>
</ol>
<h3 id="Tag_File_支持">Tag File 支持</h3><p>建立Tag文件，在JSP所支持Tag File规范下，Tag File代理了标签处理类，它的格式类似于JSP文件。可以这样理解：如同JSP可以代替Servlet作为表现层一样，Tag File则可以代替标签处理类。</p>
<p>Tag File具有以下5个编译指令。</p>
<ul>
<li>taglib：作用与JSP文件中的taglib指令效果相同，用于导入其他标签库。</li>
<li>include：作用与JSP文件中的include指令效果相同，用于导入其他JSP或静态页面。</li>
<li>tag：作用类似于JSP文件中的page指令，有pageEncoding、body-content等属性，用于设置页面编码等属性。</li>
<li>attribute：用于设置自定义标签的属性，类似于自定义标签处理类中的标签属性。</li>
<li>variable：用于设置自定义标签的变量，这些变量将传给JSP页面使用。</li>
</ul>
<p>下面是迭代器标签的Tag File，这个Tag File的语法与JSP语法非常相似。</p>
<p>iterator.tag<br><figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="vbscript">&lt;%@ tag pageEncoding=<span class="string">"GBK"</span> import=<span class="string">"java.util.List"</span>%&gt;</span><span class="xml"></span><br><span class="line"><span class="comment">&lt;!-- 定义了4个标签属性 --&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%@ attribute name=<span class="string">"bgColor"</span> %&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%@ attribute name=<span class="string">"cellColor"</span> %&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%@ attribute name=<span class="string">"title"</span> %&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%@ attribute name=<span class="string">"bean"</span> %&gt;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="title">table</span> <span class="attribute">border</span>=<span class="value">"1"</span> <span class="attribute">bgcolor</span>=<span class="value">"$&#123;bgColor&#125;"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span> <span class="tag">&lt;<span class="title">td</span>&gt;</span><span class="tag">&lt;<span class="title">b</span>&gt;</span>$&#123;title&#125;<span class="tag">&lt;/<span class="title">b</span>&gt;</span><span class="tag">&lt;/<span class="title">td</span>&gt;</span> <span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 取出request范围的a集合 --&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%</span><br><span class="line">List&lt;<span class="built_in">String</span>&gt; list = (List&lt;<span class="built_in">String</span>&gt;) <span class="built_in">request</span>.getAttribute(<span class="string">"a"</span>);</span><br><span class="line">//遍历输出list集合的元素</span><br><span class="line"><span class="keyword">for</span> (Object ele : list)&#123;</span><br><span class="line">%&gt;</span><span class="xml"> </span><br><span class="line"><span class="tag">&lt;<span class="title">tr</span>&gt;</span> <span class="tag">&lt;<span class="title">td</span> <span class="attribute">bgcolor</span>=<span class="value">"$&#123;cellColor&#125;"</span>&gt;</span></span><span class="vbscript">&lt;%=ele%&gt;</span><span class="xml"> <span class="tag">&lt;/<span class="title">td</span>&gt;</span> <span class="tag">&lt;/<span class="title">tr</span>&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%&#125;%&gt;</span><span class="xml"></span></span><br></pre></td></tr></table></figure></p>
<p>将该文件存在Web应用的某个路径下，这个路径相当于标签库的URI名。如将其放在/WEB-INF/tags下</p>
<p>在页面中使用自定义标签时，需要先导入标签库，再使用标签。使用Tag File标签与普通自定义标签的用法完全相同，只是在导入标签库时存在一些差异。由于此时的标签库没有URI，只有标签库路径。因此导入标签时，使用如下语法格式：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="preprocessor">%</span>@ taglib prefix=<span class="string">"tagPrefix"</span> tagdir=<span class="string">"path"</span> <span class="preprocessor">%</span>&gt;</span><br></pre></td></tr></table></figure>
<p>其中，prefix与之前的taglib指令的prefix属性完全相同，用于确定标签前缀；而tagdir标签库路径下存放很多Tag File，每个Tag File对应一个标签。</p>
<p>useTagFile.jsp</p>
<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="vbscript">&lt;%@ page contentType=<span class="string">"text/html; charset=GBK"</span> language=<span class="string">"java"</span> errorPage=<span class="string">""</span> %&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%@ page import=<span class="string">"java.util.*"</span> %&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%@ taglib prefix=<span class="string">"tags"</span> tagdir=<span class="string">"/WEB-INF/tags"</span> %&gt;</span><span class="xml"></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">html</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.w3.org/1999/xhtml"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">head</span>&gt;</span><span class="tag">&lt;<span class="title">title</span>&gt;</span>迭代器tag file<span class="tag">&lt;/<span class="title">title</span>&gt;</span><span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">h2</span>&gt;</span>迭代器tag file<span class="tag">&lt;/<span class="title">h2</span>&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%</span><br><span class="line">//创建集合对象，用于测试Tag File所定义的标签</span><br><span class="line">List&lt;<span class="built_in">String</span>&gt; a = <span class="keyword">new</span> ArrayList&lt;<span class="built_in">String</span>&gt;();</span><br><span class="line">a.add(<span class="string">"hello"</span>);</span><br><span class="line">a.add(<span class="string">"world"</span>);</span><br><span class="line">a.add(<span class="string">"java"</span>);</span><br><span class="line">//将集合对象放入页面范围</span><br><span class="line"><span class="built_in">request</span>.setAttribute(<span class="string">"a"</span> , a);%&gt;</span><span class="xml"></span><br><span class="line">//使用自定义标签</span><br><span class="line"><span class="tag">&lt;<span class="title">tags:iterator</span> <span class="attribute">bgColor</span>=<span class="value">"#99dd99"</span> <span class="attribute">cellColor</span>=<span class="value">"#9999cc"</span> <span class="attribute">title</span>=<span class="value">"迭代器标签"</span> <span class="attribute">bean</span>=<span class="value">"a"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span> <span class="tag">&lt;/<span class="title">html</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;tags:<span class="keyword">iterator</span> bgColor=<span class="string">"#99dd99"</span> cellColor=<span class="string">"#9999cc"</span> title=<span class="string">"迭代器标签"</span> bean=<span class="string">"a"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>tags表明该标签使用/WEB-INF/tags路径下的Tag File来处理标签；<strong>而iterator是标签名，即使用WEB-INF/tags路径下的iterator.tag文件负责处理该标签</strong>。</p>
<p>Tag File是自定义标签的简化。事实上，就如同JSP文件会编译成Servlet一样，Tag File也会编译成标签处理类，自定义标签的后台依然由标签处理类完成，而这个过程由容器完成。打开Tomcat的work\Catalina\localhost\jsp2\org\apache\jsp\tag\web路径，即可看到iterator_tag.java、iterator_tag.class两个文件，这两个文件就是Tag File所对应的标签处理类。</p>
<p>通过查看iterator_tag.java文件的内容不难发现，Tag File中只有如下几个内置对象。</p>
<ul>
<li>request：与JSP脚本中的request对象对应。</li>
<li>response：与JSP脚本中的response对象对应。</li>
<li>session：与JSP脚本中的session对象对应。</li>
<li>application：与JSP脚本中的application对象对应。</li>
<li>config：与JSP脚本中的config对象对应。</li>
<li>out：与JSP脚本中的out对象对应。</li>
</ul>
<h2 id="Servlet_3-0新特性">Servlet 3.0新特性</h2><h3 id="Servlet_3-0的Annotation">Servlet 3.0的Annotation</h3><p>Servlet 3.0规范在javax.servlet.annotation包下提供了如下Annotation。</p>
<ul>
<li>@WebServlet：用于修饰一个Servlet类，用于部署Servlet类。</li>
<li>@WebInitParam：用于与@WebServlet或@WebFilter一起使用，为Servlet、Filter配置参数。</li>
<li>@WebListener：用于修饰Listener类，用于部署Listener类。</li>
<li>@WebFilter：用于修饰Filter类，用于部署Filter类。</li>
<li>@MultipartConfig：用于修饰Servlet，指定该Servlet将会负责处理multipart/form-data类型的请求（主要用于文件上传）。</li>
<li>@ServletSecurity：这是一个与JAAS有关的Annotation，修饰Servlet指定该Servlet的安全与授权控制。</li>
<li>@HttpConstraint：用于与@ServletSecurity一起使用，用于指定该Servlet的安全与授权控制。</li>
<li>@HttpMethodConstraint：用于与@ServletSecurity一起使用，用于指定该Servlet的安全与授权控制。</li>
</ul>
<h3 id="Servlet_3-0的Web模块支持">Servlet 3.0的Web模块支持</h3><p>Servlet 3.0规范不再要求所有Web组件（如Servlet、Listener、Filter等）都部署在web.xml文件中，而是允许采用”Web模块”来部署、管理它们。</p>
<p>一个Web模块通常对应于一个JAR包，这个JAR包有如下文件结构：</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;webModule&gt;</span>.jar--这是Web模块的JAR包，可以改变</span><br><span class="line">|<span class="string">－META-INF</span><br><span class="line"></span>|<span class="string">   </span>|<span class="string">－web-fragment.xml</span><br><span class="line"></span>|<span class="string">－Web模块所用的类文件、资源文件等。</span></span><br></pre></td></tr></table></figure>
<p>从上面的文件结构可以看出，Web模块与普通JAR的最大区别在于需要在META-INF目录下添加一个web-fragment.xml文件，这个文件也被称为Web模块部署描述符。</p>
<p>web-fragment.xml文件与web.xml文件的作用、文档结构都基本相似，因为它们都用于部署、管理各种Web组件。只是web-fragment.xml用于部署、管理Web模块而已，但web-fragment.xml文件可以多指定如下两个元素。</p>
<p><code>&lt;name.../&gt;</code>：用于指定该Web模块的名称。<br><code>&lt;ordering.../&gt;</code>：用于指定加载该Web模块的相对顺序。</p>
<p>web-fragment.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-fragment</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line"><span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd"</span> <span class="attribute">version</span>=<span class="value">"3.0"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定该Web模块的唯一标识 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">name</span>&gt;</span>crazyit<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>lee.CrazyitListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">ordering</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于配置该Web模块必须位于哪些模块之前加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">before</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于指定位于其他所有模块之前加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">others</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">before</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ordering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-fragment</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>另一个web-fragment.xml:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-fragment</span> <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/javaee"</span></span><br><span class="line"><span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-fragment_3_0.xsd"</span> <span class="attribute">version</span>=<span class="value">"3.0"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 指定该Web模块的唯一标识 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">name</span>&gt;</span>leegang<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置Listener --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>lee.LeegangListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">ordering</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 用于配置该Web模块必须位于哪些模块之后加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">after</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 此处可用多个name元素列出该模块必须位于这些模块之后加载 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">name</span>&gt;</span>crazyit<span class="tag">&lt;/<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">after</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">ordering</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-fragment</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>先加载crazyit模块，再加载leegang模块。</p>
<p>Web应用除了可按web-fragment.xml文件中指定的加载顺序来加载Web模块之外，还可以通过web.xml文件指定各Web模块加载的绝对顺序。在web.xml文件中指定的加载顺序将会覆盖Web模块中web-fragment.xml文件所指定的加载顺序。</p>
<h3 id="Servlet_3-0提供的异步处理">Servlet 3.0提供的异步处理</h3><p>在以前的Servlet规范中，如果Servlet作为控制器调用了一个耗时的业务方法，那么Servlet必须等到业务方法完全返回之后才会生成响应，这将使得Servlet对业务方法的调用变成一种阻塞式的调用，因此效率比较低。</p>
<p>Servlet 3.0规范引入了异步处理来解决这个问题，异步处理允许Servlet重新发起一条新线程去调用耗时的业务方法，这样就可避免等待。</p>
<p>Servlet 3.0的异步处理是通过AsyncContext类来处理的，Servlet可通过ServletRequest的如下两个方法开启异步调用、创建AsyncContext对象：</p>
<ul>
<li>AsyncContext startAsync()</li>
<li>AsyncContext startAsync(ServletRequest, ServletResponse)</li>
</ul>
<p>重复调用上面的方法将得到同一个AsyncContext对象。AsyncContext对象代表异步处理的上下文，它提供了一些工具方法，可完成设置异步调用的超时时长，dispatch用于请求、启动后台线程、获取request、response对象等功能。</p>
<p>AsyncServlet.java:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@WebServlet</span>(urlPatterns=<span class="string">"/async"</span>,asyncSupported=<span class="literal">true</span>)</span><br><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AsyncServlet</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HttpServlet</span>  &#123;</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line">public void doGet(<span class="type">HttpServletRequest</span> request, <span class="type">HttpServletResponse</span> response)</span><br><span class="line"><span class="keyword">throws</span> <span class="type">IOException</span>,<span class="type">ServletException</span> &#123;</span><br><span class="line">    response.setContentType(<span class="string">"text/html;charset=GBK"</span>);</span><br><span class="line">    <span class="type">PrintWriter</span> out = response.getWriter();</span><br><span class="line">    out.println(<span class="string">"&lt;title&gt;异步调用示例&lt;/title&gt;"</span>);</span><br><span class="line">    out.println(<span class="string">"进入Servlet的时间："</span> + <span class="keyword">new</span> java.util.<span class="type">Date</span>() + <span class="string">".&lt;br/&gt;"</span>);</span><br><span class="line">    out.flush();</span><br><span class="line">    <span class="comment">//创建AsyncContext，开始异步调用</span></span><br><span class="line">    <span class="type">AsyncContext</span> actx = request.startAsync();</span><br><span class="line">    <span class="comment">//设置异步调用的超时时长</span></span><br><span class="line">    actx.setTimeout(<span class="number">30</span>*<span class="number">1000</span>);</span><br><span class="line">    <span class="comment">//启动异步调用的线程</span></span><br><span class="line">    actx.start(<span class="keyword">new</span> <span class="type">Executor</span>(actx));</span><br><span class="line">    out.println(<span class="string">"结束Servlet的时间："</span> + <span class="keyword">new</span> java.util.<span class="type">Date</span>() + <span class="string">".&lt;br/&gt;"</span>);</span><br><span class="line">    out.flush();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是线程执行体的代码。</p>
<p>Executor.java</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Executor</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AsyncContext actx = <span class="keyword">null</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Executor</span><span class="params">(AsyncContext actx)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actx = actx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//等待5秒钟，以模拟业务方法的执行</span></span><br><span class="line">            Thread.sleep(<span class="number">5</span> * <span class="number">1000</span>);</span><br><span class="line">            ServletRequest request = actx.getRequest();</span><br><span class="line">            List&lt;String&gt; books = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">            books.add(<span class="string">"疯狂Java讲义"</span>);</span><br><span class="line">            books.add(<span class="string">"经典Java EE企业应用实战"</span>);</span><br><span class="line">            books.add(<span class="string">"疯狂XML讲义"</span>);</span><br><span class="line">            request.setAttribute(<span class="string">"books"</span> , books);</span><br><span class="line">            actx.dispatch(<span class="string">"/async.jsp"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span>(Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该线程执行体内让线程暂停5秒来模拟调用耗时的业务方法，最后调用AsyncContext的dispatch方法把请求dispatch到指定JSP页面。</p>
<p>被异步请求dispatch的目标页面需要指定session=”false”，表明该页面不会重新创建session。</p>
<p>async.jsp:</p>
<figure class="highlight vbscript-html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"></span><span class="vbscript">&lt;%@ page contentType=<span class="string">"text/html; charset=GBK"</span> language=<span class="string">"java"</span> session=<span class="string">"false"</span>%&gt;</span><span class="xml"></span><br><span class="line"></span><span class="vbscript">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><span class="xml"></span><br><span class="line"><span class="tag">&lt;<span class="title">ul</span>&gt;</span> <span class="tag">&lt;<span class="title">c:forEach</span> <span class="attribute">items</span>=<span class="value">"$&#123;books&#125;"</span> <span class="attribute">var</span>=<span class="value">"book"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">li</span>&gt;</span>$&#123;book&#125;<span class="tag">&lt;/<span class="title">li</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">c:forEach</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="title">ul</span>&gt;</span></span><br><span class="line"></span><span class="vbscript">&lt;%out.println(<span class="string">"业务调用结束的时间："</span> + <span class="keyword">new</span> java.util.<span class="built_in">Date</span>());</span><br><span class="line">//完成异步调用</span><br><span class="line"><span class="built_in">request</span>.getAsyncContext().complete();</span><br><span class="line">%&gt;</span><span class="xml"></span></span><br></pre></td></tr></table></figure>
<p>为Servlet开启异步调用有两种方式：</p>
<ul>
<li>为@WebServlet指定asyncSupported=true。</li>
<li>在web.xml文件的<servlet...>元素中增加<async-supported...>子元素。</async-supported...></servlet...></li>
</ul>
<p>当Servlet启用异步调用的线程之后，该线程的执行过程对开发者是透明的。但在有些情况下，开发者需要了解该异步线程的执行细节，并针对特定的执行结果进行针对性处理，这可借助于Servlet 3.0提供的异步监听器来实现。</p>
<p>异步监听器需要实现AsyncListener接口，实现该接口的监听器类需要实现如下4个方法。</p>
<ul>
<li>onStartAsync(AsyncEvent event)：当异步调用开始时触发该方法。</li>
<li>onComplete(AsyncEvent event)：当异步调用完成时触发该方法。</li>
<li>onError(AsyncEvent event)：当异步调用出错时触发该方法。</li>
<li>onTimeout(AsyncEvent event)：当异步调用超时时触发该方法。</li>
</ul>
<p>提供了异步监听器之后，还需要通过AsyncContext来注册监听器，调用该对象的addListener()方法即可注册监听器。例如在上面的Servlet中增加如下代码即可注册监听器：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">AsyncContext actx = request.startAsync<span class="params">()</span>;</span><br><span class="line"><span class="comment">//为该异步调用注册监听器</span></span><br><span class="line">actx.addListener<span class="params">(new MyAsyncListener<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>虽然上面的MyAsyncListener监听器类可以监听异步调用开始、异步调用完成两个事件，但从实际运行的结果来看，它并不能监听到异步调用开始事件，这可能是因为注册该监听器时异步调用已经开始了的缘故。</p>
<p>在Filter中进行异步调用与在Servlet中进行异步调用的效果完全相似</p>
<h3 id="改进的Servlet_API">改进的Servlet API</h3><p>Servlet 3.0还有一个改变是改进了部分API，这种改进很好地简化了Java Web开发。其中两个较大的改进是：</p>
<p>HttpServletRequest增加了对文件上传的支持。</p>
<p>ServletContext允许通过编程的方式动态注册Servlet、Filter。</p>
<p>HttpServletRequest提供了如下两个方法来处理文件上传。</p>
<p>Part getPart(String name)：根据名称来获取文件上传域。</p>
<p>Collection<part> getParts()：获取所有的文件上传域。</part></p>
<p>上面两个方法的返回值都涉及一个API：Part，每个Part对象对应于一个文件上传域，该对象提供了大量方法来访问上传文件的文件类型、大小、输入流等，并提供了一个write(String file)方法将上传文件写入服务器磁盘。</p>
<p>为了向服务器上传文件，需要在表单里使用<code>&lt;input type=&quot;file&quot; .../&gt;</code>文件域，这个文件域会在HTML页面上产生一个单行文本框和一个”浏览”按钮，浏览者可通过该按钮选择需要上传的文件。除此之外，上传文件一定要为表单域设置enctype属性。</p>
<p>表单的enctype属性指定的是表单数据的编码方式，该属性有如下三个值。</p>
<ul>
<li>application/x-www-form-urlencoded：这是默认的编码方式，它只处理表单域里的value属性值，采用这种编码方式的表单会将表单域的值处理成URL编码方式。</li>
<li>multipart/form-data：这种编码方式会以二进制流的方式来处理表单数据，这种编码方式会把文件域指定文件的内容也封装到请求参数里。</li>
<li>text/plain：这种编码方式当表单的action属性为mailto:URL的形式时比较方便，这种方式主要适用于直接通过表单发送邮件的方式。</li>
</ul>
<p>如果将enctype设置为application/x-www-form-urlencoded，或不设置enctype属性，提交表单时只会发送文件域的文本框里的字符串，也就是浏览者所选择文件的绝对路径，对服务器获取该文件在客户端上的绝对路径没有任何作用，因为服务器不可能访问客户机的文件系统。</p>
<p>UploadServlet.java:</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@WebServlet<span class="params">(name=<span class="string">"upload"</span> , urlPatterns=&#123;<span class="string">"/upload"</span>&#125;)</span></span><br><span class="line">@MultipartConfig</span><br><span class="line">public class UploadServlet extends HttpServlet &#123;</span><br><span class="line">    public void service<span class="params">(HttpServletRequest request , HttpServletResponse response)</span> throws IOException , ServletException &#123; </span><br><span class="line">        response.setContentType<span class="params">(<span class="string">"text/html;charset=GBK"</span>)</span>;</span><br><span class="line">        PrintWriter out = response.getWriter<span class="params">()</span>;</span><br><span class="line">        <span class="comment">//获取普通请求参数</span></span><br><span class="line">        String fileName = request.getParameter<span class="params">(<span class="string">"name"</span>)</span>;</span><br><span class="line">        <span class="comment">//获取文件上传域</span></span><br><span class="line">        Part part = request.getPart<span class="params">(<span class="string">"file"</span>)</span>;</span><br><span class="line">        <span class="comment">//获取上传文件的类型</span></span><br><span class="line">        out.println<span class="params">(<span class="string">"上传文件的类型为："</span> + part.getContentType<span class="params">()</span> + <span class="string">"&lt;br/&gt;"</span>)</span>;</span><br><span class="line">        <span class="comment">//获取上传文件的大小</span></span><br><span class="line">        out.println<span class="params">(<span class="string">"上传文件的的大小为："</span> + part.getSize<span class="params">()</span>  + <span class="string">"&lt;br/&gt;"</span>)</span>;</span><br><span class="line">        <span class="comment">//获取该文件上传域的Header Name</span></span><br><span class="line">        Collection&lt;String&gt; headerNames = part.getHeaderNames<span class="params">()</span>;</span><br><span class="line">        <span class="comment">//遍历文件上传域的Header Name、Value</span></span><br><span class="line">        <span class="keyword">for</span> <span class="params">(String headerName : headerNames)</span> &#123;</span><br><span class="line">            out.println<span class="params">(headerName + <span class="string">"---&gt;"</span> + part.getHeader<span class="params">(headerName)</span> + <span class="string">"&lt;br/&gt;"</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将上传的文件写入服务器</span></span><br><span class="line">        part.write<span class="params">(getServletContext<span class="params">()</span>.getRealPath<span class="params">(<span class="string">"/uploadFiles"</span>)</span> + <span class="string">"/"</span> + fileName )</span>;</span><br><span class="line">        <span class="comment">//①</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面Servlet使用了@MultipartConfig修饰，处理文件上传的Servlet应该使用该Annotation修饰。接下来该Servlet中HttpServletRequest就可通过getPart(String name)方法来获取文件上传域—就像获取普通请求参数一样。</p>
<p>与Servlet 3.0所有Annotation相似的是，Servlet 3.0为@提供了相似的配置元素，我们同样可以通过在<servlet...>元素中添加<multipart-config...>子元素来达到相同的效果。</multipart-config...></servlet...></p>
<p>上面Servlet上传时保存的文件名直接使用了name请求参数，实际项目中一般不会这么做，因为可能多个用户会填写相同的name参数，这样将导致后面用户上传的文件覆盖前面用户上传的图片。实际项目中可借助于java.util.UUID工具类生成文件名。</p>
<p>ServletContext则提供了如下方法来动态地注册Servet、Filter，并允许动态设置Web应用的初始化参数。</p>
<ul>
<li>多个重载的addServlet：动态地注册Servlet。</li>
<li>多个重载的addFilter：动态地注册Filter。</li>
<li>多个重载的addListener：动态地注册Listener。</li>
</ul>
<p>setInitParameter(String name, String value)：为Web应用设置初始化参数。</p>
]]></content>
    <summary type="html">
    <![CDATA[JSP/Servlet及相关技术笔记]]>
    
    </summary>
    
      <category term="JSP" scheme="http://howiefh.github.io/tags/JSP/"/>
    
      <category term="Servlet" scheme="http://howiefh.github.io/tags/Servlet/"/>
    
      <category term="JavaEE" scheme="http://howiefh.github.io/categories/JavaEE/"/>
    
      <category term="JSP" scheme="http://howiefh.github.io/categories/JavaEE/JSP/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring笔记一]]></title>
    <link href="http://howiefh.github.io/2015/03/06/spring-note-1/"/>
    <id>http://howiefh.github.io/2015/03/06/spring-note-1/</id>
    <published>2015-03-06T08:09:20.000Z</published>
    <updated>2015-07-17T03:44:51.000Z</updated>
    <content type="html"><![CDATA[<p>使用Spring框架，必须使用Spring Core Container，主要由<code>org.springframework.core</code>、<code>org.springframework.beans</code>和<code>org.springframework.context</code>、<code>org.springframework.expression</code>四个包及其子包组成，主要提供Spring IoC容器支持。</p>
<a id="more"></a>
<p><img src="http://fh-1.qiniudn.com/spring3-modules.png" alt="Spring组成结构" title="Spring组成结构"></p>
<h2 id="Spring核心机制：依赖注入">Spring核心机制：依赖注入</h2><p>Java应用（从applets的小范围到全套n层服务端企业应用）是一种典型的依赖型应用，它就是由一些互相适当地协作的对象构成的。因此，我们说这些对象间存在依赖关系。加入A组件调用了B组件的方法，我们就可以称A组件依赖于B组件。我们通过使用依赖注入，Java EE应用中的各种组件不需要以硬编码方式耦合在一起，甚至无需使用工厂模式。当某个Java 实例需要其他Java 实例时，系统自动提供所需要的实例，无需程序显示获取，这种自动提供java实例我们谓之为依赖注入，也可以称之为控制反转（Inversion of Control IoC）。</p>
<p>依赖注入通常有如下两种：</p>
<ol>
<li>设置注入：IoC容器使用属性的setter方法来注入被依赖的实例。</li>
<li>构造注入：IoC容器使用构造器来注入被依赖的实例。</li>
</ol>
<h3 id="设值注入">设值注入</h3><p>设值注入是指IoC容器使用属性的setter方法来注入被依赖的实例。这种注入方式比较简单、直观。<br>下面是Person接口，该接口定义了一个Person规范。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;</span><br><span class="line">    //定义使用斧子的方法</span><br><span class="line">    public void useAxe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Axe接口：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;</span><br><span class="line">    <span class="comment">//Axe接口里面有个砍的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Person的实现类。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Chinese implements <span class="keyword">Person</span> &#123;</span><br><span class="line">    private Axe axe;</span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    // 设值注入所需的setter方法</span><br><span class="line">    public void setAxe(Axe axe) &#123;</span><br><span class="line">        this.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void setName(String name) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 实现<span class="keyword">Person</span>接口的userAxe方法</span><br><span class="line">    public void useAxe() &#123;</span><br><span class="line">        // 调用axe的chop方法，表明<span class="keyword">Person</span>对象依赖于Axe对象</span><br><span class="line">        System.out.println(<span class="string">"我是"</span>+name+<span class="string">"用"</span>+axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码实现了Person接口的userAxe()方法，实现该方法时调用了axe的的chop()方法，这就是典型的依赖关系。</p>
<p>在这里Spring容器的作用就是已松耦合的方式来管理这种调用关系。在上面的Chinese类中，Chinese类并不知道它要调用的axe实例在哪里，也不知道axe实例是如何实现的，它只是需要调用一个axe实例，这个Axe实例将由Spring容器负责注入。<br>Axe的实现类：StoneAxe类</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoneAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"石斧砍柴好慢啊!!!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直到这里，程序依然不知道Chinese类和Axe实例耦合，Spring也不知道！实际上，Spring需要使用XML配置文件来指定实例之间的依赖关系。<br>Spring采用了XML文件作为配置文件。<br>对于本应用的XML配置文件如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Chinese实例，其实现类是Chinese --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.Chinese"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 将StoneAxe注入给axe属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"axe"</span> <span class="attribute">ref</span>=<span class="value">"stoneAxe"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"孙悟空"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置stoneAxe实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"stoneAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.StoneAxe"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在配置文件中，Spring配置Bean实例通常会指定两个属性：</p>
<ul>
<li>id：指定该Bean的唯一标识，程序会通过id属性值来访问该Bean实例。</li>
<li>class：指定该Bean的实现类，此处不可再用接口，必须是实现类，Spring容器会使用XML解析器读取该属性值，并利用反射来创建该实现类的实例。</li>
</ul>
<p>从上面可以看出Bean于Bean之间的依赖关系放在配置文件里组织，而不是写在代码里。通过配置文件的指定，Spring能够精确地为每个Bean注入属性。因此，配置文件里的<code>&lt;bean…/&gt;</code>元素的class属性值不能是接口，而必须是真正的实现类。</p>
<p>Spring会自动接管每个<code>&lt;bean…/&gt;</code>定义里的<code>&lt;property …/&gt;</code>元素定义，Spring会在调用无参数的构造器、创建默认的Bean实例后，调用相应的setter方法为程序注入属性值。<code>&lt;property…/&gt;</code>定义的属性值将不再有该Bean来主动设置、管理，而是接受Spring的注入。</p>
<p>每个Bean的id属性是该Bean的唯一标识，程序通过id属性访问Bean，Bean与Bean的依赖关系也是通过id属性关联。<br>测试程序：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class BeanTest &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        //创建Spring容器</span><br><span class="line">        ApplicationContext ctx = new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        //获取Chinese实例</span><br><span class="line">        <span class="keyword">Person</span> <span class="keyword">person</span> = ctx.getBean(<span class="string">"chinese"</span>,<span class="keyword">Person</span>.class);</span><br><span class="line">        <span class="keyword">person</span>.useAxe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Bean与Bean之间的依赖关系有Spring管理，Spring采用setter方法为目标Be阿玛尼注入所依赖的Bean，这种方式被称之为设值注入。</p>
<p>从上面的实例我们可以看出，依赖注入以配置文件管理Bean实例之间的耦合，让Bean实例之间的耦合从代码层次分离出来。</p>
<p>Spring IoC容器有如下3个基本要点：</p>
<ol>
<li>应用程序的各个组件面向接口编程。面向接口编程可以将各个组件的耦合提升到接口层次，从而有利于项目后期的扩展。</li>
<li>应用程序的各组件不再由程序主动产生，而是由Spring容器来负责产生，并初始化。</li>
<li>Spring采用配置文件、或者Annotation来管理Bean的实现类、依赖关系，Spring容器则根据配置文件，利用反射机制来创建时间，并为之注入依赖关系。</li>
</ol>
<h3 id="构造注入">构造注入</h3><p>构造注入就是利用构造器来设置依赖关系的方式。<br>Japanese类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="comment">//默认构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//构造注入所需的带参数构造器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">(Axe axe)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的Chinese类并没有setter方法，仅仅只是提供了一个带Axe属性的构造器，Spring将通过该构造器为Chinese注入所依赖的Bean实例。</p>
<p>构造注入的配置文件需要做一些修改。为了使用构造注入，使用<code>&lt;constructor-arg…/&gt;</code>元素来指定构造器的参数。如下</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Chinese实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.Chinese"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 使用构造注入，为Japanese实例注入SteelAxe实例--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">ref</span>=<span class="value">"stoneAxe"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置stoneAxe实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"stoneAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.StoneAxe"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的配置文件使用<code>&lt;contructor-arg…/&gt;</code>元素指定了一个构造器参数，该参数类型是Axe，这指定Spring调用Chinese类里带一个Axe参数的构造器来创建chinese实例，因为使用了有参数的构造器创建实例，所以当Bean实例被创建完成后，该Bean的依赖关系也就已经设置完成。</p>
<h3 id="两种注入方式的对比">两种注入方式的对比</h3><p>Spring支持两种依赖注入方式，这两种依赖注入方式并没有好坏之分，只是适合的场景有所不同。<br>设值注入有如下优点：</p>
<ol>
<li>与传统的JavaBean的写法更相似，程序开发人员更加容易理解，接受。通过setter方法设定依赖关系显得更加直观、自然。</li>
<li>对于复杂的依赖关系，如果采用构造注入，会导致构造器过于臃肿，难以阅读。Spring在创建Bean实例时，需要同时实例化其依赖的全部实例，因此导致性能下降。而设值注入，则可以避免这些问题。</li>
<li>尤其是在某些属性可选的情况下，多参数的构造器更加笨重。</li>
</ol>
<p>但是构造器也有如下优势：</p>
<ol>
<li>构造注入可以再构造器中决定依赖关系的注入顺序，优先依赖的优先注入。</li>
<li>对于依赖关系无须变化的Bean，构造注入更有用处。因为没有setter方法，所有的依赖关系全部在构造器中设定，因此，无须担心后续的代码对依赖关系产生破坏。</li>
<li>依赖关系只能在构造器中设定，则只有组件的创建者才能改变组件的依赖关系。对组件的调用者而言，组件内部的依赖关系完全透明，更加符合高内聚的原则。</li>
</ol>
<p>通过上面的对比。所以建议用以设值注入为主，构造注入为辅的注入策略。对于依赖关系无须变化的注入，尽量采用构造注入；而其他的依赖关系，则考虑设值注入。</p>
<p>Spring有两个核心接口：BeanFactory和ApplicationContext，其中ApplicationContext是BeanFactory的子接口。他们都可代表Spring容器，Spring容器是生成Bean实例的工厂，并且管理容器中的Bean。Bean是Spring管理的基本单位，在基于Spring的Java EE应用中，所有的组件都被当成Bean处理，包括数据源、Hibernate的SessionFactory、事务管理器等。</p>
<p>而且应用中的所有组件，都处于Spring的管理下，都被Spring以Bean的方式管理，Spring负责创建Bean实例，并管理他们的生命周期。Bean在Spring容器中运行，无须感受Spring容器的存在，一样可以接受Spring的依赖注入，包括Bean属性的注入，协作者的注入、依赖关系的注入等。</p>
<p>Spring容器负责创建Bean实例，所以需要知道每个Bean的实现类，Java程序面向接口编程，无须关心Bean实例的实现类；但是Spring容器必须能够精确知道每个Bean实例的实现类，因此Spring配置文件必须精确配置Bean实例的实现类。</p>
<h2 id="Spring容器">Spring容器</h2><p>Spring容器最基本的接口就是BeanFactory。BeanFactory负责配置、创建、管理Bean，他有一个子接口：ApplicationContext，因此也称之为Spring上下文。Spring容器负责管理Bean与Bean之间的依赖关系。</p>
<p>BeanFactory接口包含以下几个基本方法：</p>
<ul>
<li><code>Boolean containBean(String name)</code>:判断Spring容器是否包含id为name的Bean实例。</li>
<li><code>&lt;T&gt; getBean(Class&lt;T&gt; requiredTypr)</code>:获取Spring容器中属于requiredType类型的唯一的Bean实例。</li>
<li><code>Object getBean(String name)</code>：返回Sprin容器中id为name的Bean实例。</li>
<li><code>&lt;T&gt; T getBean(String name,Class requiredType)</code>：返回容器中id为name,并且类型为requiredType的Bean</li>
<li><code>Class &lt;?&gt; getType(String name)</code>：返回容器中指定Bean实例的类型。</li>
</ul>
<p>在使用BeanFactory接口时，我们一般都是使用这个实现类：org.springframework.beans.factory.xml.XmlBeanFactory。然而ApplicationContext作为BeanFactory的子接口，使用它作为Spring容器会更加方便。它的实现类有：FileSystemXmlApplicationContext、ClassPathXmlApplicationContext、AnnotationConfigApplicationContext。</p>
<p>创建Spring容器实例时，必须提供Spring容器管理的Bean的详细配置信息。Spring的配置信息通常采用xml配置文件来设置，因此，创建BeanFactory实例时，应该提供XML配置文件作为参数。</p>
<p>XML配置文件通常使用Resource对象传入。Resource接口是Spring提供的资源访问接口，通过使用该接口，Spring能够以简单、透明的方式访问磁盘、类路径以及网络上的资源。</p>
<p>对于Java EE应用而言，可在启动Web应用时自动加载ApplicationContext实例，接受Spring管理的Bean无须知道ApplicationContext的存在。一般使用如下方式实例化BeanFactory</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索当前文件路径下的bean.xml文件创建Resource对象</span></span><br><span class="line">InputStreamSource isr = <span class="keyword">new</span> FileSystemResource(<span class="string">"bean.xml"</span>);</span><br><span class="line"><span class="comment">//以Resource对象作为参数创建BeanFactory实例</span></span><br><span class="line">XmlBeanFactory <span class="literal">factory</span> = <span class="keyword">new</span> XmlBeanFactory((Resource) isr);</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ClassPathResource res = <span class="keyword">new</span> ClassPathResource(<span class="string">"bean.xml"</span>);</span><br><span class="line"><span class="comment">//以Resource对象作为参数创建BeanFactory实例</span></span><br><span class="line">XmlBeanFactory <span class="literal">factory</span> = <span class="keyword">new</span> XmlBeanFactory(res);</span><br></pre></td></tr></table></figure>
<p>但是如果应用里面有多个属性配置文件，则应该采用BeanFactory的子接口ApplicationContext来创建BeanFactory的实例。ApplicationContext通常使用如下两个实现类：</p>
<ul>
<li>FileSystemXmlApplicationContext：以基于文件系统的XML配置文件创建ApplicationContext实例。</li>
<li>ClassPathXmlApplicationContext：以类加载路径下的XML配置文件创建的ApplicationContext实例。<br>如果需要同时加载多个XML配置文件，采用如下方式：</li>
</ul>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//搜索CLASSPATH路径，以classpath路径下的bean.xml、service.xml文件创建applicationContext</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="keyword">new</span> <span class="built_in">String</span>[]&#123;<span class="string">"bean.xml"</span>,<span class="string">"service.xml"</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//以指定路径下的bean.xml、service.xml文件创建applicationContext</span></span><br><span class="line">ApplicationContext ctx1 = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="keyword">new</span> <span class="built_in">String</span>[]&#123;<span class="string">"bean.xml"</span>,<span class="string">"service.xml"</span>&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="使用ApplicationContext">使用ApplicationContext</h3><p>ApplicationContext允许以声明式方式操作容器，无须手动创建它。在Web应用启动时自动创建ApplicationContext。当然，也可以采用编程方式创建ApplicationContext。</p>
<p>除了提供BeanFactory所支持的全部功能外，ApplicationContext还有如下功能：</p>
<ol>
<li>ApplicationContext继承MessageSource接口，因此提供国际化支持。</li>
<li>资源访问。</li>
<li>事件机制。</li>
<li>载入多个配置文件。</li>
<li>以声明式的方式启动，并创建Spring容器。</li>
</ol>
<p>当系统创建ApplicationContext容器时，默认会预初始化所有的singleton Bean。也就是说，当ApplicationContext容器初始化完成后，容器中所有singleton Bean也实例化完成，这就意味着：系统前期创建ApplicationContext时将有较大的系统开销，但一旦ApplicationContext初始化完成，程序后面获取singleton Bean实例时将拥有较好的性能。</p>
<h3 id="ApplicationContext的国际化支持">ApplicationContext的国际化支持</h3><p>ApplicationContext接口继承MessageSource接口，因此具备国际化功能。MessageSource接口中定义了三个方法用于国际化功能。</p>
<ul>
<li><code>String getMessage(String code,Object[] args,Locale loc);</code></li>
<li><code>String getMessage(String code,Object[] args,String default,Locale loc);</code></li>
<li><code>String getMessage(MessageSourceResolvable resolvable,Local loc);</code></li>
</ul>
<p>ApplicationContext正是通过这三个方法来实现国际化的。当程序创建ApplicationContext容器时，Spring会自动查找在配置文件中名为messageSource的bean实例，一旦找到这个Bean实例，上述三个方法的调用被委托给该MessageSource Bean。如果没有该Bean，ApplicationContext会查找其父定义中的messagesource Bean，如果找到，它会作为messageSource Bean使用。但是如果无法找到messageSource，系统将会创建一个空的staticMessageSource Bean，该Bean的能接受上述三个方法的调用。</p>
<p>在Spring中配置messagesourceBean时通常使用ResourceBundleMessageSource.如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"messsageSource"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.context.support.ResourceBundleMessageSource"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"basenames"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>message<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果有多个资源文件，全部列在此处--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>message.properties:<br><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">hello=<span class="value">欢迎你:&#123;<span class="number">0</span>&#125;</span></span></span><br><span class="line"><span class="setting">now=<span class="value">现在时间是:&#123;<span class="number">0</span>&#125;</span></span></span><br></pre></td></tr></table></figure></p>
<p>配置文件中包含非西欧文字需要使用native2ascii工具<br><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">native2ascii</span> <span class="tag">message</span><span class="class">.properties</span> <span class="tag">message_zh_CN</span><span class="class">.properties</span></span><br></pre></td></tr></table></figure></p>
<p>使用<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line"><span class="built_in">String</span>[] a =&#123;<span class="string">"howie"</span>&#125;;</span><br><span class="line"><span class="built_in">String</span> hello = ctx.getMessage(<span class="string">"hello"</span>,a, Locale.getDefault());</span><br><span class="line"><span class="built_in">Object</span>[] b = &#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line"><span class="built_in">String</span> now = ctx.getMessage(<span class="string">"now"</span>,b,Locale.getDefault());</span><br></pre></td></tr></table></figure></p>
<h3 id="ApplicationContext的事件机制">ApplicationContext的事件机制</h3><p>ApplicationContext的事件机制是观察者设计模式的实现，通过ApplicationEvent类和ApplicationListener接口，可以实现ApplicationContext的事件处理。</p>
<p>Spring的事件框架有如下两个重要成员：</p>
<ol>
<li>ApplicationEvent：容器事件，必须由ApplicationContext发布。</li>
<li>ApplicationListener：监听器，可由容器中的任何监听器Bean担任。</li>
</ol>
<p>Spring的事件机制需要事件源、事件和事件监听器组成。只是此处的事件是ApplicationContext，且事件必须由java程序显示触发。下图简单示范了ApplicationContext的事件流程。</p>
<p>下面实例展示了Spring容器的事件机制。</p>
<ol>
<li><p>定义一个ApplicationEvent类，其对象就是Spring容器事件。</p>
 <figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class EmailEvent extends ApplicationEvent &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1</span>L;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">String</span> <span class="built_in">text</span>;</span><br><span class="line">    <span class="comment">// 定义一个带参的构造函数</span></span><br><span class="line">    <span class="keyword">public</span> EmailEvent(<span class="keyword">Object</span> source) &#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> EmailEvent(<span class="keyword">Object</span> source, <span class="keyword">String</span> address, <span class="keyword">String</span> <span class="built_in">text</span>) &#123;</span><br><span class="line">        <span class="keyword">super</span>(source);</span><br><span class="line">        <span class="keyword">this</span>.address = address;</span><br><span class="line">        <span class="keyword">this</span>.<span class="built_in">text</span> = <span class="built_in">text</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//address、text的setter和getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 容器事件的监听器类必须实现ApplicationListener接口，它的实现方法如下：<br> onAPplicationEvent(ApplicationEventevent):每当容器内发生任何事件时，此方法都会被触发。</p>
</li>
<li><p>编写该容器的监听器类。</p>
 <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">EmailNotifier</span> <span class="title">implements</span> <span class="title">ApplicationListener</span>&#123;</span><br><span class="line">    <span class="comment">//该方法会在容器发生事件时触发</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span>(<span class="params">ApplicationEvent <span class="keyword">event</span></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">event</span> instanceof EmailEvent)&#123;</span><br><span class="line">            <span class="comment">//只处理EmailEvent，发送email通知</span></span><br><span class="line">            EmailEvent emailEvent = (EmailEvent) <span class="keyword">event</span>;</span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"需要发送邮件的接收地址为:"</span>+emailEvent.getAddress());</span><br><span class="line"></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"需要发送邮件的邮件正文是:"</span>+emailEvent.getText());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//容器内置事件不作任何处理</span></span><br><span class="line">            System.<span class="keyword">out</span>.println(<span class="string">"容器本身的事件:"</span>+<span class="keyword">event</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将监听器类配置在容器中。</p>
<p> 在为Spring容器注册监听器时，我们只需在Spring配置文件中配置一个实现了ApplicationListener的Bean即可，Spring容器会把这个Bean当做容器事件的监听器。</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置监听器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.app.listener.EmailNotifier"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>通过上面的3个步骤就可以实现Spring容器的事件了。当系统创建Spring容器，加载Spring容器时会自动触发容器事件，容器事件监听器可以监听到这些事件。同时我们也可以调用ApplicationContext的pulishEvent()方法来主动触发容器事件。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpringTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="comment">//创建一个ApplicationEvent对象</span></span><br><span class="line">        EmailEvent emailEvent = <span class="keyword">new</span> EmailEvent(<span class="string">"hello"</span>,<span class="string">"spring_test@163.com"</span>,<span class="string">"this is a test"</span>);</span><br><span class="line">        <span class="comment">//主动触发容器事件</span></span><br><span class="line">        ctx.publishEvent(emailEvent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果Bean想发布事件，则Bean必须获得其容器的引用。如果程序中没有直接获取容器的引用，则应该让Bean实现ApplicationContextAware或BeanFactoryAware接口，从而获得容器的引用。</p>
<p>除了我们可以自己实现Spring容器的事件外，Spring也提供了几个内置事件：</p>
<ol>
<li>ContextRefreshedEvent：ApplicationContext容器初始化或者刷新时触发该事件。</li>
<li>ContextStartedEvent：当使用ConfigurableApplicationContext接口的start()方法启动ApplicationContext容器时触发该事件。</li>
<li>ContextClosedEvent：当使用ConfigurableApplicationContext接口的close()方法关闭ApplicationContext容器时触发该事件。</li>
<li>ContextStopedEvent: 当使用ConfigurableApplicationContext接口的stop()方法停止ApplicationContext容器时触发该事件。</li>
</ol>
<h3 id="让Bean获取Spring容器">让Bean获取Spring容器</h3><p>在Spring中我们可以使用Spring容器中getBean()方法来获取Spring容器中的Bean实例。在这样的访问模式下，程序中总是持有Spring容器的引用。但是在实际的应用中，Spring容器通常是采用声明式方式配置产生：即开发者只要在web.xml文件中配置一个Listener，该Listener将会负责初始化Spring容器。在这种情况下，容器中Bean处于容器管理下，无须主动访问容器，只需要接受容器的注入管理即可。同时Bean实例的依赖关系通常也是由容器动态注入，无须Bean实例主动请求。</p>
<p>在这种情况下，Sprig容器中Bean通常不会需要访问容器中其他的Bean—采用依赖注入，让Spring把被依赖的Bean注入到依赖的Bean中即可。</p>
<p>实现BeanFactoryAware接口的Bean，拥有访问的BeanFactory容器的能力，实现BeanFactoryAware接口的Bean实例将会拥有对容器的访问能力。BeanFactoryAware接口仅有如下一个方法：</p>
<p>setBeanFactory(BeanFactory beanFactory)：该方法有一个参数beanFactory，该参数指向创建它的BeanFactory。</p>
<p>该方法将由Spring调动，当Spring调用该方法时会将Spring容器作为参数传入该方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">ApplicationContextAware</span></span>&#123;</span><br><span class="line">    <span class="comment">//将BeanFactory容器以成员变量保存</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationContext ctx;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 实现ApplicationContextAware接口实现的方法</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationContext</span><span class="params">(ApplicationContext cyx)</span>  <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ctx = ctx;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取ApplicationContext的测试方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ApplicationContext <span class="title">getContext</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的Chinese类实现了ApplicationContext接口，并实现了该接口提供的setApplicationContextAware()方法，这就使得该Bean实例可以直接访问到创建她的Spring容器。<br>将该Bean部署在Spring容器中。<br>测试类：<br>该程序先通过实例化的方法来获取ApplicationContext，然后通过chinese Bean来获得BeanFactory，并将两者进行比较。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ChineseTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        Chinese c = ctx.getBean(<span class="string">"chinese"</span>,Chinese.class);</span><br><span class="line">        System.<span class="keyword">out</span>.println(c.getContext());</span><br><span class="line">        System.<span class="keyword">out</span>.println(c.getContext()==ctx);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//结果如下：</span></span><br><span class="line"><span class="keyword">true</span></span><br></pre></td></tr></table></figure>
<p>上面的代码虽然实现了ApplicationContextAware接口让Bean拥有了访问容器的能力，但是污染了代码，导致代码与Spring接口耦合在一起。所以，如果不是特别需要，一般不建议直接访问容器。</p>
<h2 id="Spring容器中的Bean">Spring容器中的Bean</h2><p>从前面我们知道Spring其实就是一个大型的工厂，而Spring容器中的Bean就是该工厂的产品.对于Spring容器能够生产那些产品，则取决于配置文件中配置。</p>
<p>对于我们而言，我们使用Spring框架所做的就是两件事：开发Bean、配置Bean。对于Spring框架来说，它要做的就是根据配置文件来创建Bean实例，并调用Bean实例的方法完成“依赖注入”。</p>
<h3 id="Bean的基本定义">Bean的基本定义</h3><p>beans元素可以有以下属性，bean元素可以有没有default-前缀的属性，beans属性是全局的。</p>
<ul>
<li>default-lazy-init ：延迟初始化</li>
<li>default-merge：merge行为</li>
<li>default-autowire：自动装配行为</li>
<li>default-autowire-candidates：自动装配候选bean</li>
<li>default-init-method：初始化方法</li>
<li>default-destroy-method：回收方法</li>
</ul>
<p><code>&lt;beans…/&gt;</code>元素是Spring配置文件的根元素，<code>&lt;bean…/&gt;</code>元素师<code>&lt;beans../&gt;</code>元素的子元素，<code>&lt;beans…/&gt;</code>元素可以包含多个<code>&lt;bean…/&gt;</code>子元素，每个<code>&lt;bean…/&gt;</code>元素可以定义一个Bean实例，每一个Bean对应Spring容器里的一个Java实例定义Bean时通常需要指定两个属性。</p>
<ul>
<li>id：确定该Bean的唯一标识符，容器对Bean管理、访问、以及该Bean的依赖关系，都通过该属性完成。Bean的id属性在Spring容器中是唯一的。</li>
<li>class：指定该Bean的具体实现类。注意这里不能是接口。通常情况下，Spring会直接使用new关键字创建该Bean的实例，因此，这里必须提供Bean实现类的类名。</li>
</ul>
<p>下面是定义一个Bean的简单配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义第一个Bean实例：bean1 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bean1"</span> <span class="attribute">class</span>=<span class="value">"com.Bean1"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义第二个Bean实例：bean2 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bean2"</span> <span class="attribute">class</span>=<span class="value">"com.Bean2"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>当我们在配置文件中通过<code>&lt;bean id=”xxx” class=”x.xxxClass”/&gt;</code>方法配置一个Bean时，这样就需要该Bean实现类中必须有一个无参构造器。故Spring底层相当于调用了如下代码：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx = new x.<span class="function"><span class="title">xxxClass</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果在配置文件中通过构造注入来创建Bean：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bean1"</span> <span class="attribute">class</span>=<span class="value">"com.Bean1"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"chenssy"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">constructor-arg</span> <span class="attribute">value</span>=<span class="value">"35-354"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>则Spring相当于调用如下代码：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Bean </span><span class="keyword">bean </span>= new com.Test(<span class="string">"chenssy"</span>,<span class="string">"35-354"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>除了可以为<code>&lt;bean…/&gt;</code>元素指定一个id属性外，还可以为<code>&lt;bean…/&gt;</code>元素指定name属性，用于为Bean实例指定别名。如果需要为Bean实例指定多个别名，可以在name属性中使用逗号、冒号或者空格来分隔多个别名，后面通过任一别名即可访问该Bean实例。但是在一些特殊的情况下，程序无法在定义Bean时就指定所有的别名，而是在其他地方为一个已经存在的Bean实例指定别名，则可以使用<code>&lt;alias…/&gt;</code>元素来完成，该元素有如下两个属性：</p>
<ul>
<li>name：该属性指定一个Bean实例的标识名，表示将会为该Bean指定别名。</li>
<li>alias：指定一个别名.<br>如：</li>
</ul>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">alias</span> <span class="title">name</span>=”bean1” <span class="keyword">alias</span>=”name1”/&gt;</span><br><span class="line">&lt;<span class="keyword">alias</span> <span class="title">name</span>=”bean2” <span class="keyword">alias</span>=”name2”/&gt;</span><br></pre></td></tr></table></figure>
<p>在默认情况下，当Spring创建ApplicationContext容器时，Spring会自动预初始化容器中所有的singleton实例，如果我们想让Spring容器预初始化某个singleton Bean，则可以为该<code>&lt;bean…/&gt;</code>元素增加lazy-init属性，该属性用于指定该Bean实例的预初始化，如果设置为true，则Spring不会预初始化该Bean实例。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=”<span class="keyword">person</span>” class=”com.<span class="keyword">Person</span>” lazy-init=”true”/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="容器中Bean的作用域">容器中Bean的作用域</h3><p>当通过Spring容器创建一个Bean实例时，不仅可以完成Bean实例的实例化，还可以为Bean指定特定的作用域。Spring支持5种作用域：</p>
<ul>
<li>singleton：单例模式。在整个Spring IoC容器中，使用singleton定义的Bean将只有一个实例。</li>
<li>prototype：原型模式。每次通过容器的getBean方法获取prototype定义的Bean时，都将产生一个新的Bean实例。</li>
<li>request：对于每次HTTP请求，使用request定义的Bean都将产生一个新的实例，即每次HTTP请求都会产生不同的Bean实例。当然只有在WEB应用中使用Spring时，该作用域才真正有效。</li>
<li>session：对于每次HTTPSession，使用session定义的Bean都将产生一个新的实例时，即每次HTTP Session都将产生不同的Bean实例。同HTTP一样，只有在WEB应用才会有效。</li>
<li>global session：每个全局的HTTPSession对应一个Bean实例。仅在portlet Context的时候才有效。</li>
</ul>
<p>比较常用的singleton和prototype。如果一个Bean实例被设置为singleton，那么每次请求该Bean时都会获得相同的实例。容器负责跟踪Bean实例的状态，负责维护Bean实例的生命周期行为。如果一个Bean实例被设置为prototype，那么每次请求该id的Bean，Spring都会创建一个新的Bean实例返回给程序，在这种情况下，Spring容器仅仅使用new关键字创建Bean实例，一旦创建成功，容器将不会再跟踪实例，也不会维护Bean实例的状态。<strong>Spring默认使用singleton作用域</strong>。prototype作用域Bean的创建、销毁代价会比较大。除非必要，否则尽量避免将Bean的作用域设置为prototype。</p>
<p>设置Bean的作用域是通过scope属性来指定。可以接受singleton、prototype、request、session、global session 5个值。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置一个singleton Bean实例：默认 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bean1"</span> <span class="attribute">class</span>=<span class="value">"com.Bean1"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置一个prototype Bean实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"bean2"</span> <span class="attribute">class</span>=<span class="value">"com.Bean2"</span> <span class="attribute">scope</span>=<span class="value">"prototype"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>测试代码：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpringTest</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="comment">//判断两次请求singleton作用域的Bean实例是否相等</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(ctx.getBean(<span class="string">"bean1"</span>)==ctx.getBean(<span class="string">"bean1"</span>));</span><br><span class="line">        <span class="comment">//判断两次请求prototype作用域的Bean实例是否相等</span></span><br><span class="line">        System.<span class="keyword">out</span>.println(ctx.getBean(<span class="string">"bean2"</span>)==ctx.getBean(<span class="string">"bean2"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//程序运行结果如下</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line"><span class="keyword">false</span></span><br></pre></td></tr></table></figure></p>
<p>request和session作用域只在web应用中才会有效，并且必须在Web应用中增加额外配置才会生效。为了能够让request和session两个作用域生效，必须将HTTP请求对象绑定到位该请求提供的服务线程上，这使得具有request和session作用的Bean实例能够在后面的调用链中被访问到。</p>
<p>因此我们可以采用两种配置方式：采用Listener配置或者采用Filter配置，在web.xml中。<br>Listener配置：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">&lt;listener-class&gt;</span><br><span class="line">org<span class="class">.springframework</span><span class="class">.web</span><span class="class">.context</span><span class="class">.request</span><span class="class">.RequestContextListener</span></span><br><span class="line">&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure></p>
<p>Filter配置<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="attribute">filter</span>&gt;</span><br><span class="line">&lt;<span class="attribute">filter</span>-name&gt;requestContextFilter&lt;/<span class="attribute">filter</span>-name&gt;</span><br><span class="line">&lt;<span class="attribute">filter</span>-class&gt;org<span class="class">.springframework</span><span class="class">.web</span><span class="class">.filter</span><span class="class">.RequestContextFilter</span>&lt;/<span class="attribute">filter</span>-class&gt;</span><br><span class="line">&lt;/<span class="attribute">filter</span>&gt;</span><br><span class="line">&lt;<span class="attribute">filter</span>-mapping&gt;</span><br><span class="line">&lt;<span class="attribute">filter</span>-name&gt;requestContextFilter&lt;/<span class="attribute">filter</span>-name&gt;</span><br><span class="line">&lt;url-pattern&gt;<span class="comment">/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>一旦在web.xml中增加上面两种配置中的一种，程序就可以在Spring配置文件中使用request或者session作用域了。如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 指定使用request作用域 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"p"</span> <span class="attribute">class</span>=<span class="value">"com.app.Person"</span> <span class="attribute">scope</span>=<span class="value">"request"</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的配置文件配置了一个实现类Person的Bean，指定它的作用域为request。这样Spring容器会为每次的HttP请求生成一个Person的实例，当该请求响应结束时，该实例也会被注销。</p>
<h3 id="配置依赖">配置依赖</h3><p>在一般情况下，我是不应该在配置文件中管理普通属性的引用，通常只是用配置文件管理容器中的Bean实例的依赖关系。</p>
<p>Spring在实例化容器时，会校验BeanFactory中每一个Bean的配置。这些校验包括：</p>
<ul>
<li>Bean引用的依赖Bean是否指向一个合法的Bean。</li>
<li>Bean的普通属性值是否获得一个有效值。</li>
</ul>
<p>对于singleton作用域的Bean，如果没有强行取消其预初始化的行为，系统会在创建Spring容器时预初始化所用singleton Bean，与此同时，该Bean所依赖的Bean也被一起实例化。</p>
<p>BeanFactory与ApplicationContext实例化容器中的Bean的时机也是不同的：BeanFactory等到程序需要Bean实例时才创建Bean，而ApplicationContext是在创建ApplicationContext实例时，会预初始化容器中的全部Bean。</p>
<p>ApplicationContext实例化过程比BeanFactory实例化过程的时间和内存开销大，但是一旦创建成功，应用后面的响应速度会非常快，同时可以检验出配置错误，故一般都是推荐使用ApplicationContext作为Spring容器。</p>
<p>其实我们可以指定lazy-int=”true”来强制取消singleton作用域的Bean的预初始。这样该Bean就不会随着ApplicationContext启动而预实例化了。</p>
<p>Spring可以为任何java对象注入任何类型的属性，只要改java对象为该属性提供了对应的setter方法即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"person"</span> <span class="attribute">class</span>=<span class="value">"lee.Person"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Property配置需要依赖注入的属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"chenming"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span> <span class="attribute">value</span>=<span class="value">"22"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Spring会为<code>&lt;bean…/&gt;</code>元素创建一个java对象，一个这样的java对象对应一个Bean实例，对于如上代码，Spring会采用如下形式来创建Java实例。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//获取lee.<span class="keyword">Person</span>类的Class对象</span><br><span class="line">Class  personClass = Class.forName(<span class="string">"lee.Person"</span>);</span><br><span class="line">//创建lee.<span class="keyword">Person</span>类的默认实例</span><br><span class="line">Object personBean = personBean.newInStance();</span><br></pre></td></tr></table></figure>
<p>创建该实例后，Spring就会遍历该<code>&lt;bean../&gt;</code>元素的所有<code>&lt;property…/&gt;</code>子元素。<code>&lt;bean…/&gt;</code>元素每包含一个<code>&lt;property…/&gt;</code>子元素，Spring就会为该Bean实例调用一次setter方法。类似于下面程序：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取name属性的setter方法</span><br><span class="line">String setName = <span class="string">"set"</span>+<span class="string">"Name"</span>;</span><br><span class="line">//获取lee.<span class="keyword">Person</span>类里面的Set()Name方法</span><br><span class="line">java.lang.reflect.Method setMethod = personClass.getMethod(setName, aVal.getClass());</span><br><span class="line">//调用Bean实例的SetName()方法</span><br><span class="line">setMethod.invoke(personBean, aVal);</span><br></pre></td></tr></table></figure>
<p>对于使用<code>&lt;constructor-arg…/&gt;</code>元素来指定构造器注入，Spring不会采用默认的构造器来创建Bean实例，而是使用特定的构造器来创建该Bean实例。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"person"</span> <span class="variable">class=</span><span class="string">"lee.Person"</span>&gt;</span><br><span class="line">&lt;constructor-arg <span class="variable">index=</span><span class="string">"0"</span> <span class="variable">value=</span><span class="string">"aVal"</span> /&gt;</span><br><span class="line">&lt;constructor-arg <span class="variable">index=</span><span class="string">"1"</span> <span class="variable">value=</span><span class="string">"bVal"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>针对上面的代码，Spring会采用类似如下的代码来创建Bean实例：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//获取lee.<span class="keyword">Person</span>类的class对象</span><br><span class="line">Class  personClass = Class.forName(<span class="string">"lee.Person"</span>);</span><br><span class="line">//获取第一个参数是aVal类型，第二个参数是bVal类型的构造器</span><br><span class="line">Constructor personCtr = personClass.getConstructor(aVal.getClass(),bVal.getClass());</span><br><span class="line">//以指定构造器创建Bean实例</span><br><span class="line">Object bean = personCtr.newInstance(aVal,bVal);</span><br></pre></td></tr></table></figure></p>
<p>上面的程序只是一个实例，实际上Spring还需要根据<code>&lt;property…/&gt;</code>元素、<code>&lt;contructor-arg../&gt;</code>元素所使用value属性，ref属性等来判断需要注入的到底是什么数据类型，并要对这些值进行合适的类型转换，所以Spring的实际处理过程会更加复杂。</p>
<p>Java实例的属性值可以有很多种数据类型、基本类型值、字符串类型、java实例甚至其他的Bean实例、java集合、数组等。所以Spring允许通过如下几个元素为Bean实例的属性指定值：</p>
<ul>
<li>value</li>
<li>ref</li>
<li>bean</li>
<li>list、set、map、props</li>
</ul>
<h3 id="设置普通属性值">设置普通属性值</h3><p>value属性用于指定字符串类型、基本类型的属性值。Spring使用XML解析器来解析出这些数据，然后利用java.beans.PropertyEdior完成类型转换：从java.lang.String类型转换为所需的参数值类型。如果目标类型是基本数据类型，通常都是可以正确转换。<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueTest</span> </span>&#123;</span><br><span class="line"><span class="comment">//定义一个String型属性</span></span><br><span class="line"><span class="keyword">private</span> String name;</span><br><span class="line"><span class="comment">//定义一个int型属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"><span class="comment">// name 、age的getter和setter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面实例只是演示了注入普通属性值。在Spring配置文件中使用value属性来为这两个属性指定属性值。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="property">id</span>=<span class="string">"text"</span> <span class="type">class</span>=<span class="string">"com.spring.service.impl.ValueTest"</span>&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"age"</span> value=<span class="string">"1"</span> /&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"name"</span> value=<span class="string">"chenssy"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="配置合作者">配置合作者</h3><p>如果我们需要为Bean设置属性值是另一个Bean实例时，这个时候需要使用ref属性。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.spring.service.impl.SteelAce"</span>&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.spring.service.impl.Chinese"</span> &gt;</span><br><span class="line">&lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>早期Spring版本使用ref元素，ref元素可以指定如下两个属性。<br>bean:引用不在同一份XML配置文件中的其他Bean实例的id属性值。<br>local：引用同一份XML配置文件中的其他Bean实例的id属性值。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.spring.service.impl.SteelAce"</span>&gt;&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.spring.service.impl.Chinese"</span> &gt;</span><br><span class="line">&lt;property name=<span class="string">"axe"</span>&gt;</span><br><span class="line">&lt;<span class="keyword">ref</span> local=<span class="string">"steelAxe"</span>/&gt;</span><br><span class="line">&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用自动装配注入合作者bean">使用自动装配注入合作者bean</h3><p>Spring支持自动装配Bean与Bean之间的依赖关系，也就是说我们无需显示的指定依赖Bean。由BeanFactory检查XML配置文件内容，根据某种规则，为主调Bean注入依赖关系。</p>
<p>Spring的自动装配机制可以通过<code>&lt;bean.../&gt;</code>元素的default-autowire属性指定，也可以通过<code>&lt;bean.../&gt;</code>元素的autowire属性指定。</p>
<p>自动装配可以减少配置文件的工作量，但是它降低了依赖关系的透明性和清晰性，所以一般来说在较大部署环境中不推荐使用，显示配置合作者能够得到更加清晰的依赖关系。Spring提供了如下几种规则来实现自动装配。</p>
<ul>
<li>no:不适用自动装配。Bean依赖必须通过ref元素定义。</li>
<li>byName：根据属性名自动装配。BeanFactory查找容器中的全部Bean，找出其中id属性与属性同名的Bean来完成注入。如果没有找到匹配的Bean实例，则Spring不会进行任何注入。</li>
<li>byType：根据属性类型自动装配。BeanFactory查找容器中的全部Bean，如果正好有一个与依赖属性类型相同的Bean，就自动注入这个属性；但是如果有多个这样的Bean，就会抛出一个异常。如果没有匹配的Bean，则什么都不会发生，属性就不会被设置。如果需要无法自动装配时抛出异常，则设置dependency-check=”objects”。</li>
<li>constructor:与不Type类似，区别是用于构造注入的参数。</li>
<li>autodetect:BeanFactory根据Bean内部结构，决定使用constructor或者byType。如果找到一个默认的构造函数，则使用byType。</li>
</ul>
<h4 id="byName规则">byName规则</h4><p>byName规则是指通过名字注入依赖关系，假如Bean A的实现类里面包含setB()方法，而Spring的配置文件恰好包含一个id为b的Bean，则Spring容器就会将b实例注入Bean A中。如果容器中没有名字匹配的Bean，Spring则不会做任何事情。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"chinese"</span> <span class="variable">class=</span><span class="string">"com.spring.service.impl.Chinese"</span> <span class="variable">autowire=</span><span class="string">"byName"</span> /&gt;</span><br><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"gundog"</span> <span class="variable">class=</span><span class="string">"com.spring.service.impl.Gundog"</span>&gt;</span><br><span class="line">&lt;property <span class="variable">name=</span><span class="string">"name"</span> <span class="variable">value=</span><span class="string">"wangwang"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<p>上面的配置文件指定了byName规则。则com.app.service.impl.Chinese类中提供如下的依赖注入方法：<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span> 依赖关系必须的setter方法，因为需要通过名字自动装配</span><br><span class="line"><span class="keyword">*</span> 所以setter方法必须提供set+Bean名，Bean名的首字母大写</span><br><span class="line"><span class="keyword">*</span> <span class="comment">@param dog 设置的dog值</span></span><br><span class="line"><span class="keyword">*</span>/</span><br><span class="line">public void setGundog(Dog dog)&#123;</span><br><span class="line">    this.dog = dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="byType规则">byType规则</h4><p>byType规则是根据类型匹配注入依赖关系。假如A实例有setB(B b)方法，而Spring配置文件中恰好有一个类型B的Bean实例，容器为A注入类型匹配的Bean实例。如果容器中存在多个B的实例，则会抛出异常，如果没有B实例，则不会发生任何事情。<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"chinese"</span> <span class="variable">class=</span><span class="string">"com.spring.service.impl.Chinese"</span> <span class="variable">autowire=</span><span class="string">"byType"</span> /&gt;</span><br><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"gundog"</span> <span class="variable">class=</span><span class="string">"com.spring.service.impl.Gundog"</span>&gt;</span><br><span class="line">&lt;property <span class="variable">name=</span><span class="string">"name"</span> <span class="variable">value=</span><span class="string">"wangwang"</span> /&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>针对上面的配置文件Chinese类有如下方法。<br><figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/<span class="keyword">*</span><span class="keyword">*</span></span><br><span class="line"><span class="keyword">*</span> 依赖关系必须的setter方法</span><br><span class="line"><span class="keyword">*</span> 因为使用按类型自动装配，setter方法的参数类型与容器的Bean的类型相同</span><br><span class="line"><span class="keyword">*</span> 程序中的Gundog实现了Dog接口</span><br><span class="line"><span class="keyword">*</span> <span class="comment">@param dog传入的dog对象</span></span><br><span class="line"><span class="keyword">*</span>/</span><br><span class="line">public void setDog(Dog dog)&#123;</span><br><span class="line">    this.dog = dog;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当一个Bean即使用自动装配依赖，又使用ref显示依赖时，则显示指定的依赖就会覆盖自动装配。</p>
<p>在默认的情况下，Spring会自动搜索容器中的全部Bean，并对这些Bean进行判断，判断他们是否满足自动装配的条件，如果满足就会将该Bean注入目标Bean实例中。如果我们不想让Spring搜索容器中的全部Bean，也就是说，我们需要Spring来判断哪些Bean需要搜索，哪些Bean不需要搜索，这个时候就需要用到autowire-candidate属性。通过为<code>&lt;bean.../&gt;</code>元素设置autowire-candidate=”false”，即可将该Bean限制在自动装配范围之外，容器在查找自动装配对象时将不考虑该Bean。</p>
<h3 id="注入嵌套Bean">注入嵌套Bean</h3><p>如果某个Bean所依赖的Bean不想被Spring容器直接访问，则可以使用嵌套Bean。<code>&lt;bean.../&gt;</code>元素用来定义嵌套Bean，嵌套Bean只对嵌套它的外部Bean有效，Spring容器无法直接访问嵌套Bean，因此在定义嵌套Bean时是无需指定id属性的。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.Chinese"</span> <span class="attribute">autowire</span>=<span class="value">"byName"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"axe"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--</span><br><span class="line">属性值为嵌套Bean，嵌套Bean不能由Spring容器直接访问，</span><br><span class="line">所以嵌套Bean是不需要id属性</span><br><span class="line">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.SteelAce"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>采用上面的配置可以保证嵌套Bean不能被容器访问，因此不用担心其他程序修改嵌套bean。但是嵌套Bean限制了Bean的访问，提高了程序的内聚性。</p>
<h3 id="list、set、map、props">list、set、map、props</h3><p><code>&lt;list.../&gt;</code>、<code>&lt;set.../&gt;</code>、<code>&lt;map.../&gt;</code>和<code>&lt;props.../&gt;</code>元素分别用来设置类型list、set、map和Properties的集合属性值。<br>先看下面java类：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class Chinese implements Person&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面是一系列的集合属性</span></span><br><span class="line"><span class="keyword">private</span> <span class="built_in">List</span><span class="subst">&lt;</span><span class="built_in">String</span><span class="subst">&gt;</span> schools;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">Map</span> scores;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, Axe<span class="subst">&gt;</span> phaseAxes;</span><br><span class="line"><span class="keyword">private</span> Properties health;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">Set</span> axe;</span><br><span class="line"><span class="keyword">private</span> <span class="built_in">String</span><span class="preprocessor">[</span><span class="preprocessor">]</span><span class="markup"> books;</span><br><span class="line">//setter 和getter方法</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的java代码中有数组、list、set、，map、Properties。下面是针对上面的配置文件。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 定义一个普通的Axe Bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"steelAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.SteelAxe"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"stoneAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.StoneAxe"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--定义Chinese Bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.Chinese"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"schools"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>小学<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>中学<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>大学<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"scores"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"语文"</span> <span class="attribute">value</span>=<span class="value">"88"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"数学"</span> <span class="attribute">value</span>=<span class="value">"87"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"外语"</span> <span class="attribute">value</span>=<span class="value">"88"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"phaseAxes"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"原始社会"</span> <span class="attribute">value-ref</span>=<span class="value">"stoneAxe"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"农业社会"</span> <span class="attribute">value-ref</span>=<span class="value">"steelAxe"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"health"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"血压"</span>&gt;</span>正常<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"身高"</span>&gt;</span>175<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">props</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"axe"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>普通字符串<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.SteelAxe"</span>&gt;</span><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">local</span>=<span class="value">"stoneAxe"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">set</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"books"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>java 编程思想<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>思考致富<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">value</span>&gt;</span>将才<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从上面的配置文件中可以看出，Spring对list属性和数组属性的处理是一样的。</p>
<p>当我们使用<code>&lt;list.../&gt;</code>、<code>&lt;set.../&gt;</code>、<code>&lt;map.../&gt;</code>等元素配置集合属性时，我们还需要手动配置集合元素。由于集合元素又可以是基本类型值、引用容器中的其他Bean、嵌套Bean和集合属性等。所以这些元素又可以接受如下子元素：</p>
<ul>
<li>value:指定集合元素是基本数据类型或者字符类型值。</li>
<li>ref:指定集合元素师容器中另一个Bean实例。</li>
<li>bean:指定集合元素是一个嵌套Bean。</li>
<li>list、set、map、props:指定集合元素值又是集合。</li>
</ul>
<p><code>&lt;props.../&gt;</code>元素用于配置Properties类型的属性，Properties类型是一种特殊的类型，其key和value都只能是字符串。</p>
<p>使用<code>&lt;map.../&gt;</code>元素配置Map属性时比较复杂，因为Map集合的每个元素由key、value两个部分组成，所以配置文件中每个<code>&lt;entry.../&gt;</code>配置一个Map元素，其中entry支持如下4个属性：</p>
<ul>
<li>key：Map的key是基本类型或字符串。</li>
<li>key-ref：Map的key是容器中另一个Bean实例。</li>
<li>value：Map的value是基本类型或字符串。</li>
<li>value-ref：Map的value是容器中另一个Bean实例。</li>
</ul>
<h3 id="组合属性名称">组合属性名称</h3><p>当在配置文件中为Bean属性指定值时，还可以使用组合属性名的方式。例如我们使用如foo.bar.name的属性名，这表明为Bean实例的foo属性的bar属性的name属性指定值。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class <span class="keyword">Person</span> &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    //getter .. setter</span><br><span class="line">&#125;</span><br><span class="line">public class ExampleBean &#123;</span><br><span class="line">    private <span class="keyword">Person</span> <span class="keyword">person</span>=new <span class="keyword">Person</span>();</span><br><span class="line">    public <span class="keyword">Person</span> getPerson() &#123;</span><br><span class="line">        return <span class="keyword">person</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bean.xml核心配置：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="property">id</span>=<span class="string">"exampleBean"</span> <span class="type">class</span>=<span class="string">"com.bean.ExampleBean"</span>&gt;</span><br><span class="line">        &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"person.name"</span> value=<span class="string">"孙悟空"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>除了最后一个属性外，其他属性不能为null，否则引发异常</p>
<p>上面配置片段相当Spring执行：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">exampleBean.getPerson<span class="params">()</span>.setName<span class="params">(<span class="string">"孙悟空"</span>)</span>;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spring的Bean和JavaBean">Spring的Bean和JavaBean</h3><p>Spring容器对Bean没有特殊要求，甚至不要求该Bean像标准的JavaBean那样必须为每个属性提供对应的getter和setter方法。Spring中的Bean是Java实例、Java组件；而传统的Java应用中的JavaBean通常作为DTO(数据传输对象)，用来封装值对象，在各层之间传递数据。</p>
<p>虽然Spring对Bean没有特殊要求，但还是建议Spring中的Bean应该尽量满足如下几个原则：</p>
<ul>
<li>尽量为每个Bean实现类提供无参数的构造器。</li>
<li>接受构造注入的Bean，应该提供对应的构造函数。</li>
<li>接受设值注入的Bean，应该提供对应的setter方法，并不强制要求提供对应的getter方法。</li>
</ul>
<p>传统的JavaBean和Spring中的Bean存在如下区别：</p>
<ul>
<li>用处不同：传统的JavaBean更多作为值对象传递参数；Spring中的Bean用处几乎无所不包，任何应用组件都被称为Bean。</li>
<li>写法不同：传统的JavaBean作为值对象，要求每个属性都提供getter和setter方法；但Spring的Bean只需为接受设值注入的属性提供setter方法。</li>
<li>生命周期不同：传统的JavaBean作为值对象传递，不接受任何容器管理其生命周期；但Spring中的Bean由Spring管理其生命周期行为。</li>
</ul>
<h2 id="Spring_3-0提供的Java配置管理">Spring 3.0提供的Java配置管理</h2><p>Spring允许开发者使用Java类进行配置管理。</p>
<p>假如有如下Person实现类：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Chinese implements <span class="keyword">Person</span> &#123;</span><br><span class="line">       private Axe axe;</span><br><span class="line">       private String name;</span><br><span class="line">       //设值注入所需的setter方法</span><br><span class="line">       public void setAxe(Axe axe) &#123;</span><br><span class="line">           this.axe = axe;</span><br><span class="line">       &#125;</span><br><span class="line">       //设值注入所需的setter方法</span><br><span class="line">       public void setName(String name) &#123;</span><br><span class="line">           this.name = name;</span><br><span class="line">       &#125;</span><br><span class="line">       //实现<span class="keyword">Person</span>接口的useAxe方法</span><br><span class="line">       public void useAxe() &#123;</span><br><span class="line">           //调用axe的chop()方法，</span><br><span class="line">           //表明<span class="keyword">Person</span>对象依赖于axe对象</span><br><span class="line">           System.out.println(<span class="string">"我是："</span> + name + axe.chop());</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面Chinese类需要注入两个属性：name和Axe，本示例当然也为Axe提供了两个实现类：StoneAxe和SteelAxe。如果我们采用XML配置，相应的配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- Spring配置文件的根元素，使用spring-beans-3.0.xsd语义约束 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">       http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置chinese实例，其实现类是Chinese --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"org.crazyit.app.service.impl.Chinese"</span>&gt;</span></span><br><span class="line">                       <span class="comment">&lt;!-- 将stoneAxe注入给axe属性 --&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"axe"</span> <span class="attribute">ref</span>=<span class="value">"stoneAxe"</span>/&gt;</span></span><br><span class="line">                       <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">value</span>=<span class="value">"孙悟空"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置stoneAxe实例，其实现类是StoneAxe --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"stoneAxe"</span> <span class="attribute">class</span>=<span class="value">"org.crazyit.app.service.impl.StoneAxe"</span>/&gt;</span></span><br><span class="line">       <span class="comment">&lt;!-- 配置steelAxe实例，其实现类是SteelAxe --&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"steelAxe"</span> <span class="attribute">class</span>=<span class="value">"org.crazyit.app.service.impl.SteelAxe"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>如果开发者不喜欢使用XML配置文件，Spring 3.0允许开发者使用Java类进行配置。<br>上面XML配置文件可以替换为如下Java配置类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AppConfig</span> </span>&#123;</span><br><span class="line">       <span class="comment">//定义需要依赖注入的属性值</span></span><br><span class="line">       <span class="annotation">@Value</span>(<span class="string">"孙悟空"</span>) String personName;</span><br><span class="line">       <span class="comment">//配置一个Bean：chinese</span></span><br><span class="line">       <span class="annotation">@Bean</span>(name=<span class="string">"chinese"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Person <span class="title">person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Chinese p = <span class="keyword">new</span> Chinese();</span><br><span class="line">           p.setAxe(stoneAxe());</span><br><span class="line">           p.setName(personName);</span><br><span class="line">           <span class="keyword">return</span> p;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//配置Bean：stoneAxe</span></span><br><span class="line">       <span class="annotation">@Bean</span>(name=<span class="string">"stoneAxe"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Axe <span class="title">stoneAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> StoneAxe();</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//配置Bean：steelAxe</span></span><br><span class="line">       <span class="annotation">@Bean</span>(name=<span class="string">"steelAxe"</span>)</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Axe <span class="title">steelAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">new</span> SteelAxe();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面配置文件中使用了Java配置类的3个常用Annotation：</p>
<ul>
<li>@Configuration：用于修饰一个Java配置类。</li>
<li>@Bean：用于修饰一个方法，将该方法的返回值定义成容器中的一个Bean。</li>
<li>@Value：用于修饰一个Field，用于为配置一个值。</li>
</ul>
<p>一旦使用了Java配置类来管理Spring容器中Bean、及其依赖关系，此时需要使用如下方式来创建Spring容器：<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建Spring容器</span></span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span></span><br><span class="line">       AnnotationConfigApplicationContext(AppConfig.<span class="keyword">class</span>);</span><br></pre></td></tr></table></figure></p>
<p>上面AnnotationConfigApplicationContext类会根据Java配置类来创建Spring容器。不仅如此，该类还提供了一个register(Class)方法用于添加Java配置类。</p>
<p>获得Spring容器之后，接下来利用Spring容器获取Bean实例、调用Bean方法就没有任何特别之处了。</p>
<p>使用Java配置类时，还有如下常用的Annotation：</p>
<ul>
<li>@Import：修饰一个Java配置类，用于向当前Java配置类中导入其他Java配置类。</li>
<li>@Scope：用于修饰一个方法，指定该方法对应的Bean的生命域。</li>
<li>@Lazy：用于修饰一个方法，指定该方法对应的Bean的是否需要延迟初始化。</li>
<li>@DependOn：用于修饰一个方法，指定在初始化该方法对应的Bean之前初始化指定Bean。</li>
</ul>
<ol>
<li><p>如果以XML配置为主，就需要让XML配置能加载Java类配置。这并不难，只要在XML配置中增加如下代码即可：</p>
 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">    <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span></span><br><span class="line">    <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">    http://www.springframework.org/schema/beans/spring-beans-3.0.xsd</span><br><span class="line">    http://www.springframework.org/schema/context</span><br><span class="line">    http://www.springframework.org/schema/context/spring-context-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">context:annotation-config</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">!—加载Java配置类</span> <span class="attribute">--</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.crazyit.app.config.AppConfig”/&gt;</span><br><span class="line">&lt;/beans&gt;</span></span></span><br></pre></td></tr></table></figure>
<p> 由于应用以XML配置为主，因此应用创建Spring容器时，还是以这份XML文件为参数来创建ApplicationContext对象。那么Spring会先加载这份XML配置文件，再根据这份XML配置文件的指示，去加载指定的Java配置类。</p>
</li>
<li><p>如果以Java类配置为主，就需要让Java配置类能加载XML配置。这就需要借助于@ImportResource Annotation，这个Annotation可修饰Java配置类，用于导入指定的XML配置文件。也就是在Java配置类上增加如下Annotation即可：</p>
 <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Configuration</span></span><br><span class="line"><span class="comment">//导入XML配置</span></span><br><span class="line"><span class="variable">@ImportResource</span>(<span class="string">"classpath:/bean.xml"</span>)</span><br><span class="line">public class MyConfig &#123;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 由于应用以Java类配置为主，因此应用创建Spring容器时，应以Java配置类为参数，创建AnnotationConfigApplicationContext对象来作为Spring容器。那么Spring会先加载这个Java配置类，再根据这个Java配置类的指示，去加载指定的XML配置文件。</p>
</li>
</ol>
<h2 id="Bean实例的创建方式及依赖配置">Bean实例的创建方式及依赖配置</h2><p>创建Bean通常有如下方法：调用构造器，调用静态工厂方法，调用实例工厂方法。</p>
<h3 id="使用构造器创建Bean实例">使用构造器创建Bean实例</h3><p>使用构造器来创建Bean实例是最常见的情况，如果采用设置注入的方式，要求该类提供无参数构造器。class属性是必需的（除非采用继承）</p>
<p>BeanFactory将使用无参数构造器来创建Bean实例，该实例是个默认实例，Spring对Bean实例的所有属性执行默认初始化，即所有基本类型的值初始化为0或false，所有引用类型的值初始化为null。</p>
<p>接下来，BeanFactory会根据配置文件决定依赖关系，先实例化被依赖的Bean实例，然后为Bean注入依赖关系。最后将一个完整的Bean实例返回给程序，该Bean实例的所有属性，已经由Spring容器完成了初始化。</p>
<p>Axe.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;</span><br><span class="line">    public void useAxe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖Bean:SteelAxe实例..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chinese</span> <span class="title">implements</span> <span class="title">Person</span>&#123;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span>(<span class="params">Axe axe</span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Spring执行依赖关系注入"</span>);</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Spring实例化主调Bean:Chinese实例..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置 :<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> <span class="keyword">person</span>=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        <span class="keyword">person</span>.useAxe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//控制台输出：</span><br><span class="line">Spring实例化主调Bean:Chinese实例...</span><br><span class="line">Spring实例化依赖Bean:SteelAxe实例...</span><br><span class="line">Spring执行依赖关系注入</span><br><span class="line">钢斧砍柴真快</span><br></pre></td></tr></table></figure></p>
<p>执行结果清楚地反映了执行过程：</p>
<ol>
<li>程序创建ApplicationContext实例。</li>
<li>调用Chinese类的默认构造器创建默认实例。</li>
<li>根据配置文件注入依赖关系：先实例化依赖Bean，然后将依赖Bean注入。</li>
<li>返回一个完整的Chinese实例。</li>
</ol>
<h3 id="使用静态工厂方法创建Bean">使用静态工厂方法创建Bean</h3><p>Being.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Being</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeing</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Dog.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">implements</span> <span class="title">Being</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(msg+<span class="string">",狗爱啃骨头"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Cat.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cat</span> <span class="keyword">implements</span> <span class="title">Being</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String msg;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msg = msg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testBeing</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(msg+<span class="string">",猫爱吃老鼠"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BeingFactory.java :</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">BeingFactory</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Being <span class="title">getBeing</span>(<span class="params">String arg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(arg.equalsIgnoreCase(<span class="string">"dog"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Dog();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Cat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bean.xml核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"dog"</span> class=<span class="string">"com.bean.BeingFactory"</span> factory-<span class="keyword">method</span>=<span class="string">"getBeing"</span>&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">"dog"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"msg"</span> value=<span class="string">"我是狗"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"cat"</span> class=<span class="string">"com.bean.BeingFactory"</span> factory-<span class="keyword">method</span>=<span class="string">"getBeing"</span>&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">"cat"</span>/&gt;</span><br><span class="line">    &lt;property name=<span class="string">"msg"</span> value=<span class="string">"我是猫"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>从上面的核心配置可以看出，cat和dog两个Bean配置的class属性和factory-method属性完全相同，这是因为这两个实例都是由同一个工厂类的同一个静态方法生产得到的。配置这两个Bean实例指定了工厂的静态方法的实参值不同，配置静态方法的实参值使用<code>&lt;constructor-arg.../&gt;</code>元素。<br>Test.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        ApplicationContext ctx=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        Being b1=(Being) ctx.getBean(<span class="string">"dog"</span>);</span><br><span class="line">        b1.testBeing();</span><br><span class="line">        Being b2=(Being) ctx.getBean(<span class="string">"cat"</span>);</span><br><span class="line">        b2.testBeing();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用静态工厂方法创建Bean实例时，class属性也必须指定，但此时class属性并不是Bean实例的实现类，而是静态工厂类。除此之外，还需要使用factory-method属性来指定工厂的静态方法名。</p>
<h3 id="调用实例工厂方法创建Bean">调用实例工厂方法创建Bean</h3><p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;</span><br><span class="line">    public String sayHello(String name);</span><br><span class="line">    public String sayGoodBye(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayGoodBye</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">",再见！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">",你好"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>American.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">American</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayGoodBye</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">",Good Bye !"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">",Hello !"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PersonFactory.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">PersonFactory</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getPerson</span>(<span class="params">String ethnic</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(ethnic.equalsIgnoreCase(<span class="string">"chin"</span>))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Chinese();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> American();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置 :<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"personFactory"</span> class=<span class="string">"com.bean.PersonFactory"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"chinese"</span> factory-bean=<span class="string">"personFactory"</span> factory-<span class="keyword">method</span>=<span class="string">"getPerson"</span>&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">"chin"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"american"</span> factory-bean=<span class="string">"personFactory"</span> factory-<span class="keyword">method</span>=<span class="string">"getPerson"</span>&gt;</span><br><span class="line">    &lt;constructor-arg value=<span class="string">"ame"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p1=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        System.out.println(p1.sayGoodBye(<span class="string">"tom"</span>)+p1.sayHello(<span class="string">"tom"</span>));</span><br><span class="line">        <span class="keyword">Person</span> p2=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"american"</span>);</span><br><span class="line">        System.out.println(p2.sayGoodBye(<span class="string">"tom"</span>)+p2.sayHello(<span class="string">"tom"</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实例工厂方法与静态工厂方法的区别。</p>
<p>调用实例工厂方法创建Bean，必须将实例工厂配置成Bean实例。而静态工厂方法创建Bean，则无需配置工厂Bean。<br>调用实例工厂方法创建Bean，必须使用factory-bean属性确定工厂Bean。而静态工厂方法创建Bean，则使用class元素确定静态工厂类。</p>
<h2 id="深入理解容器中的Bean">深入理解容器中的Bean</h2><h3 id="使用抽象Bean">使用抽象Bean</h3><p>抽象Bean，都是指定abstract属性为true的Bean，抽象Bean不能被实例化，Spring容器不会创建抽象Bean的实例。抽象Bean的价值在于被继承，抽象Bean通常作为父Bean被继承。<br>当某个Bean将作为其他Bean的模板使用时，该Bean通常不需要实例化，而ApplicationContext默认预初始化所有的singleton Bean。为了阻止Bean模板被预初始化，可以指定abstract=“true”将该模板Bean设置为抽象Bean，Spring容器会忽略所有的抽象Bean定义，预初始化时不初始化抽象Bean。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chineseTemplate"</span> class=<span class="string">"com.bean.Chinese"</span> abstract=<span class="string">"true"</span>&gt;</span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>这样配置以后，当程序采用ApplicationContext作为Spring容器时，程序实例化ApplicationContext容器时会默认实例化所有的singleton Bean，但不会初始化abstract  Bean。<br>抽象Bean是一个模板，容器会忽略抽象Bean的定义，不会实例化抽象Bean。抽象Bean因为无须实例化，因此可以没有class属性。<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chineseTemplate"</span> abstract=<span class="string">"true"</span>&gt;</span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>抽象Bean不能实例化，因此既不能通过getBean显式地获得抽象Bean实例，也不能将抽象Bean注入成其他Bean的依赖属性。无论何时，只要企图实例化抽象Bean，都将导致错误。</p>
<h3 id="使用子Bean">使用子Bean</h3><p>现象：有一批Bean配置的大量配置信息完全相同，只有少量配置不同。那么我们是否有办法来简化配置呢？Spring提供了 Bean继承来应对这个问题。Spring可以先为这批Bean配置一个Bean模板，将这批Bean中相同的配置信息配置成Bean模板，因为Spring容器无须创建Bean模板的实例，所以通常将这个Bean模板配成抽象Bean。</p>
<p>将大部分相同信息配置成Bean模板后，将实际的Bean实例配置成Bean模板的子Bean即可。子Bean定义可以从父Bean继承实现类、构造器参数、属性值等配置信息，除此之外，子Bean配置可以增加新的配置信息，并可指定新的配置信息覆盖父Bean的定义。</p>
<p>子Bean无法从父Bean继承如下属性：depends-on、autowire、singleton、scope、lazy-init，这些属性将总是从子Bean定义中获得，或采取默认值。</p>
<p>通过为一个<code>&lt;bean.../&gt;</code>元素指定 parent属性 即可指定该Bean是一个子Bean，parent属性指定该Bean所继承的父Bean的id。</p>
<p>Axe.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖bean:SteelAxe实例..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>StoneAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoneAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"石斧砍柴真慢"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StoneAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖bean:StoneAxe实例..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;</span><br><span class="line">    public void useAxe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Chinese</span> <span class="title">implements</span> <span class="title">Person</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span>(<span class="params">Axe axe</span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Spring执行依赖关系注入..."</span>);</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Spring实例化主调bean:Chinese实例..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"steelAxe"</span> <span class="variable">class=</span><span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"stoneAxe"</span> <span class="variable">class=</span><span class="string">"com.bean.StoneAxe"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"chineseTemplate"</span> <span class="variable">class=</span><span class="string">"com.bean.Chinese"</span> <span class="variable">abstract=</span><span class="string">"true"</span>&gt;</span><br><span class="line">   &lt;property <span class="variable">name=</span><span class="string">"axe"</span> <span class="variable">ref=</span><span class="string">"steelAxe"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean <span class="variable">id=</span><span class="string">"chinese"</span> <span class="variable">parent=</span><span class="string">"chineseTemplate"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        p.useAxe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//控制台输出：</span><br><span class="line">Spring实例化依赖bean：SteelAxe实例...</span><br><span class="line">Spring实例化依赖bean：StoneAxe实例...</span><br><span class="line">Spring实例化主调bean：Chinese实例...</span><br><span class="line">Spring执行依赖关系注入...</span><br><span class="line">钢斧砍柴真快</span><br></pre></td></tr></table></figure></p>
<p>子Bean从父Bean继承了实现类，依赖关系等配置信息。实际上，子Bean也可以覆盖父Bean的配置信息：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"stoneAxe"</span> class=<span class="string">"com.bean.StoneAxe"</span>/&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"chineseTemplate"</span> class=<span class="string">"com.bean.Chinese"</span> abstract=<span class="string">"true"</span>&gt;</span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"chinese"</span> parent=<span class="string">"chineseTemplate"</span>&gt;</span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"stoneAxe"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>控制台输出：<br><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">Spring</span>实例化依赖bean：<span class="variable">SteelAxe</span>实例...</span><br><span class="line"><span class="variable">Spring</span>实例化依赖bean：<span class="variable">StoneAxe</span>实例...</span><br><span class="line"><span class="variable">Spring</span>实例化主调bean：<span class="variable">Chinese</span>实例...</span><br><span class="line"><span class="variable">Spring</span>执行依赖关系注入...</span><br><span class="line">石斧砍柴真慢</span><br></pre></td></tr></table></figure></p>
<h3 id="Bean继承与Java继承的区别">Bean继承与Java继承的区别</h3><p>Spring中的Bean继承与Java中的继承截然不同。前者是实例与实例之间的参数的延续，后者则是一般到特殊的细化；前者是对象与对象之间的关系，后者是类与类之间的关系。Spring中的Bean继承与Java中的继承有如下区别：</p>
<ol>
<li>Spring中子Bean和父Bean可以是不同类型，但Java中的继承则可保证子类是一种特殊的父类。</li>
<li>Spring中的Bean继承是实例之间的关系，因此主要表现为参数值的延续；而Java中的继承是类之间的关系，主要表现为方法、属性的延续。</li>
<li>Spring中子Bean不可作为父Bean使用，不具备多态性；Java中的子类实例完全可以当成父类实例使用。</li>
</ol>
<h3 id="容器中的_工厂Bean">容器中的 工厂Bean</h3><p>此处的工厂Bean，与前面介绍的实例工厂方法创建Bean，或者静态工厂方法创建Bean的工厂有所区别：前面那些工厂是标准的工厂模式，Spring只是负责调用工厂方法来创建Bean实例；此处的工厂Bean是Spring的一种特殊Bean，这种工厂Bean必须实现FactoryBean接口。</p>
<p>FactoryBean接口是工厂Bean的标准接口，实现该接口的Bean通常只能作为工厂Bean使用，当我们将工厂Bean部署在容器中，并通过getBean( )方法来获取工厂Bean时，容器不会返回FactoryBean实例，而是返回FactoryBean的产品。</p>
<p>FactoryBean接口提供如下三个方法：</p>
<ul>
<li>Object getObject( )    实现该方法负责返回该工厂Bean生成的Java实例。</li>
<li>Class getObjectType( )    实现该方法返回该工厂Bean生成的Java实例的实现类。</li>
<li>boolean isSingleton( )    实现该方法表示该工厂Bean生成的Java实例是否为单例模式。 实现FactoryBean接口的Bean无法作为正常Bean使用，配置FactoryBean与配置普通Bean没有区别，但当客户端对该Bean id请求时，容器返回该FactoryBean的产品，而不是返回该FactoryBean本身。</li>
</ul>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;</span><br><span class="line">    public String sayHello(String name);</span><br><span class="line">    public String sayGoodBye(String name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span></span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayGoodBye</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"再见,"</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"你好,"</span>+name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>PersonFactory.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonFactory</span> <span class="keyword">implements</span> <span class="title">FactoryBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Person p;</span><br><span class="line">    <span class="comment">//返回工厂Bean所生产的产品</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Person <span class="title">getObject</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p==<span class="keyword">null</span>)&#123;</span><br><span class="line">            p=<span class="keyword">new</span> Chinese();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取工厂Bean所生产的产品的类型</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Chinese.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回该工厂Bean所生产的产品是否为单例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="property">id</span>=<span class="string">"chinese"</span> <span class="type">class</span>=<span class="string">"com.bean.PersonFactory"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        //直接请求FactoryBean时，系统将返回该FactoryBean的产品</span><br><span class="line">        <span class="keyword">Person</span> p1=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);//1</span><br><span class="line">        System.out.println(p1.sayHello(<span class="string">"汤姆"</span>));</span><br><span class="line">        System.out.println(p1.sayGoodBye(<span class="string">"汤姆"</span>));</span><br><span class="line">        //再次获取该FactoryBean的产品</span><br><span class="line">        <span class="keyword">Person</span> p2=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);//2</span><br><span class="line">        System.out.println(p1==p2);</span><br><span class="line">        System.out.println(ctx.getBean(<span class="string">"&amp;chinese"</span>));//3</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">///控制台输出：</span><br><span class="line">你好，汤姆</span><br><span class="line">再见，汤姆</span><br><span class="line">true</span><br><span class="line">com.bean.PersonFactory@5e5a50</span><br></pre></td></tr></table></figure></p>
<p>上面的PersonFactory是一个标准的工厂Bean，该PersonFactory的getObject( )方法保证每次产生的Person对象是单例的，故该工厂类的isSingleton( )方法返回true。</p>
<p>Test.java中1和2直接请求容器中的FactoryBean，Spring将不会返回该FactoryBean实例，而是返回该FactoryBean的产品；程序3在Bean id前增加&amp;符号，这将会让Spring返回FactoryBean本身。</p>
<p>因为FactoryBean以单例方式管理产品Bean，因此两次请求的产品，是同一个共享实例。</p>
<p>当程序需要获取FactoryBean本身时，并不直接请求Bean id，而是在Bean id前增加&amp;符号。</p>
<p>对于初学者而言，可能无法体会到工厂Bean的作用。实际上，FactoryBean是Spring中非常有用的一个接口，Spring内置提供了很多实用的工厂Bean，例如TransactionProxyFactoryBean等，这个工厂Bean专门用于为目标Bean创建事务代理。</p>
<p>Spring提供的工厂Bean，大多以FactoryBean后缀结尾，Spring提供的工厂Bean，大多用于生产一批具有某种特征的Bean实例，工厂Bean是Spring的一个重要工具类。</p>
<h3 id="获得Bean部署时的id">获得Bean部署时的id</h3><p>在某些极端情况下，程序开发Bean类时需要获得在容器中部署该Bean时指定的id属性，此时可借助于Spring提供的 BeanNameAware 接口，通过该接口允许Bean类获取部署该Bean时指定的id属性。</p>
<p>BeanNameAware接口提供的一个方法：setBeanName(String name)，该方法的name参数就是Bean的id，实现该方法的Bean类就可通过该方法来获得部署该Bean的id了。</p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">BeanNameAware</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String beanName;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBeanName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beanName=name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getBeanId</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Chinese实现类，部署该Bean时指定的id为："</span>+beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml 核心配置：<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="property">id</span>=<span class="string">"chinese"</span> <span class="type">class</span>=<span class="string">"com.bean.Chinese"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        ApplicationContext ctx=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        Chinese c=(Chinese) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        c.getBeanId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"><span class="xmlDocTag">///</span>控制台输出：</span></span><br><span class="line">Chinese实现类，部署该Bean时指定的id为:chinese</span><br></pre></td></tr></table></figure></p>
<p>Spring容器何时回调Bean实例的setBeanName(String name)方法呢？Spring容器会在Bean初始化完成后回调该方法—这里的初始化指的是Bean的初始化行为：包括回调实现InitializingBean接口所实现的afterPropertiesSet方法，回调Bean配置中init-method属性指定的方法。当Spring容器完成了Bean的初始化动作之后，接下来将会回调实现BeanNameAware接口里的setBeanName(String name)方法。</p>
<h3 id="强制初始化Bean">强制初始化Bean</h3><p>Spring默认有个规则：总是先初始化主调Bean，然后再初始化依赖Bean。</p>
<p>大多数情况下，Bean之间的依赖关系非常直接，Spring容器在返回Bean实例之前，完成Bean依赖关系的注入。假如Bean A依赖于Bean B，程序请求Bean A时，Spring容器会自动先初始化Bean B，再将Bean B注入Bean A，最后将具备完整依赖的Bean A返回给程序。</p>
<p>在极端的情况下，Bean之间的依赖不够直接。比如某个类的初始化块中使用其他Bean，Spring总是先初始化主调Bean，执行初始化块时还没有实例化主调Bean，被依赖的Bean还没实例化，此时将引发异常。</p>
<p>为了让指定Bean在目标Bean之前初始化，可以使用 depends-on 属性，该属性可以在初始化主调Bean之前，强制初始化一个或多个Bean。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"beanOne"</span> class=<span class="string">"ExampleBean"</span> depends-on=<span class="string">"manager"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"manager"</span> <span class="keyword">ref</span>=<span class="string">"manager"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"manager"</span> class=<span class="string">"ManagerBean"</span>/&gt;</span><br></pre></td></tr></table></figure>
<h2 id="容器中Bean的生命周期">容器中Bean的生命周期</h2><p>对于singleton作用域的Bean，Spring容器知道Bean何时实例化结束、何时销毁，Spring可以管理实例化结束之后和销毁之前的行为。管理Bean的生命周期行为主要有如下两个时机：</p>
<ol>
<li>注入依赖关系之后。</li>
<li>即将销毁Bean之前。</li>
</ol>
<h3 id="依赖关系注入之后的行为">依赖关系注入之后的行为</h3><p>依赖关系注入之后的行为：<br>Spring提供两种方式在Bean全部属性设置成功后执行特定行为：</p>
<ol>
<li>使用 init-method 属性<br> 使用init-method属性指定某个方法应在Bean全部依赖关系设置结束后自动执行，使用这种方法不需将代码与Spring的接口耦合在一起，代码污染小。</li>
<li>实现 InitializingBean 接口<br> 该接口提供一个方法，void afterPropertiesSet( )throws Exception。Spring容器会在为该Bean注入依赖关系之后，接下来会调用该Bean所实现的afetrPropertiesSet( )方法。</li>
</ol>
<p>Axe.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;</span><br><span class="line">    public void useAxe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖bean:SteelAxe实例..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span>,<span class="title">InitializingBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring实例化主调Bean:Chinese实例..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring执行依赖关系注入..."</span>);</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行初始化方法init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行初始化方法afterPropertiesSet..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml 核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span> init-<span class="keyword">method</span>=<span class="string">"init"</span>&gt;</span><br><span class="line">    &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        p.useAxe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>从运行结果可以看出：依赖注入完成之后，程序先调用afterPropertiesSet方法，再调用init-method属性所指定的方法进行初始化。</p>
<h3 id="Bean_销毁之前的行为">Bean 销毁之前的行为</h3><p>与定制初始化行为相似，Spring也提供两种方法定制Bean实例销毁之前的行为：</p>
<ol>
<li>使用destroy-method属性：<br> destroy-method属性指定某个方法在Bean销毁之前被自动执行。使用这种方式，不需要将代码与Spring的接口耦合，代码污染小。</li>
<li>实现DisposableBean接口：<br> 该接口提供了一个方法，void destroy( ) throws Exception，该方法就是Bean实例被销毁之前应该执行的方法。</li>
</ol>
<p>Axe.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;</span><br><span class="line">    public void useAxe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖Bean:SteelAxe实例..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span>,<span class="title">DisposableBean</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring实例化主调Bean:Chinese实例..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring执行依赖关系注入..."</span>);</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行销毁之前的方法close..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行销毁之前的方法destroy..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span> destroy-<span class="keyword">method</span>=<span class="string">"close"</span>&gt;</span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        AbstractApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        p.useAxe();</span><br><span class="line">        ctx.registerShutdownHook();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>singleton 作用域的Bean通常会随容器的关闭而销毁，但问题是：ApplicationContext容器在什么时候关闭呢？在基于web的ApplicationContext实现中，系统已经提供了相应的代码保证关闭web应用时恰当地关闭Spring容器。</p>
<p>如果处于一个非web应用的环境下，为了让Spring容器优雅地关闭，并调用singleton Bean上的相应析构回调方法，则需要在JVM虚拟机里注册一个关闭钩子，这样就可保证Spring容器被恰当关闭，且自动执行singleton Bean实例的析构回调方法。</p>
<p>为了注册关闭钩子，只需要调用在AbstractApplicationContext中提供的registerShutdownHook( )方法即可。</p>
<p>从程序的输出可以看出：Spring容器注入之后，关闭之前，程序先调用destroy方法进行回收资源，再调用close方法进行回收资源。</p>
<p>如果某个Bean类实现了DisposableBean接口，在Bean被销毁之前，Spring容器会自动调用该Bean实例的destroy方法，其结果与采用destroy-method属性指定生命周期方法几乎一样。但实现DisposableBean接口污染了代码，是侵入式设计，因此不推荐使用。</p>
<p>除此之外，如果容器中很多Bean都需要指定特定的生命周期行为，则可以利用 <code>&lt;beans.../&gt;</code> 元素的 default-init-method属性和 default-destroy-method 属性，这两个属性的作用类似于 <code>&lt;bean.../&gt;</code>元素的 init-method 属性和destroy-method 属性，区别是default-init-method和default-destroy-method是针对容器中所有Bean生效。</p>
<h3 id="协调作用域不同步的Bean">协调作用域不同步的Bean</h3><p>当两个singleton作用域Bean存在依赖关系时，或prototype作用域Bean依赖singleton作用域Bean时，不会有任何问题。</p>
<p>但当singleton作用域Bean依赖prototype作用域Bean时，singleton作用域Bean只有一次初始化的机会，它的依赖关系也只在初始化阶段被设置，它所依赖的prototype作用域Bean则需要每次都得到一个全新的Bean实例，这将会导致singleton作用域的Bean的依赖得不到即时更新。</p>
<p>由于singleton Bean具有单例行为，当客户端多次请求singleton Bean时，Spring返回给客户端的将是同一个singleton Bean实例，这不存在任何问题。问题是：如果客户端多次请求singleton Bean、并调用singleton Bean去调用prototype Bean的方法时，始终都是调用同一个prototype Bean实例，这就违背了设置prototype Bean的初衷：本来希望它具有prototype行为，但实际上它却表现出singleton行为。</p>
<p>这就是问题的所在：当singleton作用域的Bean依赖于prototype作用域的Bean时，会产生不同步的现象。</p>
<p>解决该问题有如下两种思路：</p>
<ol>
<li>部分放弃依赖注入：singleton作用域Bean每次需要prototype作用域Bean时，主动向容器请求新的Bean实例，即可保证每次注入的prototype Bean实例都是最新的实例。</li>
<li>利用方法注入。<br>第一种方式显然不是一个好的做法，代码主动请求新的Bean实例，必然导致代码与Spring API耦合，造成代码严重污染。<br>通常情况下，我们采用第二种做法，使用方法注入。方法注入通常使用lookup方法注入，利用lookup方法注入可以让Spring容器重写容器中Bean的抽象或具体方法，返回查找容器中其他Bean的结果，被查找的Bean通常是一个non-singleton Bean。Spring通过使用CGLIB库修改客户端的二进制码，从而实现上述的要求。</li>
</ol>
<p>Axe.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖Bean:SteelAxe实例..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;</span><br><span class="line">    public void useAxe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title">Chinese</span> <span class="title">implements</span> <span class="title">Person</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Spring实例化主调Bean:Chinese实例..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//singleton Bean里增加一个抽象方法</span></span><br><span class="line">    <span class="comment">//方法的返回值类型是被依赖的Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Axe <span class="title">getAxe</span>(<span class="params"></span>)</span>;</span><br><span class="line">    @<span class="function">Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"正在使用"</span>+getAxe()+<span class="string">"砍柴!"</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(getAxe().chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span>&gt;</span><br><span class="line">   &lt;lookup-<span class="keyword">method</span> name=<span class="string">"getAxe"</span> bean=<span class="string">"steelAxe"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span> scope=<span class="string">"prototype"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        p.useAxe();</span><br><span class="line">        p.useAxe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们在singleton Bean里新增一个抽象方法，该方法的返回值类型是被依赖的Bean，该方法是一个抽象方法，其实现由Spring完成。问题是：Spring怎么知道如何实现该方法呢？为了让Spring知道如何实现该方法，我们需要在配置文件中使用<code>&lt;lookup-method.../&gt;</code>元素来配置这个方法。<br>使用<code>&lt;lookup-method.../&gt;</code>元素需要指定如下两个属性：</p>
<ol>
<li>name：指定需要让Spring实现的方法。</li>
<li>bean：指定Spring实现该方法后的返回值。</li>
</ol>
<p>程序的执行结果表明：使用lookup方法注入后，系统每次调用getAxe( )方法都将生成一个新的SteelAxe实例，这就可以保证当singleton作用域的Bean需要全新的Bean实例时，直接调用getAxe()方法即可，从而可以避免一直使用最早注入的Bean实例。</p>
<h2 id="深入理解依赖关系配置">深入理解依赖关系配置</h2><p>组件与组件之间的耦合，采用依赖注入管理，但是普通的javabean属性值，应直接在代码里设置。</p>
<p>在spring配置文件中使用xml元素进行配置,实际上是让spring执行相应的java代码<br>例如:</p>
<ol>
<li>使用<bean>元素，就是让spring执行无参数构造函数</bean></li>
<li>使用<property> 就是让spring执行setter方法</property></li>
</ol>
<p>但是java程序还有可能还有其他语句,调用getting,调用普通方法,访问类或者对象的file,spring也为这种语句提供利配置的语法</p>
<ol>
<li>调用getter方法：使用 PropertyPathFactoryBean</li>
<li>访问类或对象的Field值，使用FieldRetrievingFactoryBean</li>
<li>调用普通方法，使用MethodInvokingFactoryBean</li>
</ol>
<p>由此可见，spring可以然我们不写java代码就可以实现java编程，只要使用合适XML 语法进行配置，spring就可通过反射执行任意的底层java代码。</p>
<h3 id="注入其他Bean的属性值">注入其他Bean的属性值</h3><p>属性值的注入，是通过PropertyPathFactoryBean完成的，PropertyPathFactoryBean用来获取目标bean的属性，获得的值可以注入到其他bean,也可以定义成新的bean</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"person"</span> <span class="attribute">class</span>=<span class="value">"com.bean.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span> <span class="attribute">value</span>=<span class="value">"30"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"son"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.bean.Son"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span> <span class="attribute">value</span>=<span class="value">"11"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--如下将会将person的属性son的属性age传入son1实例的age属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"son1"</span> <span class="attribute">class</span>=<span class="value">"com.bean.Son"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以下是访问bean属性的简单方式,这样可以将person这个bean的age属性赋值给son1这个bean的age属性--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"person.son.age"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 以下将会获得结果son,它将是person bean的son的数值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"son2"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetBeanName"</span> <span class="attribute">value</span>=<span class="value">"person"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"propertyPath"</span> <span class="attribute">value</span>=<span class="value">"son"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 以下将会获得结果11,它将是person bean的son的age属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"theAge1"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetBeanName"</span> <span class="attribute">value</span>=<span class="value">"person"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"propertyPath"</span> <span class="attribute">value</span>=<span class="value">"son.age"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 以下会获得结果为30 ,它将是获得该bean的内部bean的age属性--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"theAge2"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.PropertyPathFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetObject"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.bean.Person"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span> <span class="attribute">value</span>=<span class="value">"30"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"propertyPath"</span> <span class="attribute">value</span>=<span class="value">"age"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public static void main<span class="params">(String[] args)</span> throws Exception &#123;</span><br><span class="line">        String path=new Test<span class="params">()</span>.getClass<span class="params">()</span>.getResource<span class="params">(<span class="string">"/"</span>)</span>.getPath<span class="params">()</span>;</span><br><span class="line">        String realpath=path.substring<span class="params">(<span class="number">1</span>, path.length<span class="params">()</span>)</span>;</span><br><span class="line">        ApplicationContext context=new FileSystemXmlApplicationContext<span class="params">(realpath+<span class="string">"/superIOCparam.xml"</span>)</span>;</span><br><span class="line">        Son son1=<span class="params">(Son)</span>context.getBean<span class="params">(<span class="string">"son1"</span>)</span>;</span><br><span class="line">        Son son2=<span class="params">(Son)</span>context.getBean<span class="params">(<span class="string">"son2"</span>)</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println<span class="params">(<span class="string">"person age is:"</span>+son1.getAge<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"person age is:"</span>+son2.getAge<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(context.getBean<span class="params">(<span class="string">"theAge1"</span>)</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(context.getBean<span class="params">(<span class="string">"theAge2"</span>)</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>可以将Bean实例的属性值注入另一个Bean，此时bean的id是指定属性表达式，不是唯一标识。</li>
<li>可以将Bean实例的属性值直接定义成Bean实例，此时的id就是它的唯一标识。且必须指定两个属性：targetBeanName用于指定目标Bean，确定获取哪个Bean的属性值，或targetObject用于指定嵌套Bean实例；propertyPath，用于指定属性，确定获取目标Bean的哪个属性值，此处的属性可直接使用复合属性的形式。</li>
</ol>
<h3 id="注入其他Bean的Field值">注入其他Bean的Field值</h3><p>FieldRetrievingFactoryBean获得目标Bean的Field值后，得到的值可注入给其他Bean，也可直接定义成新的Bean。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 将指定的类的静态Field设置成bean的属性值 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"son"</span> <span class="attribute">class</span>=<span class="value">"com.bean.Son"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id指定了哪个Field的值 将会被设置给id="son"的bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span></span><br><span class="line">            <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将其他bean的Field定义成一个bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"theAge1"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- targetClass 设置Field所在的类,targetObject,当目标对象时使用(代替targetClass) --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetClass"</span> <span class="attribute">value</span>=<span class="value">"java.sql.Connection"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- targetField指定目标类的目标Field --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetField"</span> <span class="attribute">value</span>=<span class="value">"TRANSACTION_SERIALIZABLE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 将静态Field定义成一个bean的简单写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"theAge2"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.FieldRetrievingFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"staticField"</span> <span class="attribute">value</span>=<span class="value">"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试代码：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main<span class="params">(String[] args)</span> throws Exception &#123;</span><br><span class="line">        String path=new Test<span class="params">()</span>.getClass<span class="params">()</span>.getResource<span class="params">(<span class="string">"/"</span>)</span>.getPath<span class="params">()</span>;</span><br><span class="line">        String realpath=path.substring<span class="params">(<span class="number">1</span>, path.length<span class="params">()</span>)</span>;</span><br><span class="line">        ApplicationContext context=new FileSystemXmlApplicationContext<span class="params">(realpath+<span class="string">"/superIOCparam.xml"</span>)</span>;</span><br><span class="line">        Son son=<span class="params">(Son)</span>context.getBean<span class="params">(<span class="string">"son"</span>,Son.class)</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println<span class="params">(<span class="string">"son age is:"</span>+son.getAge<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(context.getBean<span class="params">(<span class="string">"theAge1"</span>)</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(context.getBean<span class="params">(<span class="string">"theAge2"</span>)</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用FieldRetrievingFactoryBean获取Field值时，必须指定两个属性值</p>
<ul>
<li>targetClass或targetObject：分别用于指定Field值所在的目标类或目标对象，如果需要获得Field是静态Field，则使用targetClass指定目标类，否则使用targetObject指定目标对象。</li>
<li>targetField：用于指定目标Field的Field名。如果是静态Field可以通过staticField直接指定域。</li>
</ul>
<h3 id="注入其他Bean的方法返回值">注入其他Bean的方法返回值</h3><p>通过MethodInvokingFactoryBean工厂Bean，可获得指定方法的返回值并将其注入到指定Bean实例的指定属性，也可以直接定义成Bean实例。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 提供方法的bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"valueGenerator"</span> <span class="attribute">class</span>=<span class="value">"com.util.valueGenerator"</span> /&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 将一个bean的方法 返回值 注入 新bean的 age属性 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"son1"</span> <span class="attribute">class</span>=<span class="value">"com.bean.Son"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"age"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetObject"</span> <span class="attribute">ref</span>=<span class="value">"valueGenerator"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetMethod"</span> <span class="attribute">value</span>=<span class="value">"getValue"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 上面 是调用非静态类对象的getValue()这种无参方法 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 调用静态类的静态方法,静态方法的返回值直接 定义成bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sysProps"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetClass"</span> <span class="attribute">value</span>=<span class="value">"java.lang.System"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetMethod"</span> <span class="attribute">value</span>=<span class="value">"getProperties"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 调用无参 静态类的静态方法 创建bean name="staticMethod",value=静态类.静态方法--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"myBean"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"staticMethod"</span> <span class="attribute">value</span>=<span class="value">"xxx.MyStaticClass.myStaticMethod"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 有参数的方法调用,返回值 配置成一个bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"javaVersion"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.beans.factory.config.MethodInvokingFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 目标bean,确定调用哪个bean的方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetObject"</span> <span class="attribute">ref</span>=<span class="value">"sysProps"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 确定目标方法,确定调用bean的哪个方法 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"targetMethod"</span> <span class="attribute">value</span>=<span class="value">"getProperty"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 确定调用目标方法的参数 相当于调用getProperty方法,传递参数"java.version" --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"arguments"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">value</span>&gt;</span>java.version<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ValueGenrator类<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ValueGenerator</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getStaticValue</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>测试类<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public static void main<span class="params">(String[] args)</span> throws Exception &#123;</span><br><span class="line">        String path=new Test<span class="params">()</span>.getClass<span class="params">()</span>.getResource<span class="params">(<span class="string">"/"</span>)</span>.getPath<span class="params">()</span>;</span><br><span class="line">        String realpath=path.substring<span class="params">(<span class="number">1</span>, path.length<span class="params">()</span>)</span>;</span><br><span class="line">        ApplicationContext context=new FileSystemXmlApplicationContext<span class="params">(realpath+<span class="string">"/superIOCparam.xml"</span>)</span>;</span><br><span class="line">        Son son1=<span class="params">(Son)</span>context.getBean<span class="params">(<span class="string">"son1"</span>,Son.class)</span>;</span><br><span class="line">        Son son2=<span class="params">(Son)</span>context.getBean<span class="params">(<span class="string">"son2"</span>,Son.class)</span>;</span><br><span class="line"></span><br><span class="line">        System.out.println<span class="params">(<span class="string">"son age is:"</span>+son1.getAge<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"son age is:"</span>+son2.getAge<span class="params">()</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>targetClass或targetObject：分别用于指定目标类或目标对象。</li>
<li>targetMethod：用于指定目标方法的方法名。如果是静态方法可以通过staticMethod直接指定方法。</li>
</ul>
<h2 id="基于xml_schema_的简化配置方式">基于xml schema 的简化配置方式</h2><h3 id="使用p名称空间配置属性">使用p名称空间配置属性</h3><p>使用p命名空间可以简化原来property 的配置</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line"><span class="attribute">xmlns:p</span>=<span class="value">"http://www.springframework.org/schema/p"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Chinese实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.Chinese"</span> <span class="attribute">p:age</span>=<span class="value">"29"</span> <span class="attribute">p:age-ref</span>=<span class="value">"stoneAxe"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置stoneAxe实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"stoneAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.StoneAxe"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>首先，需要导入p名字空间，通过在axe后添加”-ref”指定该值不是一个具体的值，而是对另外一个Bean的引用。</p>
<h3 id="使用util_Schema">使用util Schema</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line"><span class="attribute">xmlns:p</span>=<span class="value">"http://www.springframework.org/schema/p"</span></span><br><span class="line"><span class="attribute">xmlns:util</span>=<span class="value">"http://www.springframework.org/schema/util"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/util</span><br><span class="line">http://www.springframework.org/schema/util/spring-util-3.0.xsd</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Chinese实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"chinese"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.Chinese"</span></span><br><span class="line">    <span class="attribute">p:age-ref</span>=<span class="value">"chin.age"</span></span><br><span class="line">    <span class="attribute">p:age-ref</span>=<span class="value">"stoneAxe"</span></span><br><span class="line">    <span class="attribute">p:schools-ref</span>=<span class="value">"chin.schools"</span></span><br><span class="line">    <span class="attribute">p:axes-ref</span>=<span class="value">"chin.axes"</span></span><br><span class="line">    <span class="attribute">p:scores-ref</span>=<span class="value">"chin.scores"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置stoneAxe实例 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"stoneAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.StoneAxe"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"steelAxe"</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.SteelAxe"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将指定类的静态Field暴露出来 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">util:constant</span> <span class="attribute">id</span>=<span class="value">"chin.age"</span> <span class="attribute">static-field</span>=<span class="value">"java.sql.Connection.TRANSACTION_SERIALIZABLE"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 将指定bean的属性 暴露出来 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">util:property-path</span> <span class="attribute">id</span>=<span class="value">"test"</span> <span class="attribute">path</span>=<span class="value">"chinese.age"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 加载指定资源文件 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">util:properties</span> <span class="attribute">id</span>=<span class="value">"confTest"</span> <span class="attribute">location</span>=<span class="value">"classpath:message_zh_CN.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个list --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">util:list</span> <span class="attribute">id</span>=<span class="value">"chin.schools"</span> <span class="attribute">list-class</span>=<span class="value">"java.util.LinkedList"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>小学<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>中学<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>大学<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">util:list</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定义一个set对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">util:set</span> <span class="attribute">id</span>=<span class="value">"chin.axes"</span> <span class="attribute">set-class</span>=<span class="value">"java.util.HashSet"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>字符串斧子<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.spring.service.impl.SteelAxe"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">ref</span> <span class="attribute">local</span>=<span class="value">"stoneAxe"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">util:set</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 定一个 map对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">util:map</span> <span class="attribute">id</span>=<span class="value">"chin.scores"</span> <span class="attribute">map-class</span>=<span class="value">"java.util.TreeMap"</span> <span class="attribute">key-type</span>=<span class="value">"java.lang.String"</span> <span class="attribute">value-type</span>=<span class="value">"java.lang.Double"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"数学"</span> <span class="attribute">value</span>=<span class="value">"89"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"英语"</span> <span class="attribute">value</span>=<span class="value">"89"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">entry</span> <span class="attribute">key</span>=<span class="value">"语文"</span> <span class="attribute">value</span>=<span class="value">"89"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">util:map</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>util Schema元素</p>
<ul>
<li>constant：该标签用于将指定类的静态Field暴露成一个Bean实例。使用该标签时可制定如下两个属性。<ul>
<li>id：该属性指定将静态Field定义成名为id的Bean实例</li>
<li>static-field：该属性指定将哪个类、哪个静态Field暴露出来。</li>
</ul>
</li>
<li>property-path：该标签用于将指定Bean实例的指定属性暴露成一个Bean实例，使用该标签时可指定如下两个属性<ul>
<li>id：该属性指定将属性定义成名为id的Bean实例</li>
<li>path：该属性指定将哪个Bean实例、哪个属性（支持复合属性）暴露出来。</li>
</ul>
</li>
<li>list 该标签用于定义一个List Bean，支持使用value、ref、bean等标签来定义List集合元素，使用该标签支持如下三个属性，<ul>
<li>id：该属性指定定义一个名为id的List实例</li>
<li>list-class：该属性指定Spring使用哪个List实现类来创建Bean实例</li>
<li>scope：指定该List实例的作用域</li>
</ul>
</li>
<li>set：该标签用于定义一个Set Bean，支持使用value、ref、bean等标签来定义Set集合元素，使用该标签支持如下三个属性。<ul>
<li>id：该属性指定定义一个名为id的Set Bean实例</li>
<li>set-class：该属性指定Set Bean使用哪个Set实现类来创建Bean实例</li>
<li>scope：指定该Set Bean实例的作用域</li>
</ul>
</li>
<li>map 该标签用于定义一个Map Bean，支持使用entry来定义Map的key-value对．使用该标签支持如下三个属性<ul>
<li>id：该属性指定定义一个名为id的Map Bean实例</li>
<li>map-class：该属性指定Spring使用哪个Map实现类来创建Bean实例</li>
<li>scope：指定该Map Bean实例的作用域</li>
</ul>
</li>
<li>properties：该标签用于加载一份资源文件并根据加载的资源文件创建个Properties Bean实例，使用该标签可指定如下几个属性<ul>
<li>id：该属性指定定义一个名为id的Properties Bean实例</li>
<li>location：指定资源文件的位置。</li>
<li>scope：指定该Properties Bean实例的作用域</li>
</ul>
</li>
</ul>
<h2 id="Spring3-0提供的表达式语言(SpEl)">Spring3.0提供的表达式语言(SpEl)</h2><p>Spring的表达式语言与Java注解结合，以便开发人员可以撰写和指向他们的配置，而不需要单独的XML文件写入，使得Spring开发者在不需要XML的情况下对应用进行配置。</p>
<h3 id="使用Expression接口进行表达式求值">使用Expression接口进行表达式求值</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public class SpELTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test2<span class="params">()</span> &#123;</span><br><span class="line">        ExpressionParser parser=new SpelExpressionParser<span class="params">()</span>;</span><br><span class="line">        Expression <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"'Hello World'"</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Hello World的结果"</span>+exp.getValue<span class="params">()</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"'Hello World'.concat('!')"</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"concat后的结果"</span>+exp.getValue<span class="params">()</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"'Hello World'.bytes"</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"调用getBytes方法后的结果"</span>+exp.getValue<span class="params">()</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"'Hello World'.bytes.length"</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"方法返回值后的属性的结果"</span>+exp.getValue<span class="params">()</span>)</span>;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"new String('Hello World').toUpperCase()"</span>)</span>;</span><br><span class="line">        <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"age"</span>)</span>;</span><br><span class="line">        Chinese c=act.getBean<span class="params">(<span class="string">"chinese"</span>,Chinese.class)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"以Chinese为root,age的表达式的值是:"</span>+exp.getValue<span class="params">(c, Integer.class)</span>)</span>;</span><br><span class="line">        <span class="built_in">exp</span>=parser.parseExpression<span class="params">(<span class="string">"age==15"</span>)</span>;</span><br><span class="line">        StandardEvaluationContext ctx=new StandardEvaluationContext<span class="params">()</span>;</span><br><span class="line">        ctx.setRootObject<span class="params">(c)</span>;</span><br><span class="line">        System.out.println<span class="params">(exp.getValue<span class="params">(ctx, Boolean.class)</span>)</span>;</span><br><span class="line"></span><br><span class="line">        List&lt;Boolean&gt; list=new ArrayList&lt;Boolean&gt;<span class="params">()</span>;</span><br><span class="line">        list.add<span class="params">(<span class="literal">true</span>)</span>;</span><br><span class="line">        EvaluationContext ctx2=new StandardEvaluationContext<span class="params">()</span>;</span><br><span class="line">        ctx2.setVariable<span class="params">(<span class="string">"list"</span>,list)</span>;</span><br><span class="line"></span><br><span class="line">        parser.parseExpression<span class="params">(<span class="string">"#list[0]"</span>)</span>.setValue<span class="params">(ctx2, <span class="string">"false"</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"List集合中的第一个元素:"</span>+list.get<span class="params">(<span class="number">0</span>)</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建解析器：SpEL使用ExpressionParser接口表示解析器，提供SpelExpressionParser默认实现；</li>
<li>解析表达式：使用ExpressionParser的parseExpression来解析相应的表达式为Expression对象。</li>
<li>构造上下文：准备比如变量定义等等表达式需要的上下文数据。</li>
<li>求值：通过Expression接口的getValue方法根据上下文获得表达式值。</li>
</ol>
<p>接下来让我们看下SpEL的主要接口吧：</p>
<ol>
<li>ExpressionParser接口：表示解析器，默认实现是org.springframework.expression.spel.standard包中的SpelExpressionParser类，使用parseExpression方法将字符串表达式转换为Expression对象，对于ParserContext接口用于定义字符串表达式是不是模板，及模板开始与结束字符</li>
<li>EvaluationContext接口：表示上下文环境，默认实现是org.springframework.expression.spel.support包中的StandardEvaluationContext类，使用setRootObject方法来设置根对象，使用setVariable方法来注册自定义变量，使用registerFunction来注册自定义函数等等。</li>
<li>Expression接口：表示表达式对象，默认实现是org.springframework.expression.spel.standard包中的SpelExpression，提供getValue方法用于获取表达式值，提供setValue方法用于设置对象值。</li>
</ol>
<h3 id="Bean定义中的表达式语言支持">Bean定义中的表达式语言支持</h3><p>xml配置文件和Annotation中使用SpEL时，都需要在表达式外面增加#{}包围。</p>
<h3 id="SpEL语法详述">SpEL语法详述</h3><h4 id="基本表达式">基本表达式</h4><ul>
<li>字面量表达式</li>
<li>算术运算表达式</li>
<li>比较运算表达式</li>
<li>逻辑运算表达式</li>
<li>字符串连接与截取表达式</li>
<li>三目运算及Elivis运算表达式</li>
<li>正则表达式</li>
</ul>
<p>字面量表达式<br>字符串、数字类型（int、long、float、double）、布尔类型、null。<br>字符串 ‘Hello World!’、”Hello World!”<br>数值类型 1、-1L、1.1、1.1E+2、0xa、0xaL<br>布尔类型 true、false<br>null null</p>
<p>算术运算表达式<br>加(+)、减(-)、乘(<code>*</code>)、除(/或DIV)、求余（%或MOD）、幂（^）。<br>加减乘除 <code>1+2-3*4/2</code>、<code>1+2-3*4DIV2</code><br>求余 <code>4%3</code>、<code>4MOD 3</code><br>幂运算 <code>2^3</code></p>
<p>比较运算表达式</p>
<p>不等于 !=或ne 1!= 1或 1ne 1<br>等于 ==或eq 1== 1或 1eq 1<br>大于等于 &gt;=或ge 1&gt;= 1或 1ge 1<br>小于等于 &lt;=或le 1&lt;= 1或 1le 1<br>大于 &gt;或gt 1&gt; 1或 1gt 1<br>小于 &lt;或lt 1&lt; 1或 1lt 1<br>区间 between 1 between {1, 2}</p>
<p>逻辑运算表达式<br>与 AND true AND true<br>或 OR true OR true<br>非 NOT NOT true</p>
<p>字符串连接及截取表达式<br>连接 + ‘Hello’ + ‘World !’<br>截取一个字符 string[index] ‘Hello World’[0]</p>
<p>三目运算及Elivis运算表达式<br>三目运算符 表达式1?表达式2:表达式3 2&gt;1?true:false<br>Elivis运算 表达式1?:表达式2 null? :false或true?:false</p>
<p>正则表达式<br>正则表达式 matches ‘123’ matches ‘\d{3}’</p>
<h4 id="类相关表达式">类相关表达式</h4><ul>
<li>类类型表达式</li>
<li>类实例化表达式</li>
<li>instanceof表达式</li>
<li>变量定义及引用</li>
<li>自定义函数</li>
<li>赋值表达式</li>
<li>对象属性存取及安全导航表达式<ul>
<li>访问root对象属性</li>
<li>安全访问</li>
<li>给root对象属性赋值</li>
</ul>
</li>
<li>对象方法调用</li>
<li>Bean引用</li>
</ul>
<p>类类型表达式</p>
<p>使用”T(Type)”来表示java.lang.Class实例，”Type”必须是类全限定名（java.lang包除外）。使用类类型表达式还可以进行访问类静态方法及类静态字段。</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>java.lang包类访问</td>
<td>T(String)</td>
</tr>
<tr>
<td>其他包的类访问</td>
<td>T(foo.bar.spel.SpELTest)</td>
</tr>
<tr>
<td>类静态字段访问</td>
<td>T(Integer).MAX_VALUE</td>
</tr>
<tr>
<td>类静态方法调用</td>
<td>T(Integer).parseInt(‘1’)</td>
</tr>
</tbody>
</table>
<p>类实例化表达式</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>java.lang包类的实例化</td>
<td>new String(‘hello’)</td>
</tr>
<tr>
<td>其他包的类实例化</td>
<td>new java.util.Date()</td>
</tr>
</tbody>
</table>
<p>instanceof</p>
<table>
<thead>
<tr>
<th>实例</th>
<th>示例</th>
</tr>
</thead>
<tbody>
<tr>
<td>Java内使用同义</td>
<td>‘hello’ instanceof T(String)</td>
</tr>
</tbody>
</table>
<p>变量定义与引用</p>
<p>变量定义通过EvaluationContext接口的setVariable(variableName, value)方法定义；在表达式中使用“#variableName”引用；除了引用自定义变量，SpEL还允许引用根对象及当前上下文对象，使用 “#root”引用根对象，使用“#this”引用当前上下文对象。“#this”引用当前上下文对象，此处“#this”即根对象。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">publicvoid testVariableExpression<span class="params">()</span> &#123;</span><br><span class="line">   ExpressionParser parser =new SpelExpressionParser<span class="params">()</span>;</span><br><span class="line">   EvaluationContext context =new StandardEvaluationContext<span class="params">()</span>;</span><br><span class="line">   context.setVariable<span class="params">(<span class="string">"variable"</span>,<span class="string">"hello"</span>)</span>;</span><br><span class="line">   context.setVariable<span class="params">(<span class="string">"variable"</span>,<span class="string">"world"</span>)</span>;</span><br><span class="line"></span><br><span class="line">   String result1 = parser.parseExpression<span class="params">(<span class="string">"#variable"</span>)</span>.getValue<span class="params">(context, String.class)</span>;</span><br><span class="line">   Assert.assertEquals<span class="params">(<span class="string">"world"</span>, result1)</span>;</span><br><span class="line"></span><br><span class="line">   context =new StandardEvaluationContext<span class="params">(<span class="string">"hello"</span>)</span>;</span><br><span class="line">   String result2 = parser.parseExpression<span class="params">(<span class="string">"#root"</span>)</span>.getValue<span class="params">(context, String.class)</span>;</span><br><span class="line">   Assert.assertEquals<span class="params">(<span class="string">"hello"</span>, result2)</span>;</span><br><span class="line"></span><br><span class="line">   String result3 = parser.parseExpression<span class="params">(<span class="string">"#this"</span>)</span>.getValue<span class="params">(context, String.class)</span>;</span><br><span class="line">   Assert.assertEquals<span class="params">(<span class="string">"hello"</span>, result3)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>自定义函数</p>
<p>目前只支持类静态方法注册为自定义函数；SpEL使用StandardEvaluationContext的registerFunction方法进行注册自定义函数，其实完全可以使用setVariable代替，两者其实本质是一样的。<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Test</span></span><br><span class="line">publicvoid testFunctionExpression<span class="literal">()</span>throws <span class="type">SecurityException</span>, <span class="type">NoSuchMethodException</span> &#123;</span><br><span class="line">    <span class="type">ExpressionParser</span> <span class="keyword">parser</span> = <span class="keyword">new</span> <span class="type">SpelExpressionParser</span><span class="literal">()</span>;</span><br><span class="line">    <span class="type">StandardEvaluationContext</span> context = <span class="keyword">new</span> <span class="type">StandardEvaluationContext</span><span class="literal">()</span>;</span><br><span class="line">    <span class="type">Method</span> parseInt = <span class="type">Integer</span>.<span class="keyword">class</span>.getDeclaredMethod(<span class="string">"parseInt"</span>, <span class="type">String</span>.<span class="keyword">class</span>);</span><br><span class="line">    context.registerFunction(<span class="string">"parseInt"</span>, parseInt);</span><br><span class="line">    context.setVariable(<span class="string">"parseInt2"</span>, parseInt);</span><br><span class="line">    <span class="type">String</span> expression1 = <span class="string">"#parseInt('3') == #parseInt2('3')"</span>;</span><br><span class="line">    boolean result1 = <span class="keyword">parser</span>.parseExpression(expression1).getValue(context,boolean.<span class="keyword">class</span>);</span><br><span class="line">    <span class="type">Assert</span>.assertEquals(<span class="literal">true</span>, result1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>赋值表达式</p>
<p>SpEL即允许给自定义变量赋值，也允许给跟对象赋值，直接使用“#variableName=value”即可赋值：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">@Test</span><br><span class="line">publicvoid testAssignExpression<span class="params">()</span> &#123;</span><br><span class="line">    ExpressionParser parser = new SpelExpressionParser<span class="params">()</span>;</span><br><span class="line">    <span class="comment">// 1.给root对象赋值</span></span><br><span class="line">    EvaluationContext context = new StandardEvaluationContext<span class="params">(<span class="string">"aaaa"</span>)</span>;</span><br><span class="line">    String result1 = parser.parseExpression<span class="params">(<span class="string">"#root='aaaaa'"</span>)</span>.getValue<span class="params">(context, String.class)</span>;</span><br><span class="line">    Assert.assertEquals<span class="params">(<span class="string">"aaaaa"</span>, result1)</span>;</span><br><span class="line">    String result2 = parser.parseExpression<span class="params">(<span class="string">"#this='aaaa'"</span>)</span>.getValue<span class="params">(context, String.class)</span>;</span><br><span class="line">    Assert.assertEquals<span class="params">(<span class="string">"aaaa"</span>, result2)</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.给自定义变量赋值</span></span><br><span class="line">    context.setVariable<span class="params">(<span class="string">"#variable"</span>,<span class="string">"variable"</span>)</span>;</span><br><span class="line">    String result3 = parser.parseExpression<span class="params">(<span class="string">"#variable=#root"</span>)</span>.getValue<span class="params">(context, String.class)</span>;</span><br><span class="line">    Assert.assertEquals<span class="params">(<span class="string">"aaaa"</span>, result3)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>对象属性存取及安全导航表达式</p>
<p>对象属性获取非常简单，即使用如“a.property.property”这种点缀式获取，SpEL对于属性名首字母是不区分大小写的。</p>
<p>给对象属性赋值可以采用赋值表达式或Expression接口的setValue方法赋值，而且也可以采用点缀方式赋值。</p>
<p>SpEL还引入了Groovy语言中的安全导航运算符“(对象|属性)?.属性”，用来避免当“?.”前边的表达式为null时抛出空指针异常，而是返回null。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser =new SpelExpressionParser<span class="params">()</span>;</span><br><span class="line"><span class="comment">// ===============访问root对象属性 ===============</span></span><br><span class="line">Date date =new Date<span class="params">()</span>;</span><br><span class="line">StandardEvaluationContext context =new StandardEvaluationContext<span class="params">(date)</span>;</span><br><span class="line">int result1 = parser.parseExpression<span class="params">(<span class="string">"Year"</span>)</span>.getValue<span class="params">(context,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(date.getYear<span class="params">()</span>, result1)</span>;</span><br><span class="line">int result2 = parser.parseExpression<span class="params">(<span class="string">"year"</span>)</span>.getValue<span class="params">(context,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(date.getYear<span class="params">()</span>, result2)</span>;</span><br><span class="line"><span class="comment">// ===============安全访问 ===============</span></span><br><span class="line">context.setRootObject<span class="params">(null)</span>;</span><br><span class="line">Object result3 = parser.parseExpression<span class="params">(<span class="string">"#root?.year"</span>)</span>.getValue<span class="params">(context, Object.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(null, result3)</span>;</span><br><span class="line"><span class="comment">// ===============给root对象属性赋值 ===============</span></span><br><span class="line">context.setRootObject<span class="params">(date)</span>;</span><br><span class="line">int result4 = parser.parseExpression<span class="params">(<span class="string">"Year = 4"</span>)</span>.getValue<span class="params">(context,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">4</span>, result4)</span>;</span><br><span class="line">parser.parseExpression<span class="params">(<span class="string">"Year"</span>)</span>.setValue<span class="params">(context, <span class="number">5</span>)</span>;</span><br><span class="line">int result5 = parser.parseExpression<span class="params">(<span class="string">"Year"</span>)</span>.getValue<span class="params">(context,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">5</span>, result5)</span>;</span><br></pre></td></tr></table></figure></p>
<p>对象方法调用</p>
<p>对象方法调用更简单，跟Java语法一样；如“’helo’.substring(2,4)”将返回“lo”。对于根对象可以直接调用方法。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExpressionParser parser <span class="subst">=</span><span class="literal">new</span> SpelExpressionParser();</span><br><span class="line"><span class="comment">// ===============直接调用对象方法 ===============</span></span><br><span class="line"><span class="built_in">String</span> result1 <span class="subst">=</span> parser<span class="built_in">.</span>parseExpression(<span class="string">"'hello'.substring(3)"</span>)<span class="built_in">.</span>getValue(<span class="built_in">String</span><span class="built_in">.</span>class);</span><br><span class="line">Assert<span class="built_in">.</span>assertEquals(<span class="string">"lo"</span>, result1);</span><br><span class="line"><span class="comment">// ===============调用上下文root对象方法 ===============</span></span><br><span class="line"><span class="built_in">Date</span> <span class="built_in">date</span> <span class="subst">=</span><span class="literal">new</span> <span class="built_in">Date</span>();</span><br><span class="line">StandardEvaluationContext context <span class="subst">=</span><span class="literal">new</span> StandardEvaluationContext(<span class="built_in">date</span>);</span><br><span class="line">int result2 <span class="subst">=</span> parser<span class="built_in">.</span>parseExpression(<span class="string">"getYear()"</span>)<span class="built_in">.</span>getValue(context,int<span class="built_in">.</span>class);</span><br><span class="line">Assert<span class="built_in">.</span>assertEquals(<span class="built_in">date</span><span class="built_in">.</span>getYear(), result2);</span><br></pre></td></tr></table></figure>
<p>Bean引用</p>
<p>SpEL支持使用“@”符号来引用Bean，在引用Bean时需要使用BeanResolver接口实现来查找Bean，Spring提供BeanFactoryResolver实现。</p>
<p>在示例中首先初始化了一个IoC容器，ClassPathXmlApplicationContext 实现默认会把“System.getProperties()”注册为“systemProperties”Bean，因此使用 “@systemProperties”来引用该Bean。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@<span class="type">Test</span></span><br><span class="line">publicvoid testBeanExpression<span class="literal">()</span> &#123;</span><br><span class="line">   <span class="type">ClassPathXmlApplicationContext</span> ctx =<span class="keyword">new</span> <span class="type">ClassPathXmlApplicationContext</span><span class="literal">()</span>;</span><br><span class="line">    ctx.refresh<span class="literal">()</span>;</span><br><span class="line">   <span class="type">ExpressionParser</span> <span class="keyword">parser</span> =<span class="keyword">new</span> <span class="type">SpelExpressionParser</span><span class="literal">()</span>;</span><br><span class="line">   <span class="type">StandardEvaluationContext</span> context =<span class="keyword">new</span> <span class="type">StandardEvaluationContext</span><span class="literal">()</span>;</span><br><span class="line">   context.setBeanResolver(<span class="keyword">new</span> <span class="type">BeanFactoryResolver</span>(ctx));</span><br><span class="line">   <span class="type">Properties</span> result1 = <span class="keyword">parser</span>.parseExpression(<span class="string">"@systemProperties"</span>).getValue(context, <span class="type">Properties</span>.<span class="keyword">class</span>);</span><br><span class="line">    <span class="type">Assert</span>.assertEquals(<span class="type">System</span>.getProperties<span class="literal">()</span>, result1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="集合相关表达式">集合相关表达式</h4><ul>
<li>内联List</li>
<li>内联Array</li>
<li>Collection，Map元素访问</li>
<li>Collection、Map、Array元素修改</li>
<li>集合投影</li>
<li>集合选择</li>
</ul>
<p>内联List</p>
<p>从Spring3.0.4开始支持内联List，使用{表达式，……}定义内联List。如“{1,2,3}”将返回一个整型的ArrayList，而“{}”将返回空的List，对于字面量表达式列表，SpEL会使用java.util.Collections.unmodifiableList方法将列表设置为不可修改。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将返回不可修改的空List</span></span><br><span class="line"><span class="built_in">List</span>&lt;Integer&gt; result2 = parser.parseExpression(<span class="string">"&#123;&#125;"</span>).getValue(<span class="built_in">List</span>.<span class="keyword">class</span>);</span><br><span class="line"><span class="comment">//对于列表中只要有一个不是字面量表达式，将只返回原始List，不会进行不可修改处理</span></span><br><span class="line"><span class="built_in">String</span> expression3 = <span class="string">"&#123; &#123;1 + 2,2 + 4&#125;, &#123;3, 4 + 4&#125; &#125;"</span>;</span><br><span class="line"><span class="built_in">List</span>&lt;<span class="built_in">List</span>&lt;Integer&gt;&gt; result3 = parser.parseExpression(expression3).getValue(<span class="built_in">List</span>.<span class="keyword">class</span>);</span><br><span class="line">result3.<span class="literal">get</span>(<span class="number">0</span>).<span class="literal">set</span>(<span class="number">0</span>, <span class="number">1</span>);</span><br><span class="line">Assert.assertEquals(<span class="number">2</span>, result3.size());</span><br></pre></td></tr></table></figure>
<p>内联Array</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//声明一维数组并初始化值</span><br><span class="line">int[] result2 = parser.parseExpression("new int[]&#123;1,2&#125;").getValue(int[].class);</span><br><span class="line">Assert.assertEquals(result2[0], 1);</span><br><span class="line">//定义多维数组但不初始化（定义多维数组不能初始化）</span><br><span class="line">int[<span class="link_label"></span>][<span class="link_reference"></span>][<span class="link_label"></span>] result3 = parser.parseExpression("new int[<span class="link_label">2</span>][<span class="link_reference">2</span>][<span class="link_label">2</span>]").getValue(int[<span class="link_label"></span>][<span class="link_reference"></span>][<span class="link_label"></span>].class);</span><br></pre></td></tr></table></figure>
<p>集合，字典元素访问</p>
<p>SpEL目前支持所有集合类型和字典类型的元素访问，使用“集合[索引]”访问集合元素，使用“map[key]”访问字典元素。<br>集合元素访问是通过Iterator遍历来定位元素位置的。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SpEL内联List访问</span></span><br><span class="line">int result1 = parser.parseExpression<span class="params">(<span class="string">"&#123;1,2,3&#125;[0]"</span>)</span>.getValue<span class="params">(int.class)</span>;</span><br><span class="line"><span class="comment">//即list.get(0)</span></span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">1</span>, result1)</span>;</span><br><span class="line"><span class="comment">// SpEL目前支持所有集合类型的访问</span></span><br><span class="line">Collection&lt;Integer&gt; collection =new HashSet&lt;Integer&gt;<span class="params">()</span>;</span><br><span class="line">collection.add<span class="params">(<span class="number">1</span>)</span>;</span><br><span class="line">collection.add<span class="params">(<span class="number">2</span>)</span>;</span><br><span class="line">EvaluationContext context2 =new StandardEvaluationContext<span class="params">()</span>;</span><br><span class="line">context2.setVariable<span class="params">(<span class="string">"collection"</span>, collection)</span>;</span><br><span class="line">int result2 = parser.parseExpression<span class="params">(<span class="string">"#collection[1]"</span>)</span>.getValue<span class="params">(context2,int.class)</span>;</span><br><span class="line"><span class="comment">//对于任何集合类型通过Iterator来定位元素</span></span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">2</span>, result2)</span>;</span><br><span class="line"><span class="comment">// SpEL对Map字典元素访问的支持</span></span><br><span class="line">Map&lt;String, Integer&gt; map =new HashMap&lt;String, Integer&gt;<span class="params">()</span>;</span><br><span class="line">map.put<span class="params">(<span class="string">"a"</span>, <span class="number">1</span>)</span>;</span><br><span class="line">EvaluationContext context3 =new StandardEvaluationContext<span class="params">()</span>;</span><br><span class="line">context3.setVariable<span class="params">(<span class="string">"map"</span>, map)</span>;</span><br><span class="line">int result3 = parser.parseExpression<span class="params">(<span class="string">"#map['a']"</span>)</span>.getValue<span class="params">(context3,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">1</span>, result3)</span>;</span><br></pre></td></tr></table></figure></p>
<p>列表，字典，数组元素修改</p>
<p>可以使用赋值表达式或Expression接口的setValue方法修改。对数组修改直接对“#array[index]”赋值即可修改元素值，同理适用于集合和字典类型。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ===============修改数组元素值 ===============</span></span><br><span class="line">int[] array =newint[] &#123; <span class="number">1</span>, <span class="number">2</span> &#125;;</span><br><span class="line">EvaluationContext context1 =new StandardEvaluationContext<span class="params">()</span>;</span><br><span class="line">context1.setVariable<span class="params">(<span class="string">"array"</span>, array)</span>;</span><br><span class="line">int result1 = parser.parseExpression<span class="params">(<span class="string">"#array[1] = 3"</span>)</span>.getValue<span class="params">(context1,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">3</span>, result1)</span>;</span><br><span class="line"><span class="comment">// ===============修改集合值 ===============</span></span><br><span class="line">Collection&lt;Integer&gt; collection =new ArrayList&lt;Integer&gt;<span class="params">()</span>;</span><br><span class="line">collection.add<span class="params">(<span class="number">1</span>)</span>;</span><br><span class="line">collection.add<span class="params">(<span class="number">2</span>)</span>;</span><br><span class="line">EvaluationContext context2 =new StandardEvaluationContext<span class="params">()</span>;</span><br><span class="line">context2.setVariable<span class="params">(<span class="string">"collection"</span>, collection)</span>;</span><br><span class="line">int result2 = parser.parseExpression<span class="params">(<span class="string">"#collection[1] = 3"</span>)</span>.getValue<span class="params">(context2,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">3</span>, result2)</span>;</span><br><span class="line">parser.parseExpression<span class="params">(<span class="string">"#collection[1]"</span>)</span>.setValue<span class="params">(context2, <span class="number">4</span>)</span>;</span><br><span class="line">result2 = parser.parseExpression<span class="params">(<span class="string">"#collection[1]"</span>)</span>.getValue<span class="params">(context2,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">4</span>, result2)</span>;</span><br><span class="line"><span class="comment">// ===============修改map元素值 ===============</span></span><br><span class="line">Map&lt;String, Integer&gt; map =new HashMap&lt;String, Integer&gt;<span class="params">()</span>;</span><br><span class="line">map.put<span class="params">(<span class="string">"a"</span>, <span class="number">1</span>)</span>;</span><br><span class="line">EvaluationContext context3 =new StandardEvaluationContext<span class="params">()</span>;</span><br><span class="line">context3.setVariable<span class="params">(<span class="string">"map"</span>, map)</span>;</span><br><span class="line">int result3 = parser.parseExpression<span class="params">(<span class="string">"#map['a'] = 2"</span>)</span>.getValue<span class="params">(context3,int.class)</span>;</span><br><span class="line">Assert.assertEquals<span class="params">(<span class="number">2</span>, result3)</span>;</span><br></pre></td></tr></table></figure></p>
<p>集合投影</p>
<p>在SQL中投影指从表中选择出列，而在SpEL指根据集合中的元素中通过选择来构造另一个集合，该集合和原集合具有相同数量的元素；SpEL使用“（list|map）.![投影表达式]”来进行投影运算：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">Collection<span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;</span> collection <span class="subst">=</span><span class="literal">new</span> ArrayList<span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;</span>();</span><br><span class="line">collection<span class="built_in">.</span>add(<span class="number">4</span>);</span><br><span class="line">collection<span class="built_in">.</span>add(<span class="number">5</span>);</span><br><span class="line"><span class="comment">// =============== 测试集合或数组 ===============</span></span><br><span class="line">EvaluationContext context1 <span class="subst">=</span><span class="literal">new</span> StandardEvaluationContext();</span><br><span class="line">context1<span class="built_in">.</span>setVariable(<span class="string">"collection"</span>, collection);</span><br><span class="line">Collection<span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;</span> result1 <span class="subst">=</span> parser<span class="built_in">.</span>parseExpression(<span class="string">"#collection.![#this+1]"</span>)<span class="built_in">.</span>getValue(context1, Collection<span class="built_in">.</span>class);</span><br><span class="line">Assert<span class="built_in">.</span>assertEquals(<span class="number">2</span>, result1<span class="built_in">.</span>size());</span><br><span class="line">Assert<span class="built_in">.</span>assertEquals(<span class="literal">new</span> <span class="built_in">Integer</span>(<span class="number">5</span>), result1<span class="built_in">.</span>iterator()<span class="built_in">.</span>next());</span><br><span class="line">对于集合或数组使用如上表达式进行投影运算，其中投影表达式中“<span class="variable">#this</span>”代表每个集合或数组元素，可以使用比如“<span class="variable">#this.property</span>”来获取集合元素的属性，其中“<span class="variable">#this</span>”可以省略。</span><br><span class="line"><span class="built_in">Map</span><span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span> <span class="built_in">map</span> <span class="subst">=</span><span class="literal">new</span> HashMap<span class="subst">&lt;</span><span class="built_in">String</span>, <span class="built_in">Integer</span><span class="subst">&gt;</span>();</span><br><span class="line"><span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="built_in">map</span><span class="built_in">.</span>put(<span class="string">"b"</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// ===============测试Map ===============</span></span><br><span class="line">EvaluationContext context2 <span class="subst">=</span><span class="literal">new</span> StandardEvaluationContext();</span><br><span class="line">context2<span class="built_in">.</span>setVariable(<span class="string">"map"</span>, <span class="built_in">map</span>);</span><br><span class="line"><span class="built_in">List</span><span class="subst">&lt;</span><span class="built_in">Integer</span><span class="subst">&gt;</span> result2 <span class="subst">=</span></span><br><span class="line">parser<span class="built_in">.</span>parseExpression(<span class="string">"#map.![value+1]"</span>)<span class="built_in">.</span>getValue(context2, <span class="built_in">List</span><span class="built_in">.</span>class);</span><br><span class="line">Assert<span class="built_in">.</span>assertEquals(<span class="number">2</span>, result2<span class="built_in">.</span>size());</span><br></pre></td></tr></table></figure></p>
<p>SpEL投影运算还支持Map投影，但Map投影最终只能得到List结果，如上所示，对于投影表达式中的“#this”将是Map.Entry，所以可以使用“value”来获取值，使用“key”来获取键。</p>
<p>集合选择</p>
<p>在SQL中指使用select进行选择行数据，而在SpEL指根据原集合通过条件表达式选择出满足条件的元素并构造为新的集合，SpEL使用“(list|map).?[选择表达式]”，其中选择表达式结果必须是boolean类型，如果true则选择的元素将添加到新集合中，false将不添加到新集合中。<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Collection&lt;<span class="typename">Integer</span>&gt; collection =<span class="keyword">new</span> ArrayList&lt;<span class="typename">Integer</span>&gt;();</span><br><span class="line">collection.add(<span class="number">4</span>);</span><br><span class="line">collection.add(<span class="number">5</span>);</span><br><span class="line">// ===============集合或数组测试 ==============</span><br><span class="line">EvaluationContext context1 =<span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">context1.setVariable(<span class="string">"collection"</span>, collection);</span><br><span class="line">Collection&lt;<span class="typename">Integer</span>&gt; result1 = parser.parseExpression(<span class="string">"#collection.?[#this&gt;4]"</span>).getValue(context1, Collection.class);</span><br><span class="line"><span class="keyword">Assert</span>.assertEquals(<span class="number">1</span>, result1.size());</span><br><span class="line"><span class="keyword">Assert</span>.assertEquals(<span class="keyword">new</span> <span class="typename">Integer</span>(<span class="number">5</span>), result1.iterator().<span class="keyword">next</span>());</span><br><span class="line"><span class="keyword">Map</span>&lt;<span class="typename">String</span>, <span class="typename">Integer</span>&gt; <span class="keyword">map</span> =<span class="keyword">new</span> HashMap&lt;<span class="typename">String</span>, <span class="typename">Integer</span>&gt;();</span><br><span class="line"><span class="keyword">map</span>.put(<span class="string">"a"</span>, <span class="number">1</span>);</span><br><span class="line"><span class="keyword">map</span>.put(<span class="string">"b"</span>, <span class="number">2</span>);</span><br><span class="line">// =============== <span class="keyword">Map</span>测试 ==============</span><br><span class="line">EvaluationContext context2 =<span class="keyword">new</span> StandardEvaluationContext();</span><br><span class="line">context2.setVariable(<span class="string">"map"</span>, <span class="keyword">map</span>);</span><br><span class="line"><span class="keyword">Map</span>&lt;<span class="typename">String</span>, <span class="typename">Integer</span>&gt; result2 = parser.parseExpression(<span class="string">"#map.?[#this.key != 'a']"</span>).getValue(context2, <span class="keyword">Map</span>.class);</span><br><span class="line"><span class="keyword">Assert</span>.assertEquals(<span class="number">1</span>, result2.size());</span><br><span class="line"></span><br><span class="line">List&lt;<span class="typename">Integer</span>&gt; result3 = parser.parseExpression(<span class="string">"#map.?[key != 'a'].![value+1]"</span>).getValue(context2, List.class);</span><br><span class="line"><span class="keyword">Assert</span>.assertEquals(<span class="keyword">new</span> <span class="typename">Integer</span>(<span class="number">3</span>), result3.iterator().<span class="keyword">next</span>());</span><br></pre></td></tr></table></figure></p>
<p>对于Map选择，如“#map.?[#this.key != ‘a’]”将选择键值不等于”a”的，其中选择表达式中“#this”是Map.Entry类型，而最终结果还是Map，这点和投影不同；集合选择和投影可以一起使用，如“#map.?[key != ‘a’].![value+1]”将首先选择键值不等于”a”的，然后在选出的Map中再进行“value+1”的投影。</p>
<h4 id="表达式模板">表达式模板</h4><p>模板表达式就是由字面量与一个或多个表达式块组成。每个表达式块由“前缀+表达式+后缀”形式组成，如“${1+2}”即表达式块。在前边我们已经介绍了使用ParserContext接口实现来定义表达式是否是模板及前缀和后缀定义。在此就不多介绍了，如“Error ${井v0} ${井v1}”(把<code>井</code>换位<code>#</code>)表达式表示由字面量“Error ”、模板表达式“#v0”、模板表达式“#v1”组成，其中v0和v1表示自定义变量，需要在上下文定义。</p>
]]></content>
    <summary type="html">
    <![CDATA[Spring]]>
    
    </summary>
    
      <category term="Spring" scheme="http://howiefh.github.io/tags/Spring/"/>
    
      <category term="JavaEE" scheme="http://howiefh.github.io/categories/JavaEE/"/>
    
      <category term="Spring" scheme="http://howiefh.github.io/categories/JavaEE/Spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Spring笔记二]]></title>
    <link href="http://howiefh.github.io/2015/03/06/spring-note-2/"/>
    <id>http://howiefh.github.io/2015/03/06/spring-note-2/</id>
    <published>2015-03-06T08:09:20.000Z</published>
    <updated>2015-07-19T03:24:34.000Z</updated>
    <content type="html"><![CDATA[<h2 id="两种后处理器">两种后处理器</h2><p>Spring框架提供了很好的扩展性，除了可以与各种第三方框架良好整合外，其IoC容器也允许开发者进行扩展，这种扩展甚至无须实现BeanFactory或ApplicationContext接口，而是允许通过两个后处理器对IOC容器进行扩展。Spring提供了两种常用的后处理器：</p>
<ol>
<li>Bean后处理器：这种后处理器会对容器中的Bean进行后处理，对Bean功能进行额外加强。</li>
<li>容器后处理器：这种后处理器对IoC容器进行后处理，用于增强容器功能。</li>
</ol>
<a id="more"></a>
<h3 id="Bean后处理器">Bean后处理器</h3><p>Bean后处理器是一种特殊的Bean，这种特殊Bean并不对外提供服务，它甚至可以无须id属性，它主要负责对容器中的其他Bean执行后处理，例如为容器中的目标Bean生成代理等。</p>
<p>Bean后处理器会在Bean实例创建成功之后，对Bean实例进行进一步的增强处理。</p>
<p>Bean后处理器必须实现 BeanPostProcessor 接口，它包含两个方法：</p>
<ol>
<li>Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException：第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean实例的名字。</li>
<li>Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException：第一个参数是系统即将进行后处理的Bean实例，第二个参数是该Bean实例的名字。</li>
</ol>
<p>实现该接口的Bean后处理器必须实现这两个方法，这两个方法会对容器中的Bean进行后处理，会在目标Bean初始化之前、初始化之后分别被回调，这两个方法用于对容器中的Bean实例进行增强处理。</p>
<p>Axe.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">Axe</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span>(<span class="params"></span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SteelAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring实例化依赖Bean:SteelAxe实例..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Person.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;</span><br><span class="line">    public void useAxe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span>,<span class="title">InitializingBean</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring执行依赖关系注入,setAxe..."</span>);</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring执行依赖关系注入,setName..."</span>);</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Chinese</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Spring实例化主调Bean:Chinese实例..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(name+axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterPropertiesSet</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行初始化方法afterPropertiesSet..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行初始化方法init..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FirstBeanPostProcessor.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstBeanPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span></span><br><span class="line">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean后处理器在初始化之前对"</span>+beanName+<span class="string">"进行增强处理..."</span>);</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span></span><br><span class="line">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Bean后处理器在初始化之后对"</span>+beanName+<span class="string">"进行增强处理..."</span>);</span><br><span class="line">        <span class="keyword">if</span>(bean <span class="keyword">instanceof</span> Chinese)&#123;</span><br><span class="line">            Chinese c=(Chinese)bean;</span><br><span class="line">            c.setName(<span class="string">"中国人"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span> init-<span class="keyword">method</span>=<span class="string">"init"</span>&gt;</span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;</span><br><span class="line">   &lt;property name=<span class="string">"name"</span> value=<span class="string">"依赖注入的值"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"beanPostProcessor"</span> class=<span class="string">"com.bean.FirstBeanPostProcessor"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        p.useAxe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>容器中一旦注册了Bean后处理器，Bean后处理器就会自动启动，在容器中每个Bean创建时自动工作。从上面程序的运行结果可以看出，Bean后处理器两个方法的回调时机如下所示：</p>
<p><img src="http://fh-1.qiniudn.com/Bean后处理器两个方法的毁掉时机.png" alt="Bean后处理器两个方法的毁掉时机"></p>
<p>采用ApplicationContext作为Spring容器时，无须手动注册BeanPostProcessor。但是如果采用BeanFactory作为Spring容器时，就必须手动注册BeanPostProcess，如下：<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ClassPathResource resource=new ClassPathResource(<span class="string">"bean.xml"</span>);</span><br><span class="line">        XmlBeanFactory factory=new XmlBeanFactory(resource);</span><br><span class="line">        BeanPostProcessor bpp=(FirstBeanPostProcessor) factory.getBean(<span class="string">"beanPostProcessor"</span>);</span><br><span class="line">        factory.addBeanPostProcessor(bpp);  //注册BeanPostProcessor实例</span><br><span class="line">        System.out.println(<span class="string">"程序已经实例化BeanFactory..."</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) factory.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        System.out.println(<span class="string">"程序中已经完成了chinese bean的实例化..."</span>);</span><br><span class="line">        p.useAxe();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是Spring提供的两个常用的后处理器：</p>
<ol>
<li>BeanNameAutoProxyCreator：根据Bean实例的name属性，创建Bean实例的代理。</li>
<li>DefaultAdvisorAutoProxyCreator：根据提供的advisor，对容器中所有的Bean实例创建代理。<br>上面提供的两个Bean后处理器，都用于根据容器中配置的拦截器，创建代理Bean，代理Bean就是对目标Bean进行增强、在目标Bean的基础上进行修改得到新的Bean。</li>
</ol>
<h3 id="容器后处理器">容器后处理器</h3><p>Spring还提供了一种容器后处理器。Bean后处理器负责处理容器中的所有Bean实例，而容器后处理器则负责处理容器本身。</p>
<p>容器后处理器必须实现 BeanFactoryPostProcessor 接口，该接口中有一个方法：</p>
<p>void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException</p>
<p>实现该方法的方法体就是对Spring容器进行的处理，这种处理可以对Spring容器进行自定义扩展，当然也可以对Spring容器不进行任何处理。</p>
<p>FirstBeanFactoryPostProcessor.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstBeanFactoryPostProcessor</span> <span class="keyword">implements</span> <span class="title">BeanFactoryPostProcessor</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span></span><br><span class="line">            <span class="keyword">throws</span> BeansException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"程序对Spring所做的BeanFactory的初始化没有改变..."</span>);</span><br><span class="line">        System.out.println(<span class="string">"Spring容器是:"</span>+beanFactory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml核心配置：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"chinese"</span> class=<span class="string">"com.bean.Chinese"</span>&gt;</span><br><span class="line">   &lt;property name=<span class="string">"axe"</span> <span class="keyword">ref</span>=<span class="string">"steelAxe"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br><span class="line"></span><br><span class="line">&lt;bean id=<span class="string">"steelAxe"</span> class=<span class="string">"com.bean.SteelAxe"</span>/&gt;</span><br><span class="line">&lt;bean id=<span class="string">"beanFactoryPostProcessor"</span> class=<span class="string">"com.bean.FirstBeanFactoryPostProcessor"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        p.useAxe();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>程序会自动搜索容器中实现了BeanFactoryPostProcessor接口的类，并将它注册成容器后处理器。</p>
<p>Spring已经提供了如下几个常用的容器后处理器：</p>
<ol>
<li>PropertyPlaceholderConfigurer：属性占位符配置器。</li>
<li>PropertyOverrideConfigurer：重写占位符配置器。</li>
<li>CustomAutowireConfigurer：自定义自动装配的配置器。</li>
<li>CustomScopeConfigurer：自定义作用域的配置器。</li>
</ol>
<p>从上面的介绍可以看出，容器后处理器通常用于对Spring容器进行处理，并且总是在容器实例化任何其他的Bean之前，读取配置文件的元数据，并有可能修改这些元数据。</p>
<p>如果有需要，程序可以配置多个容器后处理器，多个容器后处理器可设置order属性来控制容器后处理器的执行次序。</p>
<h3 id="属性占位符配置器">属性占位符配置器</h3><p>Spring提供了PropertyPlaceholderConfigurer，它是一个容器后处理器，负责读取Properties属性文件里的属性值，并将这些属性值设置成Spring配置文件的元数据。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果采用基于XML Schema的配置文件则可以简化下面配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.springframework.beans.factory.config.PropertyPlaceholderConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"locations"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">value</span>&gt;</span>dbconn.properties<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 如果有多个属性文件，依次在下面列出来 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attribute">destroy-method</span>=<span class="value">"close"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClass"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.driverClassName&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jdbcUrl"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>dbconn.properties:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClassName=com<span class="class">.mysql</span><span class="class">.jdbc</span><span class="class">.Driver</span></span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/javaee</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure></p>
<p>通过这种方法，可从主XML配置文件中分离出部分配置信息。如果仅需要修改数据库连接属性，则无须修改主XML配置文件。</p>
<p>简化的配置属性占位符<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">context</span>:<span class="keyword">property</span>-placeholder location=<span class="string">"classpath:dbconn.properties"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="重写占位符配置器">重写占位符配置器</h3><p>Spring提供了PropertyOverrideConfigurer，负责读取Properties属性文件里的属性值，并将这些属性值直接覆盖Spring配置文件的元数据。即允许XML配置文件中有默认的配置信息。可以认为Spring配置文件是XML配置文件和属性文件的总和。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line"><span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line"><span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">http://www.springframework.org/schema/beans/spring-beans-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--如果采用基于XML Schema的配置文件则可以简化下面配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">class</span>=<span class="value">"com.springframework.beans.factory.config.PropertyOverrideConfigurer"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"locations"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">value</span>&gt;</span>dbconn.properties<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 如果有多个属性文件，依次在下面列出来 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span> <span class="attribute">destroy-method</span>=<span class="value">"close"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>dbconn.properties:<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClassName=com<span class="class">.mysql</span><span class="class">.jdbc</span><span class="class">.Driver</span></span><br><span class="line">jdbc.url=jdbc:mysql:<span class="comment">//localhost:3306/javaee</span></span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=<span class="number">123456</span></span><br></pre></td></tr></table></figure></p>
<p>通过这种方法，可从主XML配置文件中分离出部分配置信息。如果仅需要修改数据库连接属性，则无须修改主XML配置文件。</p>
<p>简化的配置属性占位符<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">context</span>:<span class="keyword">property</span>-override location=<span class="string">"classpath:dbconn.properties"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Spring的“零配置”支持">Spring的“零配置”支持</h2><p>Spring提供了如下几个Annotation来标注Spring Bean。</p>
<table>
<thead>
<tr>
<th>Annotation名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Component</td>
<td>标注一个普通的Spring Bean类。</td>
</tr>
<tr>
<td>@Controller</td>
<td>标注一个控制器组件类。</td>
</tr>
<tr>
<td>@Service</td>
<td>标注一个业务逻辑组件类。</td>
</tr>
<tr>
<td>@Repository</td>
<td>标注一个DAO组件类。</td>
</tr>
</tbody>
</table>
<p>如果我们需要定义一个普通的Spring Bean，则直接使用@Component标注即可。但如果用@Repository、@Service或@Controller来标注这些Bean类，这些Bean类将被作为特殊的JavaEE组件对待，也许能更好地被工具处理，或与切面进行关联。</p>
<p>在Spring的未来版本中，@Controller、@Service和@Repository也许还能携带更多语义，因此如果需要在JavaEE应用中使用这些标注时，尽量考虑使用@Controller、@Service和@Repository来代替通用的@Component标注。</p>
<p>指定了某些类可作为Spring Bean类使用后，最后还需要让Spring搜索指定路径，此时需要在Spring配置文件中导入context Scheme，并指定一个简单的搜索路径。</p>
<p>SteelAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"钢斧砍柴真快"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>StoneAxe.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StoneAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">chop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"石斧砍柴真慢"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">        <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">        <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span></span><br><span class="line">        <span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">        <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">                http://www.springframework.org/schema/context</span><br><span class="line">                http://www.springframework.org/schema/context/spring-context-2.5.xsd</span><br><span class="line">                http://www.springframework.org/schema/tx</span><br><span class="line">                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"com.bean"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        ApplicationContext ctx=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        System.<span class="keyword">out</span>.println(Arrays.toString(ctx.getBeanDefinitionNames()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行Test.java，控制台输出：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[ steelAxe, stoneAxe, chinese,</span><br><span class="line">org<span class="class">.springframework</span><span class="class">.context</span><span class="class">.annotation</span><span class="class">.internalCommonAnnotationProcessor</span>,</span><br><span class="line">org<span class="class">.springframework</span><span class="class">.context</span><span class="class">.annotation</span><span class="class">.internalAutowiredAnnotationProcessor</span>,</span><br><span class="line">org<span class="class">.springframework</span><span class="class">.context</span><span class="class">.annotation</span><span class="class">.internalRequiredAnnotationProcessor</span> ]</span><br></pre></td></tr></table></figure></p>
<p>从上面程序的运行结果来看，Spring容器中三个Bean实例的名称分别为chinese、steelAxe和stoneAxe，之所以叫这些名称，是因为在这种基于Annotation的方式下，Spring采用约定的方式来为这些Bean实例指定名称，这些Bean实例的名称默认是Bean类的首字母小写，其他部分不变。</p>
<p>当然，Spring也允许在使用@Component标注时指定Bean实例的名称：<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span>(<span class="string">"axe"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SteelAxe</span> <span class="keyword">implements</span> <span class="title">Axe</span>&#123;</span></span><br><span class="line">   <span class="comment">//codes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在默认情况下，Spring会自动搜索所有以@Component、@Controller、@Service和@Repository标注的Java类，并将它们当成Spring Bean来处理。</p>
<p>除此之外，我们还可通过为<code>&lt;component-scan.../&gt;</code>元素添加<code>&lt;include-filter.../&gt;</code>或<code>&lt;exclude-filter.../&gt;</code>子元素来指定Spring Bean类，只要位于指定路径下的Java类满足这种规则，即使这些java类没有使用任何Annotation标注，Spring一样会将它们当成Bean类来处理。</p>
<p><code>&lt;include-filter.../&gt;</code>元素用于指定满足该规则的Java类会被当成Bean类处理。<code>&lt;exclude-filter.../&gt;</code>元素用于指定满足该规则的Java类不会被当成Bean类处理。使用这两个元素时都要求指定如下两个属性：</p>
<ol>
<li>type：指定过滤器类型。</li>
<li>expression：指定过滤器所需要的表达式。</li>
</ol>
<p>Spring内建支持如下4种过滤器：</p>
<ol>
<li>annotation：Annotation过滤器，该过滤器需要指定一个Annotation名，如lee.AnnotationTest</li>
<li>assignable：类名过滤器，该过滤器直接指定一个Java类。</li>
<li>regex：正则表达式过滤器，该过滤器指定一个正则表达式，匹配该正则表达式的Java类将满足该过滤规则，如<code>org\.example\.Default.*</code>。</li>
<li>aspectj：AspectJ过滤器，如<code>org.example..*Service+</code>。</li>
</ol>
<p>例如下面的配置文件指定所有以Chinese结尾的类，以Axe结尾的类都将被当成Spring Bean处理。<br><figure class="highlight puppet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="literal">context</span>:component-scan base-<span class="keyword">package</span>=<span class="string">"org.crazyit.app.service"</span>&gt;</span><br><span class="line">  &lt;<span class="literal">context</span>:<span class="literal">include</span>-filter <span class="built_in">type</span>=<span class="string">"regex"</span> expression=<span class="string">".*Chinese"</span>/&gt;</span><br><span class="line">  &lt;<span class="literal">context</span>:<span class="literal">include</span>-filter <span class="built_in">type</span>=<span class="string">"regex"</span> expression=<span class="string">".*Axe"</span>/&gt;</span><br><span class="line">&lt;/<span class="literal">context</span>:component-scan&gt;</span><br></pre></td></tr></table></figure></p>
<h3 id="指定Bean的作用域">指定Bean的作用域</h3><p>当使用XML配置方式来配置Bean实例时，可以通过scope来指定Bean实例的作用域，没有指定scope属性的Bean实例的作用域默认是singleton。</p>
<p>当我们采用零配置方式来管理Bean实例时，可以使用@Scope Annotation，只要在该Annotation中提供作用域的名称即可。例如：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="variable">@Component</span>(<span class="string">"axe"</span>)</span><br><span class="line">public class SteelAxe implements Axe&#123;</span><br><span class="line">   <span class="comment">//codes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="使用@Resource配置依赖">使用@Resource配置依赖</h3><p>@Resource位于java.annotation包下，是来自JavaEE规范的一个Annotation，Spring直接借鉴了该Annotation，通过使用该Annotation为目标Bean指定协作者Bean。</p>
<p>@Resource有一个name属性，默认情况下，Spring将这个值解释为需要被注入的Bean实例的名字。换句话说，使用@Resource与<code>&lt;property.../&gt;</code>元素的ref属性有相同的效果。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="annotation">@Resource</span>(name=<span class="string">"stoneAxe"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的@Resource Annotation指定将stoneAxe注入该setAxe( )方法，也就是将容器中的stoneAxe Bean作为setAxe方法的参数传入。</p>
<p>@Resource不仅可以修饰setter方法，也可以直接修饰Field，使用@Resource时还可以省略name属性。使用@Resource修饰Field时连setter方法都可以不要：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Resource</span>(name=<span class="string">"stoneAxe"</span>)</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>当使用@Resource修饰setter方法时，如果省略name属性，例如@Resource标注setName( )方法，则Spring默认注入容器中名为name的组件。</li>
<li>当使用@Resource修饰Field时，如果省略name属性，例如@Resource标注name Field，则Spring默认会注入容器中名为name的组件。</li>
</ol>
<h3 id="使用@PostConstruct和@PreDestroy定制生命周期行为">使用@PostConstruct和@PreDestroy定制生命周期行为</h3><p>@PostConstruct和@PreDestroy同样位于java.annotation包下，也是来自JavaEE规范的两个Annotation，Spring直接借鉴了它们，用于定制Spring容器中Bean的生命周期行为。</p>
<p>@PostConstruct和@PreDestroy大致相当于<code>&lt;bean.../&gt;</code>元素的 init-method 属性和 destroy-method 属性指定的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Resource</span>(name=<span class="string">"steelAxe"</span>)</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行初始化的init方法..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@PreDestroy</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"正在执行销毁之前的close方法..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Spring3-0新增的@DependsOn和@Lazy">Spring3.0新增的@DependsOn和@Lazy</h3><p>@DependsOn用于强制初始化其他Bean。可以修饰Bean类或方法，使用该Annotation时可以指定一个字符串数组作为参数，每个数组元素对应于一个强制初始化的Bean。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@DependsOn</span>(&#123;<span class="string">"steelAxe"</span>,<span class="string">"abc"</span>&#125;)</span><br><span class="line"><span class="variable">@Component</span></span><br><span class="line">public class Chinese implements Person&#123;</span><br><span class="line">   <span class="comment">//codes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Lazy用于指定该Bean是否取消预初始化。主要用于修饰Spring Bean类，用于指定该Bean的预初始化行为，使用该Annotation时可以指定一个boolean型的value属性，该属性决定是否要预初始化该Bean。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Lazy</span>(true)</span><br><span class="line"><span class="variable">@Component</span></span><br><span class="line">public class Chinese implements Person&#123;</span><br><span class="line">   <span class="comment">//codes here</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="自动装配和精确装配">自动装配和精确装配</h3><p>spring提供了@Autowired Annotation来指定自动装配，使用@Autowired可以标注setter方法、普通方法、Field、函数形参和构造器等。</p>
<p>例如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="annotation">@Autowired</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Axe <span class="title">getAxe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码使用@Autowired 指定setAxe()方法进行自动装配，spring将会自动搜索容器中类型为Axe的Bean实例，并将该Bean实例作为setAxe()方法的参数传入，此时spring默认的装配策略为byType。同样的@Autowired可以修饰普通的方法，Field和构造器等，且其默认的装配策略均为byType类型的装配。</p>
<p>为了实现精确的自动装配，spring提供了@Qualifier Annotation，通过使用@Qualifier，允许根据Bean的标识来指定自动装配，如下代码所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Autowired</span></span><br><span class="line">    <span class="annotation">@Qualifier</span>(<span class="string">"steelAxe"</span>)</span><br><span class="line">    <span class="keyword">private</span> Axe axe;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAxe</span><span class="params">(Axe axe)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.axe = axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Axe <span class="title">getAxe</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> axe;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">useAxe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(axe.chop());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="资源访问">资源访问</h2><p>Resource接口的主要方法有:</p>
<ul>
<li>InputStream getInputStream() throws IOException:返回资源对应的输入流.</li>
<li>boolean exists():资源是否存在.</li>
<li>boolean isOpen():资源是否打开.</li>
<li>URL getURL() throws IOException:如果底层资源可以表示成URL,该方法返回对应的URL对象.</li>
<li>File getFile() throws IOException:如果底层资源对应一个文件,该方法返回对应的File对象.</li>
<li>String getDescription():返回资源的描述信息，用于资源处理出错时输出该信息，通常是全限定文件名或实际URL.</li>
<li>String getFilename():返回资源文件名，通常是路径中的最后一部分，比如”file.txt”.</li>
</ul>
<h3 id="Resource实现类">Resource实现类</h3><p>Spring在设计上使用了策略模式，针对不同的资源访问，提供了不同的实现类，常用的实现类有：</p>
<ul>
<li>UrlResource：封装了java.net.URL,用户能够访问任何可以通过URL表示的资源,如文件的系统资源,HTTP资源和FTP资源等.</li>
<li>ClassPathResource：访问类加载路径里的资源的实现类.</li>
<li>FileSystemResource：访问文件系统资源的实现类</li>
<li>ServletContextResource：访问相对于ServletContext路径里的资源的实现类</li>
<li>InputStreamResource：访问输入流资源的实现类</li>
<li><p>ByteArrayResource：访问字节数组资源的实现类</p>
</li>
<li><p>访问网络资源</p>
</li>
</ul>
<p>URL资源通常应该提供标准的协议前缀。file:用于访问文件系统；http:用于通过HTTP协议访问资源；ftp:用于通过FTP协议访问资源等。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public class UrlResourceTest &#123;</span><br><span class="line">    public static void main<span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">//创建一个Resource对象，指定从文件系统里读取资源</span></span><br><span class="line">        <span class="comment">//1.只需要将此出替换即可使用其他策略</span></span><br><span class="line">        Resource res = new UrlResource<span class="params">(<span class="string">"file:book.xml"</span>)</span>;</span><br><span class="line">        <span class="comment">//获取该资源的简单信息</span></span><br><span class="line">        System.out.println<span class="params">(res.getFilename<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(res.getDescription<span class="params">()</span>)</span>;</span><br><span class="line">        <span class="comment">//创建Dom4j的解析器</span></span><br><span class="line">        SAXReader reader = new SAXReader<span class="params">()</span>;</span><br><span class="line">        Document doc = reader.read<span class="params">(res.getFile<span class="params">()</span>)</span>;</span><br><span class="line">        <span class="comment">//获取根元素</span></span><br><span class="line">        Element el = doc.getRootElement<span class="params">()</span>;</span><br><span class="line">        List list = el.elements<span class="params">()</span>;</span><br><span class="line">        <span class="comment">//遍历根元素的全部子元素</span></span><br><span class="line">        <span class="keyword">for</span> <span class="params">(Iterator it = list.iterator<span class="params">()</span>;it.hasNext<span class="params">()</span>;)</span> &#123;</span><br><span class="line">            Element book = <span class="params">(Element)</span>it.next<span class="params">()</span>;</span><br><span class="line">            List ll = book.elements<span class="params">()</span>;</span><br><span class="line">            <span class="keyword">for</span><span class="params">(Iterator it2 = ll.iterator<span class="params">()</span>;it2.hasNext<span class="params">()</span>;)</span> &#123;</span><br><span class="line">                Element eee = <span class="params">(Element)</span>it2.next<span class="params">()</span>;</span><br><span class="line">                System.out.println<span class="params">(eee.getText<span class="params">()</span>)</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>加载类加载路径下的资源</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource <span class="keyword">res</span> = <span class="keyword">new</span> ClassPathResource(<span class="string">"book.xml"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>访问文件系统资源</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource <span class="keyword">res</span> = <span class="keyword">new</span> FileSystemResource(<span class="string">"book.xml"</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>访问应用相关资源</li>
</ul>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Resource <span class="keyword">res</span> = <span class="keyword">new</span> ServletContextResource(<span class="string">"book.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>用于访问Web Context下相对路径下的资源。默认情况下，JSP不能直接访问WEB-INF路径下的任何资源，所以应用中的JSP页面需要使用ServletContextResource来访问资源。</p>
<ul>
<li>访问字节数组资源</li>
</ul>
<p>Spring 提供了InputStreamResource来访问二进制输入流资源，InputStreamResource是针对输入流的Resource实现，只有当没有合适的Resource实现时，才考虑使用该InputStreamResource。通常情况下，优先考虑使用ByteArrayResource或者基于文件的Resource实现。</p>
<p>InputStreamResource是一个总是被打开的Resource，所以isOpen方法总是返回true。因此需要多次读取某个流，就不要使用InputStreamResource，创建InputStreamResource实例时应提供一个InputStreamResource参数。</p>
<p>在某些情况下，如读取数据库得到的Blob对象，可以通过Blob的getBinaryStream方法获取二进制输入流。</p>
<p>ByteArrayResource在Socket，线程之间的信息交换方面是很有用的。</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">String <span class="keyword">file</span> = <span class="string">"&lt;?xml version='1.0' encoding='UTF-8'"</span></span><br><span class="line">            + <span class="string">"&lt;计算机书籍列表&gt;&lt;书&gt;&lt;书名&gt;疯狂JAVA讲义"</span></span><br><span class="line">            + <span class="string">"&lt;/书名&gt;&lt;作者&gt;李刚&lt;/作者&gt;&lt;/书&gt;&lt;书&gt;&lt;书名&gt;"</span></span><br><span class="line">            + <span class="string">"轻量级java ee企业应用实战&lt;/书名&gt;&lt;作者&gt;李刚"</span></span><br><span class="line">            + <span class="string">"&lt;/作者&gt;&lt;/书&gt;&lt;/计算机书籍列表&gt;"</span></span><br><span class="line"><span class="keyword">byte</span>[] fileBytes = <span class="keyword">file</span>.getBytes();</span><br><span class="line">Resource res = <span class="keyword">new</span> ByteArrayResource(fileBytes);</span><br></pre></td></tr></table></figure>
<h3 id="ResourceLoader接口和ResourceLoaderAware接口">ResourceLoader接口和ResourceLoaderAware接口</h3><p>ResourceLoader 接口由能返回(或者载入)Resource 实例的对象来实现。</p>
<p>所有的ApplicationContext都实现了 ResourceLoader 接口， 因此它们可以用来获取Resource 实例。</p>
<p>当你调用特定ApplicationContext的 getResource() 方法， 而且资源路径并没有特定的前缀时，你将获得与该ApplicationContext相应的 Resource 类型。例如：假定下面的代码片断是基于ClassPathXmlApplicationContext 实例上执行的：</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="keyword">template</span> = ctx.getResource(<span class="string">"some/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure>
<p>这将返回ClassPathResource；如果是基于FileSystemXmlApplicationContext 实例上执行的，那你将获得FileSystemResource。而对于 WebApplicationContext 你将获得ServletContextResource，依此类推。</p>
<p>另一方面，无论什么类型的ApplicationContext，你可以通过使用特定的前缀 classpath: 强制使用ClassPathResource。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="keyword">template</span> = ctx.getResource(<span class="string">"classpath:some/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure>
<p>同样的，你可以用任何标准的 java.net.URL 前缀，强制使用 UrlResource ：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Resource</span> <span class="keyword">template</span> = ctx.getResource(<span class="string">"file:/some/resource/path/myTemplate.txt"</span>);</span><br><span class="line"><span class="type">Resource</span> <span class="keyword">template</span> = ctx.getResource(<span class="string">"http://myhost.com/resource/path/myTemplate.txt"</span>);</span><br></pre></td></tr></table></figure></p>
<p>下面的表格概述了 String 到 Resource 的转换规则：</p>
<table>
<thead>
<tr>
<th>前缀</th>
<th>例子</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>classpath:</td>
<td>classpath:com/myapp/config.xml</td>
<td>从classpath中加载。</td>
</tr>
<tr>
<td>file:</td>
<td>file:/data/config.xml</td>
<td>作为 URL 从文件系统中加载。</td>
</tr>
<tr>
<td>http:</td>
<td><a href="http://myserver/logo.png" target="_blank" rel="external">http://myserver/logo.png</a></td>
<td>作为 URL 加载。</td>
</tr>
<tr>
<td>(none)</td>
<td>/data/config.xml</td>
<td>根据 ApplicationContext 进行判断。</td>
</tr>
</tbody>
</table>
<p>ResourceLoaderAware是特殊的标记接口，它希望拥有一个ResourceLoader 引用的对象。<br>当实现了 ResourceLoaderAware接口的类部署到ApplicationContext(比如受Spring管理的bean)中时，它会被ApplicationContext识别为 ResourceLoaderAware。 接着ApplicationContext会调用setResourceLoader(ResourceLoader)方法，并把自身作为参数传入该方法(记住，所有Spring里的ApplicationContext都实现了ResourceLoader接口)。</p>
<p>既然 ApplicationContext 就是ResourceLoader，那么该bean就可以实现 ApplicationContextAware接口并直接使用所提供的ApplicationContext来载入资源，但是通常更适合使用特定的满足所有需要的 ResourceLoader实现。 这样一来，代码只需要依赖于可以看作辅助接口的资源载入接口，而不用依赖于整个Spring ApplicationContext 接口。</p>
<p>TestBean.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestBean</span> <span class="keyword">implements</span> <span class="title">ResourceLoaderAware</span> </span>&#123;</span><br><span class="line">    ResourceLoader rd;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResourceLoader</span><span class="params">(ResourceLoader resourceloader)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rd = resourceloader;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceLoader <span class="title">getResourceLoader</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> rd;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>SpringTest.java:<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">SpringTest</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">        ApplicationContext ctx = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        TestBean tb = (TestBean)ctx.getBean(<span class="string">"test"</span>);</span><br><span class="line">        ResourceLoader rl = tb.getResourceLoader();</span><br><span class="line">        System.<span class="keyword">out</span>.println(rl == ctx);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="使用Resource作为属性">使用Resource作为属性</h3><p>前面都是通过编码的方式获取资源的，资源所在的物理位置就耦合到代码中了，如果资源位置变化，则必须改写程序。因此，可以通过依赖注入资源</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">TestBean</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Resource res;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setResource</span>(<span class="params">Resource res</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.res = res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>bean.xml:<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="property">id</span>=<span class="string">"testBean"</span> <span class="type">class</span>=<span class="string">"com.bean.TestBean"</span>&gt;</span><br><span class="line">  &lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"res"</span> value=<span class="string">"classpath:book.xml"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></p>
<p>如果不采用任何前缀，则Spring将采用与该ApplicationContext相同的资源访问策略来访问资源。</p>
<h3 id="在ApplicationContext中使用资源">在ApplicationContext中使用资源</h3><p>ApplicationContext确定资源访问策略通常有两个方法：</p>
<ul>
<li>ApplicationContext实现类指定访问策略</li>
<li>前缀指定访问策略</li>
</ul>
<h4 id="ApplicationContext实现类指定访问策略">ApplicationContext实现类指定访问策略</h4><p>ClassPathXmlApplicationContext：返回ClassPathResource<br>FileSystemXmlApplicationContext： 获得FileSystemResource<br>XmlWebApplicationContext： 获得ServletContextResource</p>
<h4 id="前缀指定访问策略">前缀指定访问策略</h4><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = new FileSystemXmlApplicationContext<span class="params">(<span class="string">"classpath:bean.xml"</span>)</span>;</span><br><span class="line">Resource r = ctx.getResource<span class="params">(<span class="string">"book.xml"</span>)</span>;</span><br><span class="line">System.out.println<span class="params">(r.getDescription<span class="params">()</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>通过classpath:前缀指定资源访问策略仅仅对当次访问有效，程序后面进行资源访问时，还是会根据ApplicationContext的实现类来选择对应的资源访问策略。建议尽量显示指定资源，而不是通过前缀。</p>
<h4 id="classpath*:前缀的用法"><code>classpath*</code>:前缀的用法</h4><p><code>classpath*</code>:前缀提供了装载多个XML配置文件的能力，当使用<code>classpath*</code>:前缀来指定XML配置文件时，系统搜索类加载路径，找出所有与文件名匹配的文件，分辨装载文件中的配置定义，最后合并成一个ApplicationContext。<code>classpath*</code>:前缀仅对ApplicationContext有效，用于加载配置文件。其他情况，使用<code>classpath*</code>:前缀加载多个资源是不行的。</p>
<p>还有一种可以一次加载多个配置文件的方式：指定配置文件时使用通配符。</p>
<p>这两种方式也可以混合使用</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"classpath*:bean*.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>这将会加载类加载路径下所有以bean开头的配置文件。</p>
<p>classpath: 只会在当前类加载路径下加载。如果有同名资源只会加载第一个。<br><code>classpath*</code>:除了当前类加载路径还会扫描jar包中的类加载路径。所有同名资源都会被加载</p>
<h4 id="file:前缀的用法">file:前缀的用法</h4><p>FileSystemApplicationContext 会简单地让所有绑定的 FileSystemResource 实例把绝对路径都当成相对路径，而不管它们是否以反斜杠开头。也就是说，下面的含义是相同的：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"conf/context.xml"</span>);</span><br><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"/conf/context.xml"</span>);</span><br></pre></td></tr></table></figure>
<p>上面的两行代码是没有区别的。</p>
<p>实际上如果的确需要使用绝对路径，那你最好就不要使用 FileSystemResource 或 FileSystemXmlApplicationContext来确定绝对路径。我们可以通过使用 file: URL前缀来强制使用UrlResource。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ApplicationContext ctx = <span class="keyword">new</span> FileSystemXmlApplicationContext(<span class="string">"file:/conf/context.xml"</span>);</span><br></pre></td></tr></table></figure>
<h2 id="Spring的AOP">Spring的AOP</h2><h3 id="使用AspectJ实现AOP">使用AspectJ实现AOP</h3><p>AOP 专门用于处理系统中分布于各个模块（不同方法）中的交叉关注点问题，在JavaEE应用中，常常通过AOP来处理一些具有横切性质的系统级服务，如事务管理、安全检查、缓存、对象池管理等，AOP已经成为一种非常常用的解决方案。</p>
<p>AspectJ是一个基于Java语言的AOP框架，提供了强大的AOP功能，其他很多AOP框架都借鉴或采纳了它的一些思想。由于Spring3.0的AOP与AspectJ进行了很好的集成，因此掌握AspectJ是学习Spring AOP的基础。</p>
<p>AspectJ是Java语言的一个AOP实现，其主要包括两个部分：第一个部分定义了如何表达、定义AOP编程中的语法规范，通过这套语法规范，我们可以方便地用AOP来解决Java语言中存在的交叉关注点问题；第二个部分是工具部分，包括编译器、调试工具等。</p>
<p>AspectJ是最早、功能比较强大的AOP实现之一，对整套AOP机制都有较好的实现，很多其他语言的AOP实现，也借鉴或采纳了AspectJ中的很多设计。而在Java领域，AspectJ中的很多语法结构基本上已经成为AOP领域的标准。</p>
<p>从Spring2.0开始，Spring AOP已经引入了对AspectJ的支持，并且允许直接使用AspectJ进行AOP编程，而Spring自身的AOP API也努力与AspectJ保持一致。因此学习Spring AOP就必然需要从AspectJ开始，因为它是Java领域最流行的AOP解决方案。即使不用Spring框架，我们甚至也可以直接使用AspectJ进行AOP编程。</p>
<p>下载、安装AspectJ和配置环境变量：<br>登陆点击打开链接站点<a href="http://www.eclipse.org/aspectj/downloads.php#stable_release" target="_blank" rel="external">AspectJ</a>，下载AspectJ的一个稳定版本。下载完成后得到一个aspectj-[version].jar文件。我这里将它放在D盘的lib文件夹下的aspectj文件夹下。启动命令行窗口：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">java</span> <span class="tag">-jar</span> <span class="tag">aspectj-</span><span class="attr_selector">[version]</span><span class="class">.jar</span></span><br></pre></td></tr></table></figure>
<p>安装好了以后记得配置环境变量：将 E:\Java\AOP\aspectj\bin添加到path环境变量中，将 E:\Java\AOP\aspectj\lib\aspectjrt.jar添加到CLASSPATH，注意这还不够，前面得有点号和分号。</p>
<h4 id="AspectJ使用入门">AspectJ使用入门</h4><p>我们在D盘下写一个Hello.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hello</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">        Hello h=<span class="keyword">new</span> Hello();</span><br><span class="line">        h.sayHello();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Hello AspectJ !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编译运行：<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac -d . Hello<span class="class">.java</span></span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure></p>
<p>假设现在客户需要在执行sayHello()方法之前启动事务，方法结束之后关闭事务，在传统的编程模式下，我们必须手动修改sayHello()方法。但是如果采用面向切面编程的思想，则可以无须修改sayHello( )方法，也可以达到同样的效果。这里我们使用AspectJ框架帮我们做到这一点。我们在D盘下写一个TransactionAspect.java：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="aspect"><span class="keyword">aspect</span> <span class="title">TransactionAspect</span></span>&#123;</span><br><span class="line">    <span class="comment">//指定执行Hello.sayHello()方法时执行下面的代码块</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">around</span>():<span class="keyword">call</span>(<span class="keyword">void</span> Hello.sayHello())&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启事务"</span>);</span><br><span class="line">        <span class="keyword">proceed</span>();<span class="comment">//回调原来的sayHello()方法</span></span><br><span class="line">        System.out.println(<span class="string">"结束事务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的java文件不是使用class、interface或enum，而是使用 aspect，aspect是AspectJ才能识别的关键字。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ajc -d . Hello<span class="class">.java</span> TransactionAspect<span class="class">.java</span></span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure></p>
<p>我们可以把 ajc 命令理解成javac命令，它们都用于编译Java程序，区别是ajc命令可以识别AspectJ的语法，从这个意义上看，我们可以将ajc当成一个增强版的javac命令。</p>
<p>运行Hello类没有任何改变，但是程序的输出已经让我们足够惊喜了，对，就是我们想要的结果！</p>
<p>有了AOP，我们完全可以不对Hello.java类进行任何修改，同时又可以满足客户的需求。上面的程序只是在控制台打印输出语句模拟事务的开启和关闭，在实际工作中可以用实际的操作代码来代替打印语句，这就可以满足客户的要求了。<br>如果客户再次提出新需求，需要在sayHello( )方法后增加记录日志的功能，那也很简单，我们再写一个 LogAspect.java :</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="aspect"><span class="keyword">aspect</span> <span class="title">LogAspect</span></span>&#123;</span><br><span class="line">    <span class="keyword">pointcut</span> <span class="title">logPointcut</span>()</span><br><span class="line">        :<span class="keyword">execution</span>(<span class="keyword">void</span> Hello.sayHello());</span><br><span class="line">    <span class="keyword">after</span>():logPointcut()&#123;</span><br><span class="line">        System.out.println(<span class="string">"记录日志功能..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">ajc</span> -d . <span class="regexp">*.java</span></span><br><span class="line">java Hello</span><br></pre></td></tr></table></figure>
<p>实际上，AspectJ允许同时为多个方法添加新功能，只要我们定义Pointcut时指定匹配更多的方法即可。如如下片段：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointcut xxxPointcut()</span><br><span class="line">   :execution(void H*.<span class="keyword">say</span>*());</span><br></pre></td></tr></table></figure>
<p>上面程序中的xxxPointcut将可以匹配所有以H开头的类中、所有以say开头的方法，但该方法返回的必须是void。如果想匹配任意的返回值类型：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointcut xxxPointcut</span><br><span class="line">   :execution(* H*.<span class="keyword">say</span>*());</span><br></pre></td></tr></table></figure>
<p>修改：</p>
<p>Hello.java :</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Hello</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span>&#123;</span><br><span class="line">        Hello h=<span class="keyword">new</span> Hello();</span><br><span class="line">        h.sayHello();</span><br><span class="line">        h.sayGoodbye();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayHello</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Hello AspectJ !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sayGoodbye</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"Goodbye Java !"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LogAspect.java :</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="aspect"><span class="keyword">aspect</span> <span class="title">LogAspect</span></span>&#123;</span><br><span class="line">    <span class="keyword">pointcut</span> <span class="title">logPointcut</span>()</span><br><span class="line">        :<span class="keyword">execution</span>(<span class="keyword">void</span> Hello.say*());</span><br><span class="line">    <span class="keyword">after</span>():logPointcut()&#123;</span><br><span class="line">        System.out.println(<span class="string">"记录日志功能..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TransactionAspect.java :</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="aspect"><span class="keyword">aspect</span> <span class="title">TransactionAspect</span></span>&#123;</span><br><span class="line">    <span class="comment">//指定执行Hello.sayHello()方法时执行下面的代码块</span></span><br><span class="line">    <span class="keyword">void</span> <span class="keyword">around</span>():<span class="keyword">call</span>(<span class="keyword">void</span> Hello.say*())&#123;</span><br><span class="line">        System.out.println(<span class="string">"开启事务"</span>);</span><br><span class="line">        <span class="keyword">proceed</span>();<span class="comment">//回调原来的sayHello()方法</span></span><br><span class="line">        System.out.println(<span class="string">"结束事务"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AOP_的基本概念">AOP 的基本概念</h3><p>如果安装了Java的反编译工具，可以反编译上篇文章中的Hello.class文件，我们将会发现该Hello.class文件不是由Hello.java文件编译得到的，该Hello.class里新增了很多内容。这表明AspectJ在编译时已增强了Hello.class类的功能，因此 AspectJ 通常被称为编译时增强的AOP框架。</p>
<p>与AspectJ相对的还有另外一种AOP框架，它们不需要在编译时对目标类进行增强，而是运行时生成目标类的代理类，该代理类要么与目标类实现相同的接口，要么是目标类的子类。总之，代理类都对目标类进行了增强处理，前者是JDK动态代理的处理策略，后者是CGLIB代理的处理策略。</p>
<p>Spring AOP以创建动态代理的方式来生成代理类，底层既可使用JDK动态代理，也可采用CGLIB代理。</p>
<p>一般来说，编译时增强的AOP框架在性能上更有优势—因为运行时动态增强的AOP框架需要每次运行时都进行动态增强。</p>
<p>AOP从程序运行角度考虑程序的流程，提取业务处理过程的切面。AOP面向的是程序运行中各个步骤，希望以更好的方式来组合业务处理的各个步骤。</p>
<p>AOP框架并不与特定的代码耦合，AOP框架能处理程序执行中特定切入点（Pointcut），而不与某个具体类耦合。AOP框架具有如下两个特征：</p>
<ol>
<li>各步骤之间的良好隔离性。</li>
<li>源代码无关性。</li>
</ol>
<p>下面是关于面向切面编程的一些术语：</p>
<ol>
<li>切面（Aspect）：业务流程运行的某个特定步骤，也就是应用运行过程的关注点，关注点可能横切多个对象，所以常常也称为横切关注点。</li>
<li>连接点（Joinpoint）：程序执行过程中明确的点，如方法的调用或者异常的抛出。Spring AOP中，连接点总是方法的调用。</li>
<li>增强处理（Advice）：AOP框架在特定的切入点执行的增强处理。处理有around，before，after等类型。</li>
<li>切入点（Pointcut）：可以插入增强处理的连接点。简而言之，当某个连接点满足指定要求时，该连接点将被添加增强处理，该连接点也就变成了切入点。例如如下代码：<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pointcut xxxPointcut()</span><br><span class="line">   :execution(void H*.<span class="keyword">say</span>*())</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>每个方法被调用都只是连接点，但如果该方法属于H开头的类，且方法名义say开头，那么该方法的调用执行将变成切入点。如何使用表达式来定义切入点是AOP的核心，Spring默认使用AspectJ切入点语法：</p>
<ol>
<li>引入：将方法或字段添加到被处理的类中。Spring允许引入新的接口到任何被处理的对象。例如你可以使用一个引入，使任何对象实现isModified接口，以此来简化缓存。</li>
<li>目标对象：被AOP框架进行增强处理的对象，也被称为被增强的对象。如果AOP框架是通过运行时代理来实现的，那么这个对象将是一个被代理的对象。</li>
<li>AOP代理：AOP框架创建的对象，简单地说，代理就是对目标对象的加强。Spring中的AOP代理可以是JDK动态代理，也可以是CGLIB代理。前者为实现接口的目标对象的代理，后者为不实现接口的目标对象的代理。</li>
<li>织入（Weaving）：将增强处理添加到目标对象中，并创建一个被增强的对象（AOP代理）的过程就是织入。织入有两种实现方式：编译时增强（例如AspectJ）和运行时增强（例如CGLIB）。Spring和其他纯Java AOP框架一样，在运行时完成织入。</li>
</ol>
<p>由前面的介绍知道：AOP代理其实是由AOP框架动态生成的一个对象，该对象可作为目标对象使用。AOP代理包含了目标对象的全部方法，但AOP代理中的方法与目标对象的方法存在差异：AOP方法在特定切入点添加了增强处理，并且回调了目标对象的方法。<br>AOP代理所包含的方法与目标对象的方法示意图如下：</p>
<p><img src="http://fh-1.qiniudn.com/AOP代理的方法和目标对象代理的方法.jpg" alt="AOP代理的方法和目标对象代理的方法"></p>
<h3 id="Spring_的AOP支持">Spring 的AOP支持</h3><p>Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理。因此，AOP代理可以直接使用容器中的其他Bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring默认使用Java动态代理来创建AOP代理，这样就可以为任何接口实例创建代理了。</p>
<p>Spring也可以使用CGLIB代理，在需要代理类而不是代理接口的时候，Spring会自动切换为使用CGLIB代理。但Spring推荐使用面向接口编程，因此业务对象通常都会实现一个或多个接口，此时默认将使用JDK动态代理，但也可强制使用CGLIB。</p>
<p>Spring AOP使用纯Java实现，它不需要专门的编译过程。Spring AOP不需要控制类装载器层次，因此它可以在所有JavaWeb容器或应用服务器中运行良好。</p>
<p>Spring目前仅支持将方法调用作为连接点，如果需要把对field的访问和更新也作为增强处理的连接点，则可以考虑使用AspectJ。</p>
<p>Spring实现AOP的方法跟其他的框架不同，Spring并不是要提供最完整的AOP实现，Spring侧重于AOP实现和Spring IOC容器之间的整合，用于帮助解决在企业级开发中的常见问题。</p>
<p>因此Spring的AOP通常和Spring IOC容器一起使用，Spring AOP从来没有打算通过提供一种全面的AOP解决方案来与AspectJ竞争。Spring AOP采用基于代理的AOP实现方案，而AspectJ则采用编译时增强的解决方案。</p>
<p>一旦我们掌握了上面AOP的相关概念，就不难发现进行AOP编程其实是很简单的事情。纵观AOP编程，其中需要程序员参与的只有三个部分：</p>
<ol>
<li>定义普通业务组件。</li>
<li>定义切入点，一个切入点可能横切多个业务组件。</li>
<li>定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作。</li>
</ol>
<p>上面三个部分的第一个部分是最平常不过的事情，那么进行AOP编程的关键就是定义切入点和定义增强处理。一旦定义了合适的切入点和增强处理，AOP框架将会自动生成AOP代理，而AOP代理的方法大致有如下公式：</p>
<p>代理对象的方法 = 增强处理 + 被代理对象的方法</p>
<p>我们使用AspectJ方式来定义切入点和增强处理，在这种方式下，Spring有两种选择来定义切入点和增强处理。</p>
<ol>
<li>基于 Annotation 的零配置方式：使用@Aspect、@Pointcut等Annotation来标注切入点和增强处理。</li>
<li>基于XML配置文件的管理方式：使用Spring配置文件来定义切入点和增强处理。</li>
</ol>
<h3 id="基于Annotation的“零配置”方式">基于Annotation的“零配置”方式</h3><p>AspectJ 允许使用Annotation定义切面、切入点和增强处理，而 Spring框架则可识别并根据这些Annotation来生成AOP代理。Spring只是使用了和AspectJ一样的注解，并没有使用AspectJ的编译器和织入器，底层依然使用的是 Spring AOP，依然是在运行时动态生成AOP代理，并不依赖于AspectJ的编译器或者织入器。</p>
<p>为了启用Spring对@AspectJ切面配置的支持，并保证Spring容器中的目标Bean被一个或多个切面自动增强，必须在配置文件中加如下代码：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;aop:aspectj-autoproxy/&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果不打算使用Spring的XML Schema配置方式，则应该在Spring配置文件中增加如下片段来启用@AspectJ支持</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean <span class="keyword">class</span>=<span class="string">"org.springframework.aop.aspectj.annotation.AnnotationAwareAspectJAutoProxyCreator"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>为了在Spring应用中启动@AspectJ支持，还需要添加 aspectjrt.jar 和aspectjweaver.jar到工程lib目录下。</p>
<h4 id="定义切面Bean">定义切面Bean</h4><p>使用@Aspect标注一个Java类，该Java类将会作为切面Bean</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogAspect</span> &#123;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开发时无须担心使用@Aspect 定义的切面类被增强处理，当Spring容器检测到某个Bean类使用了@Aspect标注之后，Spring容器不会对该Bean类进行增强。</p>
<h4 id="定义Before增强处理">定义Before增强处理</h4><p>Person.java:<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface <span class="keyword">Person</span> &#123;</span><br><span class="line">    public String sayHello(String name);</span><br><span class="line">    public void eat(String food);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Chinese.java:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我正在吃:"</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">"Hello,Spring AOP"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BeforeAdviceTest.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeforeAdviceTest</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Before</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authority</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"模拟执行权限检查"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">        <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">        <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span></span><br><span class="line">        <span class="attribute">xmlns:aop</span>=<span class="value">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">        <span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">        <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">                http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">                http://www.springframework.org/schema/context</span><br><span class="line">                http://www.springframework.org/schema/context/spring-context-3.0.xsd</span><br><span class="line">                http://www.springframework.org/schema/aop</span><br><span class="line">                http://www.springframework.org/schema/aop/spring-aop-3.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">context:component-scan</span> <span class="attribute">base-package</span>=<span class="value">"com.bean"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">context:include-filter</span> <span class="attribute">type</span>=<span class="value">"annotation"</span></span><br><span class="line">                 <span class="attribute">expression</span>=<span class="value">"org.aspectj.lang.annotation.Aspect"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">context:component-scan</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:aspectj-autoproxy</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));</span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="定义AfterReturning增强处理">定义AfterReturning增强处理</h4><p>AfterReturning 增强处理将在目标方法正常完成后被织入。<br>使用@AfterReturning可指定如下两个属性：</p>
<ol>
<li>pointcut / value : 两者都用于指定该切入点对应的切入表达式</li>
<li>returning : 指定一个返回值形参名，增强处理定义的方法可通过该行参名来访问目标方法的返回值。</li>
</ol>
<p>AfterReturningAdviceTest.java :</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AfterReturningAdviceTest</span> &#123;</span><br><span class="line">    @AfterReturning(returning=<span class="string">"rvt"</span>,pointcut=<span class="string">"execution(* com.bean.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span>(<span class="params">Object rvt</span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"获取目标方法返回值："</span>+rvt);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"模拟记录日志的功能..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));</span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="定义AfterThrowing增强处理">定义AfterThrowing增强处理</h4><p>@AfterThrowing 主要用于处理程序中未处理的异常。<br>使用@AfterThrowing 时可指定如下两个属性：</p>
<ol>
<li>pointcut / value : 用于指定该切入点对应的切入表达式。</li>
<li>throwing : 指定一个返回值形参名，增强处理定义的方法可通过该形参名来访问目标方法中所抛出的异常对象。</li>
</ol>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">5</span>/<span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">"divide执行完成！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"sayHello方法开始被执行..."</span>);</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"目标类的异常处理"</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">" Hello,Spring AOP"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AfterThrowingAdviceTest.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AfterThrowingAdviceTest</span> &#123;</span><br><span class="line">    @AfterThrowing(throwing=<span class="string">"ex"</span>,pointcut=<span class="string">"execution(* com.bean.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryActions</span>(<span class="params">Throwable ex</span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"目标方法中抛出的异常:"</span>+ex);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"模拟抛出异常后的增强处理..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));</span><br><span class="line">        p.divide();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面程序中的sayHello方法和divide两个方法都会抛出异常，但sayHello方法中的异常将由该方法显式捕捉，所以Spring AOP不会处理该异常；而divide方法将抛出ArithmeticException异常，且该异常没有被任何程序所处理，故Spring AOP会对该异常进行处理。</p>
<p>catch捕捉 意味着完全处理该异常，如果catch块中没有重新抛出新异常，则该方法可以正常结束；而 AfterThrowing 虽然处理了该异常，但他不能完全处理该异常，该异常依然会传播到上一级调用者，本例中传播到JVM，导致程序终止。</p>
<p>如果上面的doRecoveryActions方法定义了ex形参的类型是NullPointerException，则该切入点只匹配抛出NullPointerException异常的情况。</p>
<h4 id="After增强处理">After增强处理</h4><p>@After与@AfterReturning有点相似，但是也有区别：</p>
<ol>
<li>AfterReturning 增强处理只在目标方法成功完成后才会被织入。</li>
<li>After 增强处理不管目标方法如何结束，包括成功完成和遇到异常终止两种情况，它都会被织入。<br>因为不论一个方法是如何结束的，After增强处理都会被织入，因此After增强处理必须准备处理正常返回和异常返回两种情况，这种增强处理通常用于释放资源。</li>
</ol>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">5</span>/<span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">"divide执行完成！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"sayHello方法开始被执行..."</span>);</span><br><span class="line">            <span class="keyword">new</span> FileInputStream(<span class="string">"a.txt"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"目标类的异常处理"</span>+e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">" Hello,Spring AOP"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AfterAdviceTest.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AfterAdviceTest</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@After</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">realease</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"模拟方法结束后的释放资源..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));</span><br><span class="line">        p.divide();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>虽然divide方法因为ArithemeticException异常结束，但After增强处理依然被正常织入。由此After的作用有点类似finally块。</p>
<h4 id="Around增强处理">Around增强处理</h4><p>@Around 增强处理是功能比较强大的增强处理，它近似等于Before 和 AfterReturning的总和。@Around既可在执行目标方法之前织入增强动作，也可在执行目标方法之后织入增强动作。@Around甚至可以决定目标方法在什么时候执行，如何执行，更甚者可以完全阻止目标方法的执行。</p>
<p>@Around可以改变执行目标方法的参数值，也可以改变执行目标方法之后的返回值。</p>
<p>@Around功能虽然强大，但通常需要在线程安全的环境下使用。因此，如果使用普通的Before、AfterReturning就能解决的问题，就没有必要使用Around了。如果需要目标方法执行之前和之后共享某种状态数据，则应该考虑使用Around。尤其是需要使用增强处理阻止目标的执行，或需要改变目标方法的返回值时，则只能使用Around增强处理了。</p>
<p>当定义一个Around增强处理方法时，该方法的第一个形参必须是 ProceedingJoinPoint 类型，在增强处理方法体内，调用ProceedingJoinPoint的proceed方法才会执行目标方法—这就是@Around增强处理可以完全控制目标方法执行时机、如何执行的关键；如果程序没有调用ProceedingJoinPoint的proceed方法，则目标方法不会执行。</p>
<p>调用ProceedingJoinPoint的proceed方法时，还可以传入一个Object[]对象，该数组中的值将被传入目标方法作为实参。如果传入的Object[]数组长度与目标方法所需要的参数个数不相等，或者Object[]数组元素与目标方法所需参数的类型不匹配，程序就会出现异常。</p>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">divide</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a=<span class="number">5</span>/<span class="number">0</span>;</span><br><span class="line">        System.out.println(<span class="string">"divide执行完成！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sayHello方法被调用..."</span>);</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">" Hello,Spring AOP"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我正在吃:"</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AroundAdviceTest.java :<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AroundAdviceTest</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Around</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="function">Object <span class="title">processTx</span><span class="params">(ProceedingJoinPoint jp)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"执行目标方法之前，模拟开始事务..."</span>);</span><br><span class="line">        Object rvt=jp.<span class="keyword">proceed</span>(<span class="keyword">new</span> String[]&#123;<span class="string">"被改变的参数"</span>&#125;);</span><br><span class="line">        System.out.println(<span class="string">"执行目标方法之后，模拟结束事务..."</span>);</span><br><span class="line">        <span class="keyword">return</span> rvt+<span class="string">"新增的内容"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));</span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);</span><br><span class="line">        p.divide();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果proceed方法参数数组的维度大于需要增强处理的方法，程序会抛出异常。</p>
<h4 id="访问目标方法">访问目标方法</h4><p>最简单的做法就是定义增强处理方法时将第一个参数定义为JoinPoint 类型，当该增强处理方法被调用时，该JoinPoint参数就代表了织入增强处理的连接点。JoinPoint里包含了如下几个常用的方法：</p>
<ul>
<li>Object[ ] getArgs( )    返回执行目标方法时的参数</li>
<li>Signature getSignature( )    返回被增强的方法的相关信息</li>
<li>Object getTarget( )    返回被织入增强处理的目标对象</li>
<li>Object getThis( )    返回AOP框架为目标对象生成的代理对象</li>
</ul>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"sayHello方法被调用..."</span>);</span><br><span class="line">        <span class="keyword">return</span> name+<span class="string">" Hello,Spring AOP"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我正在吃:"</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>FourAdviceTest.java :<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line">public class FourAdviceTest &#123;</span><br><span class="line">    @Around<span class="params">(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span></span><br><span class="line">    public Object processTx<span class="params">(ProceedingJoinPoint jp)</span> throws Throwable&#123;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Around增强:执行目标方法之前，模拟开始事务..."</span>)</span>;</span><br><span class="line">        Object[] args=jp.getArgs<span class="params">()</span>;</span><br><span class="line">        <span class="keyword">if</span><span class="params">(args!=null &amp;&amp; args.length&gt;<span class="number">0</span> &amp;&amp; args[<span class="number">0</span>].getClass<span class="params">()</span>==String.class)</span>&#123;</span><br><span class="line">            args[<span class="number">0</span>]=<span class="string">"被改变的参数"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Object rvt=jp.proceed<span class="params">(args)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Around增强:执行目标方法之后，模拟结束事务..."</span>)</span>;</span><br><span class="line">        return rvt+<span class="string">" 新增的内容"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    @Before<span class="params">(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span></span><br><span class="line">    public void authority<span class="params">(JoinPoint jp)</span>&#123;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Before增强:模拟执行权限检查..."</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Before增强:被织入增强处理的目标方法为："</span>+ jp.getSignature<span class="params">()</span>.getName<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Before增强：目标方法的参数为："</span>+Arrays.toString<span class="params">(jp.getArgs<span class="params">()</span>)</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"Before增强:被织入增强处理的目标对象为："</span>+jp.getTarget<span class="params">()</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @AfterReturning<span class="params">(returning=<span class="string">"rvt"</span>,pointcut=<span class="string">"execution(* com.bean.*.*(..))"</span>)</span></span><br><span class="line">    public void <span class="built_in">log</span><span class="params">(JoinPoint jp,Object rvt)</span>&#123;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强：获取目标方法返回值："</span>+rvt)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强：模拟记录日志功能..."</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强：被织入增强处理的目标方法为:"</span>+ jp.getSignature<span class="params">()</span>.getName<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强：目标方法的参数为："</span>+ Arrays.toString<span class="params">(jp.getArgs<span class="params">()</span>)</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"AfterReturning增强:被织入增强处理的目标对象为："</span>+ jp.getTarget<span class="params">()</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @After<span class="params">(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span></span><br><span class="line">    public void release<span class="params">(JoinPoint jp)</span>&#123;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"After增强：模拟方法结束后的释放资源..."</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"After增强：被织入增强处理的目标方法为："</span>+ jp.getSignature<span class="params">()</span>.getName<span class="params">()</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"After增强：目标方法的参数为："</span>+ Arrays.toString<span class="params">(jp.getArgs<span class="params">()</span>)</span>)</span>;</span><br><span class="line">        System.out.println<span class="params">(<span class="string">"After增强: 被织入增强处理的目标对象为："</span>+ jp.getTarget<span class="params">()</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        System.out.println(p.sayHello(<span class="string">"张三"</span>));</span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Before、Around、AfterReturning、After增强处理的优先级从低到高的顺序：Before、Around、AfterReturning、After</p>
<h4 id="织入增强处理的顺序">织入增强处理的顺序</h4><p>Spring AOP 采用和 AspectJ 一样的优先顺序来织入增强处理：在进入连接点时，高优先级的增强处理将先被织入；在退出连接点时，高优先级的增强处理会后被织入。</p>
<p>当不同的切面里的两个增强处理需要在同一个连接点被织入时，Spring AOP将以随机的顺序来织入这两个增强处理。如果应用需要指定不同切面类里增强处理的优先级，Spring提供了如下两种解决方案：</p>
<ol>
<li>让切面类实现org.springframework.core.Ordered接口，实现该接口只需实现一个int getOrder()方法，该方法返回值越小，则优先级越高。</li>
<li>直接使用@Order注解来修饰一个切面类，使用 @Order 时可指定一个int型的value属性，该属性值越小，则优先级越高。</li>
</ol>
<p>Chinese.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chinese</span> <span class="keyword">implements</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">(String food)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"我正在吃:"</span>+food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AspectFirst.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span></span><br><span class="line"><span class="annotation">@Order</span>(<span class="number">5</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectFirst</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Before</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspectFirstStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@Before增强处理：我是AspectFirst切面，我的优先级为5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@After</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspectFirstEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@After增强处理：我是AspectFirst切面，我的优先级为5"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AspectSecond.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span></span><br><span class="line"><span class="annotation">@Order</span>(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AspectSecond</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Before</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspectSecondStart</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@Before增强处理：我是AspectSecond切面，我的优先级为1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@After</span>(<span class="string">"execution(* com.bean.*.*(..))"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aspectSecondEnd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"@After增强处理：我是AspectSecond切面，我的优先级为1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">    public static void main(String<span class="comment">[]</span> args) &#123;</span><br><span class="line">        ApplicationContext ctx=new ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        <span class="keyword">Person</span> p=(<span class="keyword">Person</span>) ctx.getBean(<span class="string">"chinese"</span>);</span><br><span class="line">        p.eat(<span class="string">"西瓜"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>同一个切面类里的两个相同类型的增强处理在同一个连接点被织入时，Spring AOP将以随机顺序来织入这两个增强处理，没有办法指定它们的织入顺序。如果确实需要保证它们以固有的顺序被织入，则可考虑将多个增强处理压缩成一个，或者将不同增强处理重构到不同切面类中，通过在切面类级别上进行排序。</p>
<h4 id="定义切入点">定义切入点</h4><p>前文中，在一个切面类中定义了4个增强处理，定义4个增强处理时分别指定了相同的切入点表达式，这种做法显然不太符合软件设计的原则：我们居然将那个切入点表达式重复了4次，如果有一天需要修改这个切入点表达式，那就要修改4个地方。如果重复了更多次呢？岁，我们就得修改更多次。</p>
<p>为了解决这个问题，AspectJ和Spring都允许定义切入点。所谓 定义切入点，其实质就是为一个切入点表达式起一个名称，从而允许在多个增强处理中重用该名称。</p>
<p>Spring AOP 只支持以Spring Bean的方法执行组作为连接点，所以可以把 切入点 看成所有能和切入表达式匹配的Bean方法。</p>
<p>切入点定义包括两个部分：</p>
<ol>
<li>一个切入点表达式：用于指定该切入点和哪些方法进行匹配。</li>
<li>一个包含名字和任意参数的方法签名：作为该切入点的名称。</li>
</ol>
<p>在@AspectJ风格的AOP中，切入点签名 采用一个普通的方法定义(方法体通常为空)，且方法的返回值必须为void；切入点表达式需要使用@Pointcut注解来标注。</p>
<p>下面的代码片段定义了一个切入点，anyOldTransfer，这个切入点将匹配任何名为transfer的方法的执行：<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用@Pointcut注解时指定切入点表达式</span></span><br><span class="line"><span class="annotation">@Pointcut</span>(<span class="string">"execution(* transfer(..))"</span>)</span><br><span class="line"><span class="comment">//使用一个返回值为void，方法体为空的方法来命名切入点</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">anyOldTransfer</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>切入点表达式，也就是组成@Pointcut注解的值，是正规的AspectJ5切入点表达式。如果想要更多了解AspectJ的切入点语法，参见AspectJ编程指南。</p>
<p>一旦采用上面的代码片段定义了名为anyOldTransfer的切入点之后，程序就可以多次重复使用该切入点了，甚至可以在其他切面类、其他包的切面类里使用该切入点，至于是否可以在其他切面类、其他包的切面类里访问该切入点，则取决于该方法签名前的访问控制符—例如，本示例中anyOldTransfer方法使用的是private修饰符，则意味着仅能在当前切面类中使用该切入点。</p>
<p>如果需要使用本切面类中的切入点，则可在使用@Pointcut时，指定value/pointcut属性值为已有的切入点，如下所示：<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@AfterReturning</span>(pointcut=<span class="string">"myPointcut()"</span>,returning=<span class="string">"retVal"</span>)</span><br><span class="line">public <span class="keyword">void</span> writeLog(<span class="built_in">String</span> msg,<span class="built_in">Object</span> retVal)&#123;</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看出，指定切入点时非常像调用Java方法的语法———只是该方法代表一个切入点，其实质是为该增强处理定义一个切入点表达式。</p>
<p>如果需要使用其他切面类中的切入点，则其他切面类中的切入点不能使用private修饰。如下程序的切面类中仅定义了一个切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemArchitecture</span></span>&#123;</span><br><span class="line">   <span class="annotation">@Pointcut</span>(<span class="string">"execution(* org.crazyit.app.service.impl.Chin*.say*(..))"</span>)</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">myPointcut</span><span class="params">()</span></span>&#123;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面的切面类中将直接使用上面定义的myPointcut切入点：<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Aspect</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">LogAspect</span> &#123;</span><br><span class="line">    @AfterReturning(pointcut=<span class="string">"SystemArchitecture.myPointcut()&amp;&amp; args(msg)"</span>,returning=<span class="string">"retVal"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeLog</span>(<span class="params">String msg,Object retVal</span>)</span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(msg);</span><br><span class="line">        System.<span class="keyword">out</span>.println(retVal);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"模拟记录日志..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="切入点指示符">切入点指示符</h4><p>前面定义切点表达式时使用了大量的execution表达式，其中execution就是一个切入点指示符。Spring AOP仅支持部分AspectJ的切入点指示符，但Spring AOP还额外支持一个bean切入点指示符。不仅如此，因为Spring AOP只支持使用方法调用作为连接点，所以Spring AOP的切入点指示符仅匹配方法执行的连接点。</p>
<p>完整的AspectJ切入点语言支持大量切入点指示符，但是Spring并不支持它们。它们是：call，get，preinitialization，staticinitialization，initialization，handler，adviceexecution，withincode，cflow，cflowbelow，if，@this和@withincode。一旦在Spring AOP中使用这些切点指示符，就会抛出IllegalArgumentException。</p>
<p>Spring AOP支持的切入点指示符有如下几个：</p>
<ul>
<li><p>execution：用于匹配执行方法的连接点，这是Spring AOP中最主要的切入点指示符。该切入点的用法也相对复杂，execution表达式的格式如下：</p>
<p>  execution(modifier-pattern? ret-type-pattern declaring-type-pattern? name-pattern(param-pattern) throws-pattern?)</p>
<p>  上面的格式中，execution是不变的，用于作为execution表达式的开头，整个表达式中几个参数的详细解释如下：</p>
<ul>
<li>modifier-pattern：指定方法的修饰符，支持通配符，该部分可以省略</li>
<li>ret-type-pattern：指定返回值类型，支持通配符，可以使用“*”来通配所有的返回值类型</li>
<li>declaring-type-pattern：指定方法所属的类，支持通配符，该部分可以省略</li>
<li>name-pattern：指定匹配的方法名，支持通配符，可以使用“*”来通配所有的方法名</li>
<li>param-pattern：指定方法的形参列表，支持两个通配符，“<em>”和“..”，其中“</em>”代表一个任意类型的参数，而“..”代表0个或多个任意类型的参数。</li>
<li>throw-pattern：指定方法声明抛出的异常，支持通配符，该部分可以省略</li>
</ul>
</li>
</ul>
<p>如下是几个execution表达式：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">execution</span><span class="params">(public * * (..)</span></span>)<span class="comment">//匹配所有public方法</span></span><br><span class="line"><span class="function"><span class="title">execution</span><span class="params">(* set*(..)</span></span>)<span class="comment">//匹配以set开始的方法</span></span><br><span class="line"><span class="function"><span class="title">execution</span><span class="params">(* com.abc.service.AdviceManager.* (..)</span></span>)<span class="comment">//匹配AdviceManager中任意方法</span></span><br><span class="line"><span class="function"><span class="title">execution</span><span class="params">(* com.abc.service.*.* (..)</span></span>)<span class="comment">//匹配com.abc.servcie包中任意类的任意方法</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>within：限定匹配特定类型的连接点，当使用Spring AOP的时候，只能匹配方法执行的连接点。下面是几个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">within</span><span class="params">(com.abc.service.*)</span></span><span class="comment">//匹配com.abc.service包中的任意连接点</span></span><br><span class="line"><span class="function"><span class="title">within</span><span class="params">(com.abc.service..*)</span></span><span class="comment">//匹配com.abc.service包或子包中任意的连接点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>this：用于指定AOP代理必须是指定类型的实例，用于匹配该对象的所有连接点。当使用Spring AOP的时候，只能匹配方法执行的连接点。下面是个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">this</span><span class="params">(com.abc.service.AdviceManager)</span></span><span class="comment">//匹配实现了AdviceManager接口的代理对象的所有连接点，在Spring中只是方法执行的连接点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>target：用于限定目标对象必须是指定类型的实例，用于匹配该对象的所有连接点。当使用Spring AOP的时候，只能匹配方法执行的连接点。下面是个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">target</span><span class="params">(com.abc.servcie.AdviceManager)</span></span><span class="comment">//匹配实现了AdviceManager接口的目标对象的所有连接点，在Spring中只是方法执行的连接点</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>args：用于对连接点的参数类型进行限制，要求参数的类型时指定类型的实例。同样，当使用Spring AOP的时候，只能匹配方法执行的连接点。下面是个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">args</span><span class="params">(java.io.Serializable)</span></span><span class="comment">//匹配只接受一个参数，且参数类型是Serializable的所有连接点，在Spring中只是方法执行的连接点</span></span><br></pre></td></tr></table></figure>
<p>  注意，这个例子与使用execution(<em> </em>(java.io.Serializable))定义的切点不同，args版本只匹配运行时动态传入参数值是Serializable类型的情形，而execution版本则匹配方法签名只包含一个Serializable类型的形参的方法。</p>
<p>  另外，Spring AOP还提供了一个名为bean的切入点提示符，它是Spring AOP额外支持的，并不是AspectJ所支持的切入点指示符。这个指示符对Spring框架来说非常有用：它将指定为Spring中的哪个Bean织入增强处理。当然，Spring AOP中只能使用方法执行作为连接点。</p>
</li>
<li><p>bean：用于指定只匹配该Bean实例内的连接点，实际上只能使用方法执行作为连接点。定义bean表达式时需要传入Bean的id或name，支持使用”*”通配符。下面是几个例子：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">bean</span><span class="params">(adviceManager)</span></span><span class="comment">//匹配adviceManager实例内方法执行的连接点</span></span><br><span class="line"><span class="function"><span class="title">bean</span><span class="params">(*Manager)</span></span><span class="comment">//匹配以Manager结尾的实例内方法执行的连接点</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="使用组合切点表达式">使用组合切点表达式</h4><p>Spring支持使用如下三个逻辑运算符来组合切入点表达式：</p>
<ul>
<li>&amp;&amp;：要求连接点同时匹配两个切点表达式</li>
<li>||：要求连接点匹配至少一个切入点表达式</li>
<li>!：要求连接点不匹配指定的切入点表达式</li>
</ul>
<p>其实在之前介绍args的时候，已经用到了“&amp;&amp;”运算符：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">pointcut</span><span class="params">(<span class="string">"execution(* com.abc.service.*.*(..) &amp;&amp; args(name))"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>上面的pointcut由两个表达式组成，而且使用&amp;&amp;来组合这两个表达式，因此连接点需要同时满足这两个表达式才能被织入增强处理。</p>
<h3 id="基于XML配置文件的管理方式">基于XML配置文件的管理方式</h3><p>在Spring的配置文件中，所有的切面、切点和增强处理都必须定义在<code>&lt;aop:config../&gt;</code>元素内部。<code>&lt;beans../&gt;</code>元素可以包含多个<code>&lt;aop:config../&gt;</code>元素，一个<code>&lt;aop:config../&gt;</code>可以包含pointcut、advisor和aspect元素，且这三个元素需要按照此顺序来定义。</p>
<p>注意：当我们使用<code>&lt;aop:config../&gt;</code>方式进行配置时，可能与Spring的自动代理方式相互冲突，因此，建议要么全部使用<code>&lt;aop:config../&gt;</code>配置方式，要么全部使用自动代理方式，不要把两者混合使用。</p>
<h4 id="配置切面">配置切面</h4><p>配置<code>&lt;aop:config../&gt;</code>元素时，实质是将已有的Spring Bean转换成切面Bean，所以需要先定义一个普通的Spring Bean。因为切面Bean可以当成一个普通的Spring Bean来配置，所以我们完全可以为该切面Bean配置依赖注入。当切面Bean的定义完成后，通过<code>&lt;aop:congig../&gt;</code>元素中使用ref属性来引用该Bean，就可以将该Bean转换成切面Bean了。配置<code>&lt;aop:config../&gt;</code>元素时可以指定如下三个属性：</p>
<ul>
<li>id：该切面Bean的标识名</li>
<li>ref：指定将要被转换成切面Bean的的普通Bean的id</li>
<li>order：指定该切面Bean的优先级，值越小，优先级越高</li>
</ul>
<p>如下配置片段定义了一个切面：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义普通的Bean实例 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"afterAdviceBean"</span> <span class="attribute">class</span>=<span class="value">"com.bean.AfterAdviceBean"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 将容器中的afterAdviceBean转换成切面Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:aspect</span> <span class="attribute">id</span>=<span class="value">"afterAdviceAspect"</span> <span class="attribute">ref</span>=<span class="value">"afterAdviceBean"</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="title">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的配置中，将一个AfterAdviceBean类型普通的Bean对象afterAdviceBean转换成了切面Bean对象afterAdviceAspect。</p>
<h4 id="配置增强处理">配置增强处理</h4><p>与使用@AspectJ完全一样，使用XML一样可以配置Before、After、AfterReturning、AfterThrowing和Around 5种增强处理，而且完全支持和@AspectJ完全一样的语义。使用XML配置增强处理分别依赖于如下几个元素：</p>
<ul>
<li><code>&lt;aop:before../&gt;</code>：配置Before增强处理</li>
<li><code>&lt;aop:after../&gt;</code>：配置After增强处理</li>
<li><code>&lt;aop:after-returning../&gt;</code>：配置AfterReturning增强处理</li>
<li><code>&lt;aop:after-throwing../&gt;</code>：配置AfterThrowing增强处理</li>
<li><code>&lt;aop:around../&gt;</code>：配置Around增强处理</li>
</ul>
<p>这些元素都不支持使用子元素，但通常可以指定如下属性：</p>
<ul>
<li>pointcut：指定一个切入点表达式，Spring将在匹配该表达式的连接点织入增强处理</li>
<li>pointcut-ref：指定一个已经存在的切入点名称，通常pointcut和pointcut-ref只需使用其中之一</li>
<li>method：指定一个方法名，指定切面Bean的该方法作为增强处理</li>
<li>throwing：只对<code>&lt;aop:after-throwing../&gt;</code>元素有效，用于指定一个形参名，AfterThrowing增强处理方法，可通过该形参访问目标方法所抛出的异常</li>
<li>returning：只对<code>&lt;aop:after-returning../&gt;</code>元素有效，用于指定一个形参名，AfterThrowing增强处理方法，可通过该形参访问目标方法的返回值</li>
</ul>
<p>定义切点时，XML配置方式和@AspectJ注解方式支持完全相同的切点指示符，一样可以支持execution、within、args、this、target和bean等切点提示符。另外，XML配置文件方式也和@AspectJ方式一样支持组合切入点表达式，但XML配置方式不再使用简单的&amp;&amp;、|| 和 ! 作为组合运算符（因为直接在XML文件中需要使用实体引用来表示他们），而是使用如下三个组合运算符：and（相当于&amp;&amp;）、or（相当于||）和not（相当于！）。 下面是一个使用<code>&lt;aop:congig../&gt;</code>的例子，这是把前面的例子中关于切面切点和增强处理的注解去掉后，使用XML配置文件来重新实现这些切面切点的功能：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"adviceTest"</span> <span class="attribute">class</span>=<span class="value">"com.bean.AdviceTest"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 注意这里可以使用order属性为Aspect指定优先级 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:aspect</span> <span class="attribute">id</span>=<span class="value">"firstAspect"</span> <span class="attribute">ref</span>=<span class="value">"adviceTest"</span> <span class="attribute">order</span>=<span class="value">"2"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @Before切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:before</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span></span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"permissionCheck"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @After切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:after</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span></span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"releaseResource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @AfterReturning切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:after-returning</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span></span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"log"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @AfterThrowing切点 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:after-throwing</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span></span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"handleException"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- @Around切点（多个切点提示符使用and、or或者not连接） --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:around</span> <span class="attribute">pointcut</span>=<span class="value">"execution(* com.abc.service.*.*(..)) and args(name,time,..)"</span></span><br><span class="line">                <span class="attribute">method</span>=<span class="value">"process"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的定义中，特意为firstAspect指定了order=2，表明firstAspect的优先级为2，如果这个XML文件中还有order=1的Aspect，那么这个Aspect将被Spring AOP优先织入。其执行结果，和前面几篇文章中介绍的相同，这里不再给出。</p>
<h4 id="配置切点">配置切点</h4><p>在Spring中通过<code>&lt;aop:pointcut../&gt;</code>元素来定义切点。当把<code>&lt;aop:pointcut../&gt;</code>元素作为<code>&lt;aop:config../&gt;</code>的子元素时，表明该切点可以被多个切面共享；当把<code>&lt;aop:pointcut../&gt;</code>元素作为<code>&lt;aop:aspect../&gt;</code>的子元素时，表明该切点只能在这个切面内使用。配置<code>&lt;aop:pointcut../&gt;</code>时，通常需要配置如下两个属性：</p>
<ul>
<li>id：指定该切点的标识名</li>
<li>expression：指定该切点关联的切点表达式</li>
</ul>
<p>如下的配置定义了一个简单的切点：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:pointcut <span class="variable">id=</span><span class="string">"point1"</span> <span class="variable">expression=</span><span class="string">"execution(* com.bean.service.*.*(..))"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>另外，如果程序中已经使用注解的方式定义了切点，在<code>&lt;aop:pointcut../&gt;</code>元素中指定切入点表达式时还有另一种用法，看例子：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;aop:pointcut <span class="variable">id=</span><span class="string">"point2"</span> <span class="variable">expression=</span><span class="string">"com.bean.AdviceTest.myPointcut()"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>下面的程序中定义了一个AfterThrowing增强处理，包含该增强处理的切面类如下：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">AfterThrowingAdviceTest</span> &#123;</span><br><span class="line">    <span class="comment">//定义一个普通方法作为增强处理方法，这个方法名将在XML配置文件中指定</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doRecoveryAction</span>(<span class="params">Throwable th</span>) </span>&#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"目标方法抛出异常："</span> + th);</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"模拟数据库事务恢复"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>与前面的切面类完全类似，该Java类就是一个普通的Java类。下面的配置文件将负责配置该Bean实例，并将该Bean转换成切面Bean：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"afterThrowingAdviceTest"</span></span><br><span class="line">    <span class="attribute">class</span>=<span class="value">"com.abc.advice.AfterThrowingAdviceTest"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">aop:config</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个切点将可以被多个&lt;aop:aspect../&gt;使用 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:pointcut</span> <span class="attribute">id</span>=<span class="value">"myPointcut"</span></span><br><span class="line">        <span class="attribute">expression</span>=<span class="value">"execution(* com.abc.service.*.*(..))"</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 这个aspect由上面的Bean afterThrowingAdviceTest转化而来 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:aspect</span> <span class="attribute">id</span>=<span class="value">"aspect1"</span> <span class="attribute">ref</span>=<span class="value">"afterThrowingAdviceTest"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义一个AfterThrowing增强处理，指定切入点以切面Bean中</span><br><span class="line">            的doRecoverryAction作为增强处理方法 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:after-throwing</span> <span class="attribute">pointcut-ref</span>=<span class="value">"myPointcut"</span></span><br><span class="line">            <span class="attribute">method</span>=<span class="value">"doRecoveryAction"</span> <span class="attribute">throwing</span>=<span class="value">"th"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">aop:aspect</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面的<code>&lt;aop:pointcut../&gt;</code>元素定义了一个全局的切点myPointcut，这样其他切面Bean就可以多次复用这个切点了。<code>&lt;aop:after-throwing../&gt;</code>元素中，使用pointcut-ref属性指定了一个已经存在的切点。</p>
<h2 id="Spring_的事务">Spring 的事务</h2><h3 id="Spring支持的事务策略">Spring支持的事务策略</h3><p>JavaEE应用的传统事务有两种策略：全局事务和局部事务。</p>
<ul>
<li>全局事务由应用服务器管理，需要底层服务器的JTA支持。</li>
<li>局部事务和底层所采用的持久化技术有关，当采用JDBC持久化技术时，需要使用Connection对象来操作事务；而采用Hibernate持久化技术时，需要使用Session对象来操作事务。</li>
</ul>
<p>当采用传统的事务编程策略时，程序代码必然和具体的事务操作代码耦合，这样造成的后果是：当应用需要在不同的事务策略之间切换时，开发者必须手动修改程序代码。当使用Spring事务策略后，就可以改变这种状况。</p>
<p>Spring事务策略是通过PlatformTransactionManager接口实现的，该接口是Spring事务策略的核心。该接口的源代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> </span>&#123;</span><br><span class="line">   <span class="comment">//平台无关的获得事务的方法</span></span><br><span class="line">   <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(TransactionDefinition definition)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">   <span class="comment">//平台无关的事务提交方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">   <span class="comment">//平台无关的事务回滚方法</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus status)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PlatformTransactionManager是一个与任何事务策略分离的接口，随着底层不同事务策略的切换，应用必须采用不同的实现类。PlatformTransactionManager接口没有与任何事务资源捆绑在一起，它可以适应于任何的事务策略，结合Spring的IoC容器，可以向PlatformTransactionManager注入相关的平台特性。</p>
<p>PlatformTransactionManager接口有许多不同的实现类，应用程序面向于平台无关的接口编程，当底层采用不同的持久层技术时，系统只需使用不同的 PlatformTransactionManager 实现类即可。而这种切换通常由Spring容器负责管理，应用程序既无须与具体的事务API耦合，也无须与特定实现类耦合，从而将应用和持久化技术、事务API彻底分离开来。</p>
<p>TransactionStatus对象表示一个事务。getTransaction(TransactionDefinition definition)返回的TransactionStatus对象，可能是一个新的事务，也可能是一个已经存在的事务对象；否则，系统将新建一个事务对象后返回。</p>
<p>TransactionDefinition接口定义了一个事务规则，该接口必须指定如下几个属性：</p>
<ul>
<li>事务隔离    当前事务和其他事务的隔离程度。例如这个事务能否看到其他事务未提交的数据等。</li>
<li>事务传播    通常，在事务中执行的代码都会在当前事务中运行。但是如果一个事务上下文已经存在，有几个选项可指定该事务性方法的执行行为。例如，大多数情况下，简单地在现有的事务上下文中运行；或者挂起现有事务，创建一个新的事务。Spring提供EJB CMT中所有的事务传播选项。</li>
<li>事务超时    事务在超时前能运行多久，也就是事务的最长持续时间。如果事务一直没有被提交或回滚，将在超出该时间后，系统自动回滚事务。</li>
<li>只读状态    只读事务不修改任何数据。在某些情况下，例如使用Hibernate时，只读事务是非常有用的优化。TransactionStatus代表事务本身，它提供了简单的控制事务执行和查询事务状态的方法，这些方法在所有的事务API中都是相同的：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionStatus</span> <span class="keyword">extends</span> <span class="title">SavepointManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isNewTransaction</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasSavepoint</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isRollbackOnly</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCompleted</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SavepointManager</span> </span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">createSavepoint</span><span class="params">()</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollbackToSavepoint</span><span class="params">(Object savepoint)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">releaseSavepoint</span><span class="params">(Object savepoint)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Spring具体的事务管理由PlatformTransactionManager的不同实现类来完成。在Spring容器中配置PlatformTransactionManager Bean时，必须针对不同环境提供不同的实现类。<br>譬如针对 JDBC数据源 的局部事务策略的配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">        <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">        <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span></span><br><span class="line">        <span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">        <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">                http://www.springframework.org/schema/context</span><br><span class="line">                http://www.springframework.org/schema/context/spring-context-2.5.xsd</span><br><span class="line">                http://www.springframework.org/schema/tx</span><br><span class="line">                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义数据源Bean，使用C3P0数据源实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClass"</span> <span class="attribute">value</span>=<span class="value">"oracle.jdbc.driver.OracleDriver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jdbcUrl"</span> <span class="attribute">value</span>=<span class="value">"jdbc:oracle:thin:@localhost:1521:orcl"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"scott"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"tiger"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxPoolSize"</span> <span class="attribute">value</span>=<span class="value">"40"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"minPoolSize"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"initialPoolSize"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxIdleTime"</span> <span class="attribute">value</span>=<span class="value">"20"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置JDBC数据源的局部事务管理器，使用DataSourceTransactionManager类 --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 该类实现PlatformTransactionManager接口，是针对采用数据源连接的特定实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span></span><br><span class="line">          <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>针对 Hibernate 的局部事务策略的配置文件如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义Hibernate的SessionFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionFactory"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"mappingResources"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>xxx/Xxx.hbm.xml<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernateProperties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLInnoDBDialect<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 配置Hibernate的局部事务管理器，使用HibernateTransactionManager类 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 该类实现PlatformTransactionManager接口，是针对采用Hibernate的特定实现 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span></span><br><span class="line">        <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hibernate3.HibernateTransactionManager"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionFactory"</span> <span class="attribute">ref</span>=<span class="value">"sessionFactory"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>从上面的配置文件可以看出，当采用Spring事务管理策略时，应用程序无须与具体的事务策略耦合。Spring提供了两种事务管理方式：</p>
<ol>
<li>编程式事务管理：即使利用Spring编程式事务时，程序也可直接获取容器中的transactionManager Bean，该Bean总是PlatformTransactionManager的实例，所以可以通过该接口提供的3个方法来开始、提交事务和回滚事务。</li>
<li>声明式事务管理：无须在Java程序中书写任何的事务操作代码，而是通过在XML文件中为业务组件配置事务代理，AOP为事务代理所织入的增强处理也由Spring提供：在目标方法执行之前，织入开始事务；在目标方法执行之后，织入结束事务。</li>
</ol>
<p>不论采用何种持久化策略，Spring都提供了一致的事务抽象，因此，应用开发者能在任何环境下，使用一致的编程模型。无须更改代码，应用就可在不同的事务管理策略中切换。</p>
<h3 id="使用TransactionProxyFactoryBean创建事务代理">使用TransactionProxyFactoryBean创建事务代理</h3><p>Spring同时支持编程式事务策略和声明式事务策略，在实际开发中，几乎都采用声明式事务策略。使用声明式事务策略的优势 十分明显：</p>
<ol>
<li>声明式事务能大大降低开发者的代码书写量，而且声明式事务几乎不影响应用的代码。因此，无论底层事务策略如何变化，应用程序都无须任何改变。</li>
<li>应用程序代码无须任何事务处理代码，可以更关注于业务逻辑的实现。</li>
<li>Spring可对任何POJO的方法提供事务管理，而且Spring的声明式事务管理无须容器的支持，可在任何环境下使用。</li>
<li>EJB的CMT无法提供声明式回滚规则；而通过配置文件，Spring可指定事务在遇到特定异常时自动回滚。Spring不仅可在代码中使用setRollbackOnly回滚事务，也可在配置文件中配置回滚规则。</li>
<li>由于Spring采用AOP方式管理事务，因此可以在事务回滚动作中插入用户自己的动作，而不仅仅是执行系统默认的回滚。</li>
</ol>
<p>在Spring1.x中，声明式事务使用 TransactionProxyFactoryBean 来配置事务代理Bean。每个TransactionProxyFactoryBean为一个目标Bean生成一个事务代理Bean，事务代理的方法改写了目标Bean的方法，就是在目标Bean的方法执行之前加入开始事务，在目标Bean的方法正常结束之后提交事务，如果遇到特定异常则回滚事务。</p>
<p>TransactionProxyFactoryBean创建事务代理时，需要了解当前事务所处的环境，该环境属性通过PlatformTransactionManager实例传入，而相关事务规则则在该Bean定义中给出。</p>
<p>NewsDao.java :<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="interface"><span class="keyword">interface</span> NewsDao </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">void</span> insert(Integer id,<span class="built_in">String</span> title,<span class="built_in">String</span> content);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>NewsDaoImpl.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsDaoImpl</span> <span class="keyword">implements</span> <span class="title">NewsDao</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource ds;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDs</span><span class="params">(DataSource ds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ds = ds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Integer id, String title, String content)</span> </span>&#123;</span><br><span class="line">        JdbcTemplate jt=<span class="keyword">new</span> JdbcTemplate(ds);</span><br><span class="line">        jt.update(<span class="string">"insert into news values(?,?,?)"</span>,<span class="keyword">new</span> Object[]&#123;id,title,content&#125;);</span><br><span class="line">        jt.update(<span class="string">"insert into news values(?,?,?)"</span>,<span class="keyword">new</span> Object[]&#123;id,title,content&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>bean.xml :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">        <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">        <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span></span><br><span class="line">        <span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">        <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">                http://www.springframework.org/schema/context</span><br><span class="line">                http://www.springframework.org/schema/context/spring-context-2.5.xsd</span><br><span class="line">                http://www.springframework.org/schema/tx</span><br><span class="line">                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义数据源Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClass"</span> <span class="attribute">value</span>=<span class="value">"oracle.jdbc.driver.OracleDriver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jdbcUrl"</span> <span class="attribute">value</span>=<span class="value">"jdbc:oracle:thin:@localhost:1521:orcl"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"scott"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"tiger"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxPoolSize"</span> <span class="attribute">value</span>=<span class="value">"40"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"minPoolSize"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"initialPoolSize"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxIdleTime"</span> <span class="attribute">value</span>=<span class="value">"20"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置一个业务逻辑Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"newsDao"</span> <span class="attribute">class</span>=<span class="value">"com.bean.NewsDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"ds"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置JDBC数据源的局部事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span></span><br><span class="line">          <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 为业务逻辑Bean配置事务代理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"newsDaoTrans"</span></span><br><span class="line">          <span class="attribute">class</span>=<span class="value">"org.springframework.transaction.interceptor.TransactionProxyFactoryBean"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"transactionManager"</span> <span class="attribute">ref</span>=<span class="value">"transactionManager"</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"target"</span> <span class="attribute">ref</span>=<span class="value">"newsDao"</span>/&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"transactionAttributes"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"*"</span>&gt;</span>PROPAGATION_REQUIRED<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">props</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        ApplicationContext ctx=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        NewsDao dao=(NewsDao) ctx.getBean(<span class="string">"newsDaoTrans"</span>);</span><br><span class="line">        dao.insert(<span class="number">1</span>,<span class="string">"夺冠"</span>,<span class="string">"绿衫军夺冠"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可以知道，插入数据失败。上面程序中违反主键约束，该行代码将引发异常。</p>
<p>如果在没有事务控制的环境下，前一条代码将会向数据表中插入一条记录，第二条插入失败。但是现在一条记录都没有插入，这说明事务起作用了，这两条语句是一个整体，因为第二条插入失败，导致第一条插入的数据也被回滚。</p>
<p>配置事务代理 时需要传入一个事务管理器，一个目标Bean，并指定该事物代理的事务属性，事务属性由transactionAttributes属性指定。上面事务属性只有一条事务传播规则，该规则指定对于所有方法都使用PROPAGATION_REQUIRED的传播规则。Spring支持的事务传播规则如下：</p>
<ul>
<li>PROPAGATION_MANDATORY    要求调用该方法的线程必须处于事务环境中，否则抛出异常。</li>
<li>PROPAGATION_NESTED    如果执行该方法的线程已经处于事务环境下，依然启动新的事务，方法在嵌套的事务里执行。如果执行该方法的线程并未处于事务中，也启动新的事务，然后执行该方法，次时与PROPAGATION_REQUIRED相同。</li>
<li>PROPAGATION_NEVER    不允许调用该方法的线程处于事务环境下，如果调用该方法的线程处于事务环境下，则抛出异常。</li>
<li>PROPAGATION_NOT_SUPPORTED    如果调用该方法的线程处在事务中，则先暂停当前事务，然后执行该方法。</li>
<li>PROPAGATION_REQUIRED    要求在事务环境中执行该方法，如果当前执行线程已经处于事务中，则直接调用；如果当前执行线程不处于事务中，则启动新的事务后执行该方法。</li>
<li>PROPAGATION_REQUIRES_NEW    该方法要求在新的事务环境中执行，如果当前执行线程已经处于事务中，则先暂停当前事务，启动新事务后执行该方法；如果当前调用线程不处于事务中，则启动新的事务后执行方法。</li>
<li>PROPAGATION_SUPPORTS    如果当前执行线程处于事务中，则使用当前事务，否则不使用事务。</li>
</ul>
<h3 id="Spring2-x的事务配置策略">Spring2.x的事务配置策略</h3><p>Spring1.x 的声明式事务使用TransactionProxyFactoryBean配置策略简单易懂，但是配置起来极为繁琐：每个目标Bean都需要额外配置一个TransactionProxyFactoryBean代理，这种方式将导致配置文件急剧增加。</p>
<p>Spring 2.x 的XML Schema方式提供了更简洁的事务配置策略，Spring2.x提供了tx命名空间来配置事务管理，tx命名空间下提供了<code>&lt;tx:advice.../&gt;</code> 元素来配置事务增强处理，一旦使用该元素配置了事务增强处理，就可直接使用<code>&lt;aop:advisor.../&gt;</code> 元素启用自动代理了。</p>
<p>bean.xml :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">        <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">        <span class="attribute">xmlns:context</span>=<span class="value">"http://www.springframework.org/schema/context"</span></span><br><span class="line">        <span class="attribute">xmlns:aop</span>=<span class="value">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">        <span class="attribute">xmlns:tx</span>=<span class="value">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">        <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans</span><br><span class="line">        http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">                http://www.springframework.org/schema/context</span><br><span class="line">                http://www.springframework.org/schema/context/spring-context-2.5.xsd</span><br><span class="line">                http://www.springframework.org/schema/tx</span><br><span class="line">                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</span><br><span class="line">                http://www.springframework.org/schema/aop</span><br><span class="line">                http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义数据源Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClass"</span> <span class="attribute">value</span>=<span class="value">"oracle.jdbc.driver.OracleDriver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jdbcUrl"</span> <span class="attribute">value</span>=<span class="value">"jdbc:oracle:thin:@localhost:1521:orcl"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"scott"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"tiger"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxPoolSize"</span> <span class="attribute">value</span>=<span class="value">"40"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"minPoolSize"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"initialPoolSize"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxIdleTime"</span> <span class="attribute">value</span>=<span class="value">"20"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置一个业务逻辑Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"newsDao"</span> <span class="attribute">class</span>=<span class="value">"com.bean.NewsDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"ds"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置JDBC数据源的局部事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"transactionManager"</span></span><br><span class="line">          <span class="attribute">class</span>=<span class="value">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置事务增强处理Bean，指定事务管理器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">tx:advice</span> <span class="attribute">id</span>=<span class="value">"txAdvice"</span> <span class="attribute">transaction-manager</span>=<span class="value">"transactionManager"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 所有以'get'开头的方法是只读的 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">tx:method</span> <span class="attribute">name</span>=<span class="value">"get*"</span> <span class="attribute">read-only</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 其他方法使用默认的事务处理 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">tx:method</span> <span class="attribute">name</span>=<span class="value">"*"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">tx:advice</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- AOP配置的元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:pointcut</span> <span class="attribute">id</span>=<span class="value">"myPointcut"</span> <span class="attribute">expression</span>=<span class="value">"execution(* com.bean.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">aop:advisor</span> <span class="attribute">advice-ref</span>=<span class="value">"txAdvice"</span> <span class="attribute">pointcut-ref</span>=<span class="value">"myPointcut"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">aop:config</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Test.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Test</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">        ApplicationContext ctx=<span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        NewsDao dao=(NewsDao) ctx.getBean(<span class="string">"newsDao"</span>);</span><br><span class="line">        dao.insert(<span class="number">1</span>,<span class="string">"夺冠"</span>,<span class="string">"绿衫军夺冠"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>可见，事务已经自动启动了。两条记录是一个事务，第二条记录插入失败，导致第一条记录也被回滚。</p>
<p>配置 <code>&lt;tx:advice.../&gt;</code> 元素时只需指定一个transaction-manager属性，该属性的默认值是“transactionManager”。除了transaction-manager属性之外，还需要配置一个attributes子元素，该子元素里又可包含多个method子元素，每个<code>&lt;method.../&gt;</code>子元素为一批方法指定所需的事务语义，包括事务传播属性、事务隔离属性、事务超时属性、只读事务、对指定异常回滚，对指定异常不回滚等。</p>
<p>配置method子元素时可以指定如下几个属性：</p>
<ul>
<li>name    必选属性，与该事务语义关联的方法名。该属性支持使用通配符，例如get<em>，handle</em>等。</li>
<li>propagation    指定事务传播行为，该属性值可为Propagation枚举类的任一枚举值，默认为Propagation_REQUIRED。</li>
<li>isolation    指定事务隔离级别。该属性值可为Isolation枚举类的任一枚举值，默认为Isolation_DEFAULT。</li>
<li>timeout    指定事务超时的时间(以秒为单位)。指定-1意味着不超时，默认值为-1。</li>
<li>read-only    指定事务是否只读。默认为false。</li>
<li>rollback-for    指定触发事务回滚的异常类，可指定多个异常类，以英文逗号隔开。</li>
<li>no-rollback-for    指定不触发事务回滚的异常类，可指定多个异常类，以英文逗号隔开。</li>
</ul>
<h3 id="使用@Transactional">使用@Transactional</h3><p>Spring 还允许将事务配置放在Java类中定义，这需要借助于@Transactional注解，该注解既可用于修饰Spring Bean类，也可用于修饰Bean类中的某个方法。</p>
<p>使用@Transactional修饰Bean类，表明这些事务设置对整个Bean类起作用；<br>使用@Transactional修饰Bean类中的某个方法，表明这些事务设置只对该方法有效。<br>使用@Transactional 时可指定如下属性：</p>
<ul>
<li>isolation    用于指定事务的隔离级别，默认为底层事务的隔离级别。</li>
<li>noRollbackFor    指定遇到指定异常时强制不回滚事务。</li>
<li>noRollbackForClassName    指定遇到指定多个异常时强制不回滚事务，该属性值可以指定多个异常类名。</li>
<li>propagation    指定事务传播属性。</li>
<li>readOnly    指定事务是否只读。</li>
<li>rollbackFor    指定遇到特定异常时强制回滚事务。</li>
<li>rollbackForClassName    指定遇到指定多个异常时强制回滚事务，该属性值可以指定多个异常类名。</li>
<li>timeout    指定事务的超时时长。 例如：</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NewsDaoImpl</span> <span class="keyword">implements</span> <span class="title">NewsDao</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> DataSource ds;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDs</span><span class="params">(DataSource ds)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ds = ds;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Transactional</span>(propagation=Propagation.REQUIRED)<span class="comment">//这里</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(Integer id, String title, String content)</span> </span>&#123;</span><br><span class="line">        JdbcTemplate jt=<span class="keyword">new</span> JdbcTemplate(ds);</span><br><span class="line">        jt.update(<span class="string">"insert into news values(?,?,?)"</span>,<span class="keyword">new</span> Object[]&#123;id,title,content&#125;);</span><br><span class="line">        jt.update(<span class="string">"insert into news values(?,?,?)"</span>,<span class="keyword">new</span> Object[]&#123;id,title,content&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仅仅使用这个Annotation修饰还不够，还需要让Spring根据Annotation来配置事务代理，所以还需要在Spring配置文件中增加如下配置片段：<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"transactionManager"</span></span><br><span class="line">          class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"dataSource"</span> <span class="keyword">ref</span>=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;tx:annotation-driven transaction-manager=<span class="string">"transactionManager"</span>/&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Spring整合Struts2">Spring整合Struts2</h2><h3 id="启动Spring容器">启动Spring容器</h3><p>实际开发中，项目多数会选择使用Spring整合Struts2框架。对于使用Spring框架的Web应用，我们不能手动创建Spring容器，而是通过配置文件，声明式地创建Spring容器。为了让Spring容器随着Web应用的启动而自动地创建起来，可以借助于ServletContextListener监听器完成，该监听器可以在Web应用启动时回调自定义方法从而创建Spring容器。</p>
<p>Spring提供了一个ContextLoaderListener，该监听器类实现了ServletContextListener接口，可以作为监听器使用。那么该监听器类的回调方法根据什么东西创建Spring容器呢？答案当然是Spring的配置文件。如果有多个配置文件需要载入，考虑使用<code>&lt;context-param.../&gt;</code>元素来确定配置文件。ContextLoaderListener加载时，会查找名为contextConfigLocation的初始化参数，因此配置<code>&lt;context-param.../&gt;</code>时应指定参数名为contextConfigLocation。参数值为Spring的多个配置文件，文件之间以逗号隔开。</p>
<p>Spring根据指定配置文件创建WebApplicationContext对象，并将其保存在Web应用的ServletContext中。如果要获得Spring容器对象，可以通过如下代码：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">WebApplicationContext ctx=  WebApplicationContextUtils.getWebApplicationContext(servletContext)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>web.xml :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">web-app</span> <span class="attribute">version</span>=<span class="value">"2.4"</span></span><br><span class="line">    <span class="attribute">xmlns</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee"</span></span><br><span class="line">    <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">    <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://java.sun.com/xml/ns/j2ee</span><br><span class="line">    http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="title">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">param-value</span>&gt;</span>classpath:beans.xml<span class="tag">&lt;/<span class="title">param-value</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">context-param</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">listener</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="tag">&lt;/<span class="title">listener-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">listener</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="title">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="title">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="title">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="title">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>index.jsp :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">a</span> <span class="attribute">href</span>=<span class="value">"test"</span>&gt;</span>点击我<span class="tag">&lt;/<span class="title">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>ok.jsp :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">操作成功，已获得Spring容器实例,控制台已经输出了容器对象...</span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>struts.xml :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE struts PUBLIC</span><br><span class="line">    "-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN"</span><br><span class="line">    "http://struts.apache.org/dtds/struts-2.1.7.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">struts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"demo"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"test"</span> <span class="attribute">class</span>=<span class="value">"com.action.TestAction"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">result</span>&gt;</span>/ok.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">struts</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>TestAction.java :<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">TestAction</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ActionSupport</span> &#123;</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public <span class="type">String</span> execute() <span class="keyword">throws</span> <span class="type">Exception</span> &#123;</span><br><span class="line">        <span class="type">ServletContext</span> servletContext=<span class="type">ServletActionContext</span>.getServletContext();</span><br><span class="line">        <span class="type">WebApplicationContext</span> ctx=</span><br><span class="line">            <span class="type">WebApplicationContextUtils</span>.getWebApplicationContext(servletContext);</span><br><span class="line">        <span class="type">System</span>.out.println(ctx);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果将Spring的配置文件放在WEB-INF目录下：</p>
<p>则修改web.xml的<param-value>的值为：<br><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;context-<span class="built_in">param</span>&gt;</span><br><span class="line">  &lt;<span class="built_in">param</span>-name&gt;contextConfigLocation&lt;/<span class="built_in">param</span>-name&gt;</span><br><span class="line">  &lt;<span class="built_in">param</span>-<span class="built_in">value</span>&gt;/WEB-INF/beans.xml&lt;/<span class="built_in">param</span>-<span class="built_in">value</span>&gt;</span><br><span class="line">&lt;/context-<span class="built_in">param</span>&gt;</span><br></pre></td></tr></table></figure></param-value></p>
<h3 id="MVC框架与Spring整合的思考">MVC框架与Spring整合的思考</h3><p>对于一个基于B/S架构的JavaEE应用而言，用户请求总是向MVC框架的控制器请求，而当控制器拦截到用户请求后，必须调用业务逻辑组件来处理用户请求。此时有一个问题：控制器应该如何获得业务逻辑组件？</p>
<p>最容易想到的策略是，直接通过 new 关键字创建业务逻辑组件，然后调用业务逻辑组件的方法，根据业务逻辑方法的返回值确定结果。</p>
<p>在实际开发中，很少采用上面的策略，因为这是一种非常差的策略。原因有三：</p>
<ol>
<li>控制器直接创建业务逻辑组件，导致控制器和业务逻辑组件的耦合降低到代码层次，不利于高层次解耦。</li>
<li>控制器不应该负责业务逻辑组件的创建，控制器只是业务逻辑组件的使用者，无须关心业务逻辑组件的实现。</li>
<li>每次创建新的业务逻辑组件导致性能下降。</li>
</ol>
<p>对于轻量级的JavaEE应用，工厂模式 则是更实际的策略。因为在轻量级JavaEE应用中，业务逻辑组件不是EJB，通常就是一个POJO，业务逻辑组件的生成通常应由工厂负责，而且工厂可以保证该组件的实例只有一个，这样就可以避免重复实例化造成的系统开销。</p>
<p>采用工厂模式，将控制器和业务逻辑组件的实现分离，从而提供更好的解耦。在采用工厂模式的访问策略中，所有的业务逻辑组件的创建由工厂负责，业务逻辑组件的运行也由工厂负责。控制器只需定位工厂实例即可。</p>
<p>如果系统采用 Spring框架，则Spring成为最大的工厂。Spring负责业务逻辑组件的创建和生成，并可管理业务逻辑组件的生命周期。可以如此理解：Spring是个性能非常优秀的工厂，可以生产出所有的实例，从业务逻辑组件，到持久层组件，甚至控制器组件。</p>
<p>现在的问题是：控制器如何访问到Spring容器中的业务逻辑组件呢？有两种策略：</p>
<ol>
<li>Spring容器负责管理控制器Action，并利用依赖注入为控制器注入业务逻辑组件。</li>
<li>利用Spring的自动装配，Action将会自动从Spring容器中获取所需的业务逻辑组件。</li>
</ol>
<h3 id="让Spring容器管理控制器">让Spring容器管理控制器</h3><p>web.xml如前所示。<br>index.jsp :<br><figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">&lt;form action=<span class="string">"add"</span> <span class="keyword">method</span>=<span class="string">"post"</span>&gt;</span><br><span class="line">部门名称:&lt;input <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"dname"</span>&gt;&lt;br&gt;</span><br><span class="line">部门地址:&lt;input <span class="keyword">type</span>=<span class="string">"text"</span> name=<span class="string">"loc"</span>&gt;&lt;br&gt;</span><br><span class="line">&lt;input <span class="keyword">type</span>=<span class="string">"submit"</span> value=<span class="string">"提交"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure></p>
<p>ok.jsp :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">部门信息添加成功...</span><br><span class="line"><span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Dept.java :<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> Dept &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> dname;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> loc;</span><br><span class="line">    <span class="comment">//setter .. getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DeptDAO.java :<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title">DeptDAO</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span>(<span class="params">Dept dept</span>)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DeptDAOImpl.java :<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DeptDAOImpl</span> <span class="keyword">implements</span> <span class="title">DeptDAO</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(Dept dept)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"将Dept对象保存进数据库"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>AddDeptAction.java :<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">AddDeptAction</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">ActionSupport</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> dname;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">String</span> loc;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">DeptDAO</span> deptDao;</span><br><span class="line">    public <span class="type">String</span> execute()&#123;</span><br><span class="line">        <span class="type">Dept</span> dept=<span class="keyword">new</span> <span class="type">Dept</span>();</span><br><span class="line">        dept.setDname(dname);</span><br><span class="line">        dept.setLoc(loc);</span><br><span class="line">        deptDao.save(dept);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//setter ... getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>struts.xml :<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE struts PUBLIC</span><br><span class="line">    "-//Apache Software Foundation//DTD Struts Configuration 2.1.7//EN"</span><br><span class="line">    "http://struts.apache.org/dtds/struts-2.1.7.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">struts</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">package</span> <span class="attribute">name</span>=<span class="value">"demo"</span> <span class="attribute">extends</span>=<span class="value">"struts-default"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">action</span> <span class="attribute">name</span>=<span class="value">"add"</span> <span class="attribute">class</span>=<span class="value">"addDeptAction"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">result</span>&gt;</span>/ok.jsp<span class="tag">&lt;/<span class="title">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">action</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">struts</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>beans.xml :<br><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml <span class="variable">version=</span><span class="string">"1.0"</span> <span class="variable">encoding=</span><span class="string">"UTF-8"</span>?&gt;</span><br><span class="line">&lt;beans <span class="variable">xmlns=</span><span class="string">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">        xmlns:<span class="variable">xsi=</span><span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">        xmlns:<span class="variable">context=</span><span class="string">"http://www.springframework.org/schema/context"</span></span><br><span class="line">        xmlns:<span class="variable">aop=</span><span class="string">"http://www.springframework.org/schema/aop"</span></span><br><span class="line">        xmlns:<span class="variable">tx=</span><span class="string">"http://www.springframework.org/schema/tx"</span></span><br><span class="line">        xsi:<span class="variable">schemaLocation=</span><span class="string">"http://www.springframework.org/schema/beans</span><br><span class="line">                http://www.springframework.org/schema/beans/spring-beans-2.5.xsd</span><br><span class="line">                http://www.springframework.org/schema/context</span><br><span class="line">                http://www.springframework.org/schema/context/spring-context-2.5.xsd</span><br><span class="line">                http://www.springframework.org/schema/tx</span><br><span class="line">                http://www.springframework.org/schema/tx/spring-tx-2.5.xsd</span><br><span class="line">                http://www.springframework.org/schema/aop</span><br><span class="line">                http://www.springframework.org/schema/aop/spring-aop-2.5.xsd"</span>&gt;</span><br><span class="line">    &lt;bean <span class="variable">id=</span><span class="string">"addDeptAction"</span> <span class="variable">class=</span><span class="string">"com.action.AddDeptAction"</span> <span class="variable">scope=</span><span class="string">"prototype"</span>&gt;</span><br><span class="line">        &lt;property <span class="variable">name=</span><span class="string">"deptDao"</span> <span class="variable">ref=</span><span class="string">"dao"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    &lt;bean <span class="variable">id=</span><span class="string">"dao"</span> <span class="variable">class=</span><span class="string">"com.dao.DeptDAOImpl"</span>/&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="Spring整合Hibernate">Spring整合Hibernate</h2><h3 id="Spring提供的DAO支持">Spring提供的DAO支持</h3><p>DAO模式 是一种标准的Java EE设计模式，DAO模式的核心思想是：所有的数据库访问，都通过DAO组件完成，DAO组件封装了数据库的增删改等原子操作。业务逻辑组件依赖于DAO组件提供的数据库原子操作，完成系统业务逻辑的实现。</p>
<p>DAO组件是整个Java EE应用的持久层访问的重要组件，每个JavaEE应用的底层实现都难以离开DAO组件的支持。Spring对实现DAO组件提供了许多工具类，系统的DAO组件可通过继承这些工具类完成，从而可以更加简便地实现DAO组件。</p>
<p>Spring提供了一系列的抽象类，这些抽象类将被作为应用中DAO实现类的父类。通过继承这些抽象类，Spring简化了DAO的开发步骤，能以一致的方式使用数据库访问技术。不管底层采用JDBC还是Hibernate，应用中都可采用一致的编程模型。</p>
<p>除外之外，Spring通过了一致的异常抽象，将原有的checked异常转换包装成Runtime异常，因而，编码时无须捕获各种技术中特定的异常。Spring DAO体系中的异常，都继承DataAccessException，而DataAccessException异常是Runtime的，无须显式捕捉。通过DataAccessException的子类包装原始异常信息，从而保证应用程序依然可以捕捉到原始异常信息。</p>
<h3 id="管理Hibernate的SessionFactory">管理Hibernate的SessionFactory</h3><p>在实际开发中，我们直接以配置文件来管理SessionFactory实例。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 定义Hibernate的SessionFactory --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionFactory"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hibernate3.LocalSessionFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"mappingResources"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">value</span>&gt;</span>xxx/Xxx.hbm.xml<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernateProperties"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.MySQLInnoDBDialect<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="使用HibernateTemplate">使用HibernateTemplate</h3><p>HibernateTemplate文档中的一句话：</p>
<p>NOTE: As of Hibernate 3.0.1, transactional Hibernate access code can also be coded in plain Hibernate style. Hence, for newly started projects,consider adopting the standard Hibernate3 style of coding data access objects instead, based on SessionFactory.getCurrentSession().(Spring’s LocalSessionFactoryBean automatically supports Spring transaction management for the Hibernate3 getCurrentSession() method.)作者说：在新开始的工程，可以考虑用标准的Hibernate3的编码方式作为HibernateTemplate的替代。因为Hibernate3提供的SessionFactory.getCurrentSession()已经取代了以往那种每次操作都open一个新Session的方式，同时Spring的LocalSessionFactoryBean自动支持Hibernate3的getCurrentSession()的事务管理。也就是说，如果不用HibernateTemplate这咱Spring的专有API，而只用Hibernate3,我们一样可以受用Spring的事务管理。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">puclic class PersonDaoImpl implements PersonDao &#123;</span><br><span class="line">    private HibernateTemplate ht = null;</span><br><span class="line">    @Resource(name=<span class="string">"sessionFactory"</span>)</span><br><span class="line">    private SessionFactory sessionFactory;</span><br><span class="line"></span><br><span class="line">    private HibernateTemplate getHibernateTemplate()&#123;</span><br><span class="line">        if(ht==null)&#123;</span><br><span class="line">            ht = new HibernateTemplate(sessionFactory);</span><br><span class="line">        &#125;</span><br><span class="line">        return ht;</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="keyword">Person</span> get(Integer id)&#123;</span><br><span class="line">        return getHibernateTemplate().get(<span class="keyword">Person</span>.class,id);</span><br><span class="line">    &#125;</span><br><span class="line">    //....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常用方法<br>delete(Object entity)：删除指定持久化实例<br>deleteAll(Collection entities)：删除集合内全部持久化类实例<br>find(String queryString)：根据HQL查询字符串来返回实例集合  //from Person,返回Person的全部实例 ；select p.name,p.password from Person 则返回Object对象， select后要new select new Person（p.name,p.password）from Pserson p<br>findByNamedQuery(String queryName)：根据命名查询返回实例集合<br>get(Class entityClass, Serializable id)：根据主键加载特定持久化类的实例<br>save(Object entity)：保存新的实例<br>saveOrUpdate(Object entity)：根据实例状态，选择保存或者更新<br>update(Object entity)：更新实例的状态，要求entity是持久状态<br>setMaxResults(int maxResults)：设置分页的大小</p>
<h3 id="使用HibernateCallback">使用HibernateCallback</h3><p>弥补HibernateTemplate灵活性不足。HibernateTemplate还提供一种更加灵活的方式来操作数据库，通过这种方式可以完全使用Hibernate的操作方式。这种灵活方式主要是通过如下两个方法完成的：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object <span class="function"><span class="title">execute</span><span class="params">(HibernateCallback action)</span></span></span><br><span class="line">List <span class="function"><span class="title">executeFind</span><span class="params">(HibernateCallback action)</span></span></span><br></pre></td></tr></table></figure>
<p>HibernateCallback是个接口，该接口包含一个方法doInHibernate(org.hibernate.Session session)，该方法只有一个参数Session。</p>
<p>在doInHibernate方法内可访问Session，该Session对象是绑定到该线程的Session实例。在该方法内的持久层操作，与不使用Spring时的持久化操作完全相同。这保证了对于复杂的持久化层访问，依然可以使用Hibernate的访问方式。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">使用hql进行分页查询</span><br><span class="line">@param hql 需要查询的hql语句</span><br><span class="line">@param offset 第一条记录索引</span><br><span class="line">@param pageSize 当前需要显示的记录数</span><br><span class="line">@<span class="keyword">return</span> 当前页的所有记录   */</span><br><span class="line">public <span class="type">List</span> findByPage(final <span class="type">String</span> hql, final <span class="type">int</span> offset, final <span class="type">int</span> pageSize)&#123;</span><br><span class="line">        //通过一个<span class="type">HibernateCallback</span>对象来执行查询</span><br><span class="line">        <span class="type">List</span> list = getHibernateTemplate().executeFind(</span><br><span class="line">                new <span class="type">HibernateCallback</span>()&#123;//实现<span class="type">HibernateCallback</span>接口必须实现的方法</span><br><span class="line">                    public <span class="type">Object</span> doInHibernate(<span class="type">Session</span> session)throws <span class="type">HibernateException</span>, <span class="type">SQLException</span>&#123;//执行<span class="type">Hibernate</span>分页查询</span><br><span class="line">                        <span class="type">List</span> <span class="literal">result</span> = session.createQuery(hql)</span><br><span class="line">                        .setFirstResult(offset)</span><br><span class="line">                        .setMaxResults(pageSize)</span><br><span class="line">                        .list();</span><br><span class="line">                        <span class="keyword">return</span> <span class="literal">result</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">        <span class="keyword">return</span> list;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：Spring提供的XxxTemplate和XxxCallBack互为补充，XxxTemplate对通用操作进行封装，而XxxCallBack解决了封装后灵活性不足的缺陷。</p>
<h3 id="实现DAO组件">实现DAO组件</h3><p>为了实现DAO组件，Spring提供了大量的XxxDaoSupport类，这些DAO支持类对于实现DAO组件有很大的帮助，因为这些DAO支持类完成了大量基础性工作。</p>
<p>Spring为Hibernate的DAO提供工具类：HibernateDaoSupport。该类主要提供如下两个方法来简化DAO的实现：</p>
<ul>
<li>public final HibernateTemplate getHibernateTemplate()</li>
<li>public final void setSessionFactory(SessionFactory sessionFactory)</li>
</ul>
<p>在继承HibernateDaoSupport的DAO实现里，程序无须理会Hibernate的Session管理，Spring会根据实际的操作，采用“每次事务打开一次session”的策略，自动提高数据库访问的性能。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyHibernateDaoSupport</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">HibernateDaoSupport</span> <span class="title">implements</span> <span class="title">IMyHibernateDaoSupport</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    public void testDao()&#123;</span><br><span class="line">        <span class="type">List</span> list = getHibernateTemplate().find(<span class="string">"from NewsInf"</span>);</span><br><span class="line">        <span class="type">System</span>.out.println(<span class="string">"list.size()="</span>+list.size());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"myHibernateDaoSupport"</span> class=<span class="string">"com.dao.impl.MyHibernateDaoSupport"</span>&gt;</span><br><span class="line">        &lt;property name=<span class="string">"hibernateTemplate"</span> <span class="keyword">ref</span>=<span class="string">"hibernateTemplate"</span>&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure>
<h3 id="使用IoC容器组装各种组件">使用IoC容器组装各种组件</h3><p>至此为止，J2EE应用所需要的各种组件都已经出现了，从MVC层的控制器组件，到业务逻辑组件，以及持久层的DAO组件，已经全部成功实现。应用程序代码并未将这些组件耦合在一起，代码中都是面向接口编程，因此必须利用Spring的IoC容器将他们组合在一起。</p>
<p>从用户角度来看，用户发出HTTP请求，当MVC框架的控制器组件拦截到用户请求时，将调用系统的业务逻辑组件，而业务逻辑组件则调用系统的DAO组件，而DAO组件则依赖于SessionFactory和DataSource等底层组件实现数据库访问。</p>
<p>从系统实现角度来看，IoC容器先创建SessionFactory和DataSource等底层组件，然后将这些底层组件注入给DAO组件，提供一个完整的DAO组件，并将此DAO组件注入给业务逻辑组件，从而提供一个完整的业务逻辑组件，而业务逻辑组件又被注入给控制器组件，控制器组件负责拦截用户请求，并将处理结果呈现给用户——这一系列的衔接都由Spring的IoC容器提供实现。</p>
<p>下面给出关于如何在容器中配置J2EE组件的大致模板，其模板代码如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="GBK"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- beans是Spring配置文件的根元素，并且指定了Schema信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">beans</span> <span class="attribute">xmlns</span>=<span class="value">"http://www.springframework.org/schema/beans"</span></span><br><span class="line">       <span class="attribute">xmlns:xsi</span>=<span class="value">"http://www.w3.org/2001/XMLSchema-instance"</span></span><br><span class="line">       <span class="attribute">xsi:schemaLocation</span>=<span class="value">"http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义数据源Bean，使用C3P0数据源实现 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"dataSource"</span> <span class="attribute">class</span>=<span class="value">"com.mchange.v2.c3p0.ComboPooledDataSource"</span></span><br><span class="line">    <span class="attribute">destroy-method</span>=<span class="value">"close"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"driverClass"</span> <span class="attribute">value</span>=<span class="value">"com.mysql.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的URL --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"jdbcUrl"</span> <span class="attribute">value</span>=<span class="value">"jdbc:mysql://localhost/j2ee"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的用户名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"user"</span> <span class="attribute">value</span>=<span class="value">"root"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"password"</span> <span class="attribute">value</span>=<span class="value">"32147"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库连接池的最大连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxPoolSize"</span> <span class="attribute">value</span>=<span class="value">"40"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库连接池的最小连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"minPoolSize"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库连接池的初始化连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"initialPoolSize"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库连接池的连接最大空闲时间 --&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"maxIdleTime"</span> <span class="attribute">value</span>=<span class="value">"20"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Hibernate的SessionFactory Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"sessionFactory"</span> <span class="attribute">class</span>=<span class="value">"org.springframework.orm.hibernate3.</span><br><span class="line">    LocalSessionFactoryBean"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 依赖注入数据源，注入的正是上文中定义的dataSource --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dataSource"</span> <span class="attribute">ref</span>=<span class="value">"dataSource"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- mappingResources属性用来列出全部映射文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"mappingResources"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">list</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 以下用来列出所有的PO映射文件 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">value</span>&gt;</span>lee/Person.hbm.xml<span class="tag">&lt;/<span class="title">value</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 此处还可列出更多的PO映射文件 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="title">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!-- 定义Hibernate的SessionFactory属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernateProperties"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="title">props</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 指定Hibernate的连接方言 --&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.dialect"</span>&gt;</span>org.hibernate.dialect.</span><br><span class="line">                MySQLDialect<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 指定启动应用时，是否根据Hibernate映射文件创建数据表 --&gt;</span></span><br><span class="line">                  <span class="tag">&lt;<span class="title">prop</span> <span class="attribute">key</span>=<span class="value">"hibernate.hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="title">prop</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;/<span class="title">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置Person持久化类的DAO Bean --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"personDao"</span> <span class="attribute">class</span>=<span class="value">"lee.PersonDaoImpl"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 采用依赖注入来传入SessionFactory的引用 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"sessionFactory"</span> <span class="attribute">ref</span>=<span class="value">"sessionFactory"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 下面能以相同的方式配置更多的持久化Bean --&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">id</span>=<span class="value">"myService"</span> <span class="attribute">class</span>=<span class="value">"lee.MyServiceImp"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注入业务逻辑组件所必需的DAO组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"peronDdao"</span> <span class="attribute">ref</span>=<span class="value">" personDao "</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 此处可采用依赖注入更多的DAO组件 --&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 配置控制器Bean，设置起作用域为Request --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">bean</span> <span class="attribute">name</span>=<span class="value">"/login"</span> <span class="attribute">class</span>=<span class="value">"lee.LoginAction"</span> <span class="attribute">scope</span>=<span class="value">"request"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 依赖注入控制器所必需的业务逻辑组件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"myService"</span> <span class="attribute">ref</span>=<span class="value">" myService "</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在上面的配置文件中，同时配置了控制器Bean、业务逻辑组件Bean、DAO组件Bean以及一些基础资源Bean。各组件的组织被解耦到配置文件中，而不是在代码层次的低级耦合。<br>当客户端的HTTP请求向/login.do发送请求时，将被容器中的lee.LoginAction拦截，LoginAction调用myService Bean，myService Bean则调用personDao等系列DAO组件，整个流程将系统中的各组件有机地组织在一起。</p>
<p>注意：在实际应用中，很少会将DAO组件、业务逻辑组件以及控制组件都配置在同一个文件中。而是在不同配置文件中，配置相同一组J2EE应用组件。</p>
<h3 id="使用声明式事务">使用声明式事务</h3><ul>
<li>针对不同的事务策略配置对应的事务管理器  <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id=<span class="string">"txManager"</span> class=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span><br><span class="line">&lt;property name=<span class="string">"dataSource"</span> <span class="keyword">ref</span>=<span class="string">"dataSource"</span>/&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure></li>
<li>使用<code>&lt;tx:advice&gt;</code>元素配置事务增强处理Bean，配置事务增强处理Bean时使用多个<code>&lt;method../&gt;</code>子元素为不同方法指定相应的事务语义</li>
<li>在<code>&lt;aop:config../&gt;</code>子元素中使用<code>&lt;aop:advisor../&gt;</code>元素配置自动事务代理  <figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;tx:advice id=<span class="string">"txAdvice"</span> transaction-manager=<span class="string">"txManager"</span>&gt;</span><br><span class="line">    &lt;tx:attributes&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"get*"</span> read-only=<span class="string">"true"</span> propagation=<span class="string">"NOT_SUPPORTED"</span>/&gt;</span><br><span class="line">        &lt;tx:<span class="keyword">method</span> name=<span class="string">"save*"</span>/&gt;</span><br><span class="line">    &lt;/tx:attributes&gt;</span><br><span class="line">&lt;/tx:advice&gt;</span><br><span class="line"></span><br><span class="line">&lt;aop:config&gt;</span><br><span class="line">    &lt;aop:pointcut</span><br><span class="line">            expression=<span class="string">"execution(* org.flyne.service.impl.*.*(..))"</span></span><br><span class="line">            id=<span class="string">"perform"</span>/&gt;</span><br><span class="line">    &lt;aop:advisor advice-<span class="keyword">ref</span>=<span class="string">"txAdvice"</span> pointcut-<span class="keyword">ref</span>=<span class="string">"perform"</span>/&gt;</span><br><span class="line">&lt;/aop:config&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[Spring]]>
    
    </summary>
    
      <category term="Spring" scheme="http://howiefh.github.io/tags/Spring/"/>
    
      <category term="JavaEE" scheme="http://howiefh.github.io/categories/JavaEE/"/>
    
      <category term="Spring" scheme="http://howiefh.github.io/categories/JavaEE/Spring/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hibernate笔记]]></title>
    <link href="http://howiefh.github.io/2015/03/05/hibernate-note/"/>
    <id>http://howiefh.github.io/2015/03/05/hibernate-note/</id>
    <published>2015-03-05T14:49:08.000Z</published>
    <updated>2015-03-13T02:19:24.000Z</updated>
    <content type="html"><![CDATA[<h2 id="对象/关系数据库映射(ORM)">对象/关系数据库映射(ORM)</h2><p>ORM全称是Object/Relation Mapping，对象/关系数据库映射。ORM可理解成一种规范，它概述了这类框架的基本特征：完成面向对象的编程语言到关系数据库的映射。</p>
<a id="more"></a>
<h3 id="ORM基本映射方式">ORM基本映射方式</h3><ul>
<li>数据表映射类：持久化类被映射到一个数据表。</li>
<li>数据表的行映射对象：持久化类会生成很多实例，每个实例就对应数据表中的一行记录。</li>
<li>数据表的列映射对象的属性。</li>
</ul>
<h3 id="流行的ORM框架">流行的ORM框架</h3><ul>
<li>JPA:JPA只是一种ORM规范，并不是ORM产品。提供接口，而不是实现。所以如果面向JPA编程，那么程序即可在各种ORM框架之间自由切换。</li>
<li>Hibernate</li>
<li>iBATIS</li>
<li>TopLink</li>
</ul>
<h2 id="Hibernate入门">Hibernate入门</h2><h3 id="Hibernate下载和安装">Hibernate下载和安装</h3><p>从 <a href="http://hibernate.org" target="_blank" rel="external">http://hibernate.org</a> 进行下载。<br>将hibernate[version].jar和lib路径下的required、bytecode、jpa子目录下所有JAR包添加到应用的类加载路径中。Hibernate底层依然基于JDBC，所以JDBC对应的驱动也要添加到类加载路径中。</p>
<h3 id="Hibernate的数据库操作">Hibernate的数据库操作</h3><p>ORM框架中非常重要的媒介：PO(Persistent Object，持久化对象)。持久化对象的作用是完成持久化操作，简单说，通过该对象可对数据执行增删改查操作—以面向对象的方式操作数据库。</p>
<p>Hibernate使用POJO(普通、传统Java对象)作为PO</p>
<p>News.java</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> class News&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">Integer</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> title;</span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">String</span> content;</span><br><span class="line">    <span class="comment">//setter 和 getter方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>News.hbm.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE hibernate-mapping PUBLIC</span><br><span class="line">"-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span><br><span class="line">"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">hibernate-mapping</span> <span class="attribute">package</span>=<span class="value">"pojo"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 每个class元素对应一个持久化对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"News"</span> <span class="attribute">table</span>=<span class="value">"news_table"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- id元素定义持久化类的标识属性 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"id"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定主键生成策略 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"identity"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"title"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"content"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Hibernate配置文件hibernate.cfg.xml</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="doctype">&lt;!DOCTYPE hibernate-configuration PUBLIC</span><br><span class="line">"-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span><br><span class="line">"http://hibernate.sourceforge.net/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">session-factory</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库所用的驱动 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connection.driver_class"</span>&gt;</span>com.mysql.jdbc.Driver<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的url，hibernate连接的数据库名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connection.url"</span>&gt;</span>jdbc:mysql://192.168.0.121/dbname<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的用户名 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接数据库的密码 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"connection.password"</span>&gt;</span><span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接池最大连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.c3p0.max_size"</span>&gt;</span>20<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接池最小连接数 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.c3p0.min_size"</span>&gt;</span>1<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定连接池里最大缓存多少个Statement对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.c3p0.max_statements"</span>&gt;</span>100<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.c3p0.idle_test_period"</span>&gt;</span>3000<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.c3p0.acquire_increment"</span>&gt;</span>2<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.c3p0.validate"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 指定数据库方言 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"dialect"</span>&gt;</span>org.hibernate.dialect.MySQLInnoDBDialect<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 根据需要自动创建数据表 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hbm2ddl.auto"</span>&gt;</span>update<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 映射文件 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">mapping</span> <span class="attribute">class</span>=<span class="value">"pojo.News"</span>/&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="title">ssion-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Hibernate并不推荐DriverManager来连接数据库，而是推荐使用数据源来管理数据库连接，这样能保证更好的性能。Hibernate推荐使用C2P0数据源。</p>
<p>数据源是一种提高数据库连接性能的常规手段，数据源会负责维持一个数据库连接池，当程序创建数据源实例时，系统会一次性地创建多个数据库连接，并把这些数据库连接保存在连接池中，当程序需要进行数据库访问时，无须重新获得数据库连接，而是从连接池中取出一个空闲的数据库连接。当程序使用数据库连接访问数据结束后，无须关闭数据库连接，而是将数据库连接归还给连接池即可，通过这种方式可以避免频繁地获取数据库连接、关闭数据库连接所导致的性能下降。</p>
<p>完成消息的插入操作</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//实例化Configuration, configure方法加载hibernate.cfg.xml文件</span></span><br><span class="line">Configuration conf = new Configuration<span class="params">()</span>.configure<span class="params">()</span>;</span><br><span class="line"><span class="comment">//以Configuration创建SessionFactory</span></span><br><span class="line">SessionFactory sf = conf.buildSessionFactory<span class="params">()</span>;</span><br><span class="line"><span class="comment">//创建Session</span></span><br><span class="line">Session sess = sf.openSession<span class="params">()</span>;</span><br><span class="line"><span class="comment">//开始事务</span></span><br><span class="line">Transaction tx = sess.beginTransaction<span class="params">()</span>;</span><br><span class="line"><span class="comment">//创建消息实例</span></span><br><span class="line">News n = new News<span class="params">()</span>;</span><br><span class="line">n.setTitle<span class="params">(<span class="string">""</span>)</span>;</span><br><span class="line">n.setContent<span class="params">(<span class="string">""</span>)</span>;</span><br><span class="line"><span class="comment">//保存消息</span></span><br><span class="line">sess.save<span class="params">(n)</span>;</span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">tx.commit<span class="params">()</span>;</span><br><span class="line"><span class="comment">//关闭session</span></span><br><span class="line">sess.close<span class="params">()</span>;</span><br><span class="line">sf.close<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>PO只有在Session的管理下才可完成数据库访问。为了使用Hibernate进行持久化操作，通常有如下操作步骤。</p>
<ul>
<li>开发持久化类，由POJO加映射文件组成</li>
<li>获取Configuration</li>
<li>获取SessionFactory</li>
<li>获取Session，打开事务 </li>
<li>用面向对象的方式操作数据库</li>
<li>关闭事务，关闭Session</li>
</ul>
<p>随PO与Session的关联关系，PO有如下三种状态    </p>
<ul>
<li>瞬态：PO从未与Session关联</li>
<li>持久化：PO实例与Session关联起来，且该实例对应到数据库记录。</li>
<li>脱管：PO实例曾经与Session关联，但因为Session关闭等原因，PO实例脱离Session的管理。</li>
</ul>
<p><img src="http://fh-1.qiniudn.com/PO_lifecycle.jpg" alt="持久化对象的生命周期"></p>
<p>对PO的操作必须在Session管理下才能同步到数据库。Session由SessionFactory工厂产生，SessionFactory是数据库编译后的内存镜像，通常一个应用对应一个SessionFactory对象。SessionFactory对象由Configuration对象产生，Configuration对象负责加载Hibernate配置文件。</p>
<h3 id="在Eclipse中使用Hibernate">在Eclipse中使用Hibernate</h3><p>Hibernate官方提供HibernateTools插件。</p>
<p>hibernate.cfg.xml文件通常在src目录下。</p>
<p>如果希望显示sql语句，自动建表可以在配置文件hibernate.cfg.xml中添加hibernate.show_sql、hibernate.format_sql和hibernate.hbm2ddl.auto</p>
<h2 id="Hibernate体系结构">Hibernate体系结构</h2><p><img src="http://fh-1.qiniudn.com/hibernate_simple_struct.gif" alt="Hibernate简要体系结构"><br><img src="http://fh-1.qiniudn.com/hibernate_struct.gif" alt="Hibernate全面解决方案体系结构"></p>
<ul>
<li>SessionFactory：这是Hibernate的关键对象，它是单个数据库映射关系经过编译后的内存镜像，它也是线程安全的。它是生成Session的工厂，本身要应用到ConnectionProvider，该对象可以在进程和集群的级别上，为那些事务之间可以重用的数据提供可选的二级缓存。</li>
<li>Session：它是应用程序和持久存储层之间交互操作的一个单线程对象。它也是Hibernate持久化操作的关键对象，所有的持久化对象必须在Session的管理下才能够进行持久化操作。此对象的生存周期很短，其隐藏了JDBC连接，也是Transaction 的工厂。Session对象有一个一级缓存，现实执行Flush之前，所有的持久化操作的数据都在缓存中Session对象处。</li>
<li>持久化对象：系统创建的POJO实例一旦与特定Session关联，并对应数据表的指定记录，那该对象就处于持久化状态，这一系列的对象都被称为持久化对象。程序中对持久化对象的修改，都将自动转换为持久层的修改。持久化对象完全可以是普通的Java Beans/POJO，唯一的特殊性是它们正与Session关联着。</li>
<li>瞬态对象和脱管对象：系统进行new关键字进行创建的Java 实例，没有Session 相关联，此时处于瞬态。瞬态实例可能是在被应用程序实例化后，尚未进行持久化的对象。如果一个曾经持久化过的实例，但因为Session的关闭而转换为脱管状态。</li>
<li>事务(Transaction)：代表一次原子操作，它具有数据库事务的概念。但它通过抽象，将应用程序从底层的具体的JDBC、JTA和CORBA事务中隔离开。在某些情况下，一个Session 之内可能包含多个Transaction对象。虽然事务操作是可选的，但是所有的持久化操作都应该在事务管理下进行，即使是只读操作。</li>
<li>连接提供者(ConnectionProvider)：它是生成JDBC的连接的工厂，同时具备连接池的作用。他通过抽象将底层的DataSource和DriverManager隔离开。这个对象无需应用程序直接访问，仅在应用程序需要扩展时使用。</li>
<li>事务工厂(TransactionFactory)：他是生成Transaction对象实例的工厂。该对象也无需应用程序的直接访问。</li>
</ul>
<h2 id="深入Hibernate的配置文件">深入Hibernate的配置文件</h2><ol>
<li><p>使用hibernate.properties作为配置文件</p>
<p> 需要通过addResource方法添加映射文件<code>new Configuration().addResource(&quot;News.hbm.xml&quot;)</code>。也可以通过addClass()方法添加持久化类<code>new Configuration().addClass(lee.Nuews.class)</code>此时映射文件应该放在类文件相同的包路径下。Hibernate自己会去搜索。</p>
</li>
<li><p>使用hibernate.cfg.xml作为配置文件</p>
<p> hibernate.cfg.xml文件中已经添加了Hibernate映射文件。<code>new Configuration().configure()</code></p>
</li>
<li><p>不用配置文件创建Configuration实例</p>
<p> 使用下面三个方法</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Configuration <span class="function"><span class="title">addResource</span><span class="params">(String resourceName)</span></span></span><br><span class="line">Configuration <span class="function"><span class="title">setProperties</span><span class="params">(Properties properties)</span></span></span><br><span class="line">Configuration <span class="function"><span class="title">setProperty</span><span class="params">(String propertyName, String value)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="JDBC连接属性">JDBC连接属性</h3><p>所有Hibernate属性的名字和语义都在org.hibernate.cfg.Environment中定义。</p>
<ul>
<li>hibernate.connection.driver_class：指定连接数据库所用的驱动。</li>
<li>hibernate.connection.url：指定连接数据库的url，hibernate连接的数据库名。</li>
<li>hibernate.connection.username：该属性是可选的。</li>
<li>hibernate.connection.passowrd：该属性是可选的。</li>
<li>hibernate.connection.pool_size：设置Hibernate数据库连接池的最大并发连接数。</li>
<li>hibernate.dialect：设置连接数据库所使用的方言。</li>
</ul>
<p>Hibernate自带的连接池仅有测试价值，实际项目中使用C3P0或Proxool连接池。</p>
<h3 id="数据库方言">数据库方言</h3><table>
<thead>
<tr>
<th>关系型数据库</th>
<th>方言</th>
</tr>
</thead>
<tbody>
<tr>
<td>DB2</td>
<td>org.hibernate.dialect.DB2Dialect</td>
</tr>
<tr>
<td>DB2 AS/400</td>
<td>org.hibernate.dialect.DB2400Dialect</td>
</tr>
<tr>
<td>DB2 OS390</td>
<td>org.hibernate.dialect.DB2390Dialect</td>
</tr>
<tr>
<td>PostgreSQL</td>
<td>org.hibernate.dialect.PostgreSQLDialect</td>
</tr>
<tr>
<td>MySQL</td>
<td>org.hibernate.dialect.MySQLDialect</td>
</tr>
<tr>
<td>MySQL with InnoDB</td>
<td>org.hibernate.dialect.MySQLInnoDBDialect</td>
</tr>
<tr>
<td>MySQL with MyISAM</td>
<td>org.hibernate.dialect.MySQLMyISAMDialect</td>
</tr>
<tr>
<td>Oracle (any version)</td>
<td>org.hibernate.dialect.OracleDialect</td>
</tr>
<tr>
<td>Oracle 9i</td>
<td>org.hibernate.dialect.Oracle9iDialect</td>
</tr>
<tr>
<td>Oracle 10g</td>
<td>org.hibernate.dialect.Oracle10gDialect</td>
</tr>
<tr>
<td>Sybase</td>
<td>org.hibernate.dialect.SybaseDialect</td>
</tr>
<tr>
<td>Sybase Anywhere</td>
<td>org.hibernate.dialect.SybaseAnywhereDialect</td>
</tr>
<tr>
<td>Microsoft SQL Server</td>
<td>org.hibernate.dialect.SQLServerDialect</td>
</tr>
<tr>
<td>SAP DB</td>
<td>org.hibernate.dialect.SAPDBDialect</td>
</tr>
<tr>
<td>Informix</td>
<td>org.hibernate.dialect.InformixDialect</td>
</tr>
<tr>
<td>HypersonicSQL</td>
<td>org.hibernate.dialect.HSQLDialect</td>
</tr>
<tr>
<td>Ingres</td>
<td>org.hibernate.dialect.IngresDialect</td>
</tr>
<tr>
<td>Progress</td>
<td>org.hibernate.dialect.ProgressDialect</td>
</tr>
<tr>
<td>Mckoi SQL</td>
<td>org.hibernate.dialect.MckoiDialect</td>
</tr>
<tr>
<td>Interbase</td>
<td>org.hibernate.dialect.InterbaseDialect</td>
</tr>
<tr>
<td>Pointbase</td>
<td>org.hibernate.dialect.PointbaseDialect</td>
</tr>
<tr>
<td>FrontBase</td>
<td>org.hibernate.dialect.FrontbaseDialect</td>
</tr>
<tr>
<td>Firebird</td>
<td>org.hibernate.dialect.FirebirdDialect</td>
</tr>
</tbody>
</table>
<h3 id="JNDI数据源的连接属性">JNDI数据源的连接属性</h3><p>JNDI: Java Naming Directory Interface,Java命名目录接口。</p>
<ul>
<li>hibernate.connection.datasource：指定数据源JNDI名字。</li>
<li>hibernate.jndi.url：指定JNDI提供者的URL，该属性是可选的。如果JNDI与HIbernate持久化访问的代码处在同一个应用中。则无须指定该属性。</li>
<li>hibernate.jndi.class：指定JND InitialContextFactory的实现类，该属性也是可选的。如果JNDI与HIbernate持久化访问的代码处在同一个应用中。则无须指定该属性。</li>
<li>hibernate.connection.username：该属性是可选的。</li>
<li>hibernate.connection.passowrd：该属性是可选的。</li>
</ul>
<p>虽然设置数据库方言并不是必需的，但对于优化持久层访问很有必要。</p>
<h3 id="Hibernate事务属性">Hibernate事务属性</h3><ul>
<li>hibernate.transaction.factory_class:指定Hibernate所用的事务工厂的类型，该属性值必须是TransactionFactory的直接或间接子类。</li>
<li>jta.UserTransaction：该属性值是一个JNDI名，Hibernate将使用JTATransactionFactory从应用服务器获取JTA UserTransaction。</li>
<li>hibernate.transaction.manager_lookup_class：该属性值应为一个TransactionManagerLookup类名，当使用JVM级别的缓存时，或在JTA环境中使用hilo生成器策略时，需要该类。</li>
<li>hibernate.transaction.flush_before_completion：指定Session是否在事务完成后自动将数据刷新到底层受苦。该属性值只能为true或false。现在更好的方法是使用Context相关的Session管理。</li>
<li>hibernate.transaction.auto_close_session：指定是否在事务结束后自动关闭Session。该属性只能是true或false。现在更好的方法是使用Context相关的Session管理。</li>
</ul>
<h3 id="二级缓存相关属性">二级缓存相关属性</h3><ul>
<li>hibernate.cache.provider_class：该属性用于设置二级缓存CacheProvider的类名</li>
<li>hibernate.cache.user_minimal_puts：</li>
<li>hibernate.cache.use_second_level_cache：</li>
<li>hibernate.cache.query_cache_factory：</li>
<li>hibernate.cache.region_prefix：</li>
<li>hibernate.cache.use_structured_entries：</li>
</ul>
<h3 id="外连接抓取属性">外连接抓取属性</h3><p>将hibernate.max_fetch_depth设为0，将在全局范围内禁止外连接抓取，设为1或更高值能启用N-1或1-1的外连接抓取。除此之外，还应该在映射文件中通过fetch=”join”来指定这种外连接抓取。</p>
<h3 id="其他常用的配置属性">其他常用的配置属性</h3><ul>
<li>hibernate.show_sql：是否在控制台打印Hibernate生成的sql语句。</li>
<li>hibernate.format_sql：是否将SQL语句格式化。</li>
<li>hibernate.use_sql_comments：是否在Hibernate生成的SQL语句中添加有助于调试的注释。前三个取值只能是true或false</li>
<li>hibernate.jdbc.fetch_size：指定JDBC抓取数量的大小，它可接受一个整数值，其实质是调用Statement.setFetchSize()方法</li>
<li>hibernate.jdbc.batch_size：指定Hibernate使用JDBC2的批量更新的大小，它接受一个整数值，建议取5到30之间的值。</li>
<li>hibernate.connection.autocommit：设置是否自动提交。通常不建议打开自动提交。</li>
<li>hibernate.hbm2ddl.auto：设置当创建SessionFactory时，是否根据映射文件自动建立数据库表。如果使用create-drop值，显示关闭SessionFactory时，将Drop刚建的数据表。该属性可以为update、create和create-drop三个值。</li>
</ul>
<h2 id="深入理解持久化对象">深入理解持久化对象</h2><h3 id="持久化类的要求">持久化类的要求</h3><ul>
<li>提供一个无参数的构造器</li>
<li>提供一个标识属性，标识属性通常映射数据库表的主键字段。可以是任何名字，可以使用基本类型及其包装类，java.lang.String，java.util.Date。如果是联合主键，甚至可以用一个用户自定义的类，也可以不指定任何标识属性，而在配置文件中将多个普通类型映射成一个联合主键，但通常不推荐这么做。主键建议使用包装类型而不是基本类型。</li>
<li>没有标识可能导致Hibernate很多功能没法使用。Hibernate建议使用可以为空的类型来作为标识属性的类型，因此应该尽量避免使用基本数据类型。</li>
<li>为持久化类的每个属性提供setter和getter方法。Hibernate默认采用属性方式访问持久化类的属性。setX、getX、isX是被认可的。</li>
<li>使用非final的类。同时应避免在非final类中声明public final的方法。如果有这种方法，必须通过设置lazy=”false”来明确地禁用代理。</li>
<li>重写equals()和hashCode()方法。需要放入Set中（当进行关联映射时，推荐这么做），通常是使用判断标志值的方法。遗憾的是，对采用自动生成标识的对象不能使用这种方法。Hibernate仅为那些持久化对象指定标识值，一个新创建的实例将不会有任何标识值，通过保存一个对象将会给它赋标识值。如果equals()和hashCode()是基于标识值的，则其hashCode返回值会发生改变，这将违反Set规则。当我们想要重用脱管实例时，该实例所属的持久化类也应该重写equals()和hashCode()</li>
</ul>
<h3 id="持久化对象的状态">持久化对象的状态</h3><ul>
<li>瞬态：对象由new操作符创建，且尚未与Hibernate Session 关联的对象。不会被持久化到数据库中，也不会被赋予持久化标识。使用Hibernate Session可以将其变为持久化状态。</li>
<li>持久化：实例对应到数据库记录，并拥有一个持久化标识。持久化对象可以是刚刚保存的也可以是刚加载的，必须与指定的Hibernate Session关联。Hibernate会检测到处于持久化状态对象的改动，在当前操作执行完成时将对象数据写会数据库，不需要手动update。</li>
<li>脱管：某个实例曾经处于持久化状态，但随着与之关联的Session关闭，该对象处于脱管状态。</li>
</ul>
<p><img src="http://fh-1.qiniudn.com/PO_lifecycle.jpg" alt="持久化对象的状态演化图"></p>
<h3 id="改变持久化对象状态的方法">改变持久化对象状态的方法</h3><p>save()和persist()方法</p>
<ol>
<li>如果News的标识属性是generated，也就是说指定了主键生成器，那么Hibernate将会在执行save方法时自动生成标识属性值，并将该标识属性值分配给该News对象。</li>
<li>如果News的标识属性是assigned类型的，或者是联合主键，那么该标识属性值应当在调用save之前手动赋给News对象。</li>
</ol>
<p>Hibernate之所以提供与save( )功能几乎完全类似的persist( )方法，一方面是为了照顾JPA的用法习惯。另一方面save和persist还有一个区别：使用save( )方法保存持久化对象时，该方法返回该持久化对象的标识属性值即对应记录的主键值；但persist( )方法保存持久化对象时，没有任何返回值。因为save方法需要立即返回持久化对象的标识属性值，所以程序执行save( )方法时会立即将持久化对象对应的数据插入数据库。而persist方法则保证当它在一个事物外部被调用时，并不立即转换成insert语句，这个功能是很有用的，尤其当我们封装一个长会话流程的时候，persist就显得尤为重要了。</p>
<p>load( )与get( )：<br>也可以通过load( )来加载一个持久化实例，这种加载就是根据持久化类的标识属性值加载持久化实例———其实质就是根据主键从数据表中加载一条新记录。News n=session.load(News.class,new Integer(pk))；pk就是需要加载的持久化实例的标识属性。<br>如果没有匹配的数据库记录，load( )方法可能抛出HibernateException异常；如果我们在类映射文件中指定了延迟加载，则load( )方法会返回一个未初始化的代理对象，这个代理对象并没有装载数据记录，直到程序调用该代理对象的某方法时，Hibernate才会去访问数据库。<br>如果希望在某对象中创建一个指向另一个对象的关联，又不想在从数据库中装载该对象的同时装载相关联的所有对象，这种延迟加载的方式就非常有用了。<br>与load( )方法类似的是get( )方法，get( )方法也用于根据主键装载持久化实例，但get( )方法会立刻访问数据库，如果没有对应的记录，get( )方法返回null，而不是返回一个代理对象。<br>一旦加载了该持久化实例后，该实体就处于持久化状态，在代码中对持久化实例所做的修改，例如：n.setTitle(“新标题”);这种修改将被保存到数据库，对标题的修改被映射成修改数据表的特定行的特定列。<br>程序对持久化实例所做的修改会在Session flush之前被自动保存到数据库，无需程序调用其他方法(不需要调用update方法)来将修改持久化。也就是说，修改对象最简单的方法就是在Session处于打开状态时load它，然后直接修改即可。<br>对于一个曾经持久化过的、但现在已脱离Session管理的持久化对象，我们把它称为处于脱管状态。当我们修改脱管对象的状态后，程序应该使用新的Session来保存这些修改。Hibernate提供了update( )、merge( )和updateOrSave( )等方法来保存这些修改。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">News</span> <span class="keyword">n</span>=firstSession.load(<span class="keyword">News</span>.<span class="keyword">class</span>,new Integer(pk));  </span><br><span class="line">firstSession.<span class="keyword">close</span>();  </span><br><span class="line"><span class="keyword">n</span>.setTitle(<span class="string">"新标题"</span>);  </span><br><span class="line">Session secondSession=HibernateSessionFactory.getSession();  </span><br><span class="line">secondSession.<span class="keyword">update</span>(<span class="keyword">n</span>);</span><br></pre></td></tr></table></figure></p>
<p>当我们用另一个Session来保存这种修改后，该脱管对象再次回到Session的管理之下，也就再次回到持久化状态。<br>当需要使用update( )来保存程序对持久化对象所做的修改时，如果不清楚该对象是否曾经持久化过，那么程序可以选择使用updateOrSave( )方法，该方法自动判断该对象是否曾经持久化，如果曾经持久化过，就使用update方法，否则将使用save操作。<br>merge( )方法也可将程序对脱管对象所做的修改保存到数据库，但merge方法与update方法最大的区别就是：merge( )方法不会持久化给定对象。举例来说，当我们执行session.update(a)代码后，a对象将会变成持久化状态；而执行session.merge(a)代码后，a对象依然不是持久化状态，a对象依然不会被关联到Session上。<br>当程序使用merge()方法来保存程序对脱管对象所做的修改时，如果Session中存在相同持久化标识的持久化对象，merge()方法里提供对象的状态将覆盖原有持久化实例的状态。如果Session中没有相应的持久化实例，则尝试从数据库中加载，或创建新的持久化实例，最后返回持久化实例。<br>merge()方法作用只是将当前对象的状态信息保存到数据库，并不会将该对象转换为持久化状态。<br>当我们使用load()和get()方法来加载持久化对象时，还可以指定一个”锁模式”参数。</p>
<p>save():保存持久化对象，在数据库中新增加一条数据<br>saveOrUpdate()保存或者是更新，该方法根据id标签的unsaved-value属性值决定执行新增加一条记录或者是更新。<br>get()根据标识符属性获得一个持久化对象，如果未找到，则返回null<br>load()该方法根据标识符属性加在一个持久化对象，如果未找到，则抛出异常<br>update() 该方法对托管状态的对象重新完成持久化，更新数据库中的数据<br>delete()删除数据库中的一条记录，不过需要先使用get() or  load() 获取持久化对象<br>close()关闭当前的session对象，并且清空该对象中的数据<br>evict()用于清除session缓存中的某一个对象<br>clear()清除Session中的所有缓存对象。</p>
<h2 id="映射">映射</h2><p> 在Hibernate中使用Annotation，跟以前xml配置的方式相比： </p>
<ol>
<li>仍然需要cfg.xml </li>
<li>在cfg.xml中需要配置要通过注解来配置的类，例如：  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;mapping <span class="keyword">package</span>=<span class="string">"test.animals"</span>/&gt; </span><br><span class="line">&lt;mapping <span class="class"><span class="keyword">class</span></span>=<span class="string">"test.Flight"</span>/&gt;</span><br></pre></td></tr></table></figure></li>
<li>程序里面，原来的new Configuration()的地方，可以变成：new AnnotationConfiguration()，也可以不用改。 </li>
<li>可以通过编程的方式来添加要映射的类，例如：  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new <span class="function"><span class="title">AnnotationConfiguration</span><span class="params">()</span></span>.<span class="function"><span class="title">addPackage</span><span class="params">(<span class="string">"test.animals"</span>)</span></span> </span><br><span class="line">          .<span class="function"><span class="title">addAnnotatedClass</span><span class="params">(Flight.class)</span></span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="映射实体">映射实体</h3><ul>
<li>@Entity，注册在类头上，将一个类声明为一个实体bean(即一个持久化POJO类) 。 </li>
<li><p>@Table，注册在类头上，注解声明了该实体bean映射指定的表（table ）。 </p>
<p>  @Table元素有name、schema、catalog 和 uniqueConstraints属性，如果需要可以指定相应的值. 结合使用@UniqueConstraint注解可以定义表的唯一约束(unique constraint) (对于绑定到单列的唯一约束,请参考@Column注解)</p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Table</span>(name=<span class="string">"tbl_sky"</span>, uniqueConstraints = &#123;<span class="variable">@UniqueConstraint</span>(columnNames=&#123;<span class="string">"month"</span>, <span class="string">"day"</span>&#125;)&#125;)</span><br></pre></td></tr></table></figure>
<p>  上面这个例子中,在month和day这两个字段上定义唯一约束. 注意columnNames数组中的值指的是逻辑列名.</p>
</li>
</ul>
<h3 id="映射属性">映射属性</h3><p>在对一个类进行注解时,你可以选择对它的的属性或者方法进行注解,根据你的选择,Hibernate的访问类型分别为 field或property. EJ3规范要求在需要访问的元素上进行注解声明,例如,如果访问类型为 property就要在getter方法上进行注解声明, 如果访问类型为 field就要在字段上进行注解声明.应该尽量避免混合使用这两种访问类型. Hibernate根据@Id 或 @EmbeddedId的位置来判断访问类型.</p>
<p>@Id用来注册主属性，@GeneratedValue用来注册主属性的生成策略，@Column用来注册属性，@Version用来注册乐观锁，@Transient用来注册不是属性。 </p>
<p>@Transient注册在多余的属性或多余的getter上，但是必须与以上的@Column等对应。 </p>
<p>Hibernate Annotations还支持将内置的枚举类型映射到一个顺序列(保存了相应的序列值) 或一个字符串类型的列(保存相应的字符串).默认是保存枚举的序列值, 但是你可以通过@Enumerated注解来进行调整</p>
<p>在核心的Java API中并没有定义时间精度(temporal precision). 因此处理时间类型数据时,你还需要定义将其存储在数据库中所预期的精度. 在数据库中,表示时间类型的数据有DATE, TIME, 和 TIMESTAMP三种精度(即单纯的日期,时间,或者两者兼备). 可使用@Temporal注解来调整精度.</p>
<p>@Lob注解表示属性将被持久化为Blob或者Clob类型, 具体取决于属性的类型, java.sql.Clob, Character[], char[] 和 java.lang.String这些类型的属性都被持久化为Clob类型, 而java.sql.Blob, Byte[], byte[] 和 serializable类型则被持久化为Blob类型.</p>
<h4 id="非主属性">非主属性</h4><p>@Column<br>   标识属性对应的字段，示例：@Column(name=”userName”) </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Column</span>( </span><br><span class="line">    name=<span class="string">"columnName"</span>;                                (<span class="number">1</span>) </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">unique</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;                   (<span class="number">2</span>) </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">nullable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;                  (<span class="number">3</span>) </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">insertable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;                (<span class="number">4</span>) </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">updatable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">true</span></span>;                 (<span class="number">5</span>) </span><br><span class="line">    <span class="function">String <span class="title">columnDefinition</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;             (<span class="number">6</span>) </span><br><span class="line">    <span class="function">String <span class="title">table</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;                        (<span class="number">7</span>) </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">default</span> 255</span>;                         (<span class="number">8</span>) </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">precision</span><span class="params">()</span> <span class="keyword">default</span> 0</span>; <span class="comment">// decimal precision   (9) </span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">scale</span><span class="params">()</span> <span class="keyword">default</span> 0</span>; <span class="comment">// decimal scale           (10)</span></span><br></pre></td></tr></table></figure>
<p>(1) name 可选,列名(默认值是属性名)<br>(2) unique 可选,是否在该列上设置唯一约束(默认值false)<br>(3) nullable 可选,是否设置该列的值可以为空(默认值false)<br>(4) insertable 可选,该列是否作为生成的insert语句中的一个列(默认值true)<br>(5) updatable 可选,该列是否作为生成的update语句中的一个列(默认值true)<br>(6) columnDefinition 可选: 为这个特定列覆盖SQL DDL片段 (这可能导致无法在不同数据库间移植)<br>(7) table 可选,定义对应的表(默认为主表)<br>(8) length 可选,列长度(默认值255)<br>(9) precision 可选,列十进制精度(decimal precision)(默认值0)<br>(10) scale 可选,如果列十进制数值范围(decimal scale)可用,在此设置(默认值0)<br>如果某属性没有注解,该属性将遵守下面的规则:</p>
<p><strong>无注解之属性的默认值</strong></p>
<p>如果属性为单一类型,则映射为@Basic<br>否则,如果属性对应的类型定义了@Embeddable注解,则映射为@Embedded<br>否则,如果属性对应的类型实现了Serializable, 则属性被映射为@Basic并在一个列中保存该对象的serialized版本<br>否则,如果该属性的类型为java.sql.Clob 或 java.sql.Blob,则作为@Lob并映射到适当的LobType.</p>
<h4 id="主属性">主属性</h4><p>@Id，标识这个属性是实体类的唯一识别的值。<br>注意：这个注解只能标注单一列构成的主键，有两个字段组成的联合主键由其他注解标识。 </p>
<p>@Id，只是标识这个属性是主键，但是并没有指出其生成策略<br>如果仅仅写出@Id，即是使用默认生成策略，如： </p>
<p><strong>JPA通用策略生成器</strong><br>JPA提供的四种标准用法为TABLE，SEQUENCE，IDENTITY，AUTO，默认AUTO</p>
<ul>
<li>AUTO - 可以是identity column类型,或者sequence类型或者table类型,取决于不同的底层数据库.</li>
<li>TABLE - 使用一个特定的数据库表格来保存主键</li>
<li>IDENTITY - 主键由数据库自动生成(主要是自动增长型)</li>
<li>SEQUENCE - 根据地层数据库的序列来生成主键，条件是数据库支持序列，主要是Oracle</li>
</ul>
<p><strong>hibernate主键策略生成器</strong></p>
<p>hibernate提供多种主键生成策略，有点是类似于JPA，有的是hibernate特有： </p>
<ul>
<li>native: 对于 oracle 采用 Sequence 方式，对于MySQL 和 SQL Server 采用identity（自增主键生成机制），native就是将主键的生成工作交由数据库完成，hibernate不管（很常用）。 </li>
<li>uuid: 采用128位的uuid算法生成主键，uuid被编码为一个32位16进制数字的字符串。占用空间大（字符串类型）。 </li>
<li>hilo: 使用hilo生成策略，要在数据库中建立一张额外的表，默认表名为hibernate_* unique_key,默认字段为integer类型，名称是next_hi（比较少用）。 </li>
<li>assigned: 在插入数据的时候主键由程序处理（很常用），这是 <generator>元素没有指定时的默认生成策略。等同于JPA中的AUTO。 </generator></li>
<li>identity: 使用SQL Server 和 MySQL 的自增字段，这个方法不能放到 Oracle 中，Oracle 不支持自增字段，要设定sequence（MySQL 和 SQL Server 中很常用）。等同于JPA中的INDENTITY。 </li>
<li>select: 使用触发器生成主键（主要用于早期的数据库主键生成机制，少用）。 </li>
<li>sequence: 调用底层数据库的序列来生成主键，要设定序列名，不然hibernate无法找到。 </li>
<li>seqhilo: 通过hilo算法实现，但是主键历史保存在Sequence中，适用于支持 Sequence 的数据库，如 Oracle（比较少用） </li>
<li>increment: 插入数据的时候hibernate会给主键添加一个自增的主键，但是一个hibernate实例就维护一个计数器，所以在多个实例运行的时候不能使用这个方法。 </li>
<li>foreign: 使用另外一个相关联的对象的主键。通常和<one-to-one>联合起来使用。 </one-to-one></li>
<li>guid: 采用数据库底层的guid算法机制，对应MYSQL的uuid()函数，SQL Server的newid()函数，ORACLE的rawtohex(sys_guid())函数等。 </li>
<li>uuid.hex: 看uuid，建议用uuid替换。 </li>
<li>sequence-identity: sequence策略的扩展，采用立即检索策略来获取sequence值，需要JDBC3.0和JDK4以上（含1.4）版本 </li>
</ul>
<p>hibernate提供了多种生成器供选择,基于Annotation的方式通过@GenericGenerator实现.<br>hibernate每种主键生成策略提供接口org.hibernate.id.IdentifierGenerator的实现类,如果要实现自定义的主键生成策略也必须实现此接口</p>
<p>如果想使用Oracle支持的sequence取主键，必须通过@GeneratedValue来指定生成策略，而由@SequenceGenerator指定如何使用sequence。 </p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Id</span></span><br><span class="line"><span class="variable">@GeneratedValue</span>(strategy = GenerationType.SEQUENCE,generator=<span class="string">"payablemoney_seq"</span>)</span><br><span class="line"><span class="variable">@SequenceGenerator</span>(name=<span class="string">"payablemoney_seq"</span>, sequenceName=<span class="string">"seq_payment"</span>)</span><br></pre></td></tr></table></figure>
<p>@SequenceGenerator定义 </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Target</span>(&#123;TYPE, METHOD, FIELD&#125;)   </span><br><span class="line"><span class="annotation">@Retention</span>(RUNTIME)  </span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> SequenceGenerator &#123;  </span><br><span class="line"> <span class="function">String <span class="title">name</span><span class="params">()</span></span>;  </span><br><span class="line"> <span class="function">String <span class="title">sequenceName</span><span class="params">()</span> <span class="keyword">default</span> ""</span>;  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">initialValue</span><span class="params">()</span> <span class="keyword">default</span> 0</span>;  </span><br><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">allocationSize</span><span class="params">()</span> <span class="keyword">default</span> 50</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>name属性表示该表主键生成策略的名称，它被引用在@GeneratedValue中设置的”generator”值中。<br>sequenceName属性表示生成策略用到的数据库序列名称。<br>initialValue表示主键初识值，默认为0。<br>allocationSize表示每次主键值增加的大小，例如设置成1，则表示每次创建新记录后自动加1，默认为50。 </p>
<p><strong>自定义主键生成策略</strong><br>自定义主键生成策略，由@GenericGenerator实现。<br>hibernate在JPA的基础上进行了扩展，可以用一下方式引入hibernate独有的主键生成策略，就是通过@GenericGenerator加入的。</p>
<p>比如说，JPA标准用法<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Id</span>  </span><br><span class="line"><span class="variable">@GeneratedValue</span>(GenerationType.AUTO)</span><br></pre></td></tr></table></figure></p>
<p>就可以用hibernate特有以下用法来实现<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GeneratedValue</span>(generator = <span class="string">"paymentableGenerator"</span>)    </span><br><span class="line"><span class="variable">@GenericGenerator</span>(name = <span class="string">"paymentableGenerator"</span>, strategy = <span class="string">"assigned"</span>)</span><br></pre></td></tr></table></figure></p>
<p>@GenericGenerator有三个属性</p>
<ul>
<li>name属性指定生成器名称。 </li>
<li>strategy属性指定具体生成器的类名。 </li>
<li>parameters得到strategy指定的具体生成器所用到的参数。 </li>
</ul>
<h4 id="乐观锁和不用持久化">乐观锁和不用持久化</h4><ul>
<li>@Version<br>  标识这个属性用来映射乐观锁的version。entity manager使用该字段来检测更新冲突(防止更新丢失,请参考last-commit-wins策略).<br>  根据EJB3规范,version列可以是numeric类型(推荐方式)也可以是timestamp类型. Hibernate支持任何自定义类型,只要该类型实现了UserVersionType. </li>
<li>@Transient<br>标识这个属性不用持久化 </li>
</ul>
<h4 id="复合属性—组件映射">复合属性—组件映射</h4><ul>
<li><p>@Embeddable 【小对象的头上】 </p>
<p>  标识实体中可以定义一个嵌入式组件(embedded component)。组件类必须在类一级定义@Embeddable注解。 </p>
</li>
<li><p>@Embedded 【大对象的属性头上】 </p>
<p>  引用定义的小对象。 </p>
<p>  使用@Embedded和 @AttributeOverride注解可以覆盖该属性对应的嵌入式对象的列映射</p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Embedded</span></span><br><span class="line"><span class="variable">@AttributeOverrides</span>( &#123;</span><br><span class="line">    <span class="variable">@AttributeOverride</span>(name=<span class="string">"iso2"</span>, column = <span class="variable">@Column</span>(name=<span class="string">"bornIso2"</span>) ),</span><br><span class="line">    <span class="variable">@AttributeOverride</span>(name=<span class="string">"name"</span>, column = <span class="variable">@Column</span>(name=<span class="string">"bornCountryName"</span>) ) &#125; )</span><br><span class="line">Country bornIn;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="复合属性—复合主键">复合属性—复合主键</h4><p>下面是定义组合主键的几种语法:</p>
<ul>
<li>将组件类注解为@Embeddable,并将组件的属性注解为@Id</li>
<li>将组件的属性注解为@EmbeddedId</li>
<li><p>将类注解为@IdClass,并将该实体中所有属于主键的属性都注解为@Id</p>
</li>
<li><p>@Embeddable 【小对象的头上】 </p>
<p>  标识实体中可以定义一个嵌入式组件(embedded component)。组件类必须在类一级定义@Embeddable注解。<br>  注意：如果这个小对象作为复合主键，一定要实现Serializable接口。这并不是注解决定的，而是Hibernate的主键都需要实现Serializable接口。 </p>
</li>
<li><p>@EmbeddedId  【大对象的属性头上】 </p>
<p>  引用定义的小对象作为主键。<br>  注意：不需要再使用@Id注解。 </p>
</li>
</ul>
<h3 id="集合映射">集合映射</h3><p>你可以对 Collection ,List (指有序列表, 而不是索引列表), Map和Set这几种类型进行映射. EJB3规范定义了怎么样使用@javax.persistence.OrderBy 注解来对有序列表进行映射： 该注解接受的参数格式：用逗号隔开的(目标实体)属性名及排序指令, 如firstname asc, age desc,如果该参数为空,则默认以id对该集合进行排序. 如果某个集合在数据库中对应一个关联表(association table)的话,你不能在这个集合属性上面使用@OrderBy注解. 对于这种情况的处理方法,请参考Hibernate Annotation Extensions. EJB3 允许你利用目标实体的一个属性作为Map的key, 这个属性可以用@MapKey(name=”myProperty”)来声明. 如果使用@MapKey注解的时候不提供属性名, 系统默认使用目标实体的主键. map的key使用和属性相同的列：不需要为map key定义专用的列，因为map key实际上就表达了一个目标属性。 注意一旦加载,key不再和属性保持同步, 也就是说,如果你改变了该属性的值,在你的Java模型中的key不会自动更新 (请参考Hibernate Annotation Extensions). 很多人被<map>和@MapKey弄糊涂了。 其他它们有两点区别.@MapKey目前还有一些限制,详情请查看论坛或者 我们的JIRA缺陷系统。 注意一旦加载,key不再和属性保持同步, 也就是说,如果你改变了该属性的值,在你的Java模型中的key不会自动更新. (Hibernate 3中Map支持的方式在当前的发布版中还未得到支持).</map></p>
<p>Hibernate将集合分以下几类.</p>
<table>
<thead>
<tr>
<th>语义</th>
<th>Java实现类</th>
<th>注解</th>
</tr>
</thead>
<tbody>
<tr>
<td>Bag 语义</td>
<td>java.util.List, java.util.Collection</td>
<td>@org.hibernate.annotations.CollectionOfElements 或 @OneToMany 或 @ManyToMany</td>
</tr>
<tr>
<td>List 语义</td>
<td>java.util.List</td>
<td>(@org.hibernate.annotations.CollectionOfElements 或 @OneToMany 或 @ManyToMany) 以及 @org.hibernate.annotations.IndexColumn</td>
</tr>
<tr>
<td>Set 语义</td>
<td>java.util.Set</td>
<td>@org.hibernate.annotations.CollectionOfElements 或 @OneToMany 或 @ManyToMany</td>
</tr>
<tr>
<td>Map 语义</td>
<td>java.util.Map</td>
<td>(@org.hibernate.annotations.CollectionOfElements 或 @OneToMany 或 @ManyToMany) 以及 (空 或 @org.hibernate.annotations.MapKey/MapKeyManyToMany(支持真正的map), 或 @javax.persistence.MapKey</td>
</tr>
</tbody>
</table>
<p>从上面可以明确地看到,没有@org.hibernate.annotations.IndexColumn 注解的java.util.List集合将被看作bag类.<br>EJB3规范不支持原始类型,核心类型,嵌入式对象的集合.但是Hibernate对此提供了支持</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">City</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@OneToMany</span>(mappedBy=<span class="string">"city"</span>)</span><br><span class="line">    <span class="annotation">@OrderBy</span>(<span class="string">"streetName"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Street&gt; <span class="title">getStreets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> streets;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Entity</span> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Street</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getStreetName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> streetName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ManyToOne</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> City <span class="title">getCity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> city;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Software</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@OneToMany</span>(mappedBy=<span class="string">"software"</span>)</span><br><span class="line">    <span class="annotation">@MapKey</span>(name=<span class="string">"codeName"</span>)</span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, Version&gt; getVersions() &#123;</span><br><span class="line">        <span class="keyword">return</span> versions;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@Table</span>(name=<span class="string">"tbl_version"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Version</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getCodeName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ManyToOne</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Software <span class="title">getSoftware</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这个例子中,City 中包括了以streetName排序的Street的集合. 而Software中包括了以codeName作为 key和以Version作为值的Map.</p>
<p>除非集合为generic类型,否则你需要指定targetEntity. 这个注解属性接受的参数为目标实体的class.</p>
<p>Hibernate Annotations还支持核心类型集合(Integer, String, Enums, ……)、 可内嵌对象的集合,甚至基本类型数组.这就是所谓的元素集合.</p>
<p>元素集合可用@CollectionOfElements来注解(作为@OneToMany的替代). 为了定义集合表(译注：即存放集合元素的表,与下面提到的主表对应),要在关联属性上使用@JoinTable注解, joinColumns定义了介乎实体主表与集合表之间的连接字段(inverseJoincolumn是无效的且其值应为空). 对于核心类型的集合或基本类型数组,你可以在关联属性上用@Column来覆盖存放元素值的字段的定义. 你还可以用@AttributeOverride来覆盖存放可内嵌对象的字段的定义. 要访问集合元素,需要将该注解的name属性值设置为”element”(“element”用于核心类型,而”element.serial” 用于嵌入式对象的serial属性).要访问集合的index/key,则将该注解的name属性值设置为”key”.</p>
<h3 id="映射继承关系">映射继承关系</h3><p>EJB3支持三种类型的继承映射:</p>
<ul>
<li>每个类一张表(Table per class)策略: 在Hibernate中对应<union-class>元素:</union-class></li>
<li>每个类层次结构一张表(Single table per class hierarchy)策略:在Hibernate中对应<subclass>元素</subclass></li>
<li>连接的子类(Joined subclasses)策略:在Hibernate中对应 <joined-subclass>元素</joined-subclass></li>
</ul>
<p>你可以用 @Inheritance注解来定义所选择的策略. 这个注解需要在每个类层次结构(class hierarchy) 最顶端的实体类上使用.</p>
<h4 id="每个类一张表">每个类一张表</h4><p>这种策略有很多缺点(例如:多态查询和关联),EJB3规范, Hibernate参考手册, Hibernate in Action,以及其他许多地方都对此进行了描述和解释. Hibernate使用SQL UNION查询来实现这种策略. 通常使用场合是在一个继承层次结构的顶端:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@Inheritance</span>(strategy = InheritanceType.TABLE_PER_CLASS)</span><br><span class="line">public class Flight implements Serializable&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p>这种策略支持双向的一对多关联. 这里不支持IDENTITY生成器策略,因为id必须在多个表间共享. 当然,一旦使用这种策略就意味着你不能使用 AUTO 生成器和IDENTITY生成器.</p>
<h4 id="每个类层次结构一张表">每个类层次结构一张表</h4><p>整个继承层次结构中的父类和子类的所有属性都映射到同一个表中, 他们的实例通过一个辨别符(discriminator)列来区分.:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@Inheritance</span>(strategy=InheritanceType.SINGLE_TABLE)</span><br><span class="line"><span class="variable">@DiscriminatorColumn</span>(</span><br><span class="line">    name=<span class="string">"planetype"</span>,</span><br><span class="line">    discriminatorType=DiscriminatorType.STRING</span><br><span class="line">)</span><br><span class="line"><span class="variable">@DiscriminatorValue</span>(<span class="string">"Plane"</span>)</span><br><span class="line">public class Plane &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@DiscriminatorValue</span>(<span class="string">"A320"</span>)</span><br><span class="line">public class A320 extends Plane &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中,Plane是父类,在这个类里面将继承策略定义为 <code>InheritanceType.SINGLE_TABLE</code>,并通过 @DiscriminatorColumn注解定义了辨别符列(还可以定义辨别符的类型). 最后,对于继承层次结构中的每个类,@DiscriminatorValue注解指定了用来辨别该类的值. 辨别符列的名字默认为 DTYPE,其默认值为实体名(在@Entity.name中定义)，其类型 为DiscriminatorType.STRING. A320是子类,如果不想使用默认的辨别符,只需要指定相应的值即可. 其他的如继承策略,辨别标志字段的类型都是自动设定的.</p>
<p>@Inheritance 和 @DiscriminatorColumn 注解只能用于实体层次结构的顶端.</p>
<h4 id="连接的子类">连接的子类</h4><p>当每个子类映射到一个表时, @PrimaryKeyJoinColumn 和@PrimaryKeyJoinColumns 注解定义了每个子类表关联到父类表的主键:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@Inheritance</span>(strategy=InheritanceType.JOINED)</span><br><span class="line">public class Boat implements Serializable &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Entity</span></span><br><span class="line">public class Ferry extends Boat &#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@PrimaryKeyJoinColumn</span>(name=<span class="string">"BOAT_ID"</span>)</span><br><span class="line">public class AmericaCupClass  extends Boat &#123; ... &#125;</span><br></pre></td></tr></table></figure>
<p>以上所有实体都使用了JOINED策略, Ferry表和Boat表使用同名的主键. 而AmericaCupClass表和Boat表使用了条件 <code>Boat.id = AmericaCupClass.BOAT_ID</code>进行关联.</p>
<h4 id="从父类继承的属性">从父类继承的属性</h4><p>有时候通过一个(技术上或业务上)父类共享一些公共属性是很有用的, 同时还不用将该父类作为映射的实体(也就是该实体没有对应的表). 这个时候你需要使用@MappedSuperclass注解来进行映射.</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@MappedSuperclass</span></span><br><span class="line">public class BaseEntity &#123;</span><br><span class="line">    <span class="variable">@Basic</span></span><br><span class="line">    <span class="variable">@Temporal</span>(TemporalType.TIMESTAMP)</span><br><span class="line">    public Date <span class="function">getLastUpdate</span>() &#123; ... &#125;</span><br><span class="line">    public String <span class="function">getLastUpdater</span>() &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable">@Entity</span> class Order extends BaseEntity &#123;</span><br><span class="line">    <span class="variable">@Id</span> public Integer <span class="function">getId</span>() &#123; ... &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在数据库中,上面这个例子中的继承的层次结构最终以Order表的形式出现, 该表拥有id, lastUpdate 和 lastUpdater三个列.父类中的属性映射将复制到其子类实体. 注意这种情况下的父类不再处在继承层次结构的顶端.</p>
<p>注意：<br>注意,没有注解为@MappedSuperclass的父类中的属性将被忽略。<br>除非显式使用Hibernate annotation中的@AccessType注解, 否则将从继承层次结构的根实体中继承访问类型(包括字段或方法)。<br>这对于@Embeddable对象的父类中的属性持久化同样有效. 只需要使用@MappedSuperclass注解即可 (虽然这种方式不会纳入EJB3标准)。<br>可以将处在在映射继承层次结构的中间位置的类注解为@MappedSuperclass。<br>在继承层次结构中任何没有被注解为@MappedSuperclass 或@Entity的类都将被忽略。</p>
<p>你可以通过 @AttributeOverride注解覆盖实体父类中的定义的列. 这个注解只能在继承层次结构的顶端使用.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@MappedSuperclass</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyingObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAltitude</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> altitude;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Transient</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMetricAltitude</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> metricAltitude;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ManyToOne</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> PropulsionType <span class="title">getPropulsion</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> metricAltitude;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@AttributeOverride</span>( name=<span class="string">"altitude"</span>, column = <span class="annotation">@Column</span>(name=<span class="string">"fld_altitude"</span>) )</span><br><span class="line"><span class="annotation">@AssociationOverride</span>( name=<span class="string">"propulsion"</span>, joinColumns = <span class="annotation">@JoinColumn</span>(name=<span class="string">"fld_propulsion_fk"</span>) )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Plane</span> <span class="keyword">extends</span> <span class="title">FlyingObject</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面这个例子中,altitude属性的值最终将持久化到Plane 表的<code>fld_altitude</code>列.而名为propulsion的关联则保存在<code>fld_propulsion_fk</code>外间列.</p>
<p>你可以为@Entity和@MappedSuperclass注解的类 以及那些对象为@Embeddable的属性定义 @AttributeOverride和@AssociationOverride.</p>
<h3 id="关联关系映射">关联关系映射</h3><h4 id="关联关系映射—简介">关联关系映射—简介</h4><p>在hibernate中，支持对象之间的关联关系映射，这样可以减少我们的dao操作，操作一个对象的时候，就可以顺带操作它的关联对象。我们知道，hibernate支持三种关联关系，1:1，1:M，M:N。但，这只是对象之间的关系。数据库的设计当然也支持1:1，1:M，M:N三种关系。比如，我们经常说的1:M，就是把1这张表的主键拿到多那边做外键。但是，很多同学经常迷惑，为什么网上介绍的1:M，比我们讲的还要复杂的多？我们只需要<set>和<many-to-one>，但是网上介绍的还有一种使用<set>和<join>的？这里我们就不得不提出 “数据库设计的降级使用”这个概念了。 </join></set></many-to-one></set></p>
<h4 id="关联关系映射—数据库降级使用">关联关系映射—数据库降级使用</h4><p>标准的1:M </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----------+          +----------+</span><br><span class="line">|<span class="string">tbl_parent</span>|<span class="string">          </span>|<span class="string">tbl_child </span>|<span class="string"> </span><br><span class="line">+----------+          +----------+</span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;  </span>|<span class="string">          </span>|<span class="string"> uuid&lt;PK&gt; </span>|</span><br><span class="line">+----------+          |<span class="string"> puuid&lt;FK&gt;</span>|</span><br><span class="line">                      +----------+</span><br></pre></td></tr></table></figure>
<p>标准的M:N </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +---------------+     +-----------+ </span><br><span class="line">|<span class="string">tbl_student</span>|<span class="string">     </span>|<span class="string">   tbl_grade   </span>|<span class="string">     </span>|<span class="string">tbl_course </span>|<span class="string">  </span><br><span class="line">+-----------+     +---------------+     +-----------+ </span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">     </span>|<span class="string"> suuid&lt;PK&gt;&lt;FK&gt; </span>|<span class="string">     </span>|<span class="string">cuuid&lt;PK&gt;  </span>|<span class="string"> </span><br><span class="line">+-----------+     </span>|<span class="string"> cuuid&lt;PK&gt;&lt;FK&gt; </span>|<span class="string">     +-----------+ </span><br><span class="line">                  +---------------+</span></span><br></pre></td></tr></table></figure>
<p>将M:N的数据库设计降级为1:M使用 </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +-----------------------+     +-----------+ </span><br><span class="line">|<span class="string">tbl_parent </span>|<span class="string">     </span>|<span class="string"> tbl_parent_child      </span>|<span class="string">     </span>|<span class="string">tbl_child  </span>|<span class="string">  </span><br><span class="line">+-----------+     +-----------------------+     +-----------+ </span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">     </span>|<span class="string"> puuid&lt;PK&gt;&lt;FK&gt;         </span>|<span class="string">     </span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string"> </span><br><span class="line">+-----------+     </span>|<span class="string"> cuuid&lt;PK&gt;&lt;FK&gt;&lt;UNIQUE&gt; </span>|<span class="string">     +-----------+ </span><br><span class="line">                  +-----------------------+</span></span><br></pre></td></tr></table></figure>
<h4 id="关联关系映射—1:1—共享主键">关联关系映射—1:1—共享主键</h4><p>标准的1:1 </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+-----------+          +----------------+</span><br><span class="line">|<span class="string">tbl_product</span>|<span class="string">          </span>|<span class="string">tbl_product_info</span>|<span class="string"> </span><br><span class="line">+-----------+          +----------------+</span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">          </span>|<span class="string">  uuid&lt;PK&gt;&lt;FK&gt;  </span>|</span><br><span class="line">+-----------+          +----------------+</span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML的配置 </p>
<p>  主1 【tbl_product】： </p>
  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="constant">one</span>-<span class="built_in">to</span>-<span class="constant">one</span> name= <span class="string">"info"</span> cascade=<span class="string">"all"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>  从1 【tbl_product_info】： </p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="property">id</span> <span class="property">name</span>= <span class="string">"uuid"</span>&gt; </span><br><span class="line">&lt;generator <span class="type">class</span>=<span class="string">"foreign  【写死，使用外来生成策略】"</span>&gt; </span><br><span class="line">        &lt;param <span class="property">name</span>=<span class="string">"property"</span>&gt;product  【引用自己的Java属性名】 </span><br><span class="line">        &lt;/param&gt; </span><br><span class="line">&lt;/generator&gt; </span><br><span class="line">&lt;/<span class="property">id</span>&gt; </span><br><span class="line">&lt;one-<span class="keyword">to</span>-one <span class="property">name</span>= <span class="string">"product"</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解的配置 </p>
<p>  主1 【tbl_product】： </p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@OneToOne</span>(cascade=CascadeType.ALL) </span><br><span class="line"><span class="variable">@PrimaryKeyJoinColumn</span> </span><br><span class="line">private ProductInfoModel info;</span><br></pre></td></tr></table></figure>
<p>  从1 【tbl_product_info】： </p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Id</span> </span><br><span class="line"><span class="variable">@Column</span> </span><br><span class="line"><span class="variable">@GeneratedValue</span>(generator=<span class="string">"copy 【引用生成策略】"</span>) </span><br><span class="line"><span class="variable">@GenericGenerator</span>(name=<span class="string">"copy  【定义生成策略】"</span>,strategy=<span class="string">"foreign  【写死，使用外来策略】"</span>,parameters=<span class="variable">@Parameter</span>(name=<span class="string">"property"</span>,value=<span class="string">"product  【引用自己的Java属性】"</span>)) </span><br><span class="line">private int uuid; </span><br><span class="line"><span class="variable">@OneToOne</span>(mappedBy=<span class="string">"info  【引用对方的Java属性】"</span>) </span><br><span class="line">private ProductModel product;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关联关系映射—1:M—外键">关联关系映射—1:M—外键</h4><p>标准的1:M </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+----------+          +----------+</span><br><span class="line">|<span class="string">tbl_parent</span>|<span class="string">          </span>|<span class="string">tbl_child </span>|<span class="string"> </span><br><span class="line">+----------+          +----------+</span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;  </span>|<span class="string">          </span>|<span class="string"> uuid&lt;PK&gt; </span>|</span><br><span class="line">+----------+          |<span class="string"> puuid&lt;FK&gt;</span>|</span><br><span class="line">                      +----------+</span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML的配置</p>
<p>  1 【tbl_parent】： </p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">set</span> <span class="property">name</span>= <span class="string">"children"</span>&gt; </span><br><span class="line">    &lt;key column=<span class="string">"puuid  【对方的数据库外键列名】"</span>/&gt; </span><br><span class="line">    &lt;one-<span class="keyword">to</span>-many <span class="type">class</span>=<span class="string">"cn.j avass.model.c.ChildModel  【对方的Java类名】"</span>/&gt; </span><br><span class="line">&lt;/<span class="keyword">set</span>&gt;</span><br></pre></td></tr></table></figure>
<p>  多 【tbl_child】： </p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;many-<span class="keyword">to</span>-one <span class="property">name</span>=<span class="string">"parent"</span> column=<span class="string">"puuid 【自己的数据库外键列名】"</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>注解的配置<br>  1 【tbl_parent】：   <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@OneToMany</span> </span><br><span class="line"><span class="variable">@JoinColumn</span>(name=<span class="string">"puuid 【对方的数据库外键列名】"</span>) </span><br><span class="line">private Set&lt;ChildModel&gt; children = new HashSet&lt;ChildModel&gt;();</span><br></pre></td></tr></table></figure>
  多 【tbl_child】：   <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@ManyToOne</span> </span><br><span class="line"><span class="variable">@JoinColumn</span>(name=<span class="string">"puuid 【自己的数据库外键列名】"</span>) </span><br><span class="line">private ParentModel parent;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关联关系映射—M:N—联接表">关联关系映射—M:N—联接表</h4><p>标准的M:N </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +---------------+     +-----------+ </span><br><span class="line">|<span class="string">tbl_student</span>|<span class="string">     </span>|<span class="string">   tbl_grade   </span>|<span class="string">     </span>|<span class="string">tbl_course </span>|<span class="string">  </span><br><span class="line">+-----------+     +---------------+     +-----------+ </span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">     </span>|<span class="string"> suuid&lt;PK&gt;&lt;FK&gt; </span>|<span class="string">     </span>|<span class="string"> uuid&lt;PK&gt;  </span>|<span class="string"> </span><br><span class="line">+-----------+     </span>|<span class="string"> cuuid&lt;PK&gt;&lt;FK&gt; </span>|<span class="string">     +-----------+ </span><br><span class="line">                  +---------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML的配置 </p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">set</span> <span class="property">name</span>=<span class="string">"courses"</span> table=<span class="string">"tbl_grade  【联接表】"</span>&gt; </span><br><span class="line">    &lt;key column=<span class="string">"suuid 【联接表里代表自己的数据库字段名】"</span>/&gt; </span><br><span class="line">    &lt;many-<span class="keyword">to</span>-many column=<span class="string">"cuuid 【联接表里代表对方的数据库字段名】"</span> </span><br><span class="line">    <span class="type">class</span>=<span class="string">"cn.ja vass.model.e.CourseMode  【对方的类名】l"</span>/&gt; </span><br><span class="line">&lt;/<span class="keyword">set</span>&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解的配置 </p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@ManyToMany</span> </span><br><span class="line"><span class="variable">@JoinTable</span>( </span><br><span class="line">name=<span class="string">"tbl_grade  【联接表】"</span>, </span><br><span class="line">joinColumns=<span class="variable">@JoinColumn</span>(name=<span class="string">"suuid 【联接表里代表自己的数据库字段名】"</span>), </span><br><span class="line">inverseJoinColumns=<span class="variable">@JoinColumn</span>(name=<span class="string">"cuuid   【联接表里代表对方的数据库字段名】"</span> ) </span><br><span class="line">) </span><br><span class="line">private Set&lt;CourseModel&gt; courses = new HashSet&lt;CourseModel&gt;();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>关联关系映射—1:1—引用外键 </p>
<p>标准的1:M </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +-----------------------+  </span><br><span class="line">|<span class="string">tbl_product</span>|<span class="string">     </span>|<span class="string"> tbl_product_info      </span>|<span class="string">  </span><br><span class="line">+-----------+     +-----------------------+ </span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">     </span>|<span class="string"> uuid&lt;PK&gt;              </span>|<span class="string"> </span><br><span class="line">+-----------+     </span>|<span class="string"> puuid&lt;FK&gt;&lt;UNIQUE&gt;     </span>|<span class="string"> </span><br><span class="line">                  +-----------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML的配置</p>
<p>  主1 【tbl_product】： </p>
  <figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="constant">one</span>-<span class="built_in">to</span>-<span class="constant">one</span> name=<span class="string">"info"</span> foreign-key= <span class="string">"puuid  【对方的数据库外键列名】"</span>  cascade=<span class="string">"all"</span>/&gt;</span><br></pre></td></tr></table></figure>
<p>  从1 【tbl_product_info】： </p>
  <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;many-to-one <span class="variable">name=</span><span class="string">"product"</span> <span class="variable">column=</span><span class="string">"puuid 【自己的数据库外键列名】"</span> <span class="variable">unique=</span><span class="string">"true 【写死】"</span>/&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>注解的配置 </p>
<p>  主1 【tbl_product】： </p>
  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@OneToOne</span>(cascade=CascadeType.ALL,mappedBy=<span class="string">"product  【对方的Java类属性名】"</span>) </span><br><span class="line"><span class="keyword">private</span> ProductInfoModel info;</span><br></pre></td></tr></table></figure>
<p>  从1 【tbl_product_info】： </p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@OneToOne</span> </span><br><span class="line"><span class="variable">@JoinColumn</span>(name=<span class="string">"puuid 【自己的数据库外键列名】"</span>) </span><br><span class="line">private ProductModel product;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关联关系映射—1:M—联接表">关联关系映射—1:M—联接表</h4><p>标准的1:M </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +-----------------------+     +-----------+ </span><br><span class="line">|<span class="string">tbl_parent </span>|<span class="string">     </span>|<span class="string"> tbl_parent_child      </span>|<span class="string">     </span>|<span class="string">tbl_child  </span>|<span class="string">  </span><br><span class="line">+-----------+     +-----------------------+     +-----------+ </span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">     </span>|<span class="string"> puuid&lt;PK&gt;&lt;FK&gt;         </span>|<span class="string">     </span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string"> </span><br><span class="line">+-----------+     </span>|<span class="string"> cuuid&lt;PK&gt;&lt;FK&gt;&lt;UNIQUE&gt; </span>|<span class="string">     +-----------+ </span><br><span class="line">                  +-----------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML的配置<br>  1 【tbl_parent 】： </p>
  <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;set <span class="variable">name=</span><span class="string">"children"</span> <span class="variable">table=</span><span class="string">"tbl_parent_child  【联接表】"</span>&gt; </span><br><span class="line">    &lt;key <span class="variable">column=</span><span class="string">"puuid  【联接表里代表自己的数据库列名】"</span>/&gt; </span><br><span class="line">    &lt;many-to-many <span class="variable">column=</span><span class="string">"cuuid 【联接表里代表对方的数据库列名】"</span> <span class="variable">unique=</span><span class="string">"true 【写死】"</span> <span class="variable">class=</span><span class="string">"cn.javass.model.d.ChildModel  【对方的Java类名】"</span>/&gt; </span><br><span class="line">&lt;/set&gt; </span><br><span class="line">&lt;join <span class="variable">table=</span><span class="string">"tbl_parent_child  【联接表】"</span>&gt; </span><br><span class="line">    &lt;key <span class="variable">column=</span><span class="string">"cuuid 【联接表里代表自己的数据库列名】"</span>/&gt; </span><br><span class="line">    &lt;many-to-one <span class="variable">name=</span> <span class="string">"parent"</span> <span class="variable">column=</span><span class="string">"puuid  【联接表里代表对方的数据库列名】"</span> <span class="variable">unique=</span><span class="string">"true 【写死】"</span>/&gt; </span><br><span class="line">&lt;/join&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解的配置<br>  1 【tbl_parent 】： </p>
  <figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@OneToMany</span>(mappedBy=<span class="string">"parent  【对方的Java类属性名】"</span>) </span><br><span class="line"><span class="keyword">private</span> Set&lt;ChildModel&gt; children = <span class="keyword">new</span> HashSet&lt;ChildModel&gt;();</span><br></pre></td></tr></table></figure>
<p>  多 【tbl_child】： </p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@ManyToOne</span> </span><br><span class="line"><span class="variable">@JoinTable</span>( </span><br><span class="line">name=<span class="string">"tbl_parent_child 【联接表】"</span>, </span><br><span class="line">joinColumns=<span class="variable">@JoinColumn</span>(name=<span class="string">"cuuid 【联接表里代表自己的数据库字段名】"</span>), </span><br><span class="line">inverseJoinColumns=<span class="variable">@JoinColumn</span>(name=<span class="string">"puuid 【联接表里代表对方的数据库字段名】"</span>) </span><br><span class="line">) </span><br><span class="line">private ParentModel parent;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="关联关系映射—1:1—联接表">关联关系映射—1:1—联接表</h4><p>标准的1:M </p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">+-----------+     +-----------------------+     +----------------+ </span><br><span class="line">|<span class="string">tbl_product</span>|<span class="string">     </span>|<span class="string"> tbl_product_relation  </span>|<span class="string">     </span>|<span class="string">tbl_product_info</span>|<span class="string">  </span><br><span class="line">+-----------+     +-----------------------+     +----------------+ </span><br><span class="line"></span>|<span class="string">uuid&lt;PK&gt;   </span>|<span class="string">     </span>|<span class="string"> puuid&lt;PK&gt;&lt;FK&gt;&lt;UNIQUE&gt; </span>|<span class="string">     </span>|<span class="string">uuid&lt;PK&gt;        </span>|<span class="string"> </span><br><span class="line">+-----------+     </span>|<span class="string"> cuuid&lt;PK&gt;&lt;FK&gt;&lt;UNIQUE&gt; </span>|<span class="string">     +----------------+ </span><br><span class="line">                  +-----------------------+</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>XML的配置<br>  1 【tbl_product 】： </p>
  <figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;join <span class="variable">table=</span><span class="string">"tbl_product_relation  【联接表】"</span>&gt; </span><br><span class="line">    &lt;key <span class="variable">column=</span><span class="string">"puuid  【联接表里代表自己的列名】"</span>/&gt; </span><br><span class="line">    &lt;many-to-one <span class="variable">name=</span><span class="string">"course  【自己的Java属性名】"</span> <span class="variable">column=</span><span class="string">"cuuid  【联接表里代表对方的列名】"</span> <span class="variable">unique=</span><span class="string">"true 【写死】"</span>/&gt; </span><br><span class="line">&lt;/join&gt;</span><br></pre></td></tr></table></figure>
</li>
<li><p>注解的配置<br>  1 【tbl_product 】： </p>
  <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@ManyToOne</span> </span><br><span class="line"><span class="variable">@JoinTable</span>( </span><br><span class="line">name=<span class="string">"tbl_product_relation 【联接表】"</span>, </span><br><span class="line">joinColumns=<span class="variable">@JoinColumn</span>(name=<span class="string">"suuid 【联接表里代表自己的列名】"</span>), </span><br><span class="line">inverseJoinColumns=<span class="variable">@JoinColumn</span>(name=<span class="string">"cuuid 【联接表里代表对方的列名】"</span>,unique=true 【写死】) </span><br><span class="line">) </span><br><span class="line">private CourseModel course;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="二级缓存">二级缓存</h3><p>@Cache示例<br>定义在实体类上，示例如下：<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span> </span><br><span class="line"><span class="variable">@Cache</span>(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE) </span><br><span class="line">public class Forest &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="批量处理">批量处理</h2><p>可以使用循环进行批量处理。批量插入、更新时为了避免运行失败，定时将Session缓存的数据刷入数据库</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//累加器i是20的倍数时，将Session中的数据刷入数据库，并清空Session缓存</span></span><br><span class="line"><span class="keyword">if</span> <span class="params">(i % <span class="number">20</span> == <span class="number">0</span>)</span> &#123;</span><br><span class="line">    session.flush<span class="params">()</span>;</span><br><span class="line">    session.clear<span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>批量更新时，如果需要返回多行数据，应该使用scroll()方法，从而充分利用服务器端游标所带来的性能优势。<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Session session = HibernateUtil.currentSession<span class="params">()</span>;</span><br><span class="line">Transaction tx = session.beginTransaction<span class="params">()</span>;</span><br><span class="line">ScrollableResults users = session.createQuery<span class="params">(<span class="string">"from User"</span>)</span>.setCacheMode<span class="params">(CacheMode.IGNORE)</span>.scroll<span class="params">(ScrollMode.FORWARD_ONLY)</span>;</span><br><span class="line">int count = <span class="number">0</span>;</span><br><span class="line">while<span class="params">(users.next<span class="params">()</span>)</span>&#123;</span><br><span class="line">    User u = <span class="params">(User)</span>users.get<span class="params">(<span class="number">0</span>)</span>;</span><br><span class="line">    u.setName<span class="params">(<span class="string">"新用户"</span>)</span>;</span><br><span class="line">    <span class="keyword">if</span><span class="params">(++count % <span class="number">20</span> == <span class="number">0</span>)</span>&#123;</span><br><span class="line">        session.flush<span class="params">()</span>;</span><br><span class="line">        session.clear<span class="params">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">tx.commit<span class="params">()</span>;</span><br><span class="line">HibernateUtil.closeSession<span class="params">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>Hibernate提供HQL语句也可以批量更新、删除。语法<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">UPDATE</span> | <span class="keyword">DELETE</span> <span class="keyword">FROM</span>? &lt;CLASSNAME&gt; [<span class="keyword">WHERE</span> WHERE_CONDITIONS]</span></span><br></pre></td></tr></table></figure></p>
<p>FROM子句中，FROM关键字是可选的。<br>在FROM子句中只能有一个类名，该类名不能有别名。<br>不能再批量HQL语句中使用连接，显式或者银石都不行。但可以在WHERE子句的语法中使用子查询。<br>整个WHERE子句是可选的。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> updateEntities = session.createQuery(hql).executeUpdate<span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<h2 id="使用HQL查询">使用HQL查询</h2><p>步骤</p>
<ol>
<li>获取Hibernate Session对象</li>
<li>编写HQL语句</li>
<li>以HQL语句作为参数，调用Session的createQuery方法创建查询对象。</li>
<li>如果HQL语句包含参数，则调用Query的setXXX方法为参数赋值。</li>
<li>调用Query对象的list等方法返回查询结果列表（持久化实体集）</li>
</ol>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Session session = HibernateUtil.currentSession<span class="params">()</span>;</span><br><span class="line">Transaction tx = session.beginTransaction<span class="params">()</span>;</span><br><span class="line">SimpleDateFormat sdf = new SimpleDateFormat<span class="params">(<span class="string">"yyyy-MM-dd"</span>)</span>;</span><br><span class="line">Date start = sdf.parse<span class="params">(<span class="string">"2005-01-01"</span>)</span>;</span><br><span class="line">List pl = session.createQuery<span class="params">(<span class="string">"select distinct p from Person p"</span></span><br><span class="line">        + <span class="string">" inner join p.myEvents event where event.happenDate"</span></span><br><span class="line">        + <span class="string">" between :firstDate and :endDate"</span>)</span></span><br><span class="line">            .setDate<span class="params">(<span class="string">"firstDate"</span>, start)</span></span><br><span class="line">            .setDate<span class="params">(<span class="string">"endDate"</span>, new Date<span class="params">()</span>)</span></span><br><span class="line">            .list<span class="params">()</span>;</span><br><span class="line"><span class="keyword">for</span><span class="params">(Iterator pit = pl.iterator<span class="params">()</span>;pit.hasNext<span class="params">()</span>;)</span>&#123;</span><br><span class="line">    Person p = <span class="params">(Person)</span> pit.next<span class="params">()</span>;</span><br><span class="line">    System.out.println<span class="params">(p.getName<span class="params">()</span>)</span>;</span><br><span class="line">&#125;</span><br><span class="line">tx.commit<span class="params">()</span>;</span><br><span class="line">HibernateUtil.closeSession<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>执行HQL语句类似于用PreparedStatement执行SQL语句，因此HQL语句中可以使用占位符作为参数。HQL的占位符既可使用英文问好(?)，这与SQL语句中的占位符一样；也可使用有名字的占位符，使用有名字的占位符时，应该在占位符名字前增加英文冒号(:)。</p>
<p>setXXX()：方法有两个版本，分别根据参数索引赋值和根据参数名字赋值。<br>list(): 返回查询到的全部结果<br>setFirstResult(int firstResult)：设置返回的结果集从第几条开始<br>setMaxResults(int maxResults)：设置本次查询返回的结果数目</p>
<p>后两个方法用于对HQL查询实现分页控制</p>
<p>HQL语句本身是不区分大小写的。也就是说，HQL语句的关键字、函数都是不区分大小写的。但HQL语句中所使用的包名、类名、实例名、属性名都区分大小写。</p>
<h3 id="from子句">from子句</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span></span><br><span class="line">from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure>
<p>建议为每个实例起别名。as关键字是可选的，为了增加可读性，建议保留。</p>
<h3 id="关联和连接">关联和连接</h3><p>两种形式关联连接：隐式和显式</p>
<p>隐式连接形式不使用join关键字，使用英文点号（.）来隐式连接关联实体，Hibernate底层自动进行关联查询。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span> p where p.myEvents.title &gt; :title</span><br></pre></td></tr></table></figure></p>
<p>显示连接则需要使用 xxx join关键字<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span> p</span><br><span class="line">inner join p.myEvents event</span><br><span class="line">where event.happenDate &lt; :endDate</span><br></pre></td></tr></table></figure></p>
<p>可使用几种连接方式</p>
<ul>
<li>inner join，内连接，可简写成join。</li>
<li>left outer join，左外连接，可简写成，left join</li>
<li>right outer join，右外连接，可简写成，right join</li>
<li>full join，全连接，不常用</li>
</ul>
<p>还可通过with关键字来提供额外的连接条件。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from Person <span class="tag">p</span></span><br><span class="line">inner join <span class="tag">p</span><span class="class">.myEvents</span> event</span><br><span class="line">with <span class="tag">p</span><span class="class">.id</span> &gt; event<span class="class">.id</span></span><br><span class="line">where event<span class="class">.happenDate</span> &lt; :endDate</span><br></pre></td></tr></table></figure></p>
<p>省略select关键字，返回的结果也是集合，但集合元素是被查询持久化对象、所有被关联的持久化对象所组成的数组。如上查询将会返回person、event_table表中的所有数据。</p>
<p>为了查询结果不重复可以使用distinct关键字</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select <span class="keyword">distinct</span> p <span class="keyword">from</span> <span class="type">Person</span> p</span><br><span class="line">inner join p.myEvents e</span><br><span class="line">where e.title := eventTitle</span><br></pre></td></tr></table></figure>
<p>如果关联实体是集合如myEvents这时不可以用隐式连接，必须显式连接关联实体或组件。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span> as p</span><br><span class="line">join fetch p.scores</span><br></pre></td></tr></table></figure></p>
<p>上次的fetch关键字将导致Hibernate在初始化Person对象时，同时抓取Person关联的scores集合属性。也可以在配置文件中制定<code>lazy=&quot;false&quot;</code></p>
<p>fetch关键字注意：</p>
<ul>
<li>fetch不应该与setMaxResults()与setFirstResult()共用。因为这些操作是基于结果集的，而在预先抓取集合类时可能包含重复的数据，即无法预先知道精确的行数。</li>
<li>fetch不能与独立的with条件一起使用</li>
<li>如果在一次查询中fetch多个集合，可以查询返回笛卡尔积，因此要多加注意。</li>
<li>对bag映射而言，同时join fetch多个集合时可能出现非预期结果，因此需要谨慎使用。</li>
<li>full join fetch 与 right join fetch是没有任何意义的</li>
</ul>
<p>也可以通过fetch all properties 来强制Hibernate立即抓取这些属性。<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Document fetch all properties order <span class="keyword">by</span> <span class="property">name</span></span><br></pre></td></tr></table></figure></p>
<h3 id="select子句">select子句</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select p.name.firstName from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure>
<p>select可以选择组件属性包含的属性<br>通常情况下，使用select子句查询的结果是集合，而集合元素是select后的实例、属性等组成的数组。<br>如果select后只有一项（包括持久化实例或属性），则查询得到的集合元素就是该持久化实例或属性。<br>如果select后有多个项，则每个集合元素就是选择出的多项组成的数组。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select p.name, p from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure></p>
<p>集合元素类似于[String,Person]结构的数组，其中第一个元素是Person实例的name属性，第二个是Person实例</p>
<p>将选出的属性存入一个List对象。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select new list(p.name,p.address) from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure></p>
<p>返回的集合元素是list而不是数组<br>也可以将选出的属性封装为对象，必须有对应的构造方法<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select new ClassTest(p.name,p.address) from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure></p>
<p>还可以给选出元素命名别名<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select p.name as personName from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure></p>
<p>这种用法与new map结合使用更加普遍。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select new map(p.name as personName) from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure></p>
<p>选出的集合元素是Map对象，以personName作为Map的key，实际选出的值作为Map的value</p>
<h3 id="HQL查询的聚集函数">HQL查询的聚集函数</h3><ul>
<li>avg：计算属性平均值</li>
<li>count：统计选择对象的数量</li>
<li>max：统计属性值的最大值</li>
<li>min：统计属性值的最小值</li>
<li>sum：计算属性值的总和</li>
</ul>
<p>select子句还支持字符串连接符、算术运算符，以及SQL函数。也支持使用distinct和all关键字。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">select p.name || <span class="string">""</span> || p.address from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure></p>
<h3 id="多态查询">多态查询</h3><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span> as p</span><br></pre></td></tr></table></figure>
<p>该查询语句不仅会查出Person的全部实例，还会查询出Person的子类。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from java<span class="class">.lang</span><span class="class">.Object</span> o</span><br></pre></td></tr></table></figure></p>
<p>该查询可以返回所有被持久化的对象。此查询无法使用order by子句对结果集排序，从而不允许对这些查询结果使用Query.scroll()</p>
<h3 id="HQL查询的where子句">HQL查询的where子句</h3><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Cat cat <span class="keyword">where</span> cat.mate.<span class="property">name</span> like <span class="string">"kit%"</span></span><br></pre></td></tr></table></figure>
<p>如果cat.mate是集合属性，Hibernate3.2.3以后的版本不支持这种用法。<br>class关键字用来存取一个实例的鉴别值。嵌入where子句中的java类名，将被作为该类的鉴别值。<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Cat</span> <span class="keyword">cat</span> where <span class="keyword">cat</span>.<span class="keyword">class</span> = DomesticCat</span><br></pre></td></tr></table></figure></p>
<p>当where子句的运算符只支持基本类型或字符串时，where子句中的属性表达式必须以基本类型或者字符串结尾，不要使用组件类型属性结尾。<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from Account as a where a.<span class="keyword">person</span>.name.firstName like <span class="string">"dd%"</span></span><br></pre></td></tr></table></figure></p>
<p>下面的语句则是错误的<br><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from Account as a where a.<span class="keyword">person</span>.name like <span class="string">"dd%"</span></span><br></pre></td></tr></table></figure></p>
<p>‘=’可以用于实例。</p>
<h3 id="表达式">表达式</h3><p>在where子句中允许使用的表达式包括 大多数你可以在SQL使用的表达式种类:</p>
<ul>
<li>数学运算符<code>+, -, *, /</code></li>
<li>二进制比较运算符<code>=, &gt;=, &lt;=, &lt;&gt;, !=, like</code></li>
<li>逻辑运算符<code>and, or, not</code></li>
<li>in, not in, between, is null, is not null, is empty, is not empty, member of and not member of</li>
<li>“简单的” case, case … when … then … else … end,和 “搜索” case, case when … then … else … end</li>
<li>字符串连接符…||… or concat(…,…)</li>
<li>current_date(), current_time(), current_timestamp()</li>
<li>second(…), minute(…), hour(…), day(…), month(…), year(…),</li>
<li>EJB-QL 3.0定义的任何函数或操作：substring(), trim(), lower(), upper(), length(), locate(), abs(), sqrt(), bit_length()</li>
<li>coalesce() 和 nullif()</li>
<li>cast(… as …), 其第二个参数是某Hibernate类型的名字，以及extract(… from …)，只要ANSI cast() 和 extract() 被底层数据库支持</li>
<li>任何数据库支持的SQL标量函数，比如sign(), trunc(), rtrim(), sin()</li>
<li>JDBC参数传入 ?</li>
<li>命名参数:name, :start_date, :x1</li>
<li>SQL 直接常量 ‘foo’, 69, ‘1970-01-01 10:00:01.0’</li>
<li><p>Java public static final 类型的常量 eg.Color.TABBY</p>
</li>
<li><p>关键字in与between可按如下方法使用:</p>
  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> DomesticCat cat <span class="keyword">where</span> cat.name between <span class="string">'A'</span> <span class="keyword">and</span> <span class="string">'B'</span></span><br><span class="line"><span class="keyword">from</span> DomesticCat cat <span class="keyword">where</span> cat.name <span class="keyword">in</span> ( <span class="string">'Foo'</span>, <span class="string">'Bar'</span>, <span class="string">'Baz'</span> )</span><br></pre></td></tr></table></figure></li>
<li><p>而且否定的格式也可以如下书写：</p>
  <figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> DomesticCat cat <span class="keyword">where</span> cat.name <span class="keyword">not</span> between <span class="string">'A'</span> <span class="keyword">and</span> <span class="string">'B'</span></span><br><span class="line"><span class="keyword">from</span> DomesticCat cat <span class="keyword">where</span> cat.name <span class="keyword">not</span> <span class="keyword">in</span> ( <span class="string">'Foo'</span>, <span class="string">'Bar'</span>, <span class="string">'Baz'</span> )</span><br></pre></td></tr></table></figure>
</li>
<li><p>同样, 子句is null与is not null可以被用来测试空值(null).</p>
</li>
<li><p>在Hibernate配置文件中声明HQL“查询替代（query substitutions）”之后， 布尔表达式（Booleans）可以在其他表达式中轻松的使用:</p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"hibernate.query.substitutions"</span>&gt;<span class="constant">true</span> <span class="number">1</span>, <span class="constant">false</span> <span class="number">0</span>&lt;/<span class="keyword">property</span>&gt;</span><br></pre></td></tr></table></figure>
<p>  系统将该HQL转换为SQL语句时，该设置表明将用字符 1 和 0 来 取代关键字true 和 false:</p>
  <figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Cat cat <span class="keyword">where</span> cat.alive = <span class="constant">true</span></span><br></pre></td></tr></table></figure></li>
<li>你可以用特殊属性size, 或是特殊函数size()测试一个集合的大小。  <figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from Cat <span class="built_in">cat</span> where <span class="built_in">cat</span>.kittens.<span class="built_in">size</span> &gt; <span class="number">0</span></span><br><span class="line">from Cat <span class="built_in">cat</span> where <span class="built_in">size</span>(<span class="built_in">cat</span>.kittens) &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure></li>
<li>对于索引了（有序）的集合，你可以使用minindex 与 maxindex函数来引用到最小与最大的索引序数。 同理，你可以使用minelement 与 maxelement函数来 引用到一个基本数据类型的集合中最小与最大的元素。  <figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Calendar cal <span class="keyword">where</span> maxelement(cal.holidays) &gt; current <span class="built_in">date</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Order</span> <span class="keyword">order</span> <span class="keyword">where</span> maxindex(<span class="keyword">order</span>.items) &gt; <span class="number">100</span></span><br><span class="line"><span class="keyword">from</span> <span class="keyword">Order</span> <span class="keyword">order</span> <span class="keyword">where</span> minelement(<span class="keyword">order</span>.items) &gt; <span class="number">10000</span></span><br></pre></td></tr></table></figure></li>
<li><p>在传递一个集合的索引集或者是元素集(elements与indices 函数) 或者传递一个子查询的结果的时候，可以使用SQL函数any, some, all, exists, in</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select mother from Cat as mother, Cat as kit</span><br><span class="line">where kit <span class="keyword">in</span> <span class="function"><span class="title">elements</span><span class="params">(foo.kittens)</span></span></span><br><span class="line">select <span class="tag">p</span> from NameList list, Person <span class="tag">p</span></span><br><span class="line">where <span class="tag">p</span><span class="class">.name</span> = some <span class="function"><span class="title">elements</span><span class="params">(list.names)</span></span></span><br><span class="line">from Cat cat where exists <span class="function"><span class="title">elements</span><span class="params">(cat.kittens)</span></span></span><br><span class="line">from Player <span class="tag">p</span> where <span class="number">3</span> &gt; all <span class="function"><span class="title">elements</span><span class="params">(p.scores)</span></span></span><br><span class="line">from Show show where <span class="string">'fizard'</span> <span class="keyword">in</span> <span class="function"><span class="title">indices</span><span class="params">(show.acts)</span></span></span><br></pre></td></tr></table></figure>
<p>  注意，在Hibernate3种，这些结构变量- size, elements, indices, minindex, maxindex, minelement, maxelement - 只能在where子句中使用。</p>
</li>
<li><p>一个被索引过的（有序的）集合的元素(arrays, lists, maps)可以在其他索引中被引用（只能在where子句中）：</p>
  <figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">from Order order where order.items<span class="comment">[0]</span>.id = 1234</span><br><span class="line">select <span class="keyword">person</span> from <span class="keyword">Person</span> <span class="keyword">person</span>, Calendar calendar</span><br><span class="line">where calendar.holidays<span class="comment">['national day']</span> = <span class="keyword">person</span>.birthDay</span><br><span class="line">    and <span class="keyword">person</span>.nationality.calendar = calendar</span><br><span class="line">select item from Item item, Order order</span><br><span class="line">where order.items<span class="comment">[ order.deliveredItemIndices<span class="comment">[0]</span> ]</span> = item and order.id = 11</span><br><span class="line">select item from Item item, Order order</span><br><span class="line">where order.items<span class="comment">[ maxindex(order.items) ]</span> = item and order.id = 11</span><br></pre></td></tr></table></figure>
<p>  在[]中的表达式甚至可以是一个算数表达式。</p>
  <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> item <span class="keyword">from</span> Item item, <span class="keyword">Order</span> <span class="keyword">order</span></span><br><span class="line"><span class="keyword">where</span> <span class="keyword">order</span>.items[ <span class="keyword">size</span>(<span class="keyword">order</span>.items) - <span class="number">1</span> ] = item</span></span><br></pre></td></tr></table></figure>
<p>  对于一个一对多的关联（one-to-many association）或是值的集合中的元素， HQL也提供内建的index()函数，</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">select item, <span class="function"><span class="title">index</span><span class="params">(item)</span></span> from Order <span class="attribute">order</span> </span><br><span class="line">    join <span class="attribute">order</span><span class="class">.items</span> item</span><br><span class="line">where <span class="function"><span class="title">index</span><span class="params">(item)</span></span> &lt; <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>  如果底层数据库支持标量的SQL函数，它们也可以被使用</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from DomesticCat cat where <span class="function"><span class="title">upper</span><span class="params">(cat.name)</span></span> like <span class="string">'FRI%'</span></span><br></pre></td></tr></table></figure>
<p>  如果你还不能对所有的这些深信不疑，想想下面的查询。如果使用SQL，语句长度会增长多少，可读性会下降多少：</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">select cust</span><br><span class="line">from Product prod,</span><br><span class="line">    Store store</span><br><span class="line">    inner join store<span class="class">.customers</span> cust</span><br><span class="line">where prod<span class="class">.name</span> = <span class="string">'widget'</span></span><br><span class="line">    and store<span class="class">.location</span><span class="class">.name</span> <span class="keyword">in</span> ( <span class="string">'Melbourne'</span>, <span class="string">'Sydney'</span> )</span><br><span class="line">    and prod = all <span class="function"><span class="title">elements</span><span class="params">(cust.currentOrder.lineItems)</span></span></span><br></pre></td></tr></table></figure>
<p>  提示: 会像如下的语句</p>
  <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SELECT cust<span class="class">.name</span>, cust<span class="class">.address</span>, cust<span class="class">.phone</span>, cust<span class="class">.id</span>, cust<span class="class">.current_order</span></span><br><span class="line">FROM customers cust,</span><br><span class="line">    stores store,</span><br><span class="line">    locations loc,</span><br><span class="line">    store_customers sc,</span><br><span class="line">    product prod</span><br><span class="line">WHERE prod<span class="class">.name</span> = <span class="string">'widget'</span></span><br><span class="line">    AND store<span class="class">.loc_id</span> = loc<span class="class">.id</span></span><br><span class="line">    AND loc<span class="class">.name</span> IN ( <span class="string">'Melbourne'</span>, <span class="string">'Sydney'</span> )</span><br><span class="line">    AND sc<span class="class">.store_id</span> = store<span class="class">.id</span></span><br><span class="line">    AND sc<span class="class">.cust_id</span> = cust<span class="class">.id</span></span><br><span class="line">    AND prod<span class="class">.id</span> = ALL(</span><br><span class="line">        SELECT item<span class="class">.prod_id</span></span><br><span class="line">        FROM line_items item, orders o</span><br><span class="line">        WHERE item<span class="class">.order_id</span> = o<span class="class">.id</span></span><br><span class="line">            AND cust<span class="class">.current_order</span> = o<span class="class">.id</span></span><br><span class="line">    )</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="order_by子句">order by子句</h3><p>查询返回的列表(list)可以按照一个返回的类或组件（components)中的任何属性（property）进行排序：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from DomesticCat <span class="keyword">cat</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">cat</span>.name asc, <span class="keyword">cat</span>.weight <span class="keyword">desc</span>, <span class="keyword">cat</span>.birthdate</span><br></pre></td></tr></table></figure></p>
<p>可选的asc或desc关键字指明了按照升序或降序进行排序.默认是升序排序。</p>
<h3 id="group_by子句">group by子句</h3><p>一个返回聚集值(aggregate values)的查询可以按照一个返回的类或组件（components)中的任何属性（property）进行分组：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">select cat<span class="class">.color</span>, <span class="function"><span class="title">sum</span><span class="params">(cat.weight)</span></span>, <span class="function"><span class="title">count</span><span class="params">(cat)</span></span> </span><br><span class="line">from Cat cat</span><br><span class="line">group by cat<span class="class">.color</span></span><br><span class="line">select foo<span class="class">.id</span>, <span class="function"><span class="title">avg</span><span class="params">(name)</span></span>, <span class="function"><span class="title">max</span><span class="params">(name)</span></span> </span><br><span class="line">from Foo foo join foo<span class="class">.names</span> name</span><br><span class="line">group by foo.id</span><br></pre></td></tr></table></figure>
<p>having子句在这里也允许使用.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">select cat<span class="class">.color</span>, <span class="function"><span class="title">sum</span><span class="params">(cat.weight)</span></span>, <span class="function"><span class="title">count</span><span class="params">(cat)</span></span> </span><br><span class="line">from Cat cat</span><br><span class="line">group by cat<span class="class">.color</span> </span><br><span class="line">having cat<span class="class">.color</span> <span class="keyword">in</span> (eg<span class="class">.Color</span><span class="class">.TABBY</span>, eg<span class="class">.Color</span><span class="class">.BLACK</span>)</span><br></pre></td></tr></table></figure>
<p>如果底层的数据库支持的话(例如不能在MySQL中使用)，SQL的一般函数与聚集函数也可以出现 在having与order by 子句中。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="operator"><span class="keyword">select</span> cat</span><br><span class="line"><span class="keyword">from</span> Cat cat</span><br><span class="line">    <span class="keyword">join</span> cat.kittens kitten</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> cat</span><br><span class="line"><span class="keyword">having</span> <span class="keyword">avg</span>(kitten.weight) &gt; <span class="number">100</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> <span class="keyword">count</span>(kitten) <span class="keyword">asc</span>, <span class="keyword">sum</span>(kitten.weight) <span class="keyword">desc</span></span></span><br></pre></td></tr></table></figure>
<p>注意group by子句与 order by子句中都不能包含算术表达式（arithmetic expressions）.</p>
<h3 id="子查询">子查询</h3><p>对于支持子查询的数据库，Hibernate支持在查询中使用子查询。一个子查询必须被圆括号包围起来（经常是SQL聚集函数的圆括号）。 甚至相互关联的子查询（引用到外部查询中的别名的子查询）也是允许的。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> Cat <span class="keyword">as</span> fatcat </span><br><span class="line"><span class="keyword">where</span> fatcat.weight &gt; ( </span><br><span class="line">    <span class="function"><span class="keyword">select</span> <span class="title">avg</span>(<span class="params">cat.weight</span>) <span class="keyword">from</span> DomesticCat cat </span><br><span class="line">)</span></span><br></pre></td></tr></table></figure></p>
<p>在select列表中包含一个表达式以上的子查询，你可以使用一个元组构造符（tuple constructors）：<br><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Cat</span> <span class="keyword">as</span> <span class="keyword">cat</span> </span><br><span class="line">where not ( <span class="keyword">cat</span>.name, <span class="keyword">cat</span>.color ) <span class="keyword">in</span> ( </span><br><span class="line">    select <span class="keyword">cat</span>.name, <span class="keyword">cat</span>.color from DomesticCat <span class="keyword">cat</span> </span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>注意在某些数据库中（不包括Oracle与HSQL），你也可以在其他语境中使用元组构造符， 比如查询用户类型的组件与组合：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span> where name = ('Gavin', 'A', 'King')</span><br></pre></td></tr></table></figure>
<p>该查询等价于更复杂的：</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">from <span class="keyword">Person</span> where name.first = 'Gavin' and name.initial = 'A' and name.last = 'King')</span><br></pre></td></tr></table></figure>
<p>有两个很好的理由使你不应当作这样的事情：首先，它不完全适用于各个数据库平台；其次，查询现在依赖于映射文件中属性的顺序。</p>
<h3 id="命名查询">命名查询</h3><p>命名查询实际上就是给查询语句起个名字，执行查询的时候就是直接使用起的这个名字，避免重复写HQL语句，使查询在代码中得到更多的重用。</p>
<ol>
<li><p>使用@NamedQuery注解在实体类中定义命名查询。</p>
 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@<span class="function"><span class="title">NamedQuery</span><span class="params">(name=<span class="string">"findAllUser"</span>,query=<span class="string">"SELECT u FROM User u"</span>)</span></span></span><br></pre></td></tr></table></figure>
<p> @NamedQuery中的属性name指定命名查询的名称，query属性指定命名查询的语句。</p>
<p> 如果要定义多个命名查询，需要使用@NamedQueries。</p>
 <figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@NamedQueries</span>(&#123;</span><br><span class="line">    <span class="variable">@NamedQuery</span>(name=<span class="string">"findAllUser"</span>,query=<span class="string">"SELECT u FROM User u"</span>),</span><br><span class="line">    <span class="variable">@NamedQuery</span>(name=<span class="string">"findUserWithId"</span>,query=<span class="string">"SELECT u FROM User u WHERE u.id = ?1"</span>),</span><br><span class="line">    <span class="variable">@NamedQuery</span>(name=<span class="string">"findUserWithName"</span>,query=<span class="string">"SELECT u FROM User u WHERE u.name = :name"</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>定义好命名查询后，可以使用EntityManager的createNamedQuery方法传入命名查询的名称创建查询。例如：createNamedQuery(“findAllUser”);</p>
</li>
<li>一个简单的例子。　　</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Column;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Entity;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.GeneratedValue;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Id;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.NamedQueries;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.NamedQuery;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Table;</span><br><span class="line"> </span><br><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@Table</span>(name=<span class="string">"t_user"</span>)</span><br><span class="line"><span class="annotation">@NamedQueries</span>(&#123;</span><br><span class="line">        <span class="annotation">@NamedQuery</span>(name=<span class="string">"findAllUser"</span>,query=<span class="string">"SELECT u FROM User u"</span>),</span><br><span class="line">        <span class="annotation">@NamedQuery</span>(name=<span class="string">"findUserWithId"</span>,query=<span class="string">"SELECT u FROM User u WHERE u.id = ?1"</span>),</span><br><span class="line">        <span class="annotation">@NamedQuery</span>(name=<span class="string">"findUserWithName"</span>,query=<span class="string">"SELECT u FROM User u WHERE u.name = :name"</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Id</span></span><br><span class="line">    <span class="annotation">@GeneratedValue</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@Column</span>(name=<span class="string">"name"</span>)</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">     </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">getId</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Long id)</span> </span>&#123; <span class="keyword">this</span>.id = id; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>测试<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManager;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.EntityManagerFactory;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Persistence;</span><br><span class="line"><span class="keyword">import</span> javax.persistence.Query;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> org.junit.After;</span><br><span class="line"><span class="keyword">import</span> org.junit.Before;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> entity.User;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestNamedQuery</span> </span>&#123;</span><br><span class="line">     </span><br><span class="line">    EntityManagerFactory emf = <span class="keyword">null</span>;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//根据在persistence.xml中配置的persistence-unit name 创建EntityManagerFactory</span></span><br><span class="line">        emf = Persistence.createEntityManagerFactory(<span class="string">"myJPA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//关闭EntityManagerFactory</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> != emf) &#123;</span><br><span class="line">            emf.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedQuery1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EntityManager em = emf.createEntityManager();</span><br><span class="line">        List&lt;User&gt; users = em.createNamedQuery(<span class="string">"findAllUser"</span>).getResultList();<span class="comment">//根据User实体中定义的命名查询</span></span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedQuery2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EntityManager em = emf.createEntityManager();</span><br><span class="line">        Query query =  em.createNamedQuery(<span class="string">"findUserWithId"</span>);<span class="comment">//根据User实体中定义的命名查询</span></span><br><span class="line">        query.setParameter(<span class="number">1</span>, <span class="number">2L</span>);</span><br><span class="line">        List&lt;User&gt; users = query.getResultList();</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    <span class="annotation">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testNamedQuery3</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        EntityManager em = emf.createEntityManager();</span><br><span class="line">        Query query =  em.createNamedQuery(<span class="string">"findUserWithName"</span>);<span class="comment">//根据User实体中定义的命名查询</span></span><br><span class="line">        query.setParameter(<span class="string">"name"</span>, <span class="string">"李坏"</span>);</span><br><span class="line">        List&lt;User&gt; users = query.getResultList();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="条件查询">条件查询</h2><ul>
<li>Criteria：代表一次查询</li>
<li>Criterion：代表一个查询条件</li>
<li>Restrictions：产生查询条件的工具类</li>
</ul>
<p>执行条件查询的步骤如下：</p>
<ol>
<li>获得Hibernate的Session对象</li>
<li>以Session对象创建Criteria （org.hibernate.Criteria接口表示特定持久类的一个查询。Session是 Criteria实例的工厂。）</li>
<li>使用Restrictions的静态方法创建Criterion查询条件</li>
<li>向Criteria查询中添加Criterion查询条件</li>
<li>执行Criteria的list等方法返回结果集</li>
</ol>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> <span class="built_in">list</span> <span class="subst">=</span> session<span class="built_in">.</span>createCriteria(Student<span class="built_in">.</span>class)</span><br><span class="line"><span class="built_in">.</span>add(Restrictions<span class="built_in">.</span><span class="literal">gt</span>(<span class="string">"name"</span>,<span class="string">"a"</span>))</span><br><span class="line"><span class="built_in">.</span><span class="built_in">list</span>();</span><br></pre></td></tr></table></figure>
<p>Criteria常用方法</p>
<ul>
<li>Criteria setFirstResult(int firstResult):设置查询返回的第一行记录</li>
<li>Criteria setMaxResults(int maxResults):设置查询返回的记录数</li>
<li>Criteria add(Criterion criterion):增加查询条件</li>
<li>Criteria addOrder(Order order):增加排序规则</li>
</ul>
<p>Restrictions产生查询条件Criterion，常用静态方法</p>
<p>下面方法返回Criterion</p>
<ul>
<li>Restrictions.eq —&gt; equal,等于.</li>
<li>Restrictions.allEq —&gt; 参数为Map对象,使用key/value进行多个等于的比对,相当于多个Restrictions.eq的效果</li>
<li>Restrictions.gt —&gt; great-than &gt; 大于</li>
<li>Restrictions.ge —&gt; great-equal &gt;= 大于等于</li>
<li>Restrictions.lt —&gt; less-than, &lt; 小于</li>
<li>Restrictions.le —&gt; less-equal &lt;= 小于等于</li>
<li>Restrictions.between —&gt; 对应SQL的between子句</li>
<li>Restrictions.like —&gt; 对应SQL的LIKE子句</li>
<li>Restrictions.in —&gt; 对应SQL的in子句</li>
<li>Restrictions.and —&gt; and 关系</li>
<li>Restrictions.or —&gt; or 关系</li>
<li>Restrictions.not —&gt; 求否</li>
<li>Restrictions.isEmpty —&gt; 判断属性是否为空,为空则返回true</li>
<li>Restrictions.isNotEmpty —&gt; 与isNull相反</li>
<li>Restrictions.isNull —&gt; 判断属性是否为空,为空则返回true</li>
<li>Restrictions.isNotNull —&gt; 与isNull相反</li>
<li>Restrictions.sqlRestriction —&gt; SQL限定的查询</li>
<li>Restrictions.sizeEq —&gt; 判断某个属性的元素个数是否与size相等<br>下面方法返回Order</li>
<li>Restrictions.asc —&gt; 限定升序排序</li>
<li>Restrictions.desc —&gt; 限定降序排序</li>
</ul>
<h3 id="关联和动态关联">关联和动态关联</h3><p>你可以使用createCriteria()非常容易的在互相关联的实体间建立约束。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list = session.createCriteria<span class="params">(Student.class)</span></span><br><span class="line">    .add<span class="params">( Restrictions.like<span class="params">(<span class="string">"name"</span>, <span class="string">"F%"</span>)</span></span><br><span class="line">    .createCriteria<span class="params">(<span class="string">"enrolments"</span>)</span></span><br><span class="line">    .add<span class="params">( Restrictions.gt<span class="params">(<span class="string">"semester"</span>, <span class="number">2</span>)</span></span><br><span class="line">    .list<span class="params">()</span>;</span></span></span><br></pre></td></tr></table></figure>
<p>第一个查询条件是直接过滤Person的属性。第二个查询条件则过滤Person的关联实体的属性，其中enrolments是Person类的关联实体，而semester则是Enrolment类的属性。返回的并不是Enrolment对象，而是Person对象的集合。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">List list = session.createCriteria<span class="params">(Student.class)</span></span><br><span class="line">    .add<span class="params">( Restrictions.like<span class="params">(<span class="string">"name"</span>, <span class="string">"F%"</span>)</span></span><br><span class="line">    .createAlias<span class="params">(<span class="string">"enrolments"</span>,<span class="string">"en"</span>)</span></span><br><span class="line">    .add<span class="params">( Restrictions.gt<span class="params">(<span class="string">"en.semester"</span>, <span class="number">2</span>)</span></span><br><span class="line">    .list<span class="params">()</span>;</span></span></span><br></pre></td></tr></table></figure>
<p>createAlias()并不创建一个新的 Criteria实例。它只是给关联实体（包括集合里包含的关联实体）起一个别名，让后面的过滤条件可根据该关联实体进行筛选。</p>
<p>Student实例所保存的之前两次查询所返回的enrolments集合是没有被条件预过滤的。如果你希望只获得符合条件的enrolments， 你必须使用returnMaps()。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List list = session.createCriteria<span class="params">(Student.class)</span></span><br><span class="line">    .add<span class="params">( Restrictions.like<span class="params">(<span class="string">"name"</span>, <span class="string">"F%"</span>)</span></span><br><span class="line">    .createCriteria<span class="params">(<span class="string">"enrolments"</span>,<span class="string">"en"</span>)</span></span><br><span class="line">    .add<span class="params">( Restrictions.gt<span class="params">(<span class="string">"en.semester"</span>, <span class="number">2</span>)</span></span><br><span class="line">    .returnMaps<span class="params">()</span></span><br><span class="line">    .list<span class="params">()</span>;</span><br><span class="line">Iterator iter = list.iterator<span class="params">()</span>;</span><br><span class="line">while <span class="params">( iter.hasNext<span class="params">()</span> )</span> &#123;</span><br><span class="line">    Map map = <span class="params">(Map)</span> iter.next<span class="params">()</span>;</span><br><span class="line">    Student stu= <span class="params">(Student)</span> map.get<span class="params">(Criteria.ROOT_ALIAS)</span>;</span><br><span class="line">    Student en = <span class="params">(Student)</span> map.get<span class="params">(<span class="string">"en"</span>)</span>;</span><br><span class="line">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>动态关联抓取</strong></p>
<p>FetchMode里有如下几个常量：</p>
<ul>
<li>DEFAULT：使用配置文件指定的延迟加载策略处理</li>
<li>JOIN：使用外连接、预初始化所有关联实体</li>
<li>SELECT：启用延迟加载，系统将使用单独的select语句来初始化关联实体。只有当真正访问关联实体的时候，才会执行第二条select语句。</li>
</ul>
<p>你可以使用setFetchMode()在运行时定义动态关联抓取的语义。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">List</span> <span class="built_in">list</span> <span class="subst">=</span> session<span class="built_in">.</span>createCriteria(Student<span class="built_in">.</span>class)</span><br><span class="line">    <span class="built_in">.</span>add( Restrictions<span class="built_in">.</span>like(<span class="string">"name"</span>, <span class="string">"F%"</span>)</span><br><span class="line">    <span class="built_in">.</span>setFetchMode(<span class="string">"enrolments"</span>,FetchMode<span class="built_in">.</span><span class="keyword">JOIN</span>)</span><br><span class="line">    <span class="built_in">.</span><span class="built_in">list</span>();</span><br></pre></td></tr></table></figure>
<p>以上程序会预初始化Student关联的enrolments集合。</p>
<h3 id="投影(Projections)、聚合（aggregation）和分组（grouping）">投影(Projections)、聚合（aggregation）和分组（grouping）</h3><p>org.hibernate.criterion.Projections是 Projection 的实例工厂。我们通过调用 setProjection()应用投影到一个查询。</p>
<ul>
<li>AggregateProjection avg(String propertyName)：类似avg函数</li>
<li>CountProjection count(String propertyName)：类似count函数</li>
<li>CountProjection countDistinct(String propertyName)：类似count(distinct column)</li>
<li>PropertyProjection groupProperty(String propertyName)：类似添加group by子句</li>
<li>AggregateProjection max(String propertyName)：类似max函数</li>
<li>AggregateProjection min(String propertyName)：类似min函数</li>
<li>Projection rowCount()：类似count(*)</li>
<li>AggregateProjection sum(String propertyName)：类似sum函数</li>
</ul>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">List results = session.createCriteria<span class="params">(Cat.class)</span></span><br><span class="line">    .setProjection<span class="params">( Projections.rowCount<span class="params">()</span> )</span></span><br><span class="line">    .add<span class="params">( Restrictions.eq<span class="params">(<span class="string">"color"</span>, Color.BLACK)</span> )</span></span><br><span class="line">    .list<span class="params">()</span>;</span><br><span class="line">List results = session.createCriteria<span class="params">(Cat.class)</span></span><br><span class="line">    .setProjection<span class="params">( Projections.projectionList<span class="params">()</span></span><br><span class="line">        .add<span class="params">( Projections.rowCount<span class="params">()</span> )</span></span><br><span class="line">        .add<span class="params">( Projections.avg<span class="params">(<span class="string">"weight"</span>)</span> )</span></span><br><span class="line">        .add<span class="params">( Projections.max<span class="params">(<span class="string">"weight"</span>)</span> )</span></span><br><span class="line">        .add<span class="params">( Projections.groupProperty<span class="params">(<span class="string">"color"</span>)</span> )</span></span><br><span class="line">    )</span></span><br><span class="line">    .list<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>在一个条件查询中没有必要显式的使用 “group by” 。某些投影类型就是被定义为 分组投影，他们也出现在SQL的group by子句中。</p>
<p>你可以选择把一个别名指派给一个投影，这样可以使投影值被约束或排序所引用。下面是两种不同的实现方式：<br><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List results = session.createCriteria<span class="params">(Cat.class)</span></span><br><span class="line">    .setProjection<span class="params">( Projections.alias<span class="params">( Projections.groupProperty<span class="params">(<span class="string">"color"</span>)</span>, <span class="string">"colr"</span> )</span> )</span></span><br><span class="line">    .addOrder<span class="params">( Order.asc<span class="params">(<span class="string">"colr"</span>)</span> )</span></span><br><span class="line">    .list<span class="params">()</span>;</span><br><span class="line">List results = session.createCriteria<span class="params">(Cat.class)</span></span><br><span class="line">    .setProjection<span class="params">( Projections.groupProperty<span class="params">(<span class="string">"color"</span>)</span>.as<span class="params">(<span class="string">"colr"</span>)</span> )</span></span><br><span class="line">    .addOrder<span class="params">( Order.asc<span class="params">(<span class="string">"colr"</span>)</span> )</span></span><br><span class="line">    .list<span class="params">()</span>;</span><br></pre></td></tr></table></figure></p>
<p>alias()和as()方法简便的将一个投影实例包装到另外一个别名的Projection实例中。简而言之，当你添加一个投影到一个投影列表中时你可以为它指定一个别名，使用ProjectionList的add()方法添加投影时指定别名</p>
<h3 id="离线(detached)查询和子查询">离线(detached)查询和子查询</h3><p>DetachedCriteria类使你在一个session范围之外创建一个查询，并且可以使用任意的 Session来执行它。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DetachedCriteria query = DetachedCriteria.forClass<span class="params">(Cat.class)</span></span><br><span class="line">    .add<span class="params">( Property.forName<span class="params">(<span class="string">"sex"</span>)</span>.eq<span class="params">('F')</span> )</span>;</span><br><span class="line">Session session = HibernateUtil.currentSession<span class="params">()</span>; </span><br><span class="line">Transaction txn = session.beginTransaction<span class="params">()</span>;</span><br><span class="line">List results = query.getExecutableCriteria<span class="params">(session)</span>.setMaxResults<span class="params">(<span class="number">100</span>)</span>.list<span class="params">()</span>;</span><br><span class="line">txn.commit<span class="params">()</span>;</span><br><span class="line">session.close<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>DetachedCriteria也可以用以表示子查询。条件实例包含子查询可以通过 Subqueries或者Property获得。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DetachedCriteria avgWeight = DetachedCriteria.forClass(<span class="keyword">Cat</span>.<span class="keyword">class</span>)</span><br><span class="line">	.setProjection( Property.forName(<span class="string">"weight"</span>).avg() );</span><br><span class="line">session.createCriteria(<span class="keyword">Cat</span>.<span class="keyword">class</span>)</span><br><span class="line">	.add( Property.forName("weight).gt(avgWeight) )</span><br><span class="line">	.<span class="keyword">list</span>();</span><br><span class="line">DetachedCriteria weights = DetachedCriteria.forClass(<span class="keyword">Cat</span>.<span class="keyword">class</span>)</span><br><span class="line">	.setProjection( Property.forName(<span class="string">"weight"</span>) );</span><br><span class="line">session.createCriteria(<span class="keyword">Cat</span>.<span class="keyword">class</span>)</span><br><span class="line">	.add( Subqueries.geAll(<span class="string">"weight"</span>, weights) )</span><br><span class="line">	.<span class="keyword">list</span>();</span><br></pre></td></tr></table></figure>
<p>甚至相互关联的子查询也是有可能的：</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DetachedCriteria avgWeightForSex = DetachedCriteria.forClass<span class="params">(Cat.class, <span class="string">"cat2"</span>)</span></span><br><span class="line">	.setProjection<span class="params">( Property.forName<span class="params">(<span class="string">"weight"</span>)</span>.avg<span class="params">()</span> )</span></span><br><span class="line">	.add<span class="params">( Property.forName<span class="params">(<span class="string">"cat2.sex"</span>)</span>.eqProperty<span class="params">(<span class="string">"cat.sex"</span>)</span> )</span>;</span><br><span class="line">session.createCriteria<span class="params">(Cat.class, <span class="string">"cat"</span>)</span></span><br><span class="line">	.add<span class="params">( Property.forName<span class="params">(<span class="string">"weight).gt(avgWeightForSex) )</span><br><span class="line">	.list();</span></span></span></span><br></pre></td></tr></table></figure>
<h2 id="SQL查询">SQL查询</h2><p>SQL查询是通过SQLQuery接口来表示的。Query接口的子接口，可调用Query接口的方法：setFirstResult、setMaxResults、list。</p>
<p>此外还有两个重载的方法。</p>
<ul>
<li>addEntity()：将查询到的记录与特定的实体关联。</li>
<li>addScalar()：将查询到的记录关联成标量值。</li>
</ul>
<p>执行SQL查询的步骤如下：</p>
<ol>
<li>获取Hibernate Session对象 </li>
<li>编写SQL语句</li>
<li>以SQL语句为参数，调用Session的createSQLQuery方法创建查询对象</li>
<li>调用SQLQuery对象的addScalar或addEntity方法将选出的结果与标量值或实体进行关联，分别用于进行标量查询或实体查询。</li>
<li>如果SQL语句包含参数，则调用Query的setxxx方法为参数赋值。</li>
<li>调用Query的list方法返回查询的结果集。</li>
</ol>
<h3 id="标量查询">标量查询</h3><figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">session.createSQLQuery<span class="params">(<span class="string">"select * from student_inf"</span>)</span></span><br><span class="line">    .addScalar<span class="params">(<span class="string">"name"</span>,StandardBasicTypes.STRING)</span></span><br><span class="line">    .list<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<p>list方法返回数组元素的List，但是像上面程序指定了name列，只会返回单个变量值的List</p>
<p>addScalar的作用</p>
<ul>
<li>指定查询结果包含哪些数据列—没有被addScalar选出的列将不会包含在查询结果中。</li>
<li>指定查询结果中数据列的数据类型。</li>
</ul>
<h3 id="实体查询">实体查询</h3><p>如果查询返回了某个数据表的全部数据列（<strong>记住：是选出全部数据列</strong>），且该数据表有对应的持久化类映射，我们就可把查询结果转换成实体查询。将查询结果转换成实体，可以使用addEntity方法。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="built_in">list</span> = session.createSQLQuery(<span class="string">"select enrolment_inf where year=:year"</span>)</span><br><span class="line">        .addEntity(<span class="type">Enrolment</span>.<span class="keyword">class</span>)</span><br><span class="line">        .setInteger(<span class="string">"year"</span>,<span class="number">2005</span>)</span><br><span class="line">        .<span class="built_in">list</span><span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<p>可以看出原生SQL语句一样支持使用参数。</p>
<p>Hibernate还支持将查询结果转换成多个实体。如果要将查询结果转换成多个实体，则需要指定别名，并调用addEntity(String alias, Class entityClass)方法将不同数据表转换成不同实体。<br>Hibernate还可将查询的结果转换成非持久化实体，只要该JavaBean为这些数据列提供了对应的setter和getter方法。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span> <span class="built_in">list</span> = session.createSQLQuery(<span class="type">SQLQuery</span>).setResultTransformer(<span class="type">Transformers</span>.aliasToBean(<span class="type">StudentCourse</span>.<span class="keyword">class</span>)).<span class="built_in">list</span><span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="处理关联和继承">处理关联和继承</h3><p>将关联实体转换成查询结果的方法是SQLQuery addJoin(String alias, String path)，该方法第一个参数是转换后的实体名，第二个参数是待转换的实体属性。</p>
<figure class="highlight nimrod"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public <span class="type">void</span> joinQuery()&#123;</span><br><span class="line">    <span class="type">Session</span> session = <span class="type">HibernateUtil</span>.currentSession();</span><br><span class="line">    <span class="type">Transaction</span> tx = session.beginTransaction();</span><br><span class="line">    <span class="type">String</span> sql = <span class="string">"select s.*,e.* from student_inf s,enrolment_inf e where s.student_id=e.student_id"</span>;</span><br><span class="line">    <span class="type">List</span> list = session.createSQLQuery(sql)</span><br><span class="line">                .addEntity(<span class="string">"s"</span>,<span class="type">Student</span>.class)</span><br><span class="line">                .addJoin(<span class="string">"e"</span>,<span class="string">"s.enrolments"</span>)</span><br><span class="line">                .list();</span><br><span class="line">    tx.commit();</span><br><span class="line">    <span class="type">HibernateUtil</span>.closeSession();</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">Iterator</span> <span class="keyword">iterator</span> = list.<span class="keyword">iterator</span>();<span class="keyword">iterator</span>.hasNext();)&#123;</span><br><span class="line">        //每个集合元素都是<span class="type">Person</span>、<span class="type">MyEvent</span>所组成的数组</span><br><span class="line">        <span class="type">Object</span>[] objects = (<span class="type">Object</span>[]) <span class="keyword">iterator</span>.next();</span><br><span class="line">        <span class="type">Student</span> stu = (<span class="type">Student</span>) objects[<span class="number">0</span>];</span><br><span class="line">        <span class="type">Enrolments</span> e = (<span class="type">Enrolments</span>) objects[<span class="number">1</span>];</span><br><span class="line">        <span class="type">System</span>.<span class="keyword">out</span>.println(s.getName()+<span class="string">"\t"</span>+e.getYear());</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的程序中可以看到的，程序将s.enrolments属性转换成别名为e的实体，也就是说程序执行的结果是Student、Enrolment对象数组的列表。</p>
<h3 id="命名SQL查询">命名SQL查询</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@SqlResultSetMapping</span>(name=<span class="string">"compositekey"</span>,</span><br><span class="line">        entities=<span class="annotation">@EntityResult</span>(entityClass=SpaceShip.class,</span><br><span class="line">            fields = &#123;</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"name"</span>, column = <span class="string">"name"</span>),</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"model"</span>, column = <span class="string">"model"</span>),</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"speed"</span>, column = <span class="string">"speed"</span>),</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"captain.firstname"</span>, column = <span class="string">"firstn"</span>),</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"captain.lastname"</span>, column = <span class="string">"lastn"</span>),</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"dimensions.length"</span>, column = <span class="string">"length"</span>),</span><br><span class="line">                    <span class="annotation">@FieldResult</span>(name=<span class="string">"dimensions.width"</span>, column = <span class="string">"width"</span>)</span><br><span class="line">                    &#125;),</span><br><span class="line">        columns = &#123; <span class="annotation">@ColumnResult</span>(name = <span class="string">"surface"</span>),</span><br><span class="line">                    <span class="annotation">@ColumnResult</span>(name = <span class="string">"volume"</span>) &#125; )</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NamedNativeQuery</span>(name=<span class="string">"compositekey"</span>,</span><br><span class="line">    query=<span class="string">"select name, model, speed, lname as lastn, fname as firstn, length, width, length * width as surface from SpaceShip"</span>, </span><br><span class="line">    resultSetMapping=<span class="string">"compositekey"</span>)</span><br><span class="line">&#125; )</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpaceShip</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String model;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> speed;</span><br><span class="line">    <span class="keyword">private</span> Captain captain;</span><br><span class="line">    <span class="keyword">private</span> Dimensions dimensions;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@ManyToOne</span>(fetch= FetchType.LAZY)</span><br><span class="line">    <span class="annotation">@JoinColumns</span>( &#123;</span><br><span class="line">            <span class="annotation">@JoinColumn</span>(name=<span class="string">"fname"</span>, referencedColumnName = <span class="string">"firstname"</span>),</span><br><span class="line">            <span class="annotation">@JoinColumn</span>(name=<span class="string">"lname"</span>, referencedColumnName = <span class="string">"lastname"</span>)</span><br><span class="line">            &#125; )</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Captain <span class="title">getCaptain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> captain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCaptain</span><span class="params">(Captain captain)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.captain = captain;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setModel</span><span class="params">(String model)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.model = model;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getSpeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSpeed</span><span class="params">(<span class="keyword">double</span> speed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.speed = speed;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Dimensions <span class="title">getDimensions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> dimensions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDimensions</span><span class="params">(Dimensions dimensions)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dimensions = dimensions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@IdClass</span>(Identity.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Captain</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String firstname;</span><br><span class="line">    <span class="keyword">private</span> String lastname;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getFirstname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> firstname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFirstname</span><span class="params">(String firstname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.firstname = firstname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Id</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getLastname</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lastname;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setLastname</span><span class="params">(String lastname)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lastname = lastname;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Session的getNamedQuery即可获取指定命名SQL查询。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session.getNamedQuery(<span class="string">"compositekey"</span>).<span class="built_in">list</span><span class="literal">()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="调用存储过程">调用存储过程</h3><p>Hibernate可以通过命名SQL查询来调用存储过程或函数。对于函数，该函数必须返回一个结果集；对于存储过程，该存储过程的第一个参数必须是传出参数，且数据类型是结果集。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="function"><span class="keyword">procedure</span> <span class="title">select_all_student</span><span class="params">()</span></span><br><span class="line"><span class="title">select</span> *</span><br><span class="line"><span class="title">from</span> <span class="title">student_inf</span>;</span></span><br></pre></td></tr></table></figure>
<p>如果需要使用该存储过程，可以先将其定义成命名SQL查询，当使用原生SQL来调用存储过程或触发器时，应为<code>&lt;sql-query.../&gt;</code>元素指定<code>callable=&quot;true&quot;</code>。还需要使用<code>&lt;return-property .../&gt;</code>子元素将指定列转换成实体的属性。</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;sql-query <span class="property">name</span>=<span class="string">"callProcedure"</span> callable=<span class="string">"true"</span>&gt;</span><br><span class="line">    &lt;<span class="constant">return</span> <span class="type">class</span>=<span class="string">"Student"</span>&gt;</span><br><span class="line">        &lt;<span class="constant">return</span>-<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"studentNumber"</span> column=<span class="string">"student_id"</span>/&gt;</span><br><span class="line">        &lt;<span class="constant">return</span>-<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"name"</span> column=<span class="string">"name"</span>/&gt;</span><br><span class="line">    &lt;/<span class="constant">return</span>&gt;</span><br><span class="line">    &#123;call select_all_student()&#125;</span><br><span class="line">&lt;/sql-query&gt;</span><br></pre></td></tr></table></figure>
<p>调用存储过程</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">private void callProcedure<span class="params">()</span>&#123;</span><br><span class="line">    Session session = HibernateUtil.currentSession<span class="params">()</span>;</span><br><span class="line">    Transaction tx=session.beginTransaction<span class="params">()</span>;</span><br><span class="line">    List list = session.getNamedQuery<span class="params">(<span class="string">"callProcedure"</span>)</span>.list<span class="params">()</span>;</span><br><span class="line">    tx.commit<span class="params">()</span>;</span><br><span class="line">    HibernateUtil.closeSession<span class="params">()</span>;</span><br><span class="line">    <span class="comment">//遍历结果集</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意</p>
<ul>
<li>建议采用的调用方式是标准SQL92语法，如<code>{?=call functionName(&lt;parameters&gt;)}</code>或 <code>{callprocedureName(&lt;parameters&gt;)}</code>，不支持原生的调用语法。</li>
<li>因为存储过程本身完成了查询的全部操作。因此，调用存储过程进行的查询无法使用setFirstResult/setMaxResults进行分页。</li>
</ul>
<p>对于Oracle有如下规则:</p>
<ul>
<li>存储过程必须返回一个结果集.它通过返回<code>SYS_REFCURSOR</code>实现(在Oracle9或10),在Oracle里你需要定义一个<code>REF CURSOR</code> 类型</li>
<li>推荐的格式是<code>{ ? = call procName(&lt;parameters&gt;) }</code>或<code>{ ? = call procName }</code>(这更像是Oracle规则而不是Hibernate规则)</li>
</ul>
<p>对于Sybase或者MS SQL server有如下规则:</p>
<ul>
<li>存储过程必须返回一个结果集。.注意这些servers可能返回多个结果集以及更新的数目.Hibernate将取出第一条结果集作为它的返回值， 其他将被丢弃。</li>
<li>如果你能够在存储过程里设定SET NOCOUNT ON，这可能会效率更高，但这不是必需的。</li>
</ul>
<h3 id="定制SQL">定制SQL</h3><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@Table</span>(name=<span class="string">"CHAOS"</span>)</span><br><span class="line"><span class="annotation">@SQLInsert</span>( sql=<span class="string">"INSERT INTO CHAOS(size, name, nickname, id) VALUES(?,upper(?),?,?)"</span>)</span><br><span class="line"><span class="annotation">@SQLUpdate</span>( sql=<span class="string">"UPDATE CHAOS SET size = ?, name = upper(?), nickname = ? WHERE id = ?"</span>)</span><br><span class="line"><span class="annotation">@SQLDelete</span>( sql=<span class="string">"DELETE CHAOS WHERE id = ?"</span>)</span><br><span class="line"><span class="annotation">@SQLDeleteAll</span>( sql=<span class="string">"DELETE CHAOS"</span>)</span><br><span class="line"><span class="annotation">@Loader</span>(namedQuery = <span class="string">"chaos"</span>)</span><br><span class="line"><span class="annotation">@NamedNativeQuery</span>(name=<span class="string">"chaos"</span>, query=<span class="string">"select id, size, name, lower( nickname ) as nickname from CHAOS where id= ?"</span>, resultClass = Chaos.<span class="keyword">class</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Chaos</span> &#123;</span></span><br><span class="line">    <span class="annotation">@Id</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> Long size;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String nickname;</span><br><span class="line">    <span class="comment">//setter and getter</span></span><br><span class="line">    ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也可以使用xml配置文件形式</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;class name=<span class="string">"Person"</span>&gt;</span><br><span class="line">    &lt;id name=<span class="string">"id"</span>&gt;</span><br><span class="line">        &lt;generator class=<span class="string">"increment"</span>/&gt;</span><br><span class="line">    &lt;/id&gt;</span><br><span class="line">    &lt;property name=<span class="string">"name"</span> not-null=<span class="string">"true"</span>/&gt;</span><br><span class="line">    &lt;sql-insert&gt;INSERT INTO <span class="keyword">PERSON</span> (NAME, ID) VALUES ( UPPER(?), ? )&lt;/sql-insert&gt;</span><br><span class="line">    &lt;sql-update&gt;UPDATE <span class="keyword">PERSON</span> SET NAME=UPPER(?) WHERE ID=?&lt;/sql-update&gt;</span><br><span class="line">    &lt;sql-delete&gt;DELETE FROM <span class="keyword">PERSON</span> WHERE ID=?&lt;/sql-delete&gt;</span><br><span class="line">&lt;/class&gt;</span><br></pre></td></tr></table></figure>
<p>使用存储过程也是可以的，需要指定<code>callable=&quot;true&quot;</code>，调用存储过程的顺序必须和Hibernate所期待的顺序相同。程序将日志调试级别设为<code>org.hibernate.persister.entity</code>。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">class</span> <span class="attribute">name</span>=<span class="value">"Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">id</span> <span class="attribute">name</span>=<span class="value">"id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">generator</span> <span class="attribute">class</span>=<span class="value">"increment"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"name"</span> <span class="attribute">not-null</span>=<span class="value">"true"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">sql-insert</span> <span class="attribute">callable</span>=<span class="value">"true"</span>&gt;</span>&#123;call createPerson(?,?)&#125;<span class="tag">&lt;/<span class="title">sql-insert</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">sql-update</span> <span class="attribute">callable</span>=<span class="value">"true"</span>&gt;</span>&#123;? = call updatePerson(?)&#125;<span class="tag">&lt;/<span class="title">sql-delete</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">sql-delete</span> <span class="attribute">callable</span>=<span class="value">"true"</span>&gt;</span>&#123;? = call deletePerson(?)&#125;<span class="tag">&lt;/<span class="title">sql-delete</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">class</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h2 id="数据过滤">数据过滤</h2><p>过滤器和定义在类和集合映射文件上的<code>where</code>属性非常相似。它们的区别是过滤器可以带参数，应用程序可以在运行时决定是否启用指定的过滤器，使用怎样的参数值。而映射文见上的<code>where</code>属性将一直生效，且无法动态传入参数。</p>
<p>过滤器的用法很想数据库视图，区别是视图在数据库中已经定义完成，而过滤器则还需在应用程序中确定参数值。</p>
<p>@org.hibernate.annotations.FilterDef 或 @FilterDefs 定义过滤器声明,为同名过滤器所用. 过滤器声明带有一个name()和一个parameters()数组,@ParamDef包含name和type, 你还可以为给定的@filterDef定义一个defaultCondition()参数, 当@Filter中没有任何定义时,可使用该参数定义缺省条件. @FilterDef (s)可以在类或包一级进行定义.</p>
<p>现在我们来定义应用于实体或集合加载时的SQL过滤器子句.我们使用@Filter,并将其置于实体或集合元素上。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@FilterDef</span>(name=<span class="string">"minLength"</span>, parameters=<span class="variable">@ParamDef</span>( name=<span class="string">"minLength"</span>, type=<span class="string">"integer"</span> ) )</span><br><span class="line"><span class="variable">@Filters</span>( &#123;</span><br><span class="line">    <span class="variable">@Filter</span>(name=<span class="string">"betweenLength"</span>, condition=<span class="string">":minLength &lt;= length and :maxLength &gt;= length"</span>),</span><br><span class="line">    <span class="variable">@Filter</span>(name=<span class="string">"minLength"</span>, condition=<span class="string">":minLength &lt;= length"</span>)</span><br><span class="line">&#125; )</span><br><span class="line">public class Forest &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>过滤器的目标是实体表，使用@Filter，如果是关联表使用@FilterJoinTable<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@OneToMany</span></span><br><span class="line"><span class="variable">@JoinTable</span></span><br><span class="line"><span class="comment">//filter on the target entity table</span></span><br><span class="line"><span class="variable">@Filter</span>(name=<span class="string">"betweenLength"</span>, condition=<span class="string">":minLength &lt;= length and :maxLength &gt;= length"</span>)</span><br><span class="line"><span class="comment">//filter on the association table</span></span><br><span class="line"><span class="variable">@FilterJoinTable</span>(name=<span class="string">"security"</span>, condition=<span class="string">":userlevel &gt;= requredLevel"</span>)</span><br><span class="line">public Set&lt;Forest&gt; <span class="function">getForests</span>() &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>默认情况下，Hibernate自动确定@Filter SQL条件中的所有点，这样别名需要被注入，设置@Filter中deduceAliasInjectionPoints为false。然后使用@SqlFragmentAlias注解，在SQL的条件语句中使用{alias}占位符。<br><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@Entity</span></span><br><span class="line"><span class="variable">@Table</span>(name=<span class="string">"T_TREE"</span>)</span><br><span class="line"><span class="variable">@Filters</span>(&#123;</span><br><span class="line">    <span class="variable">@Filter</span>(name=<span class="string">"isTall"</span>, condition=<span class="string">"&#123;alias&#125;.LENGTH &gt;= 100"</span>, deduceAliasInjectionPoints = false),</span><br><span class="line">    <span class="variable">@Filter</span>(name=<span class="string">"isOak"</span>, condition=<span class="string">"&#123;t&#125;.WOODTYPE like 'oak'"</span>, deduceAliasInjectionPoints = false,</span><br><span class="line">        aliases=&#123;<span class="variable">@SqlFragmentAlias</span>(alias=<span class="string">"t"</span>, table=<span class="string">"T_TREE"</span>)&#125;)</span><br><span class="line">&#125;)</span><br><span class="line">public class Tree &#123; ... &#125;</span><br></pre></td></tr></table></figure></p>
<p>对于xml配置文件方式，系统默认不启用过滤器，必须通过Session的enableFilter(String filterName)才可以启用过滤器，该方法返回一个Filter实例，Filter包含setParameter方法用于为过滤器参数赋值。</p>
<p>通常来说，如果某个筛选条件使用得非常频繁，那么我们可以将该筛选条件设置为过滤器；如果是临时的数据筛选，还是使用常规查询比较好。对于在SQL语句中使用行内表达式、视图的地方，现在可考虑使用过滤器。</p>
<h2 id="事物控制">事物控制</h2><h3 id="事务的概念">事务的概念</h3><p>事务是一步或几步基本操作组成的逻辑执行单元，这些基本操作作为一个整体执行单元，它们要么全部执行，要么全部取消，绝不能仅仅执行部分。一般而言，每次用户请求，对应一个业务逻辑方法，一个业务逻辑方法往往具有逻辑上的原子性，应该使用事务。</p>
<p>事务具备4个特性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持续性（Durability）。这四个特性简称ACID性。</p>
<h3 id="Session与事务">Session与事务</h3><p>Hibernate的事务（Transaction对象）通过Session的beginTransaction方法显式打开，Hibernate自身并不提供事务控制行为，底层直接使用JDBC连接、JTA资源或其他资源的事务。</p>
<p>从编程角度来看，Hibernate的事务由Session对象开启；从底层实现来看，Hibernate事务由TransactionFactory的实例来产生。</p>
<p>TransactionFactory是一个事务工厂的接口，有不同实现：CMTTransactionFactory（针对容器管理事务环境的实现类）、JDBCTransactionFactory（针对JDBC局部事务环境的实现类）、JTATransactionFactory（针对JTA全局事务环境的实现类）。</p>
<p>SessionFactory底层封装了TransactionFactory。SessionFactory创建的代价很高，它是线程安全的对象，被设计成可以被所有线程所共享。通常，SessionFactory会在应用启动时创建，一旦创建将不会轻易关闭，只有退出时才关闭。</p>
<p>Session是轻量级的，是线程不安全的。对于单个业务进程、单个的工作单元而言，Session只被使用一次。创建Session时，并不会立即打开与数据库之间的连接，只有需要进行数据库操作时，Session才会获取JDBC连接。因此，打开和关闭Session，并不会对性能造成很大影响。甚至即使无法确定一个请求是否需要数据访问，也可以打开Session对象，因为如果不进行数据库访问，Session不会获取JDBC连接。</p>
<p>数据库事务应该尽可能短，降低数据库锁定造成的资源争用。</p>
<p>Hibernate的所有持久化访问都必须在Session管理下进行，但并不推荐因为一次简单的数据库原子操作，就打开和关闭一次Session，数据库事务也是如此。</p>
<p>Hibernate建议采用每个请求对应一次Session的模式—因此一次请求通常表示需要执行一个完整的业务功能，这个功能由系列的数据库原子操作组成，而且它们应该是一个逻辑上的整体。</p>
<p>对于长事务，Hibernate有如下三种模式：</p>
<ul>
<li>自动版本化 - Hibernate能够自动进行乐观并发控制，如果在用户思考的过程中发生并发修改冲突，Hibernate能够自动检测到。</li>
<li>脱管对象（Detached Objects）- 如果你决定采用前面已经讨论过的 session-per-request模式，所有载入的实例在用户思考的过程中都处于与Session脱离的状态。Hibernate允许你把与Session脱离的对象重新关联到Session上，并且对修改进行持久化，这种模式被称为 session-per-request-with-detached-objects。自动版本化被用来隔离并发修改。</li>
<li>长生命周期的Session （Long Session）- Hibernate 的Session 可以在数据库事务提交之后和底层的JDBC连接断开，当一个新的客户端请求到来的时候，它又重新连接上底层的 JDBC连接。这种模式被称之为session-per-application-transaction，这种情况可 能会造成不必要的Session和JDBC连接的重新关联。自动版本化被用来隔离并发修改。</li>
</ul>
<p>如果程序打开Session很长时间，或载入过多数据，Session占用的内存会一直增长，直到抛出OutOfMemoryException。可以通过clear和evict方法管理Session的缓存。对于大批量的数据处理，推荐使用DML风格 的HQL语句完成。</p>
<p>如果在Session范围之外，访问未初始化的集合或代理（由Hibernate的延迟加载特性所引起），HIbernate将会抛出LazyInitializationException异常。</p>
<p>Hibernate的initialize静态方法可以强制初始化某个集合或代理。只要Session处于open状态，Hibernate.initialize(teacher)将会初始化teacher代理。</p>
<p>两种方法保证Session处于打开状态：</p>
<ul>
<li>在一个Web应用中，可以利用过滤器，在用户请求结束、页面生成结束时关闭Session。也就是保证视图显示层一直打开Session，这就是所谓的Open Session in View模式。当然采用这种模式时必须保证所有异常得到正确处理，在呈现视图界面之前，或在生成视图界面的过程中发生异常时，必须保证可以正确关闭Session，并结束事务。（Spring框架提供的OpenSessionInViewFilter就可以满足这个要求。</li>
<li>使用业务逻辑层负责准备数据，在业务逻辑层返回数据之前，业务逻辑层对每个所需集合调用Hibernate.initialize()方法，或者使用带fetch子句或FetchMode.JOIN的查询，事先取得所有数据，并将这些数据封装成VO（值对象）集合，然后程序可以关闭Session了。业务逻辑层将VO集传入视图层，让视图层只负责简单的显示逻辑。这种模式下，可以让视图层和Hibernate API彻底分离，保证视图层不会出现持久层API。</li>
</ul>
<h3 id="上下文相关的会话">上下文相关的会话</h3><p>从 3.1 开始，SessionFactory.getCurrentSession() 的后台实现是可拔插的。因此，我们引入了新的扩展接口（org.hibernate.context.CurrentSessionContext）和新的配置参数（hibernate.current_session_context_class），以便对什么是当前会话的范围（scope）和上下文（context）的定义进行拔插。</p>
<p>Hibernate 内置了org.hibernate.context.CurrentSessionContext 接口的三种实现：</p>
<ul>
<li>org.hibernate.context.JTASessionContext：当前会话根据 JTA 来跟踪和界定。这和以前的仅支持 JTA 的方法是完全一样的。详情请参阅 Javadoc。</li>
<li>org.hibernate.context.ThreadLocalSessionContext：当前会话通过当前执行的线程来跟踪和界定。详情也请参阅 Javadoc。</li>
<li>org.hibernate.context.ManagedSessionContext：当前会话通过当前执行的线程来跟踪和界定。但是，你需要负责使用这个类的静态方法将 Session 实例绑定、或者取消绑定，它并不会打开（open）、flush 或者关闭（close）任何 Session。</li>
</ul>
<p>对于在容器中使用Hibernate的场景而言，通常会采用第一种方式；对于独立的Hibernate应用而言，通常会采用第二种方式。</p>
<p>在hibernate.cfg.xml文件中增加以下中的一种配置<br><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;thread&lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;jta&lt;/<span class="keyword">property</span>&gt;</span><br><span class="line">&lt;<span class="keyword">property</span> <span class="property">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;managed&lt;/<span class="keyword">property</span>&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="二级缓存和查询缓存">二级缓存和查询缓存</h2><p>Hibernate 两个级别的缓存</p>
<ul>
<li>默认总是启用的Session级别的一级缓存</li>
<li>可选的SessionFactory级别的二级缓存</li>
</ul>
<p>其中Session级别的一级缓存不需要开发者关心，默认总是有效的，当应用保存持久化实体、修改持久化实体时，Session并不会立即把这种改变flush到数据库，而是缓存在当前Session的一级缓存中，除非程序显式调用Session的flush方法，或程序关闭Session时才会把这些改变一次性flush到底层数据库。</p>
<p>SessionFactory级别的二级缓存是全局性的，应用的所有Session都共享这个二级缓存。不过此级别的缓存默认是关闭的，必须由程序显式开启。Session优先从二级缓存抓取数据。</p>
<h3 id="开启二级缓存">开启二级缓存</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--开启二级缓存--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.cache.use_second_level_cache"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--设置二级缓存实现类--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.cache.provider_class"</span>&gt;</span>org.hibernate.cache.EhCacheProvider<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>缓存策略提供商（Cache Providers）</p>
<table>
<thead>
<tr>
<th>Cache</th>
<th>Provider class</th>
<th>Type</th>
<th>Cluster Safe</th>
<th>Query Cache Supported</th>
</tr>
</thead>
<tbody>
<tr>
<td>Hashtable</td>
<td>org.hibernate.cache.HashtableCacheProvider</td>
<td>memory</td>
<td></td>
<td>yes</td>
</tr>
<tr>
<td>EHCache</td>
<td>org.hibernate.cache.EhCacheProvider</td>
<td>memory, disk</td>
<td></td>
<td>yes</td>
</tr>
<tr>
<td>OSCache</td>
<td>org.hibernate.cache.OSCacheProvider</td>
<td>memory, disk</td>
<td></td>
<td>yes</td>
</tr>
<tr>
<td>SwarmCache</td>
<td>org.hibernate.cache.SwarmCacheProvider</td>
<td>clustered (ip multicast)</td>
<td>yes (clustered invalidation)</td>
<td></td>
</tr>
<tr>
<td>JBoss Cache    1.x</td>
<td>org.hibernate.cache.TreeCacheProvider</td>
<td>clustered (ip multicast), transactional</td>
<td>yes (replication)</td>
<td>yes (clock sync req.)</td>
</tr>
<tr>
<td>JBoss Cache    2</td>
<td>org.hibernate.cache.jbc.JBossCacheRegionFactory</td>
<td>clustered (ip multicast), transactional</td>
<td>yes (replication)</td>
<td>yes (clock sync req.)</td>
</tr>
</tbody>
</table>
<p>EHCache缓存配置文件ehcache.xml，将其放在类加载路径下稍作修改即可。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="title">ehcache</span>&gt;</span>  </span><br><span class="line">　<span class="tag">&lt;<span class="title">diskStore</span> <span class="attribute">path</span>=<span class="value">"java.io.tmpdir"</span>/&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!--maxElementsInMemory设置缓存中最多可放多少个对象</span><br><span class="line">    eternal设置缓存是否永久有效</span><br><span class="line">    timeToldleSeconds设置缓存的对象多少秒没有被使用就会清理掉</span><br><span class="line">    timeToLiveSeconds设置缓存的对象在过期之前可以缓存多少秒</span><br><span class="line">    diskPersistent设置缓存是否被持久化到硬盘中，保存路径由diskStore元素指定</span><br><span class="line">    --&gt;</span></span><br><span class="line">　　<span class="tag">&lt;<span class="title">defaultCache</span>  </span><br><span class="line">　　　<span class="attribute">maxElementsInMemory</span>=<span class="value">"10000"</span></span><br><span class="line">　　　<span class="attribute">eternal</span>=<span class="value">"false"</span> </span><br><span class="line">　　　<span class="attribute">overflowToDisk</span>=<span class="value">"true"</span> </span><br><span class="line">　　　<span class="attribute">timeToIdleSeconds</span>=<span class="value">"300"</span></span><br><span class="line">　　　<span class="attribute">timeToLiveSeconds</span>=<span class="value">"180"</span> </span><br><span class="line">　　　<span class="attribute">diskPersistent</span>=<span class="value">"false"</span></span><br><span class="line">　　　<span class="attribute">diskExpiryThreadIntervalSeconds</span>= "<span class="attribute">120</span>"/&gt;</span>    </span><br><span class="line"><span class="tag">&lt;/<span class="title">ehcache</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>@org.hibernate.annotations.Cache定义了缓存策略及给定的二级缓存的范围. 此注解适用于根实体(非子实体),还有集合.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Entity</span></span><br><span class="line"><span class="annotation">@Cache</span>(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Forest</span> </span>&#123; ... &#125;</span><br><span class="line">    <span class="annotation">@OneToMany</span>(cascade=CascadeType.ALL, fetch=FetchType.EAGER)</span><br><span class="line">    <span class="annotation">@JoinColumn</span>(name=<span class="string">"CUST_ID"</span>)</span><br><span class="line">    <span class="annotation">@Cache</span>(usage = CacheConcurrencyStrategy.NONSTRICT_READ_WRITE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> SortedSet&lt;Ticket&gt; <span class="title">getTickets</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> tickets;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">@Cache<span class="params">(</span><br><span class="line">    CacheConcurrencyStrategy usage<span class="params">()</span>;                 <span class="params">(<span class="number">1</span>)</span></span><br><span class="line">    String region<span class="params">()</span> default <span class="string">""</span>;                       <span class="params">(<span class="number">2</span>)</span></span><br><span class="line">    String include<span class="params">()</span> default <span class="string">"all"</span>;                   <span class="params">(<span class="number">3</span>)</span></span><br><span class="line">)</span></span><br></pre></td></tr></table></figure>
<p>(1)    usage: 给定缓存的并发策略(NONE, READ_ONLY, NONSTRICT_READ_WRITE, READ_WRITE, TRANSACTIONAL)<br>(2)    region (可选的)：缓存范围(默认为类的全限定类名或是集合的全限定角色名)<br>(3)    include (可选的)：值为all时包括了所有的属性(proterty), 为non-lazy时仅含非延迟属性(默认值为all)</p>
<ul>
<li>只读策略缓存（Strategy: read only）<br>  如果你的应用程序只需读取一个持久化类的实例，而无需对其修改， 那么就可以对其进行只读 缓存。这是最简单，也是实用性最好的方法。甚至在集群中，它也能完美地运作。</li>
<li>读/写策略（Strategy: read/write）<br>  如果应用程序需要更新数据，那么使用读/写缓存 比较合适。 如果应用程序要求“序列化事务”的隔离级别（serializable transaction isolation level），那么就决不能使用这种缓存策略。 如果在JTA环境中使用缓存，你必须指定hibernate.transaction.manager_lookup_class属性的值， 通过它，Hibernate才能知道该应用程序中JTA的TransactionManager的具体策略。    在其它环境中，你必须保证在Session.close()、或Session.disconnect()调用前， 整个事务已经结束。 如果你想在集群环境中使用此策略，你必须保证底层的缓存实现支持锁定(locking)。Hibernate内置的缓存策略并不支持锁定功能。</li>
<li>非严格读/写策略（Strategy: nonstrict read/write）<br>  如果应用程序只偶尔需要更新数据（也就是说，两个事务同时更新同一记录的情况很不常见），也不需要十分严格的事务隔离， 那么比较适合使用非严格读/写缓存策略。如果在JTA环境中使用该策略， 你必须为其指定hibernate.transaction.manager_lookup_class属性的值， 在其它环境中，你必须保证在Session.close()、或Session.disconnect()调用前， 整个事务已经结束。</li>
<li>事务策略（transactional）<br>  Hibernate的事务缓存策略提供了全事务的缓存支持， 例如对JBoss TreeCache的支持。这样的缓存只能用于JTA环境中，你必须指定 为其hibernate.transaction.manager_lookup_class属性。</li>
</ul>
<h3 id="管理缓存和统计缓存">管理缓存和统计缓存</h3><p>无论何时，当你给save()、update()或 saveOrUpdate()方法传递一个对象时，或使用load()、 get()、list()、iterate() 或scroll()方法获得一个对象时, 该对象都将被加入到Session的内部缓存中。</p>
<p>当随后flush()方法被调用时，对象的状态会和数据库取得同步。 如果你不希望此同步操作发生，或者你正处理大量对象、需要对有效管理内存时，你可以调用evict() 方法，从一级缓存中去掉这些对象及其集合。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">News</span> <span class="keyword">news</span> = (<span class="keyword">News</span>) newsList.<span class="literal">get</span>(0);</span><br><span class="line">sess.evict(<span class="keyword">news</span>);</span><br></pre></td></tr></table></figure>
<p>Session还提供了一个contains()方法，用来判断某个实例是否处于当前session的缓存中。</p>
<p>如若要把所有的对象从session缓存中彻底清除，则需要调用Session.clear()。</p>
<p>对于二级缓存来说，在SessionFactory中定义了许多方法， 清除缓存中实例、整个类、集合实例或者整个集合。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">sessionFactory.evict<span class="params">(Cat.class, catId)</span>; <span class="comment">//evict a particular Cat</span></span><br><span class="line">sessionFactory.evict<span class="params">(Cat.class)</span>;  <span class="comment">//evict all Cats</span></span><br><span class="line">sessionFactory.evictCollection<span class="params">(<span class="string">"Cat.kittens"</span>, catId)</span>; <span class="comment">//evict a particular collection of kittens</span></span><br><span class="line">sessionFactory.evictCollection<span class="params">(<span class="string">"Cat.kittens"</span>)</span>; <span class="comment">//evict all kitten collections</span></span><br></pre></td></tr></table></figure>
<p>如若需要查看二级缓存或查询缓存区域的内容，你可以使用统计（Statistics） API。</p>
<p>此时，你必须手工打开统计选项。可选的，你可以让Hibernate更人工可读的方式维护缓存内容。<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开启二级缓存的统计功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.generate_statistics"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置使用结构化方式来维护缓存项 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.cache.use_structured_entries"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map cacheEntries = sessionFactory.getStatistics<span class="params">()</span></span><br><span class="line">        .getSecondLevelCacheStatistics<span class="params">(regionName)</span></span><br><span class="line">        .getEntries<span class="params">()</span>;</span><br></pre></td></tr></table></figure>
<h3 id="使用查询缓存">使用查询缓存</h3><p>大部分情况下查询缓存并不能提供应用性能，甚至反而会降低应用性能，因此实际项目中慎重使用查询缓存。</p>
<p>首先在配置文件中增加如下配置<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 启用查询缓存 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">property</span> <span class="attribute">name</span>=<span class="value">"hibernate.cache.use_query_cache"</span>&gt;</span>true<span class="tag">&lt;/<span class="title">property</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>此外还需要调用Query对象的setCacheable(true)才会对查询结果进行缓存。</p>
<h2 id="事件机制">事件机制</h2><p>Hibernate的事件框架由两个部分组成</p>
<ul>
<li>拦截器机制：对于特定动作拦截，回调应用中的特定动作。</li>
<li>事件系统：重写Hibernate的事件监听器。</li>
</ul>
<h3 id="拦截器">拦截器</h3><p>Interceptor接口提供了从会话(session)回调(callback)应用程序(application)的机制，这种回调机制可以允许应用程序在持久化对象被保存、更新、删除或是加载之前，检查并（或）修改其属性。一个可能的用途，就是用来跟踪审核(auditing)信息。</p>
<ul>
<li><p>创建会话(session)的时候可以指定拦截器。</p>
  <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Session</span> session = sf.openSession( <span class="keyword">new</span> <span class="type">MyInterceptor</span><span class="literal">()</span> );</span><br></pre></td></tr></table></figure>
</li>
<li><p>也可以使用Configuration来设置一个全局范围的拦截器。</p>
  <figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="type">Configuration</span><span class="literal">()</span>.setInterceptor( <span class="keyword">new</span> <span class="type">MyInterceptor</span><span class="literal">()</span> );</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="事件系统">事件系统</h3><p>基本上，Session接口的每个方法都有相对应的事件。比如 LoadEvent，FlushEvent，等等（查阅XML配置文件 的DTD，以及org.hibernate.event包来获得所有已定义的事件的列表）。当某个方法被调用时，Hibernate Session会生成一个相对应的事件并激活所有配置好的事件监听器。系统预设的监听器实现的处理过程就是被监听的方法要做的（被监听的方法所做的其实仅仅是激活监听器，“实际”的工作是由监听器完成的）。不过，你可以自由地选择实现一个自己定制的监听器（比如，实现并注册用来处理处理LoadEvent的LoadEventListener接口），来负责处理所有的调用Session的load()方法的请求。</p>
<p>监听器应该被看作是单例(singleton)对象，也就是说，所有同类型的事件的处理共享同一个监听器实例，因此监听器不应该保存任何状态（也就是不应该使用成员变量）。</p>
<p>用户定制的监听器应该实现与所要处理的事件相对应的接口，或者从一个合适的基类继承（甚至是从Hibernate自带的默认事件监听器类继承，为了方便你这样做，这些类都被声明成non-final的了）。用户定制的监听器可以通过编程使用Configuration对象来注册，也可以在Hibernate的XML格式的配置文件中进行声明（不支持在Properties格式的配置文件声明监听器）。下面是一个用户定制的加载事件(load event)的监听器：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">MyLoadListener</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">DefaultLoadEventListener</span> &#123;</span></span><br><span class="line">    <span class="comment">// this is the single method defined by the LoadEventListener interface</span></span><br><span class="line">    public <span class="type">Object</span> onLoad(<span class="type">LoadEvent</span> event, <span class="type">LoadEventListener</span>.<span class="type">LoadType</span> loadType)</span><br><span class="line">            <span class="keyword">throws</span> <span class="type">HibernateException</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> ( !<span class="type">MySecurity</span>.isAuthorized( event.getEntityClassName(), event.getEntityId() ) ) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="type">MySecurityException</span>(<span class="string">"Unauthorized access"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onLoad(event, loadType);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>你还需要修改一处配置，来告诉Hibernate以使用选定的监听器来替代默认的监听器。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">hibernate-configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">session-factory</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="title">listener</span> <span class="attribute">type</span>=<span class="value">"load"</span> <span class="attribute">class</span>=<span class="value">"MyLoadListener"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一个事件配置多个监听器<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">event</span> type=<span class="string">"load"</span>&gt;</span><br><span class="line">    &lt;listener <span class="keyword">class</span>=<span class="string">"listener.MyLoadListener"</span> /&gt;</span><br><span class="line">    &lt;listener <span class="keyword">class</span>=<span class="string">"listener.DefaultLoadEventListener"</span> /&gt;</span><br><span class="line">&lt;/<span class="keyword">event</span>&gt;</span><br></pre></td></tr></table></figure></p>
<p>看看用另一种方式，通过编程的方式来注册它。</p>
<figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Configuration</span> cfg = <span class="keyword">new</span> <span class="type">Configuration</span><span class="literal">()</span>;</span><br><span class="line">cfg.getSessionEventListenerConfig<span class="literal">()</span>.setLoadEventListener( <span class="keyword">new</span> <span class="type">MyLoadListener</span><span class="literal">()</span> );</span><br></pre></td></tr></table></figure>
<p>或<br><figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Configuration</span> cfg = <span class="keyword">new</span> <span class="keyword">Configuration</span>();</span><br><span class="line">cfg.setListener(<span class="string">"load"</span>, <span class="string">"listener.MyLoadListener"</span>);</span><br></pre></td></tr></table></figure></p>
<p>注册多个事件<br><figure class="highlight ocaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">LoadEventListener</span><span class="literal">[]</span> stack = &#123; <span class="keyword">new</span> <span class="type">MyLoadListener</span><span class="literal">()</span>, <span class="keyword">new</span> <span class="type">DefaultLoadEventListener</span><span class="literal">()</span>&#125;;</span><br><span class="line">cfg.getEventListeners<span class="literal">()</span>.setLoadEventListeners(stack);</span><br></pre></td></tr></table></figure></p>
<p>通过在XML配置文件声明而注册的监听器不能共享实例。如果在多个<listener>节点中使用了相同的类的名字，则每一个引用都将会产生一个独立的实例。如果你需要在多个监听器类型之间共享监听器的实例，则你必须使用编程的方式来进行注册。</listener></p>
<p>为什么我们实现了特定监听器的接口，在注册的时候还要明确指出我们要注册哪个事件的监听器呢？ 这是因为一个类可能实现多个监听器的接口。在注册的时候明确指定要监听的事件，可以让启用或者禁用对某个事件的监听的配置工作简单些。</p>
<p>参考：</p>
<p><a href="http://xiaogui9317170.iteye.com/blog/283526" target="_blank" rel="external">基于按annotation的hibernate主键生成策略</a><br><a href="https://docs.jboss.org/hibernate/annotations/3.4/reference/zh_cn/html_single/" target="_blank" rel="external">Hibernate Annotations</a><br><a href="http://www.cnblogs.com/luxh/archive/2012/06/01/2531428.html" target="_blank" rel="external">JPA的查询语言—JPQL的命名查询@NamedQuery</a></p>
]]></content>
    <summary type="html">
    <![CDATA[Hibernate]]>
    
    </summary>
    
      <category term="Hibernate" scheme="http://howiefh.github.io/tags/Hibernate/"/>
    
      <category term="JavaEE" scheme="http://howiefh.github.io/categories/JavaEE/"/>
    
      <category term="Hibernate" scheme="http://howiefh.github.io/categories/JavaEE/Hibernate/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Java编程思想笔记九]]></title>
    <link href="http://howiefh.github.io/2015/02/07/thinking-in-java-note-9/"/>
    <id>http://howiefh.github.io/2015/02/07/thinking-in-java-note-9/</id>
    <published>2015-02-07T12:51:16.000Z</published>
    <updated>2015-02-08T13:12:54.000Z</updated>
    <content type="html"><![CDATA[<p>Swing中有一个非常令人称道的原则，称为“正交使用”。意思是，一旦你理解了库中的某个通用概念，你就可以把这个概念应用到其他地方。</p>
<h2 id="Swing_基础">Swing 基础</h2><p>Swing有它自己的专用线程来接收UI事件并更新屏幕，如果从其他线程着手对屏幕进行操作，那么就可能产生冲突和死锁。其他线程通过事件分发线程提交要执行的任务，可以通过将任务提交给SwingUtilities.invokeLater()来实现这种方式，这个方法会通过事件分发线程将任务放置到（最终将得到执行的）待执行事件队列中。程序中的所有代码都遵循这种通过SwingUtilities.invokeLater()来提交操作的方式。这包括启动程序自身，即main也不应该调用Swing方法，就像上面的程序一样，它应该向事件队列提交任务。</p>
<p>Java中设计和实现图形用户界面的工作主要有：</p>
<ol>
<li>创建组件（Component)：创建组成界面的各种元素，如按钮、文本框等。</li>
<li>指定布局（Layout）：根据具体需要排列组件的位置关系。</li>
<li>响应事件（Event）：定义图形用户界面的事件和各界面元素对不同事件的响应，从而实现图形用户界面与用户的交互功能。</li>
</ol>
<a id="more"></a>
<h3 id="组件">组件</h3><p>Swing GUI由顶层容器-中间容器-基本组件构成</p>
<ul>
<li>顶层容器，这些组件在Swing GUI层次体系的顶层，主要包括JFrame，JApplet，JDialog等</li>
<li>通用容器，具有普遍应用场合，包括Jpanel，JScrollPane，JSplitPane，JTabbedPane, JToolBar等</li>
<li>特殊容器，在GUI中起特殊作用的中间层容器，包括JInternalFrame，JLayeredPane，JRootPane等</li>
<li>基本控制组件，这些基本组件主要用于接收用户输入，它们一般能够显示简单的状态，包括JButton，JComboBox，JList，JMemu，JSlider，JTestField等</li>
<li>不可编辑的信息显示组件，完全用来显示信息的组件，包括JLabel，JProgressBar等</li>
<li>可编辑的信息显示组件，这些组件用来显示可被用户编辑修改的格式化信息，包括JTable，JFileChooser，JTree等</li>
</ul>
<p>Swing组件中，除了顶层容器组件，所有以J开头的组件都是JComponent类的子类，可以添加工具提示setToolTipText(String)</p>
<ul>
<li><p>对话框</p>
<ul>
<li>JOptionPane（简单标准的对话框）</li>
<li>ProgressMonitor（显示操作进程的对话框）</li>
<li>JColorChooser（标准对话框）</li>
<li>JFileChooser（标准对话框）</li>
<li>JDialog（可制定对话框）</li>
</ul>
</li>
<li><p>按钮类组件</p>
<ul>
<li>包括JButton，JCheckBox,JRadioButton, JMenuItem, JCheckBoxMenuItem</li>
<li>AbstractButton是一个抽象类，它是JButton，JCheckBox,JRadioButton, JMenuItem, JCheckBoxMenuItem类的父类</li>
</ul>
</li>
<li><p>文本组件</p>
<ul>
<li>JTextField</li>
<li>JPasswordField</li>
<li>JTextArea</li>
<li>JEditorPane</li>
<li>JTextPane</li>
</ul>
</li>
<li><p>标签JLable</p>
</li>
<li>列表JList</li>
<li>表格JTable</li>
<li>树JTree</li>
<li>选择框JComboBox</li>
<li>文件选择器JFileChooser</li>
<li>颜色选择器JColorChooser</li>
<li>进程条JProgressBar</li>
<li>滑动块Jslider</li>
<li>微调器JSpinner</li>
</ul>
<h3 id="布局管理">布局管理</h3><p>Java提供了下列布局管理器</p>
<ol>
<li><p>FlowLayout 流式布局管理器(JPanel的默认布局)</p>
<p> FlowLayout(int align, int hgap, int vgap)，组件按参数指定的对齐方式摆放，组件之间水平距离由hgap指定，垂直距离由vgap指定，aligh 默认居中，hgap，vgap默认5个像素。使用FlowLayout，所有组件将被压缩到它们的最小尺寸，如果重新调整视窗大小，那么布局管理器将随之重新流动所有组件。</p>
</li>
<li><p>BorderLayout 边界布局管理器(JFrame,JWindow的默认布局)</p>
<p> BorderLayout()：组件之间没有水平间隙与垂直间隙；BorderLayout(int hgap, int vgap)：指定组件之间的水平和垂直间隙</p>
<p> BorderLayout布局管理器将容器分为5个区：East, West, South, North和Center。对于除Center以外的所有位置，加入的组件被沿着一个方向压缩到最小尺寸，同时在另一个方向上拉伸到最大尺寸。不过对于Center，组件将在两个方向上同时拉伸，以覆盖中央区域。</p>
</li>
<li><p>GridLayout网格布局管理器</p>
<p> BorderLayout()：组件之间没有水平间隙与垂直间隙；BorderLayout(int hgap, int vgap)：指定组件之间的水平和垂直间隙；GridLayout(int rows, int cols, int hgap, int vgap)，容器划分为指定数目的网格，并制定组件间的水平垂直距离</p>
</li>
<li><p>GridBagLayout网格包布局管理器</p>
<p> GridBagLayout所管理的每个组件都与一个GridBagConstraints类的对象相关。这个约束对象指定了组建的显示区域在网格中的位置，以及在其显示区域中应该如何摆放组件</p>
<p> GridBagConstraints对象的定制是通过设置一个或者多个GridBagConstraints的变量来实现的：</p>
<ul>
<li>gridx,gridy指定组件左上角在网格中的行与列</li>
<li>gridwidth, gridheight指定组件显示区域所占的列数与行数</li>
<li>fill指定组件填充网格的方式</li>
<li>ipadx,ipady指定组件显示区域的内部填充</li>
<li>insets指定组件显示区域的外部填充</li>
<li>anchor指定组件在显示区域的摆放位置</li>
<li>weightx, weighty用来指定在容器大小改变是，增加或减少的孔家如何在组件间进行分配  </li>
</ul>
</li>
<li><p>BoxLayout箱式布局管理器</p>
<p> 箱式布局管理器将组件垂直摆放在一列或水平摆放的一行中，具体由BoxLayout.X_AXIS和BoxLayout.Y_AXIS指定</p>
</li>
<li><p>GroupLayout分组布局管理器</p>
<p> GroupLayout 是一个 LayoutManager，它将组件按层次分组，以决定它们在 Container 中的位置。GroupLayout 主要供生成器使用，但也可以手工编码。分组由 Group 类的实例来完成。GroupLayout 支持两种组。串行组 (sequential group) 按顺序一个接一个地放置其子元素。并行组 (parallel group) 能够以四种方式对齐其子元素。</p>
<p> 每个组可以包含任意数量的元素，其中元素有 Group、Component 或间隙 (gap)。间隙可被视为一个具有最小大小、首选大小和最大大小的不可见组件。此外，GroupLayout 还支持其值取自 LayoutStyle 的首选间隙。</p>
</li>
<li><p>CardLayout卡片布局管理器</p>
<p> CardLayout()，组件与左右上下界之间没有间隙， CardLayout(int hgap, int vgap)，参数hgap指定组件距离左右边界的间隙，参数vgap指定组件距离上下边界的间隙。</p>
<p> CardLayout常用的方法：<code>public void first (Container parent)</code>，显示第一张卡片，<code>public void next (Container parent)</code>，显示下一张卡片(如果当前是最后一张，则显示第一张)，<code>public void previous (Container parent)</code>，显示前一张卡片，<code>public void last (Container parent)</code>，显示最后一张卡片，<code>public void show (Container parent, String name)</code>，显示指定名称的组件，</p>
</li>
<li><p>无布局管理器</p>
<p> 使用setLayout(null)把容器的布局管理器设置为空。需要使用setLocation(), setSize(),setBounds()或者reshape()等方法手工设置组件大小和位置(这些方法会导致平台相关，不建议使用)</p>
</li>
</ol>
<p>第三方：FormLayout、MigLayout，TableLayout</p>
<h3 id="事件">事件</h3><p>事件处理模型中的3类对象</p>
<ul>
<li>事件<br>  当用户在界面上执行一个操作，如敲键盘、拖动或者单击鼠标，都产生了事件</li>
<li>事件源<br>  产生事件的组件就是一个事件源。如在一个Button上单击鼠标时，将产生一个ActionEvent类型的事件，这个Button就是事件源</li>
<li>事件处理器<br>  事件处理器是一个方法，该方法接收一个事件对象，对其进行解释，并做出相应的处理</li>
</ul>
<p>事件及其相应的监听器接口</p>
<table>
<thead>
<tr>
<th>事件类别</th>
<th>描述信息</th>
<th>接口名</th>
<th>方法</th>
</tr>
</thead>
<tbody>
<tr>
<td>　ActionEvent</td>
<td>激活组件</td>
<td>　　ActionListener</td>
<td>　actionPerformed(ActionEvent)</td>
</tr>
<tr>
<td>　ItemEvent</td>
<td>选择了某些项目</td>
<td>　　ItemListener</td>
<td>　itemStateChanged(ItemEvent)</td>
</tr>
<tr>
<td>　MouseEvent</td>
<td>鼠标移动</td>
<td>　　MouseMotionListener</td>
<td>　mouseDragged(MouseEvent) 　mouseMoved(MouseEvent)</td>
</tr>
<tr>
<td>  MouseEvent</td>
<td>鼠标点击等</td>
<td>　　MouseListener</td>
<td>　mousePressed(MouseEvent) 　mouseReleased(MouseEvent) 　mouseEntered(MouseEvent) 　mouseExited(MouseEvent) 　mouseClicked(MouseEvent)</td>
</tr>
<tr>
<td>　KeyEvent</td>
<td>键盘输入</td>
<td>　　KeyListener</td>
<td>　keyPressed(KeyEvent) 　keyReleased(KeyEvent) 　keyTyped(KeyEvent)</td>
</tr>
<tr>
<td>　FocusEvent</td>
<td>组件收到或失去焦点</td>
<td>　　FocusListener</td>
<td>　focusGained(FocusEvent) 　focusLost(FocusEvent)</td>
</tr>
<tr>
<td>　AdjustmentEvent</td>
<td>移动了滚动条等组件</td>
<td>　　AdjustmentListener</td>
<td>　adjustmentValueChanged(AdjustmentEvent)</td>
</tr>
<tr>
<td>　ComponentEvent</td>
<td>对象移动缩放显示隐藏等</td>
<td>　　ComponentListener</td>
<td>　componentMoved(ComponentEvent) 　componentHidden(ComponentEvent) 　componentResized(ComponentEvent) 　componentShown(ComponentEvent)</td>
</tr>
<tr>
<td>　WindowEvent</td>
<td>窗口收到窗口级事件</td>
<td>　　WindowListener</td>
<td>　windowClosing(WindowEvent) 　windowOpened(WindowEvent) 　windowIconified(WindowEvent) 　windowDeiconified(WindowEvent) 　windowClosed(WindowEvent) 　windowActivated(WindowEvent) 　windowDeactivated(WindowEvent)</td>
</tr>
<tr>
<td>　ContainerEvent</td>
<td>容器中增加删除了组件</td>
<td>　　ContainerListener</td>
<td>　componentAdded(ContainerEvent) componentRemoved(ContainerEvent)</td>
</tr>
<tr>
<td>　TextEvent</td>
<td>文本字段或文本区发生改变</td>
<td>　　TextListener</td>
<td>　textValueChanged(TextEvent)</td>
</tr>
</tbody>
</table>
<p>事件适配器 </p>
<ol>
<li>ComponentAdapter( 组件适配器) </li>
<li>ContainerAdapter( 容器适配器) </li>
<li>FocusAdapter( 焦点适配器) </li>
<li>KeyAdapter( 键盘适配器) </li>
<li>MouseAdapter( 鼠标适配器) </li>
<li>MouseMotionAdapter( 鼠标运动适配器)</li>
<li>WindowAdapter( 窗口适配器) </li>
</ol>
<p>可以创建一个全局的监听器，不过有时写成内部类会更有用。这不仅是因为将监听器类放在它们所服务的用户接口类或者业务逻辑类的内部时，可以在逻辑上对其进行分组，而且还因为内部类对象含有一个对其外部类对象的引用，这就为跨越类和子类系统边界的调用提供了一种优雅的方式。</p>
<p>Swing支持键盘快捷键，可以用键盘而不是鼠标来选择任何从AbstractButton继承而来的组件：只要使用重载的构造器，使它的第二个参数接受快捷键的标识符即可。如果没有这样的构造器，可以通过setMnemonic()方法<code>btn.setMnemonic(KeyEvent.VK_B)</code>。</p>
<p>setActionCommand()的用法。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先设置 </span></span><br><span class="line">menuitem.setActionCommand<span class="params">(<span class="string">"Open"</span>)</span>;</span><br><span class="line"><span class="comment">//在事件处理器中</span></span><br><span class="line">JMenuItem target = <span class="params">(JMenuItem)</span>e.getSource<span class="params">()</span>;</span><br><span class="line">String actionCommand = target.getActionCommand<span class="params">()</span>;</span><br><span class="line"><span class="keyword">if</span><span class="params">(actionCommand.equals<span class="params">(<span class="string">"Open"</span>)</span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>任何能够接受文本的组件都可以接受html文本，且能根据html的规则来重新格式化文本。必须使文本以<code>&lt;html&gt;</code>开始，然后就可以使用普通的html标记了，注意，不会强制要求你添加普通的结束标记。</p>
<p>选择外观<br>try {<br>    UIManager.setLookAndFeel(UIManager.getSystemLookAndFeelClassName());<br>} catch(Exception e) {<br>    throw new RuntimeException(e);<br>}<br>不过你要确保在创建任何可视组件之前先调用这些代码。</p>
<h3 id="绘图">绘图</h3><ol>
<li><p>paint方法</p>
<p> public void paint(Graphics g)       以画布为参数，在画布上执行画图方法 </p>
</li>
<li><p>repaint方法</p>
<p> Applet重画时系统自动调用paint方法</p>
</li>
<li><p>update方法</p>
<p> public void update(Graphics g)       更新容器，向repaint发出刷新小应用程序的信号，缺省的update方法清除Applet画图区并调用paint方法</p>
</li>
</ol>
<p><strong>Graphics类</strong></p>
<p>Graphics类提供画各种图形的方法，其中包括线、圆和椭圆、矩形和多边形、图像以及各种字体的文本等。这些方法具体如下：</p>
<p>public abstract void clipRect(int x, int y, int width, int height)        指定的区域切分<br>public abstract void drawLine(int x1, int y1, int x2, int y2) 使用当前颜色，在点(x1, y1) 和 (x2, y2) 之间画线<br>public abstract void drawOval(int x, int y, int width, int height) 画椭圆<br>public abstract void fillOval(int x, int y, int width, int height) 画实心椭圆<br>public abstract void drawPolygon(int[] xPoints, int[] yPoints, int nPoints) 画x和y坐标定义的多边形<br>public void drawRect(int x, int y, int width, int height) 画矩形<br>public void fillRect(int x, int y, int width, int height) 画实心矩形<br>public abstract void drawRoundRect(int x, int y, int width, int height, int arcWidth, int arcHeight) 画圆角矩形<br>public abstract void drawString(String str, int x, int y) 使用当前字体和颜色画字符串str<br>public abstract void setColor(Color c) 设置图形上下文的当前颜色<br>public abstract void setPaintMode() 设置画模式<br>public abstract boolean drawImage (Image img, int x, int y, ImageObserver observer) 画特定图<br>public abstract void setFont(Font font) 设置特定的font字体。使用时首先得到font对象的一个实例，Font类常用构造函数为：public Font(String name, int style, int size) </p>
<p>Color类</p>
<p><code>public Color(int red, int green, int blue)</code><br><code>public Color(int red, int green, int blue, int alpha)</code>       其中：前三个分量即RGB颜色模式中的参数，第四个alpha分量指透明的程度。当alpha分量为255时，表示完全不透明，正常显示；当alpha分量为0时，表示完全透明，前三个分量不起作用</p>
<p>Graphics2D类</p>
<p>Graphics2D类继承于Graphics类，提供几何学、坐标变换、颜色管理以及文本排列等的更高级控制。Graphics2D类是Java平台上渲染二维图形、文字、以及图片的基础类，提供较好的对绘制形状、填充形状、旋转形状、绘制文本、绘制图像以及定义颜色的支持。在AWT编程接口中，用户通过paint方法接收Graphics对象作为参数，若是使用Graphics2D类，就需要在Paint方法中进行强制转换。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">paint</span><span class="params">(Graphics old)</span></span>&#123;	Graphics2D <span class="keyword">new</span> = (Graphics2D)old;&#125;</span><br></pre></td></tr></table></figure>
<p>Graphics2D提供以下两个方法进行形状的绘制：<br>public abstract void draw(Shape s)         根据Graphics2D的环境设置画出形状s。<br>public abstract void fill(Shape s)         画实心形状s。</p>
<p>Shape的实现类：Line2D（线）、Rectangle2D（矩形）、RoundRectangle2D（圆角矩形）、Ellipse2D（椭圆）、GeneralPath（几何路径）。</p>
<h2 id="Swing与并发">Swing与并发</h2><h3 id="长期运行的任务">长期运行的任务</h3><p>在专用线程中执行长时间 GUI 交互任务的抽象类。 </p>
<p>使用 Swing 编写多线程应用程序时，要记住两个约束条件：（有关详细信息，请参阅 How to Use Threads）： </p>
<ul>
<li>不应该在事件指派线程 上运行耗时任务。否则应用程序将无响应。 </li>
<li>只能在事件指派线程 上访问 Swing 组件。 </li>
</ul>
<p>这些约束意味着需要时间密集计算操作的 GUI 应用程序至少需要以下两个线程：1) 执行长时间任务的线程； 2) 所有 GUI 相关活动的事件指派线程 （EDT）这涉及到难以实现的线程间通信。 </p>
<p>SwingWorker 设计用于需要在后台线程中运行长时间运行任务的情况，并可在完成后或者在处理过程中向 UI 提供更新。SwingWorker 的子类必须实现 doInBackground() 方法，以执行后台计算。 </p>
<p>工作流 </p>
<p>SwingWorker 的生命周期中包含三个线程： </p>
<ul>
<li>当前线程：在此线程上调用 execute() 方法。它调度 SwingWorker 以在 worker 线程上执行并立即返回。可以使用 get 方法等待 SwingWorker 完成。 </li>
<li>Worker 线程：在此线程上调用 doInBackground() 方法。所有后台活动都应该在此线程上发生。要通知 PropertyChangeListeners 有关绑定 (bound) 属性的更改，请使用 firePropertyChange 和 getPropertyChangeSupport() 方法。默认情况下，有两个可用的绑定属性：state 和 progress。 </li>
<li>事件指派线程：所有与 Swing 有关的活动都在此线程上发生。SwingWorker 调用 process 和 done() 方法，并通知此线程的所有 PropertyChangeListener。 </li>
</ul>
<p>通常，当前 线程就是事件指派线程。 </p>
<p>在 worker 线程上调用 doInBackground 方法之前，SwingWorker 通知所有 PropertyChangeListener 有关对 StateValue.STARTED 的 state 属性更改。doInBackground 方法完成后，执行 done 方法。然后 SwingWorker 通知所有 PropertyChangeListener 有关对 StateValue.DONE 的 state 属性更改。 </p>
<p>SwingWorker 被设计为只执行一次。多次执行 SwingWorker 将不会调用两次 doInBackground 方法。 </p>
<p>示例用法 </p>
<p>下例说明了最简单的使用范例：在后台完成某些处理，并在处理完成后更新 Swing 组件。 </p>
<p>假定想找到“Meaning of Life”并在 JLabel 中显示结果。 </p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="type">JLabel</span> label;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MeaningOfLifeFinder</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">SwingWorker&lt;String</span>, <span class="title">Object&gt;</span> &#123;</span></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  public <span class="type">String</span> doInBackground() &#123;</span><br><span class="line">    <span class="keyword">return</span> findTheMeaningOfLife();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="keyword">protected</span> void done() &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123; </span><br><span class="line">      label.setText(get());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (<span class="type">Exception</span> ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">(<span class="keyword">new</span> <span class="type">MeaningOfLifeFinder</span>()).execute();</span><br></pre></td></tr></table></figure>
<h3 id="可视化线程机制">可视化线程机制</h3><p>调用repaint时，并未强制在这一时刻立即进行绘制，而只是设置了一个“脏标识”，表示当下一次事件分发线程准备好重绘时，这个区域是重绘的备选元素之一。</p>
<p>当事件分发线程实际执行paint时，首先调用paintComponent，然后是paintBorder和paintChildren。如果需要在导出组件中覆盖paint，就必须牢记调用基类版本的paint，以使得它仍旧可以执行正确的行为。</p>
<h2 id="可视化编程与JavaBean">可视化编程与JavaBean</h2><h3 id="什么是JavaBean">什么是JavaBean</h3><p>JavaBean 只是一个命名规则</p>
<ol>
<li>对于一个名称为xxx的属性，通常你要写两个方法；getXxx()和setXxx()。任何浏览这些方法的工具，都会把get或sett后面的第一个字母自动转换为小写，以产生属性名，get方法返回的类型要与set方法里参数的类型相同属性的名称与set和get所依据的类型毫无关系</li>
<li>对于布尔型属性可以使用以上get和set的方式，不过也可以把get替换成is</li>
<li>Bean的普通方法不必遵循以上命名规则，不过它们必须是public的。</li>
<li>对于事件，要使用Swing中处理监听器的方式。这与前面所见到的完全相同addBounceListener( BounceListener)和 removeBounceListener (BounceListener)用来处理BounceEvent事件。大多数情况下，内置的事件和监听器就能够满足需求了，不过也可以自己编写事件和监听器接口。</li>
</ol>
<h3 id="使用Introspector抽取BeanInfo">使用Introspector抽取BeanInfo</h3><p>Introspector（内省器），这个类最重要的就是静态的getBeanInfo方法。向这个方法传递一个Class对象引用，它能够完全侦测这个类，然后返回一个BeanInfo对象，可以通过这个对象得到Bean的属性、方法和事件。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">public class BeanDumper extends JFrame &#123;  </span><br><span class="line">    private JTextField query = new JTextField<span class="params">(<span class="number">20</span>)</span>;  </span><br><span class="line">    private JTextArea results = new JTextArea<span class="params">()</span>;  </span><br><span class="line">  </span><br><span class="line">    public void print<span class="params">(String s)</span> &#123;  </span><br><span class="line">        results.append<span class="params">(s + <span class="string">" \n"</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public void dump<span class="params">(Class&lt;?&gt; bean)</span> &#123;  </span><br><span class="line">        results.setText<span class="params">(<span class="string">""</span>)</span>;  </span><br><span class="line">        BeanInfo bi = null;  </span><br><span class="line">  </span><br><span class="line">        try &#123;  </span><br><span class="line">            bi = Introspector.getBeanInfo<span class="params">(bean, Object.class)</span>;  </span><br><span class="line">        &#125; catch <span class="params">(IntrospectionException e)</span> &#123;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"Couldn 't introspect"</span> + bean.getName<span class="params">()</span>)</span>;  </span><br><span class="line">            return;  </span><br><span class="line">        &#125;  </span><br><span class="line">        <span class="comment">// 获取 bean属性 方法  </span></span><br><span class="line">        <span class="keyword">for</span> <span class="params">(PropertyDescriptor d : bi.getPropertyDescriptors<span class="params">()</span>)</span> &#123;  </span><br><span class="line">            Class&lt;?&gt; p = d.getPropertyType<span class="params">()</span>;  </span><br><span class="line">            <span class="keyword">if</span> <span class="params">(p == null)</span>  </span><br><span class="line">                continue;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"Property type:\n"</span> + p.getName<span class="params">()</span>)</span>;  </span><br><span class="line">            Method m = d.getReadMethod<span class="params">()</span>;  </span><br><span class="line">            <span class="keyword">if</span> <span class="params">(m != null)</span>  </span><br><span class="line">                System.out.println<span class="params">(<span class="string">"read method:+\n"</span> + m.getName<span class="params">()</span>)</span>;  </span><br><span class="line">            Method rm = d.getWriteMethod<span class="params">()</span>;  </span><br><span class="line">            <span class="keyword">if</span> <span class="params">(rm != null)</span>  </span><br><span class="line">                System.out.println<span class="params">(<span class="string">"write method:+\n"</span> + rm.getName<span class="params">()</span>)</span>;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"===================================="</span>)</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"public methods:"</span>)</span>;  </span><br><span class="line">        <span class="keyword">for</span> <span class="params">(MethodDescriptor ms : bi.getMethodDescriptors<span class="params">()</span>)</span> &#123;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"ms:"</span> + ms.getMethod<span class="params">()</span>.toString<span class="params">()</span>)</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"===================================="</span>)</span>;  </span><br><span class="line">        System.out.println<span class="params">(<span class="string">"envent support:"</span>)</span>;  </span><br><span class="line">        <span class="keyword">for</span> <span class="params">(EventSetDescriptor e : bi.getEventSetDescriptors<span class="params">()</span>)</span> &#123;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"listener type:\n"</span>  </span><br><span class="line">                    + e.getListenerType<span class="params">()</span>.getName<span class="params">()</span>)</span>;  </span><br><span class="line">            <span class="keyword">for</span> <span class="params">(Method lm : e.getListenerMethods<span class="params">()</span>)</span>  </span><br><span class="line">                System.out.println<span class="params">(<span class="string">"listener method:\n"</span> + lm.getName<span class="params">()</span>)</span>;  </span><br><span class="line">  </span><br><span class="line">            <span class="keyword">for</span> <span class="params">(MethodDescriptor lmd : e.getListenerMethodDescriptors<span class="params">()</span>)</span>  </span><br><span class="line">                System.out.println<span class="params">(<span class="string">"listener methodDescriptor:\n"</span>  </span><br><span class="line">                        + lmd.getName<span class="params">()</span>)</span>;  </span><br><span class="line">            <span class="comment">//  </span></span><br><span class="line">            Method addListener = e.getAddListenerMethod<span class="params">()</span>;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"add listener method:\n"</span> + addListener)</span>;  </span><br><span class="line">            Method removeListener = e.getRemoveListenerMethod<span class="params">()</span>;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"Remove Listener Method:\n"</span> + removeListener)</span>;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"==========================================="</span>)</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="comment">// ------------------------------------------------  </span></span><br><span class="line">    class Dumper implements ActionListener &#123;  </span><br><span class="line">  </span><br><span class="line">        @Override  </span><br><span class="line">        public void actionPerformed<span class="params">(ActionEvent e)</span> &#123;  </span><br><span class="line">            String name = query.getText<span class="params">()</span>;  </span><br><span class="line">            System.out.println<span class="params">(<span class="string">"name=========&gt;"</span>+name)</span>;  </span><br><span class="line">            Class&lt;?&gt; c = null;  </span><br><span class="line">            try &#123;  </span><br><span class="line">                c = Class.forName<span class="params">(name)</span>;  </span><br><span class="line">            &#125; catch <span class="params">(ClassNotFoundException e1)</span> &#123;  </span><br><span class="line">                results.setText<span class="params">(<span class="string">"couldn 't find "</span> + name)</span>;  </span><br><span class="line">                e1.printStackTrace<span class="params">()</span>;  </span><br><span class="line">                return;  </span><br><span class="line">            &#125;  </span><br><span class="line">            dump<span class="params">(c)</span>;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public BeanDumper<span class="params">()</span> &#123;  </span><br><span class="line">        JPanel p = new JPanel<span class="params">()</span>;  </span><br><span class="line">        p.setLayout<span class="params">(new FlowLayout<span class="params">()</span>)</span>;  </span><br><span class="line">        p.add<span class="params">(new JLabel<span class="params">(<span class="string">"qualifeied bean name:"</span>)</span>)</span>;  </span><br><span class="line">        p.add<span class="params">(query)</span>;  </span><br><span class="line">        add<span class="params">(BorderLayout.NORTH, p)</span>;  </span><br><span class="line">        add<span class="params">(new JScrollPane<span class="params">(results)</span>)</span>;  </span><br><span class="line">        Dumper dmpr = new Dumper<span class="params">()</span>;  </span><br><span class="line">        query.addActionListener<span class="params">(dmpr)</span>;  </span><br><span class="line">        query.setText<span class="params">(<span class="string">"org.rui.swing.bean.Frog"</span>)</span>;  </span><br><span class="line">        dmpr.actionPerformed<span class="params">(new ActionEvent<span class="params">(dmpr, <span class="number">0</span>, <span class="string">""</span>)</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    public static void main<span class="params">(String[] args)</span> &#123;  </span><br><span class="line">        <span class="comment">//工具类  </span></span><br><span class="line">        SwingConsole.run<span class="params">(new BeanDumper<span class="params">()</span>, <span class="number">600</span>, <span class="number">500</span>)</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="JavaBean与同步">JavaBean与同步</h3><ol>
<li>尽可能地让Bean中的所有公共方法都是synchronized的。</li>
<li>当一个多路事件触发了一组对该事件感兴趣的监听器时，你必须假定，在你遍历列表进行通知的同时，监听器可能会被添加或移除。<br> 可以通过忽略synchronized关键字并使用单路事件处理方式，回避并发问题。 </li>
</ol>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这是这是一个单播侦听器  </span></span><br><span class="line"><span class="comment">// 最简单形式的侦听器管理  </span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">addActionListener</span><span class="params">(ActionListener l)</span>  </span><br><span class="line">        <span class="keyword">throws</span> TooManyListenersException </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (actionListener != <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TooManyListenersException();  </span><br><span class="line">    &#125;  </span><br><span class="line">    actionListener = l;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断方法是否被同步需要考虑的问题</p>
<ol>
<li>这个方法会修改对象中“关键”变量的状态吗？要弄清楚变量是否“关键”，必须判断它们是否被程序中的其他线程读写。</li>
<li>这个方法依赖于那些“关键”变量吗？如果有某个同步方法会修改此方法所使用的变量，那么你应该把这个方法也同步。要是觉得问题不大，这种改变只起瞬时作用，你就可以做出不同步的决定，以避免同步方法调用所产生的开销。</li>
<li>第三个线索是查看基类版本的paintComponent是否同步，这只是一个线索。注意，同步不会继承，也就是说，基类方法是同步的，派生类中覆盖后的版本并非自动同步。</li>
<li>方法执行必须尽可能快。要尽可能把处理的开销移到方法外面。</li>
</ol>
<h3 id="对Bean更高级的支持">对Bean更高级的支持</h3><p>前面的例子只演示了单一属性，但也可以使用数组来表示多重属性。这称为索引属性。<br>属性可以被绑定，即它们能通过PropertyChangeEvent事件通知其他对象<br>属性可以被约束，即如果属性的改变是不可接受的，其他对象可以否决这个改变。</p>
<p>Swing的可替代选择flex，SWT</p>
]]></content>
    <summary type="html">
    <![CDATA[thinking in java; java编程思想; 图形化用户界面;]]>
    
    </summary>
    
      <category term="Thinking in Java" scheme="http://howiefh.github.io/tags/Thinking-in-Java/"/>
    
      <category term="Java" scheme="http://howiefh.github.io/categories/Java/"/>
    
  </entry>
  
</feed>