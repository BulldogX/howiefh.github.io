title: php学习笔记（二）-数据存储与检索
date: 2013-08-01 15:38:39
categories: PHP
tags: PHP
---
## 打开文件

```php
resource fopen ( string $filename , string $mode [, bool $use_include_path = false [, resource $context ]] )
```
* filename:文件名
* mode:打开文件模式(r,r+,w,w+,x,x+,a,a+,b,t)
    * 出于移植性考虑，在打开文件时总是使用'b'标记
    * 只是windows下的选项，不是推荐选项
* use_include_path:如果也需要在 include_path 中搜寻文件的话，可以将可选的第三个参数 use_include_path 设为 '1' 或 TRUE。
* context:在 PHP 5.0.0 中增加了对上下文（Context）的支持。有关上下文（Context）的说明参见 Streams。
* $_SERVERR['DOCUMENT_ROOT']:文档根目录  /var/www

问题：由于权限问题，fopen可能无法成功打开文件，返回有效的文件指针

解决：使用错误抑制操作符
```php
@ $fp = fopen("$DOCUMENT_ROOT/../orders/orders.txt", 'ab');
if (!$fp) {
  echo "<p><strong> Your order could not be processed at this time. Please try again later.</strong></p></body></html>";
  exit;
}
```
<!-- more -->

## 写文件

```php
int fwrite ( resource $handle , string $string [, int $length ] )
```
* handle:文件指针
* string:要写入的内容
* length:最多可以写入length个字节
* fpus是fwrite函数的别名

```php
int file_put_contents ( string $filename , mixed $data [, int $flags = 0 [, resource $context ]] )
```
* filename:要写入数据的文件名
* data:要写入的数据
* flags:FILE_USE_INCLUDE_PATH, FILE_APPEND, LOCK_EX
* context:一个context资源
* file_put_contents可以在不调用fopen函数写数据到文件中

## 关闭文件

```php
bool fclose ( resource $handle )
```
* handle:文件指针

## 读文件

* 判断文件是否结束
    {% codeblock %}
    bool feof ( resource $handle )
    {% endcodeblock %}
    handle:文件指针
* 每次读取一行数据
    * `string fgets ( resource $handle [, int $length ] )`
        * handle:文件指针
        * length:从handle指向的文件中读取一行并返回长度最多为length-1字节的字符串，碰到换行符、EOF、或者读取了length-1字节后停止。忽略此参数则length被指定为1024
    * `string fgetss ( resource $handle [, int $length [, string $allowable_tags ]] )`
        和fgets()相同，只除了fgetss()尝试从读取的文本中去掉任何 HTML 和 PHP 标记。

        * allowable_tags:可以用可选的第三个参数指定哪些标记不被去掉。
    * `array fgetcsv ( resource $handle [, int $length = 0 [, string $delimiter = ',' [, string $enclosure = '"' [, string $escape = '\\' ]]]] )`
        和 fgets() 类似，只除了 fgetcsv() 解析读入的行并找出 CSV 格式的字段然后返回一个包含这些字段的数组。

        * delimiter:设置设置字段分界符，只允许一个字符
        * enclosure:设置字段环绕符，只允许一个字符
        * escape:设置转义字符，只允许一个字符，默认反斜杠
* 读取整个文件
    * `int readfile ( string $filename [, bool $use_include_path = false [, resource $context ]] )`
        * filename:要读取的文件名
        * use_include_path:如果也需要在 include_path 中搜寻文件的话，可以将可选的第三个参数 use_include_path 设为 '1' 或 TRUE。
        * context:一个context资源
    * `int fpassthru ( resource $handle )`
        * handle:文件指针

        需要先使用fopen()函数打开文件
    * `array file ( string $filename [, int $flags = 0 [, resource $context ]] )`
        参数 flags 可以是以下一个或多个常量：

        * FILE_USE_INCLUDE_PATH
            在 include_path 中查找文件。
        * FILE_IGNORE_NEW_LINES
            在数组每个元素的末尾不要添加换行符
        * FILE_SKIP_EMPTY_LINES
            跳过空行
    * `string file_get_contents ( string $filename [, bool $use_include_path = false [, resource $context [, int $offset = -1 [, int $maxlen ]]]] )`

* 读取一个字符

{% codeblock %}
string fgetc ( resource $handle )
{% endcodeblock %}
* 读取任意长度
{% codeblock %}
string fread ( resource $handle , int $length )
{% endcodeblock %}

## 其他常用文件函数

* 检查文件是否存在
    {% codeblock %}
    bool file_exists ( string $filename )
    {% endcodeblock %}
* 确定文件大小
    {% codeblock %}
    int filesize ( string $filename )
    {% endcodeblock %}
    nl2br() 函数可以讲输出的\n转换成换行符<br/>
* 删除一个文件
    {% codeblock %}
    bool unlink ( string $filename [, resource $context ] )
    {% endcodeblock %}
* 在文件中定位
    * 定位到文件开头
        {% codeblock %}
        bool rewind ( resource $handle )
        {% endcodeblock %}
    * 定位到指定位置
        {% codeblock %}
        int fseek ( resource $handle , int $offset [, int $whence = SEEK_SET ] )
        {% endcodeblock %}
        whence的取值：

        * SEEK_SET - 设定位置等于 offset 字节。
        * SEEK_CUR - 设定位置为当前位置加上 offset。
        * SEEK_END - 设定位置为文件尾加上 offset。
    * 返回文件指针的位置
        {% codeblock %}
        int ftell ( resource $handle )
        {% endcodeblock %}

## 文件锁定

```
bool flock ( resource $handle , int $operation [, int &$wouldblock ] )
```
operation 可以是以下值之一：

* LOCK_SH取得共享锁定（读取的程序）。
* LOCK_EX 取得独占锁定（写入的程序。
* LOCK_UN 释放锁定（无论共享或独占）。

如果不希望 flock() 在锁定时堵塞，则是 LOCK_NB（Windows 上还不支持）。

wouldblock：如果锁定会堵塞的话（EWOULDBLOCK 错误码情况下），可选的第三个参数会被设置为 TRUE。（Windows 上不支持）
