title: Git学习笔记
date: 2013-05-02 18:31:29
categories: Git
tags: Git
---

## git别名

```
git config --global alias.ci "commit"
git config --global alias.co "chechout"
git config --global alias.st "status"
git config --global alias.br "branch"
```

## 忽略文件

如果是版本库级别的忽略用`.gitignore`；如果仅仅是个人的忽略用`.git/info/exclude`，不会将此设置传播出去

忽略规则:
```
# 此为注释 – 将被 Git 忽略
*.a		# 忽略所有 .a 结尾的文件
!lib.a		# 但 lib.a 除外
/TODO		# 仅仅忽略项目根目录下的 TODO 文件，不包括 subdir/TODO
build/		# 忽略 build/ 目录下的所有文件
doc/*.txt	# 会忽略 doc/notes.txt 但不包括 doc/server/arch.txt
```
<!--more-->

## 添加文件到暂存区

* 基本命令 `git add`；
* 交互式模式 `git add -i`；
* 补丁模式 `git add -p`

## 提交修改

先暂存，后提交
```
git add files
git commit -m ".."
```
直接提交 `git commit -m ".." -a`； 或者 `git commit -m ".." files`

* 多个-m可以换行
* 提交留言至少应该体现出进行本次修改的原因
* 增补提交
    对于提交后发现一些小问题的情况，可以使用--amend。只能针对最后一个提交。例如：编辑contact.html添加一个链接 `git commit -m "add link to google" -a`。之后修改链接地址 `git commit -C HEAD -a --amend`。`-C`使复用制定提交（HEAD）的提交留言。`-c`会打开默认编辑器。增补提交是修正上次提交，git log 会发现只有增补提交的提交名称，而没有上次的。

## 查看工作目录状态

```
git status
```

## 查看文件改动

* 比较工作目录和暂存区 `git diff`；
* 比较暂存区和版本库 `git diff --cached`；
* 比较工作目录和版本库 `git diff HEAD`

## 查看提交信息

常用命令 `git log`，快速查看历史记录 `git log --pretty=oneline`。记录比较多时，可以使用jk等vi的命令向下向上查看。

```
git log -p  # 添加-p选项可以显示版本间代码差异
git log -1  # 显示一个
git log -2  # 查看近两次提交
git log a8b8a42  # 查看提交名称为a8b8a42及其之前的提交，至少应该有四位
```
按范围查看提交信息
```
git log --since="5 hours"  # 查看5小时以内的提交
git log --before="5 hours" # 查看5小时之前的提交
```
可以接受的的时间格式：3 hours, 5 minutes, 1 minute, 2013-4-13, 2013.4.13, 2013-4.13
```
git log 8d0a22b..a8b8a42    # 查看提交名称在8d0a22b和a8b8a42之间的提交，不包括起点，只包括终点
git log 8d0a22b..HEAD       # 查看提交名称8d0a22b到当前分支末梢的最新版本，也可以不输HEAD
git log --pretty=format:"%h %s" 1.0..HEAD # 查看标签1.0到当前分支末梢的最新版本
```

* `^`:一个脱字符作用相遇回溯一个版本 8d0a22b^是指8d0a22b之前的那个版本
* `~n`:波浪线加数字是指回溯n个版本。8d0a22b~1是指8d0a22b的父节点

以下命令执行结果相同
```
git log -1 HEAD^^^
git log -1 HEAD^~2
git log -1 HEAD~1^^
git log -1 HEAD~3
```
查看版本之间的差异
```
git diff 8d0a22b      # 默认第二个参数不写的话就是HEAD
git diff --stat 1.0   # --stat可以统计改动的代码量，同样第二个参数不写就是HEAD
```
查看代码块的历史信息
```
git blame index.html
```
输出：
{% codeblock %}
^a8b8a42 (howiefh 2013-04-13 19:18:35 +0800  1) <html>
e207eaa0 (howiefh 2013-04-13 19:30:12 +0800  2)         <head>
{% endcodeblock %}

有脱字符的表示版本库中的第一个提交

可以限定查看范围
```
git blame -L 12,13 index.html
git blame -L 12,+2 index.html
git blame -L 12,-2 index.html
git blame -L "/<\/body>/",+2 index.html
git blame -L "/<\/body>/",-2 8d0a22b^ -- index.html
```

**跟踪内容**

创建文件original.txt写入三行，并再复制这三行
```
git blame original.txt
git blame -M original.txt
```
后者显示的所有提交名称相同，因为git检测到了重复的内容

复制文件original.txt并重命名为copy.txt
```
git blame -C -C copy.txt
```
显示出事提交名称和初始文件名original.txt
```
git log -C -C -1 -p		# 可以检测到复制信息
```

## 反转提交

```
git revert -n HEAD     # -n选项git 会暂存所有变更，而不立即提交，--no-edit不打开编辑器
git revert -n 49005c1
git commit
```
复位
```
git reset --hard HEAD^		# 复位到HEAD的父节点
git reset --hard HEAD~3		# 复位到HEAD的曾祖父节点
```
**revert vs. reset**

* revert相对安全，是对某一次提交undo，并且保留提交历史。
* reset相对比较危险，要对某一次提交undo则其后的所有提交都会undo，不保留历史，永久性的。

**改写历史记录**

重新排序
```
git rebase -i HEAD~3   # 之后在打开的编辑器中改变顺序
```
将多个提交压合成一个提交
```
git rebase -i 0bb3dfb^  # 将要修改要合并的另一个记录移动到0bb3dfb后，并将其前面的pick改为squash
```
将一个提交分解成多个提交
```
git rebase -i HEAD~4  # 在打开的编辑器中将要分解的记录前的pick改为edit，保存退出，git reset HEAD^，git diff，对文件修改并分别提交，git rebase --continue
```

## 克隆远程版本库

```
git clone git://github.com/tswicegood/mysite-chp6.git
```
克隆后本地只有主分支，可以通过`git branch -a` 查看所有分支，其它分支是隐藏的，可以通过`git checkout -b experimental origin/experimental`创建并切换分支。

版本库同步，Git从远程的分支获取最新的版本到本地有这样2个命令：
{% codeblock %}
git fetch
git pull <远程版本库名称> <需要拖入的远程版本库的分支名>
{% endcodeblock %}

**fetch vs pull**

1. git fetch：相当于是从远程获取最新版本到本地，不会自动merge

    {% codeblock %}
    git fetch origin master
    git log -p master..origin/master
    git merge origin/master
    {% endcodeblock %}

    以上命令的含义：首先从远程的origin的master主分支下载最新的版本到origin/master分支上；然后比较本地的master分支和origin/master分支的差别；最后进行合并

    上述过程其实可以用以下更清晰的方式来进行：

    {% codeblock %}
    git fetch origin master:tmp
    git diff tmp
    git merge tmp
    {% endcodeblock %}

    从远程获取最新的版本到本地的tmp分支上；之后再进行比较合并

2. git pull：相当于是从远程获取最新版本并merge到本地
    {% codeblock %}
    git pull origin master
    {% endcodeblock %}

    上述命令其实相当于git fetch 和 git merge。在实际使用中，git fetch更安全一些，因为在merge前，我们可以查看更新情况，然后再决定是否合并。

给远程版本库起别名
```
git remote add origin git://github.com/tswicegood/mysite.git
```
推入远程版本库
```
git push origin master
```
查看本地创建的全部远程版本库别名
```
git remote
```
查看某个远程版本库 的详细信息
{% codeblock %}
git remote show <版本库别名>
{% endcodeblock %}
删除版本库别名
{% codeblock %}
git remote rm <版本库别名>
{% endcodeblock %}

## 创建分支

```
git branch RB_1.0 master  # RB_1.0新分支名，master 主干
git branch RB_1.0.1 1.0   # 1.0是打过的标签
```
以下情况创建分支

* 试验性修改
* 增加新功能
* bug修复

## 切换分支

```
git checkout RB_1.0
```
创建分支并检出该分支
```
git chechout -b new master  # new是新分支名，master是告诉git，不是从当前分支，而是从主分支上创建新分支，即基于主分支末梢创建新分支
```

## 重命名分支

```
git branch -m master mymaster  # master是就分支名，mymaster是新分支名
```
新分支名和已有的分支名相同时，重命名不会成功。
```
git branch -M master mymaster
```
可以强制重命名，并覆盖已有分支名称，需小心使用

## 合并分支

直接合并
```
git chechout master
git merge alternate    # 将分支alternate的修改合并进master
```
压合合并
```
git chechout master
git merge --squash contact
git commit -m "add contact file"   # 将分支contact多次提交的修改合并为一次提交
```
**拣选合并**

拣选一次提交进行合并
```
git chechout master
git cherry-pick 3d5a506
```
拣选多个提交
```
git checkout master
git cherry-pick -n 3d5a506  # 3d5a506是提交名称
git commit   # 不需要-m参数
```
**冲突处理**

如果在不同分支上对同一文件的同一文本块进行不同的修改，合并这两个不同分支时会有冲突
```
git mergetool
```
选择工具来人工处理冲突
```
git commit     # 不需要-m参数
```
把RB_1.0分支上所做的修改合并到主分支上
```
git chechout master
git rebase RB_1.0
```

## 删除分支

```
git branch -d RB_1.0 	# 仅仅是删除了分知名，该分支的内容并没有被删除
```
如果分支还没有合并回当前分支，删除不会成功
```
git branch -D RB_1.0
```
可以强制删除分支

## 打标签
```
git tag 1.0 RB_1.0
```
查看标签
```
git tag
```

## 创建归档文件

```
git archive --format=tar --prefix=mysite-1.0/ 1.0 | gzip > mysite-1.0.tar.gz
git archive --format=zip --prefix=mysite-1.0/ 1.0 > mysite-1.0.zip
```

## 文件重命名和移动

```
git mv index.html hello.html
```

## [合并其他remote上面的更新](http://huacnlee.com/blog/merge-other-remote-commits-to-current-fork-with-git/)

在 Github 上面 Fork 别人的项目时，我们常常会遇到主项目有了更新，这个时候怎么把主项目的更新合并到自己 Fork 的版本里面来呢？

```
# 我先吧 tualatrix Fork 的版本获取到本地
~/work $ git clone git://github.com/tualatrix/ruby-china.git
~/work $ cd ruby-china
~/work/ruby-china <master> $ git remote
origin
# 添加 huacnlee (也就是主项目的 remote 地址)
~/work/ruby-china <master> $ git remote add huacnlee git://github.com/huacnlee/ruby-china.git
# 用 fetch 命令获取 huacnlee 的所有分支
~/work/ruby-china <master> $ git fetch huacnlee
remote: Counting objects: 499, done.
remote: Compressing objects: 100% (143/143), done.
remote: Total 315 (delta 211), reused 253 (delta 172)
Receiving objects: 100% (315/315), 190.17 KiB | 92 KiB/s, done.
Resolving deltas: 100% (211/211), completed with 72 local objects.
From git://github.com/huacnlee/ruby-china
 * [new branch]      master -> huacnlee/master
# 将 huacnlee 的 master 分支的改动合并过来,目前是处与 master 分支
~/work/ruby-china <master> $ git merge huacnlee/master
```

一个教程：<http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000>
