title: php学习笔记(1)-快速入门
date: 2013-07-31 15:38:39
categories: PHP
tags: PHP
---
## 标记风格

* xml(推荐) `<?php .... ?>`
* 简短风格 `<? .... ?>`
* script风格 `<script language="php">....</script>`
* asp风格 `<% ... %>`

<!-- more -->

## 换行、制表符、空格都被认为是空格

## 注释 

```
// ...    
/*...*/  
# ...
```

## 使用表单变量

* 简短风格
    {% codeblock %}
    $tireqty
    {% endcodeblock %}
* 中等风格(推荐)
    {% codeblock %}
    $_POST['tireqty']
    {% endcodeblock %}
    取决于使用那种方法提交，如提交方法是POST，则使用$_POST['tireqty']获取数据，通过POST和GET方法提交的数据都可以通过$_REQUEST数组获取。这些数组被称为超级全局变量。  
* 冗长风格
    {% codeblock %}
    $HTTP_POST_VARS['tireqty']
    {% endcodeblock %}

## 点号是字符串连字符  

双引号中，变量名称将被变量值替代，单引号中,变量名不会被替代

## 3种字符串  

双引号的，单引号的和heredoc
heredoc:
* 以`<<<End`开始标记开始，以End结束标记结束，结束标记必须顶头写，不能有缩进和空格，且在结束标记末尾要有分号。结束标记和开始标记相同，比如常用大写的EOT、EOD、EOF来表示，但是不只限于这几个，只要保证开始标记和结束标记不在正文中出现即可。
* 位于开始标记和结束标记之间的变量可以被正常解析，但是函数则不可以。在heredoc中，变量不需要用连接符.或,
* heredoc常用在输出包含大量HTML语法文档的时候

## php是弱类型的，变量类型取决于赋给它的值。类型转换和c语言类似

## 可变变量

```
$test = 'hello php';
$varname = 'test';
echo $$varname;
```
$$varname 相当于 $test

## 常量

```
define('TIREPRICE', 1000);
define('OILPRICE', 10);
define('SPARKPRICE', 4);
```
引用常量时不需要$  
了解php自定义的常量用函数phpinfo();

## 变量作用域

* 内置超级全局变量可以在脚本的任何地方使用和可见。即如果我们在一个PHP页面中改变了其中的一个值，那么在其他PHP页面中使用时，它的值也会发生改变。
* 常量一旦被声明将可以在全局可见，也就是说，它们可以函数内外使用，但是这仅仅限于一个页面之中（包含我们通过include和include_once包含进来的PHP脚本），但是在其他的页面中就不能使用了。 
* 在一个脚本中声明的全局变量在整个脚本中是可见的，但不是在函数内部，在函数内部的变量如果与全局变量名称相同，以函数内部的变量为准。 
* 函数内部使用的变量声明为全局变量时，其名称要与全局变量的名称一致，在这样的情况下，我们就可以在函数中使用函数外部的全局变量了，这样就可以避免上一种因为函数内部的变量与外部的全局变量名称相同而覆盖了外部变量这样的情况。 
* 在函数内部创建并声明为静态的变量无法在函数外部可见，但是可以在函数的多次执行过程中保持该值，最常见的情况就是在函数的递归执行的过程之中。 
* 在函数内部创建的变量对函数来说是本地的，而当函数终止时，该变量也就不存在了。   
超级全局变量的完整列表如下：
* $GOBALS 所有全局变量数组
* $_SERVER 服务器环境变量数组
* $_POST 通过POST方法传递给该脚本的变量数组
* $_GET 通过GET方法传递给该脚本的变量数组
* $_COOKIE cookie变量数组
* $_FILES 与文件上传相关的变量数组
* $_ENV 环境变量数组
* $_REQUEST 所有用户输入的变量数组包括$_GET $_POST $_COOKIE 所包含的输入内容
* $_SESSION 会话变量数组 

## 操作符

* 引用 &
    {%code lang:php%}
    $a = 5;
    $b = &$a;
    {%endcode%}
    引用就像是一个别名 类似c++ 
* 恒等操作符 ===  
    只有当恒等操作符两边的操作数相等并且具有相同的数据类型时才为true  
    例如： 0=='0'为true，但是0==='0'为false  
    不恒等操作符 !==
* 与、或、异或 and or xor  
    and 和 or的优先级比&&和||低
* 错误抑制操作符 @  
    可以在任何表达式前面使用
    {%code lang:php%}
    $a=@(57/0)
    {%endcode%}
    如果没有@操作符，这一行代码将产生一个除0警告，使用这个操作符，这个警告就会被抑制。
    如果通过这种方法抑制了一些警告，一旦遇到一个警告，就要写一些错误处理代码。
* 执行操作符 反向单引号``  
    反向单引号之间的命令将被当做命令行命令来执行
* 数组操作符  
    {%code lang:php%}
    $a + $b 	联合 	$a 和 $b 的联合。
    $a == $b 	相等 	如果 $a 和 $b 具有相同的键／值对则为 TRUE。
    $a === $b 	全等 	如果 $a 和 $b 具有相同的键／值对并且顺序和类型都相同则为 TRUE。
    $a != $b 	不等 	如果 $a 不等于 $b 则为 TRUE。
    $a <> $b 	不等 	如果 $a 不等于 $b 则为 TRUE。
    $a !== $b 	不全等 	如果 $a 不全等于 $b 则为 TRUE。
    {%endcode%}
* 类型操作符  
    instanceof

## print和echo  

* 以函数形式调用print会返回1  
*  echo执行速度比print快 

## 可变函数  

* 测试和设置变量类型
    {%code lang:php%}
    string gettype(mixed var);
    {%endcode%}
    传递一个变量，返回类型名称字符串：bool, int, double, string, array, object, resource
    {%code lang:php%}
    bool settype(mixed var, string type);
    is_array():检测是否是字符串
    is_long():检查是否是整数
    {%endcode%}
* 测试变量状态
    判断变量是否存在
    {%code lang:php%}
    bool isset(mixed var);
    bool isset(mixed var[...]);
    {%endcode%}
    销毁变量
    {%code lang:php%}
    void unset(mixed var);
    void unset(mixed var[...]);
    {%endcode%}
    判断变量是否存在，其值是否为非空或非0
    {%code lang:php%}
    bool empty(mixed var);
    {%endcode%}
* 变量重解释
    {%code lang:php%}
    int intval(mixed var[,int base]);
    float floatval(mixed var);
    string strval(mixed var);
    {%endcode%}

## 从控制结构或脚本中跳出

```
break
continue
exit
```
